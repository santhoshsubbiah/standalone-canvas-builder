class ZEventNameSpacing {
    constructor() {
        this.functionMaps = {};
    }

    addEventListener(element, event, func) {
        this.functionMaps[event] = func;
        if (func) {
            element.addEventListener(event.split('.')[0], func);
        }
    }

    removeEventListener(element, event) {
        if (this.functionMaps[event]) {
            element.removeEventListener(event.split('.')[0], this.functionMaps[event]);
            delete this.functionMaps[event];
        }
    }
}
let ZPolyfill = {};
try {
    ZPolyfill.WeakMap = WeakMap
} catch (WeakMap) {
    ZPolyfill.WeakMap = (function(id, Object) {
        let dP = Object.defineProperty;
        let hOP = Object.hasOwnProperty;
        let proto = WeakMap.prototype;
        proto.delete = (key) => this.has(key) && delete key[this._];
        proto.get = (key) => this.has(key) ? key[this._] : void 0;

        proto.has = (key) => hOP.call(key, this._);

        proto.set = (key, value) => {
            dP(key, this._, {
                configurable: true,
                value: value
            });
            return this;
        };
        return WeakMap;
        function WeakMap(iterable) {
            dP(this, '_', { // No I18N
                value: '_@ungap/weakmap' + id++ // No I18N
            });
            if (iterable) {iterable.forEach(add, this);}
        }
        function add(pair) {
            this.set(pair[0], pair[1]);
        }
    }(Math.random(), Object));
}
let ZWeakMap = ZPolyfill.WeakMap;
let ZCTemplates = {
    nodeRef: new ZWeakMap(),
    templateCache: {},
    uniqueId: `{zt-${String(Math.random()).slice(2)}}`, // No I18N
    attrSuffix: '$zta$', // No I18N
    attrRegEx: /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/, // No I18N
    Event: new ZEventNameSpacing(),
    renderView: function(htmlResult, container) {
        let instance = new ZNodeProcessor(),
            ref = this.nodeRef;
        let nodeRef = ref.get(container);
        if (!nodeRef) {
            instance._emptyElement(container, container.firstChild);
            ref.set(container, nodeRef = instance);
            nodeRef._addPlaceholders(container);
        }
        nodeRef._setResult(htmlResult);
        nodeRef.update();
    },
    removeCacheData: function(container) {
        let nodeRef = this.nodeRef.get(container);
        if (nodeRef) {
            this.nodeRef.set(container, null);
        }
    },
    DOM: function(htmlResult) {
        let instance = new ZNodeProcessor();
        if (htmlResult instanceof ZTemplates) {
            return instance._processHTML(htmlResult, true).childNodes[0];
        }
    },
    functionList: new ZWeakMap(),
    prevValues: new ZWeakMap(),
    _specialFunc: (f) => (...args) => {
        let d = f(...args);
        ZT.functionList.set(d, true);
        return d;
    },
    _isSpecialFunc: function(o) {
        return typeof o === 'function' && this.functionList.has(o) // No I18N
    },
    html(strings, ...values) {
        return new ZTemplates(strings, values, 'html'); // No I18N
    },
    _updateTemplateCache(result) {
        let cache = this.templateCache;
        let value = cache[result.type];
        if (!value) {
            value = {
                strings: new ZWeakMap(),
                keys: {}
            };
            cache[result.type] = value;
        }
        let template = value.strings.get(result.strings);
        if (template) {
            return template;
        }
        let key = result.strings.join(this.uniqueId);
        template = value.keys[key];
        if (!template) {
            template = new ZNodeTraverser(result, result.getTemplate());
            value.keys[key] = template;
        }
        value.strings.set(result.strings, template);
        return template;
    },
    _processAttr(node, attrName, strings) {
        let prefix = attrName[0],
            actualAttr = attrName.slice(1);
        if (prefix === '?') {
            return [ new ZConditionalAttributePart(node, actualAttr) ];
        } else if (prefix === '.') {
            return new ZPropertyPart(node, actualAttr, strings)._parts;
        } else if (attrName.indexOf('on-') > -1) {
            return [ new ZEventPart(node, attrName.slice(3)) ];
        }
        return new ZAttributeUpdater(node, attrName, strings)._parts;
    },
    _processTextValue() {
        return new ZNodeProcessor();
    },
    _isPlainText(value) {
        return value === null || !(typeof value === 'object' || typeof value === 'function'); // No I18N
    },
    _getTemplate: (function() {
        let createTemplate = () => document.createElement('template'); // No I18N
        if ('content' in createTemplate()) { // No I18N
            return (value) => {
                // --- Not supported by IE
                let template = createTemplate();
                template.innerHTML = value;
                return template;
            }
        }
        return (value) => {
            // IE 9 & Above
            let template = document.createDocumentFragment();
            let tempNode = document.createElement('div'); // No I18N
            let fillUsingTable = () => {
                tempNode.innerHTML = '<table>' + value + '</table>'; // No I18N
                return tempNode.firstChild.firstChild;
            }
            if (/^(<td|<th|<tr)/.test(value)) {
                if (/^<tr/.test(value)) {
                    tempNode = fillUsingTable();
                } else {
                    tempNode = fillUsingTable().firstChild;
                }
            } else {
                tempNode.innerHTML = value;
            }
            let children = tempNode.childNodes;
            while (children[0]) {
                template.appendChild(children[0]);
            }
            // IE 9 && above //JQuery is used
            // let template = document.createDocumentFragment();
            // if (/^(<tr|<td|<th)/.test(value)) {
            //     let children = $(value).toArray();
            //     for (let i = 0; i < children.length; i++) {
            //         template.appendChild(children[i]);
            //     }
            // } else {
            //     let tempNode = document.createElement('div'); // No I18N
            //     tempNode.innerHTML = value;
            //     let children = tempNode.childNodes;
            //     while (children[0]) {
            //         template.appendChild(children[0]);
            //     }
            // }

            // IE 10 && IE 11
            // let template = document.createDocumentFragment();
            // let tempTag = 'div';// No I18N
            // if (/^<tr/.test(value)) {
            //     tempTag = 'thead'; // No I18N
            // } else if (/^(<td|<th)/.test(value)) {
            //     tempTag = 'tr'; // No I18N
            // }
            // let tempNode = document.createElement(tempTag);
            // tempNode.innerHTML = value;
            // let children = tempNode.childNodes;
            // while (children[0]) {
            //     template.appendChild(children[0]);
            // }

            template.content = template;
            return template;
        }
    }())
};
let ZT = ZCTemplates;
ZT.placeholder = `<!--${ZT.uniqueId}-->`;

ZT.customHTML = ZT._specialFunc((value) => (part) => {
    let prevValue = ZT.prevValues.get(part);
    if (prevValue === value && ZT._isPlainText(value)) {
        return;
    }
    let template = ZT._getTemplate(value);
    part._setResult(document.importNode(template.content, true));
    ZT.prevValues.set(part, value);
});
class ZTemplates {
    constructor(strings, values, type) {
        this.strings = strings;
        this.values = values;
        this.type = type;
    }

    _getHTML() {
        let length = this.strings.length - 1;
        let html = '';
        for (let i = 0; i < length; i++) {
            let s = this.strings[i],
                isAttr = false;
            html += s.replace(ZT.attrRegEx, (match, space, attrName, value) => {
                isAttr = true;
                return space + attrName + ZT.attrSuffix + value + ZT.uniqueId;
            })
            if (!isAttr) {
                html += ZT.placeholder;
            }
        }
        return html + this.strings[length];
    }

    getTemplate() {
        return ZT._getTemplate(this._getHTML());
    }
}
class ZTemplateUpdater {
    constructor(template) {
        this.template = template;
        this._parts = [];
        this._partIndex = this._nodeIndex = 0;
    }

    _updateNodes() {
        let template = document.importNode(this.template._template.content, true);
        this._traverseDOM(template);
        return template;
    }

    _traverseDOM(node) {
        let dynamicParts = this.template._parts;
        node = node.firstChild;
        while (node && this._partIndex < dynamicParts.length) {
            let part = dynamicParts[this._partIndex];
            if (this._nodeIndex === part.index) {
                if (part.type === 'node') { // No I18N
                    let part = ZT._processTextValue();
                    part._setRefNodes(node);
                    this._parts.push(part);
                } else {
                    this._parts.push(...ZT._processAttr(node, part.name, part.strings));
                }
                this._partIndex++;
            } else {
                this._nodeIndex++;
                this._traverseDOM(node);
                node = node.nextSibling;
            }
        }
    }

    updateValues(values) {
        for (let i = 0, len = this._parts.length; i < len; i++) {
            let part = this._parts[i];
            if (part) {
                part._setResult(values[i])
                part.update();
            }
        }
    }
}
class ZAttributeUpdater {
    constructor(node, attrName, strings) {
        this.node = node;
        this.attrName = attrName;
        this.strings = strings;
        this._parts = [];
        for (let i = 0; i < strings.length - 1; i++) {
            this._parts[i] = this._createPart();
        }
    }

    _createPart() {
        return new ZAttributePart(this);
    }

    _getValue() {
        let strings = this.strings,
            attrValue = '',
            len = strings.length - 1;
        for (let i = 0; i < len; i++) {
            attrValue += strings[i];
            let part = this._parts[i];
            if (part) {
                let value = part.value;
                if (part.value || part.value === 0) {
                    attrValue += typeof value === 'string' ? value : String(value); // No I18N
                }
            }
        }
        attrValue += strings[len];
        return attrValue;
    }

    update() {
        this.node.setAttribute(this.attrName, this._getValue());
    }
}
class ZAttributePart {
    constructor(instance) {
        this._attrPart = instance;
        this._changed = false;
    }

    _setResult(value) {
        if (value !== this.value) {
            this.value = value;
            this._changed = true;
        }
    }

    update() {
        this._changed && this._attrPart.update();
        this._changed = false;
    }
}
class ZNodeTraverser {
    constructor(result, template) {
        this._template = template;
        this._placeholderRegEx = new RegExp(`${ZT.uniqueId}|${ZT.placeholder}`)
        this._index = -1;
        this._parts = [];
        this._partIndex = 0;
        this._nodesToBeRemoved = [];
        this._storeDynamicParts(template, result);
        for (let i = 0; i < this._nodesToBeRemoved.length; i++) {
            let node = this._nodesToBeRemoved[i];
            if (node.parentNode) {
                node.parentNode.removeChild(node);
            }
        }
    }

    _storeDynamicParts(template, result) {
        this._traverseDOM(template.content, result);
    }

    _traverseDOM(node, result) {
        let previousNode;
        node = node.firstChild;
        while (node) {
            this._index++;
            previousNode = node;
            switch (node.nodeType) {
                case 1:
                    if (node.hasAttributes()) {
                        let attrs = node.attributes,
                            count = 0;
                        for (let i = 0; i < attrs.length; i++) {
                            if (attrs[i].value.indexOf(ZT.uniqueId) >= 0) {
                                count++;
                            }
                        }
                        for (let j = count; j > 0; j--) {
                            let attrPart = result.strings[this._partIndex],
                                name = ZT.attrRegEx.exec(attrPart);
                            if (name) {
                                name = name[2];
                            }
                            let placeholderAttrName = name.toLowerCase() + ZT.attrSuffix,
                                attrValue = node.getAttribute(placeholderAttrName),
                                strings = attrValue.split(this._placeholderRegEx);
                            this._parts.push({
                                type: 'attr', // No I18N
                                index: this._index,
                                name,
                                strings
                            });
                            node.removeAttribute(placeholderAttrName);
                            this._partIndex += strings.length - 1;
                        }
                    }
                    break;
                case 8:
                    if (node.nodeValue === ZT.uniqueId) {
                        let parent = node.parentNode,
                            previousSibling = node.previousSibling;
                        if (parent && !previousSibling || previousSibling !== previousNode || previousSibling.nodeType !== 3) {
                            parent.insertBefore(document.createComment(''), node);
                        } else {
                            this._index--;
                        }
                        this._parts.push({
                            type: 'node', // No I18N
                            index: this._index++
                        });
                        this._nodesToBeRemoved.push(node);
                        if (!node.nextSibling && parent) {
                            parent.insertBefore(document.createComment(''), node);
                        } else {
                            this._index--;
                        }
                        node = previousNode;
                        this._partIndex++;
                    }
                    break;
            }
            this._traverseDOM(node, result);
            node = node.nextSibling;
        }
    }
}
class ZEventPart {
    constructor(element, eventName) {
        this.element = element;
        this.eventName = eventName;
    }

    _setResult(value) {
        this.currentVal = value;
    }

    update() {
        let currentHandler = this.currentVal ? this.currentVal.handler : null,
            oldHandler = this.value ? this.value.handler : null;
        if (!currentHandler && oldHandler) {
            ZT.Event.removeEventListener(this.element, this.eventName + '.' + this.value.namespace, this._handleEvent.bind(this));
        }
        if (currentHandler && !oldHandler) {
            let eventNames = this.currentVal.eventNames;
            if (!eventNames) {
                eventNames = [ this.eventName ];
            }
            for (let i = 0; i < eventNames.length; i++) {
                ZT.Event.addEventListener(this.element, eventNames[i] + '.' + this.currentVal.namespace, this._handleEvent.bind(this));
            }
        }
        this.value = this.currentVal;
        this.currentVal = {};
    }

    _handleEvent(event) {
        if (this.value && typeof this.value.handler === 'function') {
            this.value.handler.call(this.element, event);
        }
    }
}
class ZPropertyPart extends ZAttributeUpdater {
    _getValue() {
        return this._parts[0].value;
    }

    update() {
        this.node[this.attrName] = this._getValue();
    }
}
class ZConditionalAttributePart {
    constructor(node, attrName, strings) {
        this.node = node;
        this.attrName = attrName;
        this.strings = strings;
    }

    _setResult(value) {
        this.currentVal = value;
    }

    update() {
        let value = this.currentVal,
            node = this.node;
        if (this.value !== value) {
            if (value) {
                value = typeof value === 'boolean' ? '' : value; // No I18N
                node.setAttribute(this.attrName, value);
            } else {
                node.removeAttribute(this.attrName);
            }
        }
        this.value = value;
    }
}
class ZNodeProcessor {
    _emptyElement(container, start, end) {
        let node = start;
        while (node && node !== end) {
            let tempNode = node.nextSibling;
            container.removeChild(node);
            node = tempNode;
        }
    }

    _setResult(value) {
        this.currentVal = value;
    }

    _addPlaceholders(container) {
        this.start = container.appendChild(document.createComment('')); // No I18N
        this.end = container.appendChild(document.createComment('')); // No I18N
    }

    _setRefNodes(node) {
        this.start = node;
        this.end = node.nextSibling;
    }

    update() {
        while (ZT._isSpecialFunc(this.currentVal)) {
            let func = this.currentVal;
            this.currentVal = {};
            func(this);
        }
        let value = this.currentVal;
        if (ZT._isPlainText(value)) {
            if (value !== this.value) {
                this._updateNode(value);
            }
        } else if (value instanceof ZTemplates) {
            this._processHTML(value);
        } else if (value.nodeType) {
            // instanceof Node check is not working in some applications
            // } else if (value instanceof Node) {
            this._insertNode(value);
        } else if (value instanceof Array) {
            this._processValues(value);
        }
    }

    _processValues(values) {
        if (!(this.value instanceof Array)) {
            this.value = [];
            this.remove();
        }
        let nodeParts = this.value,
            nodePart, i,
            len = values.length;
        for (i = 0; i < len; i++) {
            nodePart = nodeParts[i];
            if (!nodePart) {
                nodePart = new ZNodeProcessor();
                nodeParts.push(nodePart);
                if (i === 0) {
                    nodePart._appendNodePart(this)
                } else {
                    nodePart._insertAfterPart(nodeParts[i - 1]);
                }
            }
            nodePart._setResult(values[i]);
            nodePart.update();
        }
        if (i < nodeParts.length) {
            nodeParts.length = i;
            this.remove(nodePart && nodePart.end);
        }
    }

    _appendNodePart(part) {
        part._insert(this.start = document.createComment(''));
        part._insert(this.end = document.createComment(''));
    }

    _insertAfterPart(previousPart) {
        previousPart._insert(this.start = document.createComment(''));
        this.end = previousPart.end;
        previousPart.end = this.start;
    }

    remove(start = this.start) {
        this._emptyElement(this.start.parentNode, start.nextSibling, this.end);
    }

    _insert(node) {
        this.end.parentNode.insertBefore(node, this.end);
    }

    _insertNode(value) {
        if (this.value === value) {
            return;
        }
        this.remove();
        this._insert(value);
        this.value = value;
    }

    _updateNode(value) {
        let node = this.start.nextSibling;
        value = value || '';
        if (node === this.end.previousSibling && node.nodeType === 3) {
            node.textContent = value;
        } else {
            this._insertNode(document.createTextNode(typeof value === 'string' ? value : String(value))); // No I18N
        }
        this.value = value;
    }

    _processHTML(value, doNotRender) {
        let template = ZT._updateTemplateCache(value),
            updatedTemplate;
        if (this.value && this.value.template === template) {
            this.value.updateValues(value.values);
        } else {
            let instance = new ZTemplateUpdater(template);
            updatedTemplate = instance._updateNodes();
            instance.updateValues(value.values);
            if (!doNotRender) {
                this._insertNode(updatedTemplate);
            }
            this.value = instance;
        }
        return updatedTemplate;
    }
}
// To facilitate require('ztemplates.js')
(function(ZT) {
    if (typeof module === 'object' && typeof module.exports === 'object') { // No I18N
        module.exports = (function() {
            return ZT;
        }());
    }
}(ZCTemplates));

(function($){
	/* Core Variable */
	let needToInit = true,
	    userAgent = navigator.userAgent.toLowerCase(),
	    sourceDiv = document.createElement('div'),
	    sourceText = document.createTextNode(' '),
	    objectProperties = [ '_CLASSES', '_EVENTS', '_SELECTORS', '_attrs', '_props' ]; // No I18N
	sourceDiv.appendChild(sourceText);
	let useWebComponentsSelector = window.ZComponentsConfig && window.ZComponentsConfig.useWebComponentsSelector;
	let ZComponents = {
	    pluginPrefix: 'z', // No I18N
	    changeSet: 'v5_1', // No I18N
	    isRTL: false,
	    selector: 'data-ctype', // No I18N
	    version: 'v5_1', // No I18N
	    environment: 'production', // No I18N
	    userAgent: userAgent,
	    webComponents: [],
	    webComponentsToInit: [],
	    SVG: {},
	    Templates: {},
	    webComponentsSupport: false,
	    useWebComponentsSelector: useWebComponentsSelector === undefined ? false : useWebComponentsSelector,
	    _animationEnd: 'webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend transitionend', // No I18N
	    _transitionEnd: 'webkitTransitionEnd, otransitionend, oTransitionEnd, msTransitionEnd, transitionend', // No I18N
	    locale: 'en-US', // No I18N
	    zIndex: 1000, // ZIndex can be used for components like dialog.
	    $window: $(window),
	    $document: $(document),
	    $body: $('body'), // No I18N
	    DOMUtil: $,
	    DOMUtilInstance: window.$ZCDOMUtil || $,
	    keys: {},
	    minimizeArray: [],
	    keyCode: {
	        BACKSPACE: 8,
	        COMMA: 188,
	        DELETE: 46,
	        DOWN: 40,
	        END: 35,
	        ENTER: 13,
	        ESCAPE: 27,
	        HOME: 36,
	        LEFT: 37,
	        NUMPAD_ADD: 107,
	        NUMPAD_DECIMAL: 110,
	        NUMPAD_DIVIDE: 111,
	        NUMPAD_ENTER: 108,
	        NUMPAD_MULTIPLY: 106,
	        NUMPAD_SUBTRACT: 109,
	        PAGE_DOWN: 34,
	        PAGE_UP: 33,
	        PERIOD: 190,
	        RIGHT: 39,
	        SPACE: 32,
	        TAB: 9,
	        UP: 38,
	        ALT: 18
	    },
	    isEmpty(obj) {
	        return !(obj && Object.keys(obj).length);
	    },
	    iterateData(data, callback) {
	        return Array(data).join(0).split(0).map(callback);
	    },
	    getKebabCaseKey(string) {
	        return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
	    },
	    getID(cName, element, prefix, suffix) {
	        cName = cName || ''; // No I18N
	        if (element instanceof this.DOMUtilInstance) {
	            element = element[0];
	        }
	        return (element && element.id || cName + '-' + (prefix ? prefix + '-' : '') + Math.round(Math.random() * 100000000) + (suffix ? '-' + suffix : '')); // No I18N
	    },
	    _getIconInfo(iconClass, svgIconId, defaultSVGId, defaultIconClassName, options) {
	        let svgIconClass, hasIcon;
	        options = options || {};
	        svgIconId = !iconClass && !svgIconId ? defaultSVGId : svgIconId;
	        if (svgIconId) {
	            let iconInfo = svgIconId.split(' '); // No I18N
	            svgIconId = iconInfo[0];
	            svgIconClass = iconInfo[1] ? iconInfo.slice(1).join(' ') : undefined; // No I18N
	            iconClass = undefined;
	            hasIcon = true;
	        }
	        options.icon = hasIcon || defaultIconClassName || iconClass;
	        options.iconClassName = ((defaultIconClassName || '') + ' ' + (iconClass || '')).trim(); // No I18N
	        options.SVGIconClassName = svgIconClass || options.SVGIconClassName || ''; // No I18N
	        if (svgIconId) {
	            options.SVGIconId = ((svgIconId.indexOf('#') < 0 ? '#' : '') + svgIconId); // No I18N
	        }
	        return options;
	    },
	    createElement(opt, compWOPrefix, doNotInitialize) {
	        opt = opt || {};
	        let compWithZPrefix = 'z' + compWOPrefix; // No I18N
	        let options = Object.create(opt),
	            tagNames = ZC.tagNames[compWithZPrefix],
	            tagNameInOpt = opt.tagName,
	            normalTag = tagNameInOpt || tagNames[0],
	            customTag = tagNameInOpt || tagNames[1],
	            appendTo = options.appendTo,
	            tempElement = options.mainElement || document.getElementById(options.id); // Object.create is used to avoid same memory reference problem.
	        if (tempElement) {
	            let componentData = $(tempElement).data(compWithZPrefix),
	                container, element;
	            if (componentData) {
	                if (componentData.container) {
	                    container = componentData.container[0];
	                }
	                element = componentData.element[0];
	                return (options.isCE ? element : (container ? [ element, container ] : [ element ]));
	            }
	        }
	        let tagName = (options.isCE ? customTag : normalTag) || 'div', // No I18N
	            domEle = options.id && document.getElementById(options.id),
	            element = domEle || document.createElement(tagName),
	            $element = $(element),
	            attributes = options.customAttributes,
	            isCustomTag = tagName.indexOf('-') > -1; // No I18N
	        if (options.id) {
	            attributes = attributes || {};
	            attributes.id = options.id
	        }
	        if (attributes) {
	            $element.attr(attributes);
	        }
	        // This part of code is moved above, since for datepicker like components, setProperties has to be called before the children components are initialized
	        // (faced an issue for beforedatecellrender event)
	        if (isCustomTag && options) {
	            // window.setTimeout(function() { // ##revisit temporarily added since setProperties is undefined error thrown.
	            element._zinitdata = options;
	            // element.setProperties(options);
	            // }, 20)
	            // element.textContent = options.text; to be removed
	        }
	        if (!options.templateRender) {
	            appendTo = $(appendTo || 'body')[0];
	            if (options.insertBefore) {
	                appendTo.parentNode.insertBefore(element, appendTo);
	            } else {
	                appendTo.appendChild(element)
	            }
	        }
	        if (!isCustomTag && !doNotInitialize) {
	            let instance = ZC[compWOPrefix]($element, options); // Initialize the component if its not a custom tag.
	            if (opt.templateRender) {
	                // If this.container & this.element are different, both this.element and this.container should be moved to the appropriate position in the template.
	                if (instance.container && instance.container[0] !== instance.element[0]) {
	                    return [ instance.element[0], instance.container[0] ];
	                }
	                return [ instance.element[0] ];
	            }
	            return instance.element;
	        }
	        // storing in data is needed if not initialized.. For ex: Buttongroup like components where inner buttons won't be initialized.
	        !isCustomTag && $.data(element, 'ZCOpts', options); // No I18N
	        return element;
	    },
	    OS: {
	        isLinux() { // appVersion holds the version details alone in some browsers. Also spec specifies to return platform as empty string by some browsers. Hence, added three conditions.
	            return navigator.appVersion.indexOf('Linux') > -1 || userAgent.indexOf('Linux') > -1 || navigator.platform.indexOf('Linux') > -1; // No I18N
	        },
	        isMac() {
	            return /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
	        },
	        isWindows() {
	            return navigator.platform.indexOf('Win') > -1; // No I18N
	        }
	    },
	    _getEvents(current = [], parent = []) {
	        return parent.concat(current).filter((elem, pos, arr) => arr.indexOf(elem) === pos);
	    },
	    registerComponent(componentName, parentComponent, protoObj) {
	        let subComponent;
	        if (protoObj) {
	            subComponent = true;
	        } else {
	            protoObj = parentComponent;
	            parentComponent = this.CoreComponent;
	        }
	        let len = objectProperties.length,
	            prop;
	        let compWOPrefix = componentName.toLowerCase().replace(/^z/, '');// No I18N
	        let compWithZPrefix = 'z' + compWOPrefix; // No I18N
	        let parentProto = parentComponent.prototype;
	        // typeof protoObj will be a function for Javascript ES6 Class.
	        if (subComponent && typeof protoObj === 'object') { // No I18N
	            protoObj = this._objectTypeFallback(protoObj, compWithZPrefix, parentComponent, parentProto);
	        }
	        let tagNames = ZC.tagNames[compWithZPrefix];
	        let isWebComponent = (tagNames && tagNames[1] && this.webComponentsSupport);
	        let useWebComponentsSelector = this.useWebComponentsSelector;
	        if (isWebComponent && useWebComponentsSelector) {
	            protoObj.prototype.isCE = true;
	        }
	        let proto = protoObj.prototype,
	            tempProp;
	        for (let i = 0; i < len; i++) {
	            prop = objectProperties[i];
	            tempProp = prop.replace('_', ''); // No I18N
	            if (prop === '_EVENTS') {
	                proto[prop] = this._getEvents(proto[tempProp], parentProto[tempProp]);
	                proto[prop] = this._getEvents(proto[prop], parentProto[prop]);
	                proto[prop].push('beforedestroy'); // No I18N
	            } else {
	                proto[prop] = $.extend(true, prop === '_attrs' ? {
	                    rtl: false,
	                    templateData: null,
	                    templateFunc: null,
	                    zclassName: null,
	                    templateRender: null
	                } : {}, parentProto[tempProp] || {}, parentProto[prop] || {}, proto[tempProp] || {});
	            }
	        }
	        proto._DEFAULTS = $.extend(true, {}, proto._attrs, proto._props);
	        /* Adding propType for webComponent and for js component that have null or undefined as default value for its options. Example for js comp: dropdownlist, listbox */
	        if (this.webComponentsSupport || parentProto.propType || proto.propType) {
	            proto._propType = $.extend(true, this._getDataInfo(proto._DEFAULTS), parentProto.propType || {}, parentProto._propType || {}, proto.propType || {});
	        }
	        // Since we have used 'z' prefix in all the templates & tagNames
	        if (isWebComponent) {
	            if (useWebComponentsSelector) {
	                protoObj.prototype.isCE = false;
	            } else {
	                this.register(tagNames[1], protoObj, parentComponent);
	            }
	        }
	        this[componentName] = protoObj;
	        if (!this[compWithZPrefix]) {
	            let DEFAULTS = {},
	                Templates = {};
	            if (subComponent) {
	                let parentObject = this[parentProto.name];
	                if (parentObject) {
	                    $.extend(Templates, parentObject.Templates);
	                }
	            }
	            this[compWithZPrefix] = {
	                DEFAULTS,
	                Templates
	            }
	            let methodName = 'create' + componentName.substr(1); // No I18N
	            if (!ZC[methodName]) {
	                ZC[methodName] = (options) => ZC.createElement(options, compWOPrefix);
	            }
	        }
	        this[compWOPrefix] = function(element, options) { // To Support ZC.<componentName>() Invocation.
	            element = $(element);
	            if (element.length > 1) { // To help initializing multiple elements.
	                let resultArray = [];
	                for (let k = 0; k < element.length; k++) {
	                    resultArray[k] = ZComponents._createComponent(element[k], options, componentName, protoObj);
	                }
	                return resultArray;
	            }
	            return ZComponents._createComponent(element, options, componentName, protoObj);
	        };
	        let compPluginName = this.pluginPrefix + compWOPrefix;
	        $.prototype[compPluginName] = function(options) { // Assigning the childComponent to global scope... [ Alternative to JQuery's Method ]
	            let returnValue = this,
	                length = this.length;
	            if (!options || typeof options === 'object') { // component is initialized
	                options = options || {};
	                for (let i = 0; i < length; i++) {
	                    ZComponents._createComponent(this[i], options, componentName, protoObj, true);
	                }
	            } else if (typeof options === 'string' && options.indexOf('_') < 0) { // No I18N
	                // Public Method Invocation
	                let params = Array.prototype.slice.call(arguments, 1);
	                for (let i = 0; i < length; i++) {
	                    let componentInstance = $(this[i]).data(compWithZPrefix);
	                    if (componentInstance) {
	                        returnValue = componentInstance[options].apply(componentInstance, params);
	                    }
	                }
	            } else {
	                return false;
	            }
	            return returnValue;
	        };
	    },
	    _getDataInfo(defaults) {
	        let optionsType = {};
	        for (let key in defaults) {
	            let value = defaults[key];
	            if (value !== undefined && value !== null) { // for checking boolean value, if(value) is avoided
	                optionsType[key] = Array.isArray(value) ? 'array' : typeof value;
	            }
	        }
	        return optionsType;
	    },
	    _defineGetProp(proto, attrName, value) {
	        Object.defineProperty(proto, attrName, {
	            get: function() {
	                return value;
	            }
	        });
	    },
	    _extend(target, base) {
	        // target.prototype = $.extend({},base.prototype,target.prototype);
	        $.each(target.prototype, function(prop, value) {
	            if (typeof value === 'function') { // No I18N
	                target.prototype[prop] = (function() {
	                    let _super = function() {
	                        return base.prototype[prop].apply(this, arguments);
	                    };
	                    return function() {
	                        this._super = _super;
	                        return value.apply(this, arguments);
	                    };
	                }());
	            }
	        });
	    },
	    _createComponent(element, options, cName, prototype, returnElement) {
	        element = $(element);
	        let cnamelower = cName.toLowerCase();
	        if (element[0] && (element[0] === window || element[0].nodeType)) {
	            if (element.data(cnamelower)) {
	                return returnElement ? element : element.data(cnamelower);
	            }
	            let data = this._getInitOpts(element, cnamelower, options, prototype),
	                instance = new ZComponents[cName](element, data, options);
	            if (ZC.environment === 'development' && ZC.handleExceptions) { // No I18N
	                // Exception handling will be performed for development environment only.
	                instance = ZC.handleExceptions(instance);
	            }
	            if (!document.body.contains(element[0])) { // existing element was removed during component initialization.
	                element = instance.element;
	            }
	            element.data({
	                [cnamelower]: instance,
	                componentName: cnamelower
	            });
	            return instance;
	        }
	    },
	    _getInitOpts(element, componentName, options, mainProto) {
	        let eleOptions = ZC._getOpts(element, mainProto);
	        if (eleOptions.override) { // handling the case where two or more components share the same set of attributes.
	            let newArray = {};
	            for (let obj in eleOptions) {
	                if (obj.indexOf(componentName) === 0) {
	                    let result = obj.replace(componentName, ''), // No I18N
	                        keyName = result[0].toLowerCase() + result.substring(1);
	                    newArray[keyName] = eleOptions[obj];
	                }
	            }
	            eleOptions = newArray;
	        }
	        return $.extend(true, {}, ZC[componentName] ? ZC[componentName].DEFAULTS : {}, eleOptions, options);
	    },
	    _getOpts(element, mainProto) {
	        element = element instanceof ZC.DOMUtilInstance ? element[0] : element;
	        if (element) {
	            let tagName = element.tagName || '',
	                object;
	            // NeedCodeRevisit
	            if (this.webComponentsSupport && window.customElements ? customElements.get(tagName.toLowerCase()) : undefined) {
	                if (!element.$c) {
	                    this._triggerConnectedCallback(element);
	                }
	                object = element.$c[element.$c.parentElement ? '_subOpts' : '_opts']; // No I18N
	            } else {
	                object = $.data(element, 'ZCOpts'); // No I18N
	                if (!object && element.attributes) {
	                    let dataAttr = element.getAttribute('data'); // No I18N
	                    if (dataAttr) {
	                        // Retrieving options present in data attribute as a json.
	                        object = ZComponents._getObject(dataAttr, element, mainProto);
	                    }
	                    // element.dataset produces incorrect results in IE 11 browser.
	                    object = this[element.dataset && !ZC.Browser.isIE ? '_getDataSet' : '_getDataAttributes'](element, object || {}, mainProto); // No I18N
	                    $.data(element, 'ZCOpts', object); // No I18N
	                }
	            }
	            return object || {};
	        }
	    },
	    getOpts() {
	        return ZC._getOpts(...arguments);
	    },
	    _getObject(data, element, mainProto, aName) {
	        if (typeof data === 'object') { // No I18N
	            return data;
	        }
	        data = data || element.getAttribute('data'); // No I18N
	        data = data.indexOf('{') < 0 ? `{ ${data} }` : data; // No I18N
	        try {
	            data = JSON.parse(data.replace(/'/g, '"')); // No I18N
	        } catch (error) { // props check added since data might contain braces in them intentionally.
	            data = (!aName || (mainProto && Object.keys(mainProto.prototype._props).indexOf(aName) > -1)) ? {} : data;
	        }
	        return data;
	    },
	    _getDataSet(element, object, mainProto) {
	        let data = element.dataset,
	            value;
	        for (let i in data) {
	            // Removed hasOwnProperty check since i will be obviously present in data
	            /* replace svg and Html as Caps */
	            value = data[i];
	            i = this._getCorrectedKey(i);
	            object[i] = this._normalizeValue(i, value, mainProto && mainProto.prototype, mainProto);
	        }
	        return object;
	    },
	    _getCorrectedKey(key) {
	        return key
	            .replace(/(Html|Svg|svg|Hsv|Hsl|Rgb)/g, (x) => x.toUpperCase())
	            .replace(/^(OKButton)/i, 'OKButton'); // No I18N
	    },
	    _normalizeValue(optionName, value, instance, mainProto) {
	        if (value) {
	            let propType = instance && instance._propType;
	            if (propType && propType[optionName]) {
	                let dataType = propType[optionName];
	                try {
	                    switch (dataType) {
	                        case 'boolean': // No I18N
	                            value = value === 'true' || value === optionName; // No I18N
	                            break;
	                        case 'array': // No I18N
	                            value = JSON.parse(value);
	                            break;
	                        case 'object': // No I18N
	                            value = ZComponents._getObject(value, undefined, mainProto, optionName);
	                            break;
	                        case 'number': // No I18N
	                            value = parseFloat(value);
	                            break;
	                    }
	                } catch (e) {
	                    return value;
	                }
	            } else {
	                value = (value === 'true' || value === 'false') ? value === 'true' : value.indexOf('{') < 0 ? value : ZComponents._getObject(value, undefined, mainProto, optionName);
	            }
	        }
	        return value;
	    },
	    _getDataAttributes(element, object, mainProto) {
	        let data = element.attributes,
	            len = data.length;
	        for (let i = 0; i < len; i++) {
	            let name = data[i].nodeName,
	                value = data[i].nodeValue === '' ? 'true' : data[i].nodeValue; // No I18N
	            if (name !== 'data' && name.match(/^data-/)) { // No I18N
	                // data-* attributes and other attributes
	                name = ZC._getCamelCaseStr(name.replace(/^data-/, '')); // No I18N
	                /*  replacing the hyphenated names to camelCase
	                    modified the optionName since providing data-inner-html attribute in html element will be converted to innerHtml only.
	                    replace svg and Html as Caps */
	                object[name] = this._normalizeValue(i, value, mainProto && mainProto.prototype, mainProto);
	            }
	        }
	        return object;
	    },
	    _getCamelCaseStr(str) {
	        return str.replace(/(-html|-svg|svg|-hsv|-hsl|-rgb)|(-\w)/gi, (x) => x.replace('-', '').toUpperCase());
	        // changing the Ui by using the above regex replaces the menuId key also. So, we need below stmt in addition.
	        // Since, it is a costly operation, Currently that component needs to handle it. If we need this for more no of components, we will enable them.
	        // str = str.replace(/(ui|Ui)[A-Z]+/g, function(match){ return match.toUpperCase()});
	    },
	    _init() {
	        if (ZComponents.webComponentsSupport) {
	            let componentInstances = ZComponents.webComponentsToInit;
	            /* Web component initialization has been moved from connectedCallback to here. Since textNode and other children will not be available on connectedCallback. */
	            if (componentInstances && componentInstances.length) {
	                componentInstances.forEach((instancesArr) => {
	                    if (typeof instancesArr !== 'string') {
	                        instancesArr.forEach((instance) => {
	                            $(instance.element).data(instance.name, instance);
	                            instance._initComp();
	                            instance._appendTemplateContent();
	                        });
	                    }
	                });
	                ZComponents.webComponentsToInit = [];
	            }
	        }
	        ZComponents.setProperties();
	    },
	    setProperties() {
	        let doc = document.documentElement || {},
	            body = document.body || {};
	        ZComponents.documentObject = {
	            height: Math.max(doc.clientHeight, doc.scrollHeight, doc.offsetHeight, body.offsetHeight, body.scrollHeight),
	            width: Math.max(doc.clientWidth, doc.scrollHeight, doc.offsetHeight, body.offsetWidth, body.scrollWidth)
	        };
	        ZComponents.windowObject = {
	            height: window.innerHeight,
	            width: window.innerWidth
	        };
	    },
	    _render(data, componentName, templateName, element, appendTo, otherParams) { // No I18N
	        let isCE = otherParams.isCE;
	        let skipParent = otherParams.skipParent;
	        let container = otherParams.container;
	        let refElement = otherParams.refElement;
	        let isContainer = false,
	            templates = ZC[componentName].Templates;
	        data.zElement = false;
	        templateName = templateName || 'children'; // No I18N
	        templateName = isCE ? 'WC' + (templateName[0].toUpperCase() + templateName.substr(1)) : templateName;
	        if (!skipParent && !container) {
	            let templateFunc = templates[isCE ? 'WCContainer' : 'container']; // No I18N
	            if (templateFunc) {
	                element = ZT.DOM(templateFunc(data)); // No I18N
	                if (appendTo) {
	                    $(element).appendTo(appendTo);
	                } else if (refElement) {
	                    $(element).insertAfter(refElement);
	                }
	                isContainer = true;
	            }
	        } else {
	            element = element || (skipParent ? container || refElement : refElement);
	        }
	        let templateFunc = templates[templateName];
	        if (templateFunc) {
	            ZT.renderView(templateFunc(data), element);
	        }
	        if (isContainer) {
	            data.zElement = true;
	            /* !data.isCE && This is removed since whether it is a webcomponent/jscomponent, when container is present, the actual element should be hidden.  */
	            !data.differentAppend && $(refElement).hide();
	        }
	        return element; // element has to be returned always since methods using ZC._render has stored the element for further processing.
	    },
	    // stored in ZC scope in order to use in Alert Dialog like components.
	    _handleFocus(element, componentName) {
	        element = $(element);
	        let keyCodes = ZC.keyCode,
	            keyCode,
	            focusClass = 'has-focus', // No I18N
	            mfocusCls = 'has-mfocus', // No I18N
	            kfocusCls = 'has-kfocus', // No I18N
	            nameSpace = '.fs.' + componentName, // No I18N
	            eventType = '', // No I18N
	            isUI = false,
	            blurEventName = 'blur' + nameSpace, // No I18N
	            focusEventName = 'focus' + nameSpace, // No I18N
	            eventNames = 'mousedown' + nameSpace + ' keydown' + nameSpace + ' keyup' + nameSpace; // No I18N
	        /* Since event order is mousedown, focus, mouseup followed by click. Binding mousedown here. */
	        element.off(eventNames + ' ' + blurEventName + ' ' + focusEventName).on(eventNames, (event) => { // No I18N
	            if (element.hasClass('is-disabled')) { // No I18N
	                return;
	            }
	            if (event.originalEvent && event.type !== 'keyup') { // No I18N
	                // If the element is already active element, then the focus event is not triggered after mousedown. So, activeElement check included.
	                isUI = document.activeElement !== element[0]; // since originalEvent is present for triggered focus events too. Maintaining a variable to distinguish triggered focus and UI focus.
	            }
	            keyCode = event.keyCode;
	            eventType = event.type === 'mousedown' ? mfocusCls : kfocusCls; // No I18N
	            if ((event.type === 'keydown' && keyCode !== keyCodes.ENTER && keyCode !== keyCodes.SPACE) || (event.type === 'keyup' && keyCode !== keyCodes.TAB)) { // No I18N
	                return;
	            }
	            element.addClass(focusClass + ' ' + eventType); // No I18N
	        }).on(blurEventName, () => element.removeClass(focusClass + ' ' + mfocusCls + ' ' + kfocusCls)) // No I18N
	            .on(focusEventName, () => {
	                if (element.hasClass('is-disabled')) { // No I18N
	                    return;
	                }
	                // originalEvent check is added since trigger(focus) should focus the element.
	                if (!isUI) {
	                    element.addClass(focusClass + ' ' + kfocusCls);
	                }
	                isUI = false;
	            });
	    },
	    encodeHTML(str) {
	        sourceText.nodeValue = str;
	        return sourceDiv.innerHTML;
	    },
	    // Component Users can set I18N for all Components at once or individual components separately.
	    setI18NKeys(moduleName, values, replace) {
	        if (typeof moduleName === 'object') { // No I18N
	            // {"zdialog" : {"close":"Close the Dialog"},"ztooltip":{"close": "Close Text"} }
	            for (let i in moduleName) {
	                this.keys[i] = $.extend({}, this.keys[i], moduleName[i]);
	            }
	        } else {
	            // module name is a string. Format: "zdialog",{ "close" : "Close the Dialog"}, true or false
	            this.keys[moduleName] = replace ? values : $.extend({}, this.keys[moduleName], values);
	        }
	    },
	    _triggerFunction(functionName, context, params) {
	        // Invoking functions which are passed as strings in HTML Elements.
	        let executionContext = ZC._getContext(functionName);
	        return executionContext && executionContext.apply(context, params);
	    },
	    _getContext(functionName) {
	        if (typeof functionName === 'string') {
	            let executionContext = window,
	                namespaces = functionName.split('.'); // No I18N
	            for (let i = 0; i < namespaces.length && executionContext; i++) {
	                executionContext = executionContext[namespaces[i]];
	            }
	            return executionContext;
	        }
	        return functionName;
	    },
	    getI18NText(moduleName, key, stringArray) {
	        let defaultKeys;
	        if (arguments.length === 4) {
	            defaultKeys = stringArray;
	            stringArray = arguments[3];
	        }
	        let keyObject = ZComponents.keys[moduleName] || {},
	            ii8nText = keyObject[key] || '';
	        if (ii8nText === '' && defaultKeys) { // No I18N
	            ii8nText = defaultKeys[key];
	        }
	        if (stringArray) {
	            for (let i = 0; i < stringArray.length; i++) {
	                ii8nText = ii8nText.replace('{' + i + '}', stringArray[i]); // No I18N
	            }
	        }
	        return ii8nText;
	    },
	    create(initObject) {
	        let componentName = initObject.ctype.replace(initObject.ctype.charAt(0), ''); // No I18N
	        return this['create' + componentName.charAt(0).toUpperCase() + componentName.substring(1)](initObject); // No I18N
	    },
	    getRTLBasedDir(direction, rtl) {
	        if (rtl) {
	            return direction.replace(/(left|right)/, ($0) => $0 === 'left' ? 'right' : 'left'); // No I18N
	        }
	        return direction;
	    },
	    display(hide, element) {
	        if (!ZC._display) {
	            let flexElement = sourceDiv.cloneNode(),
	                flexString = [ '-webkit-box', '-moz-box', '-ms-flexbox', '-webkit-flex', 'flex' ].map((val) => 'display:' + val).join(';'); // No I18N
	            document.body.appendChild(flexElement).setAttribute('style', flexString);
	            ZC._display = window.getComputedStyle(flexElement).display;
	            flexElement.parentElement.removeChild(flexElement);
	        }
	        // more than one elements might be passed from the components. For Ex: Refer Date Picker Drilldown Animation. So, reverting the code to jQuery syntax.
	        $(element).css('display', hide ? 'none' : ZC._display); // No I18N
	        return element;
	    },
	    Browser: {
	        isMobile: /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent),
	        isIE: userAgent.indexOf('msie') > -1 || userAgent.indexOf('.net') > -1, // No I18N
	        isEdge: userAgent.indexOf('edge') > -1, // No I18N
	        isSafari: userAgent.indexOf('safari') > -1 && userAgent.indexOf('chrome') < 0, // No I18N
	        isChrome: userAgent.indexOf('chrome') > -1 && navigator.vendor.indexOf('Google Inc') > -1 && userAgent.indexOf('opr') === -1, /* Since window.chrome returns an object in edge, condition has been revisited */ // No I18N
	        isFirefox: userAgent.indexOf('firefox') > -1,
	        getIEVersion() {
	            let rv = -1; // Return value assumes failure.
	            if (ZC.Browser.isIE) {
	                let match = userAgent.match(/MSIE (\d*)/i);
	                if (!match) {
	                    match = userAgent.match(/Trident.*rv:(\d*)/i)
	                }
	                if (match) {
	                    rv = parseInt(match[1]);
	                }
	            }
	            return rv;
	        },
	        getFirefoxVersion() {
	            let res = -1;
	            if (ZC.Browser.isFirefox) {
	                res = parseInt(userAgent.match(/Firefox\/(\d*)/i)[1]);
	            }
	            return res;
	        }
	    },
	    _objectTypeFallback(protoObj, cnamelower, parentComponent, parentProto) {
	        let propsToBeMergedWithParent = [ 'name', 'attrs', 'props', 'CLASSES', 'EVENTS', 'SELECTORS' ]; // No I18N
	        protoObj.name = cnamelower;
	        // class is created by extending parent component
	        let childClass = class extends parentComponent {};
	        let childPrototype = childClass.prototype;
	        for (let property in protoObj) {
	            if (protoObj.hasOwnProperty(property)) {
	                let value = protoObj[property];
	                let parentValue = childPrototype[property];
	                let propertyDescriptor;
	                let isFunc = typeof value === 'function'; // No I18N
	                let doesParentHasProperty;
	                if (!isFunc) {
	                    let currentProto = parentProto;
	                    // Looping is done becos property descriptor is not returned if it is the property of the __proto__ object.
	                    while (currentProto && !(doesParentHasProperty = currentProto.hasOwnProperty(property))) {
	                        currentProto = Object.getPrototypeOf(currentProto);
	                    }
	                    if (doesParentHasProperty) {
	                        propertyDescriptor = Object.getOwnPropertyDescriptor(currentProto, property);
	                    }
	                }
	                // If function, property descriptor need not be checked.
	                // If the property is writable, it could be assigned directly. Else it is deleted and reassigned using getter in the else part.
	                if (isFunc || !doesParentHasProperty || propertyDescriptor.writable) {
	                    childPrototype[property] = value;
	                } else {
	                    if (doesParentHasProperty) {
	                        if (typeof value === 'object') { // No I18N
	                            // The property need not be deleted because it is not present in the childPrototype but in its prototype chain.
	                            // delete childPrototype[property];
	                            // Only certain properties are merged, others are overridden.
	                            if (propsToBeMergedWithParent.indexOf(property) !== -1) {
	                                if (Array.isArray(value)) {
	                                    value = parentValue.concat(value);
	                                } else {
	                                    value = $.extend(true, {}, parentValue, value);
	                                }
	                            }
	                        } else if (value === parentValue) {
	                            continue;
	                            // delete childPrototype[property];
	                        }
	                    }
	                    this._defineGetProp(childPrototype, property, value);
	                }
	            }
	        }
	        this._extend(childClass, parentComponent);
	        protoObj = childClass;
	        return protoObj;
	    }
	}
	window.ZComponents = ZComponents;
	let ZC = ZComponents;
	ZC.Templates.Utilities = {};
	document.addEventListener('DOMContentLoaded', ZC._init); // No I18N
	window.addEventListener('resize', ZC.setProperties); // No I18N
	class CoreComponent {
			get name(){
				return "corecomponent";
			}
	    constructor(element, options = {}) {
	        // this.name = this.constructor.name || this.constructor.name.toLowerCase(); // construtor.name will be present for components which is extended by simply providing an object.
	        this.element = element;
	        // ZC[this.name] ? ZC[this.name].DEFAULTS : {}, ZC._getOpts(element) were removed form assigning to this._opts
	        // which was already handled by getOpts()
	        this._opts = $.extend(true, {}, this._DEFAULTS, options);
	        this._create(element, this._opts);
	        /* Common Getter and Setter Methods for all properties present in a Component. */
	        // NeedCodeRevisit - This function call is need?
	        if (element) {
	            this._defineGetterSetter();
	        }
	    }
	    _getID(element, prefix, suffix) {
	        return ZC.getID(this.name, element, prefix, suffix);
	    }
	    _alterBorderRadius(opts, clear) {
	        return ZC.alterBorderRadius && ZC.alterBorderRadius({
	            ...opts,
	            element: opts.element || this.getElement(),
	            forElement: opts.forElement || this._opts.forElement
	        }, clear);
	    }
	    _isValid(key, value) {
	        return this._ALLOWEDVALUES[key].indexOf(value) > -1;
	    }
	    /** Should be removed after discussing with Raju - Revisit
	    _bindHandlers(events) {
	        for (let handler in events) {
	            let eventInfo = events[handler],
	                eventNames, key = handler + 'Handler', // No I18N
	                isDynamicEvent = false;
	            if (typeof eventInfo === 'string') {
	                eventNames = eventInfo.split(' ')
	            } else if (typeof eventInfo === 'object') {
	                isDynamicEvent = true;
	                eventNames = eventInfo.event.split(' ');
	            }
	            this._data[key] = {
	                namespace: this.name,
	                handler: this['_' + handler + 'Handler'].bind(this)
	            }
	            if (eventNames.length > 1 || isDynamicEvent) {
	                this._data[key].eventNames = eventNames;
	            }
	        }
	    } */
	    _addEvents(eventHandlers, element = this.getElement()) {
	        for (let handler in eventHandlers) {
	            let event = this._suffixCName(eventHandlers[handler]);
	            event && element.off(event).on(event, this['_' + handler + 'Handler'].bind(this)); // No I18N
	        }
	    }
	    _suffixCName(events) {
	        return events ? events.split(' ').reduce((acc, event) => acc + event + '.' + this.name + ' ', '') : ('.' + this.name); // No I18N
	    }
	    _removeEvents(events, element = this.getElement()) {
	        element.off(this._suffixCName(events));
	    }
	    _setParentClass(value) {
	        let data = this._data,
	            oldValue = data.parentClass;
	        if (oldValue !== value) {
	            let element = this._useParent || !this.container ? this.element : this.container;
	            if (element) {
	                oldValue && element.removeClass(oldValue);
	                element.addClass(value);
	            }
	            this._data.parentClass = value;
	        }
	    }
	    _commonPropSetters() {
	        this._data = {};
	        let opts = this._opts,
	            element = this.element[0],
	            dir = element.dir || document.body.dir; // No I18N
	        opts.rtl = dir === 'rtl' || opts.rtl; // No I18N
	        if (opts.templateData && typeof opts.templateData === 'object') { // No I18N
	            $.extend(true, this._data, opts.templateData);
	        }
	        this._data.isCE = opts.isCE;
	        // Removed window.getComputedStyle since it is recalculating the style and takes a lot of time to execute.
	    }
	    _create(element, options) {
	        this._commonPropSetters();
	        this.isCE = this.isCE || options.isCE;
	        this._useParent = this.isCE;
	        this._init(...arguments);
	        if (this._useParent) {
	            this.container = element;
	        }
	        let opts = this._opts;
	        // Attributes & class names will be added to the parent containers only when the container is not created from template.
	        let base = this;
	        this._data.parentClass = (opts.zclassName || opts.className || '') + (opts.rtl ? ' zh-rtl' : '');
	        Object.defineProperty(this._data, 'className', { // No I18N
	            set: function(value) {
	                base._setParentClass(value || base._data.parentClass);
	            },
	            get: function() {
	                return base._data.parentClass;
	            }
	        });
	        this._initialRender();
	        this._construct(...arguments);
	        this._data.rendered = true;
	        this._bindEvents();
	    }
	    _initialRender() {
	        this._render();
	    }
	    _appendEle(appendTo) {
	        if (appendTo) {
	            appendTo = $(appendTo)[0];
	            if (appendTo) {
	                let container = this.getElement()[0];
	                if (appendTo.lastElementChild !== container) {
	                    appendTo.appendChild(container);
	                }
	            }
	        }
	    }
	    _init() {}
	    _buildData() {}
	    _postRender() {}
	    _postEachRender() {}
	    _preRender(data) {
	        return data;
	    }
	    _construct() {}
	    _bindEvents() {}
	    _handleFocus(element, eludeFocusBinding) {
	        ZC._handleFocus(element || this.container, this.name, eludeFocusBinding);
	    }
	    _defineGetterSetter() {
	        let attrName,
	            compAttrs = Object.keys(this._DEFAULTS),
	            len = compAttrs.length,
	            i;
	        for (i = 0; i < len; i++) {
	            attrName = compAttrs[i];
	            // Checking whether a method is already available in the same name as property.
	            // For Ex: In tokenfield component, the name search will be used to denote a property as well as a method.
	            if (!this[attrName]) {
	                // Not able to checkin by having functions inside loops.. So using another _defineProperty method.
	                this._defineProperty(attrName);
	            }
	        }
	    }
	    _defineProperty(attrName) {
	        Object.defineProperty(this, attrName, {
	            set: function(value) {
	                this.setAttribute(attrName, value);
	            },
	            get: function() {
	                return this.getAttribute(attrName);
	            }
	        });
	    }
	    _display(hide, element = this.element) {
	        return ZC.display(hide, element);
	    }
	    _dispatchEvent(eventName, event, data, element, isFromUI) {
	        let eventType = eventName,
	            componentName = this.eventPrefix || this.name,
	            value;
	        if (this.isCE) {
	            eventType = 'z' + eventType; // No I18N
	        }
	        let type = eventType || eventName;
	        element = element || this.element;
	        let prop, orig,
	            callback = this._opts[type];
	        data = data || {};
	        data.fromUI = data.fromUI || isFromUI;
	        data.element = element;
	        data.container = this.getElement();
	        data.options = this._opts;
	        event = $.Event(event);
	        event.type = (componentName && !this.isCE ? componentName + type : type).toLowerCase();
	        // the original event may come from any element
	        // so we need to reset the target on the new event
	        event.originalTarget = event.target; // saving the original target.
	        event.target = element;
	        orig = event.originalEvent;
	        if (orig) {
	            for (prop in orig) {
	                if (!(prop in event)) {
	                    event[prop] = orig[prop];
	                }
	            }
	        }
	        if (this.isCE) {
	            event = this._dispatchCEEvent(eventType, data, element, event.originalEvent);
	        } else {
	            event.detail = data;
	            // Executing the callbacks assigned as property to the instance. Example: instance.onclick = function(){}
	            element.trigger(event, data);
	        }
	        // Temporarily commented. Need to discuss. - Revisit
	        // type = type[0].toUpperCase()+type.substr(1);
	        if (this['on' + type]) {
	            this['on' + type](event, data);
	        }
	        if (element[0]['onlyte' + type]) { // No I18N
	            element[0]['onlyte' + type](event, data); // No I18N
	        }
	        data = [ event ].concat(data);
	        if (!this.isCE) {
	            if (callback && typeof callback === 'string') { // No I18N
	                value = ZC._triggerFunction(callback, element[0], data);
	            } else {
	                value = typeof callback === 'function' ? callback.apply(element, data) : undefined; // No I18N
	            }
	        }
	        return typeof value === 'boolean' ? value : !event.isDefaultPrevented(); // No I18N
	    }
	    _getRTLBasedDir(dir) {
	        return ZC.getRTLBasedDir(dir, this._opts.rtl);
	    }
	    _getI18NText(key, stringArray, optionKey) {
	        let defaultKeys = this._opts.labels || this._opts.messages,
	            i18nText = optionKey ? this._opts[optionKey][key] : undefined;
	        if (i18nText) {
	            return i18nText;
	        }
	        let keyObject = ZC.keys[this.name] || {},
	            ii8nText = keyObject[key] || ''; // No I18N
	        if (ii8nText === '' && defaultKeys) { // No I18N
	            ii8nText = defaultKeys[key];
	        }
	        if (stringArray) {
	            for (let i = 0; i < stringArray.length; i++) {
	                ii8nText = ii8nText.replace(`{${i}}`, stringArray[i]);
	            }
	        }
	        return ii8nText;
	    }
	    listen(eventName, callback) {
	        this['on' + (eventName[0].toUpperCase() + eventName.substr(1)).replace(this.name, '')] = callback; // No I18N
	    }
	    getElement() {
	        return this.container || this.element;
	    }
	    getAttribute(optionName) {
	        return this._opts[optionName];
	    }
	    getAttributes() {
	        return $.extend(true, {}, this._opts); // extending in order to avoid object overriding.
	    }
	    setAttributes(options, element = this.element) {
	        for (let i in options) {
	            this.setAttribute(i, options[i], true);
	        }
	        this._renderAttrChange();
	    }
	    // This method is used to convert a JSON object to a valid style string that can be used for the template.
	    _getStyle(obj) {
	        if (obj && typeof obj === 'object') { // No I18N
	            let styleStr = ''; // No I18N
	            for (let key in obj) {
	                if (obj[key]) {
	                    styleStr += `${key}:${obj[key]};`
	                }
	            }
	            return styleStr;
	        }
	        return obj;
	        // the following method replaces comma in values as well and forloop is faster than stringify so it is replaced.
	        // return JSON.stringify(obj).replace(/{|}|"/g, '').replace(/,/g, ';'); // No I18N
	    }
	    _setAttribute() {}
	    _getOptVal(value, oldValue) {
	        if (value && typeof value === 'object' && typeof oldValue === 'object') { // No I18N
	            if (!(value instanceof Array) && !(oldValue instanceof Array) && !(value instanceof Date) && !(value instanceof RegExp) && !(value instanceof $) && !(value instanceof Element) && value !== window && !value.nodeName) {
	                return $.extend(true, {}, oldValue, value);
	            }
	            return value;
	        }
	        return value;
	    }
	    _isNotNull(value) {
	        return !this._isNull(value);
	    }
	    _isNull(value) {
	        return value === undefined || value === null;
	    }
	    _render(data, templateName = this._opts.templateFunc, element, skipParent = this._skipParent) {
	        data = data || Object.assign({}, this._opts, this._data);
	        data = this._preRender(data);
	        let componentName = this._opts.templateName || this.name;
	        let hasContainer = !!ZC[componentName].Templates[data.isCE ? 'WCContainer' : 'container']; // No I18N
	        // Snippet to use existing container instead of creating new one.
	        // if (!data.rendered && hasContainer) {
	        //     let containerId = data.attrs && data.attrs.id;
	        //     if (containerId) {
	        //         let outerContainer = $('#' + containerId); // No I18N
	        //         if (outerContainer.length) {
	        //             hasContainer = false;
	        //             this.container = outerContainer;
	        //         }
	        //     }
	        // }
	        skipParent = typeof skipParent === 'boolean' ? skipParent : hasContainer ? data.rendered : true; // No I18N
	        let renderParam = {
	            isCE: this._data.isCE,
	            skipParent,
	            container: this.container ? this.container[0] : undefined,
	            refElement: this.element && !data.differentAppend ? this.element[0] : undefined
	        }
	        // this._opts.templateName is used to prevent default template name from running.
	        let container = ZC._render(data, componentName, templateName, element, data.differentAppend, renderParam);
	        if (container && data.zElement) { // ZC._render always returns values. Since specific template can be rendered by setting skipParent as true, assigning this.container in that case will be erroneous. So, added skipParent check too.
	            this.container = $(container);
	        }
	        let parentEle = this.getElement();
	        if (data.attrs) {
	            element = data.alwaysSetAttrs ? parentEle : (element ? $(element) : (this._useParent || !this.container ? this.element : undefined));
	            if (element) {
	                element.attr(data.attrs);
	            }
	        }
	        if (!this._data.rendered) {
	            this._postRender(parentEle, this._opts);
	        }
	        this._postEachRender(parentEle, data);
	        return container;
	    }
	    setAttribute(optionName, value, isInternal) {
	        let opts = this._opts,
	            oldValue = opts[optionName],
	            isSpecialAttr,
	            container = this.getElement();
	        if (value === undefined) {
	            value = this._DEFAULTS[optionName];
	        }
	        // Added null check since null is an object
	        if ((typeof oldValue !== 'object' || oldValue === null) && oldValue === value) { // No I18N
	            // checking whether the value is actually modified or not.
	            return;
	        }
	        value = this._getOptVal(value, oldValue);
	        if (this.isCE && this.element[0]._initialized || !this.isCE || ZC.useWebComponentsSelector) {
	            this._setAttribute(optionName, value);
	        }
	        // Added container check since some components do not have container itself. Eg: List
	        isSpecialAttr = container && !this._stopAttrUpdate;
	        if (isSpecialAttr) {
	            if (optionName === 'rtl') { // No I18N
	                container[value ? 'addClass' : 'removeClass']('zh-rtl'); // No I18N
	                this._updateClass('zh-rtl', value ? null : true); // No I18N
	            } else if (optionName === 'className' || optionName === 'zclassName') { // No I18N
	                this._updateClass(value, oldValue);
	            } else if (optionName === 'disabled') { // No I18N
	                this._disable(value);
	            } else if (optionName === 'appendTo') { // No I18N
	                this._appendEle(value || 'body'); // No I18N
	            } else if (optionName === 'templateFunc') { // No I18N
	                this._domChanged = true;
	            } else if (optionName === 'templateData') { // No I18N
	                if (value) {
	                    $.extend(true, this._data, value);
	                    this._domChanged = true;
	                } else if (oldValue) {
	                    Object.keys(oldValue).forEach((key) => this._data[key] = null);
	                    this._domChanged = true;
	                }
	            } else {
	                isSpecialAttr = false;
	            }
	        }
	        this._stopAttrUpdate = false;
	        if (isSpecialAttr) {
	            opts[optionName] = value;
	        }
	        if (!isInternal) {
	            this._renderAttrChange();
	        }
	    }
	    _renderAttrChange() {
	        if (this._reInit) {
	            this._domChanged = true;
	            this._buildData();
	        }
	        if (this._domChanged) {
	            this._render();
	        }
	        this._domChanged = this._reInit = false;
	    }
	    _setBtnValue(attrs, btnObj) {
	        let mainElement = btnObj && btnObj.mainElement;
	        if (mainElement) {
	            ZC.button(mainElement).setAttributes(attrs);
	        } else {
	            this._domChanged = true;
	        }
	    }
	    _setUndefined(arr, addTxt) {
	        for (let i = 0, len = arr.length; i < len; i++) {
	            this['_' + arr[i] + addTxt] = undefined;
	        }
	    }
	    _disable(disable, element, preventClsManip) {
	        let useData = !element,
	            dCls = 'is-disabled'; // No I18N
	        element = element || this.getElement();
	        if (!preventClsManip) {
	            if (useData) {
	                this._updateClass(disable ? dCls : '', !disable && dCls);
	            } else {
	                element[disable ? 'addClass' : 'removeClass'](dCls); // No I18N
	            }
	        }
	        this._addedByComponent = true;
	        if (disable) {
	            element.attr({
	                'aria-disabled': true, // No I18N
	                disabled: true // No I18N
	            });
	        } else {
	            element.removeAttr('aria-disabled disabled'); // No I18N
	        }
	        this._addedByComponent = false;
	    }
	    _emptyElement(container, start) {
	        while (start) {
	            let tempNode = start.nextSibling;
	            container.removeChild(start);
	            start = tempNode;
	        }
	    }
	    // To update this._data.className
	    _updateClass(className, removeOrReplace, container) {
	        if (container) {
	            container[removeOrReplace ? 'removeClass' : 'addClass'](className); // No I18N
	        } else if (this._data) {
	            let data = this._data,
	                oldClass = data.className;
	            if (removeOrReplace) {
	                if (typeof removeOrReplace === 'boolean') { // No I18N
	                    removeOrReplace = className;
	                    className = ''; // No I18N
	                }
	                oldClass = oldClass.replace(new RegExp('(?:^|( +)?)' + removeOrReplace + '(?:$|( +)?)', 'g'), ' ' + className + ' '); // No I18N
	            } else {
	                oldClass += ' ' + className;
	            }
	            data.className = oldClass;
	        }
	    }
	    _destroy() {}
	    destroy() {
	        if (this.container || this.element) { // This check is added to avoid calling destroy method more than once
	            this._dispatchEvent('beforedestroy'); // No I18N
	            let $element = this.element,
	                container = this.container,
	                actualElement = container || $element;
	            actualElement.off('.' + this.name);
	            this._destroy();
	            (!container && !this._useParent) && $element.empty();
	            ZT.removeCacheData(actualElement[0]);
	            $element && $element.removeData(this.name).removeData('ZCOpts'); // No I18N
	            this._data && this._setParentClass(' '); // No I18N
	            // undefined is replaced by space since className property setter has undefined check
	            if (!this._useParent && container) {
	                container.remove();
	                $element[0].style.display = ''; // No I18N
	            }
	            if (this.isCE && !this._eleRemoval) {
	                this._destroyCE(true);
	            }
	            this.container = this.element = undefined;
	        }
	    }
		_mapJSONToData  (data, mapValue, encode) {
		    if (this._isNotNull(mapValue) && this._isNotNull(data)) {
		        mapValue = mapValue.trim().split('.'); // No I18N
		        for (let i = 0; i < mapValue.length; i++) {
		            data = data[mapValue[i]];
		        }
		        return data && encode ? this._encodeContent(data) : data;
		    }
		}
		_toArr  (values, removeDuplicates) {
		    let valArr;
		    if (values instanceof $) {
		        valArr = values.toArray();
		    }
		    valArr = Array.isArray(values) ? values : [ values ];
		    return valArr.filter((val, index) => {
		        if (this._isNotNull(val)) {
		            if (!removeDuplicates || valArr.indexOf(val) === index) {
		                return true;
		            }
		        }
		    });
		}
		_isAjaxSource  (dataSource) {
		    return dataSource && (dataSource.URL || dataSource.search);
		}
		_removeNulls  (values) {
		    return values.filter((val) => this._isNotNull(val));
		}
		_getProp  (data, mapKey, encode) {
		    let dataMapping = this._getMapping();
		    let mapField = dataMapping[mapKey];
		    return this._mapJSONToData(data, mapField, encode);
		}
		_getMapping  () {
		    return this._dataMapping || this._opts.dataMapping;
		}
		_getUniqueValue  (data) {
		    if (this._isNotNull(data)) {
		        let value;
		        if (typeof data === 'object') { // No I18N
		            value = this._getProp(data, 'value'); // No I18N
		            if (this._isNotNull(value)) {
		                return String(value);
		            }
		            value = this._getProp(data, 'text'); // No I18N
		            if (this._isNotNull(value)) {
		                return String(value);
		            }
		            return value;
		        }
		        return String(data);
		    }
		}
		_getMatchingRegex  (query, filter) {
		    let criteria = filter.criteria || 'contains'; // No I18N
		    let caseSensitive = filter.caseSensitive;
		    query = this._escapeQuery(query);
		    let regex = {
		        contains: '(' + query + ')', // No I18N
		        startswith: '(^' + query + ')', // No I18N
		        endswith: '(' + query + '$)', // No I18N
		        equals: '(^' + query + '$)' // No I18N
		    }
		    return new RegExp(regex[criteria.toLowerCase()], 'g' + (caseSensitive ? '' : 'i')); // No I18N
		}
		_getSearchBy  (fields) {
		    if (fields) {
		        if (typeof fields === 'string') { // No I18N
		            fields = fields.split(','); // No I18N
		        }
		    } else {
		        let dataMapping = this._getMapping();
		        fields = [ dataMapping.text ];
		    }
		    return fields.map((by) => by.trim());
		}
		_isFunc  (func) {
		    return typeof func === 'function'; // No I18N
		}
		disable  (disable = true) {
		    this._opts.disabled = disable;
		    this._disable(disable);
		    this._renderAttrChange();
		}
		enable  () {
		    this.disable(false);
		}
		_removeSpecialChars  (string) {
		    return string.replace(/[^a-zA-Z0-9]/g, ''); // No I18N
		}
		_setProp  (data, mapKey, value) {
		    let dataMapping = this._getMapping();
		    let mapField = dataMapping[mapKey];
		    if (mapField) {
		        let keys = mapField.split('.'); // No I18N
		        let finalKey = keys.pop();
		        keys.forEach((key) => {
		            data = data[key] = data[key] || {};
		        });
		        data[finalKey] = value;
		    }
		}
		_getById  (id) {
		    return this.container ? this.container.find('[id="' + id + '"]') : $(); // No I18N
		    // return $(document.getElementById(id));
		}
		_encodeContent  (data, encode) {
		    encode = this._isNotNull(encode) ? encode : !this._isEncoded();
		    return encode ? ZC.encodeHTML(data) : data;
		}
		_isEncoded  () {
		    return this._opts.isLabelHTMLEncoded;
		}
		_isAlphaNumericKey  (orgEvent) {
		    let keyCode = orgEvent.keyCode;
		    return !(orgEvent.metaKey || orgEvent.ctrlKey) && (keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222 || keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 97 && keyCode <= 122 || keyCode === ZC.keyCode.SPACE || keyCode === ZC.keyCode.DELETE || keyCode === ZC.keyCode.BACKSPACE);
		}
		_getItemId  (data, baseId) {
		    // Special characters are removed while generating the Id.
		    let id = data.zitemid;
		    if (!id) {
		        let value = this._getUniqueValue(data);
		        if (value) {
		            value = this._removeSpecialChars(String(value));
		        }
		        if (value) {
		            id = baseId + '-' + value; // No I18N
		        } else {
		            id = ZC.getID(this.name, null, baseId);
		        }
		    }
		    return id;
		}
		_escapeQuery  (query) {
		    return query.replace(new RegExp("([',\",(,),+,?,>,<,.,|,*,\\\\,\\[,\\]])", 'g'), '\\$1'); // No I18N
		}
		_getCustomContent  (data, template, highlight, labelKey = 'label', encode) { // No I18N
		    if (template) {
		        if (typeof template === 'string') { // No I18N
		            return template.replace(/(#?#[^#\n"']+#?#)/g, (match) => {
		                let prop = match.replace(/#/g, ''); // No I18N
		                let content = data[prop];
		                if (this._isNotNull(content)) {
		                    content = this._encodeContent(content, encode);
		                    if (highlight) {
		                        content = this._highlight(content, prop);
		                    }
		                    return content;
		                }
		                return match;
		            });
		        } else if (typeof template === 'function') { // No I18N
		            return template(data);
		        }
		    } else {
		        let dataMapping = this._getMapping();
		        let content = this._encodeContent(this._getProp(data, labelKey), encode);
		        if (highlight) {
		            content = this._highlight(content, dataMapping[labelKey]);
		        }
		        return content;
		    }
		}
		_objectTypeFallback  (protoObj, cnamelower, parentComponent, parentProto) {
		    let propsToBeMergedWithParent = [ 'attrs', 'props', 'CLASSES', 'EVENTS', 'SELECTORS' ]; // No I18N
		    protoObj.name = cnamelower;
		    // class is created by extending parent component
		    let childClass = class extends parentComponent { };
		    childClass.name = protoObj.name;
		    let childPrototype = childClass.prototype;
		    for (let property in protoObj) {
		        if (protoObj.hasOwnProperty(property)) {
		            let value = protoObj[property];
		            let parentValue = childPrototype[property];
		            let propertyDescriptor;
		            let isFunc = typeof value === 'function'; // No I18N
		            let doesParentHasProperty;
		            if (!isFunc) {
		                let currentProto = parentProto;
		                // Looping is done becos property descriptor is not returned if it is the property of the __proto__ object.
		                while (currentProto && !(doesParentHasProperty = currentProto.hasOwnProperty(property))) {
		                    currentProto = Object.getPrototypeOf(currentProto);
		                }
		                if (doesParentHasProperty) {
		                    propertyDescriptor = Object.getOwnPropertyDescriptor(currentProto, property);
		                }
		            }
		            // If function, property descriptor need not be checked.
		            // If the property is writable, it could be assigned directly. Else it is deleted and reassigned using getter in the else part.
		            if (isFunc || !doesParentHasProperty || propertyDescriptor.writable) {
		                childPrototype[property] = value;
		            } else {
		                if (doesParentHasProperty) {
		                    if (typeof value === 'object') { // No I18N
		                        // The property need not be deleted because it is not present in the childPrototype but in its prototype chain.
		                        // delete childPrototype[property];
		                        // Only certain properties are merged, others are overridden.
		                        if (propsToBeMergedWithParent.indexOf(property) !== -1) {
		                            if (Array.isArray(value)) {
		                                value = parentValue.concat(value);
		                            } else {
		                                value = $.extend(true, {}, parentValue, value);
		                            }
		                        }
		                    } else if (value === parentValue) {
		                        continue;
		                        // delete childPrototype[property];
		                    }
		                }
		                this._defineGetProp(childPrototype, property, value);
		            }
		        }
		    }
		    this._extend(childClass, parentComponent);
		    protoObj = childClass;
		}
		_translateEToA  (result) {
		    let locale = this._opts.locale || ''; // No I18N
		    if (locale === 'ar' || locale.indexOf('ar-') === 0) { // No I18N
		        return String(result).replace(/[0-9]/g, (w) => String.fromCharCode(w.charCodeAt(0) + 1584));
		    }
		    return result;
		}
		_translateAToE  (char) {
		    let locale = this._opts.locale || ''; // No I18N
		    if (locale === 'ar' || locale.indexOf('ar-') === 0) { // No I18N
		        return String(char).replace(/[\u0660-\u0669]/g, (c) => c.charCodeAt(0) - 0x0660);
		    }
		    return char;
		}
	}
	ZC.CoreComponent = CoreComponent; 
	ZC.tagNames = {
		zalertbanner: ['div', 'z-alertbanner'],

		zbutton: ['button', 'z-button'],

		zbuttongroup: ['div', 'z-buttongroup'],

		zfileupload: ['label', 'z-fileupload'],

		zmenubutton: ['button', 'z-menubutton'],

		zsplitbutton: ['button', 'z-splitbutton'],

		zcheckboxbutton: ['div', 'z-checkboxbutton'],

		zradiobutton: ['div', 'z-radiobutton'],

		znumberfield: ['input', 'z-numberfield'],

		zcurrencyfield: ['input', 'z-currencyfield'],

		ztimeinput: ['div', 'z-timeinput'],

		zpopover: ['div', 'z-popover'],

		zmenu: ['div', 'z-menu'],

		zlistbox: ['div', 'z-listbox'],

		zdropdownlist: ['div', 'z-dropdownlist'],

		zdialog: ['div', 'z-dialog'],

		zalertdialog: ['div', 'z-alertdialog'],

		zaccordion: ['div', 'z-accordion'],

		zaccitem: ['div', 'z-accitem'],

		zcollapsiblepanels: ['div', 'z-collapsiblepanels'],

		zcollapsiblepanel: ['div', 'z-collapsiblepanel'],

		zdatefield: ['input', 'z-datefield'],

		zsuggestfield: ['input', 'z-suggestfield'],

		ztokenfield: ['input', 'z-tokenfield'],

		ztimefield: ['input', 'z-timefield'],

		zdatetimepicker: ['div', 'z-datetimepicker'],

		zdatetimefield: ['input', 'z-datetimefield'],

		zdatepicker: ['div', 'z-datepicker'],

		zdaterangepicker: ['div', 'z-daterangepicker'],

		zdatetimerangepicker: ['div', 'z-datetimerangepicker'],

		zcolorselect: ['div', 'z-colorselect'],

		zcolorsplitbutton: ['div', 'z-colorsplitbutton'],

		zcolorbutton: ['div', 'z-colorbutton'],

		zselect: ['select', 'z-select'],

		zoption: ['option', 'z-option'],

		zoptgroup: ['optgroup', 'z-optgroup'],

		zoptionseparator: ['option', 'z-optionseparator'],

		zaddoption: ['option', 'z-addoption'],

		zcombobox: ['select', 'z-combobox'],

		zslider: ['div', 'z-slider'],

		zspinnerslider: ['div', 'z-spinnerslider'],

		zdoubleslider: ['div', 'z-doubleslider'],

		zprogressbar: ['div', 'z-progressbar'],

		zprogresswheel: ['div', 'z-progresswheel'],

		ztoggleswitch: ['div', 'z-toggleswitch'],

		zrockerswitch: ['div', 'z-rockerswitch'],

		zcolorpicker: ['div', 'z-colorpicker'],

		zadvancedcolorpicker: ['div', 'z-advancedcolorpicker'],

		ztabpanel: ['div', 'z-tabpanel'],

		zpanel: ['div', 'z-panel'],

		zdateselect: ['select', 'z-dateselect'],

		zdatetimeselect: ['select', 'z-datetimeselect'],

		zscreengrabber: ['div', 'z-screengrabber'],

		zpreview: ['div', 'z-preview'],

		zfontlibrary: ['div', 'z-fontlibrary'],
};
	ZC.AJAX = {
	    transport: function(params, successCallback, failureCallback, alwaysCallback) {
	        return $.ajax({
	            url: params.sourceURL,
	            data: params.data,
	            type: params.type,
	            dataType: params.dataType,
	            success(data) {
	                successCallback && successCallback(data)
	            },
	            fail(error, exception) {
	                failureCallback && failureCallback(error, exception);
	            },
	            error(error, exception) {
	                failureCallback && failureCallback(error, exception);
	            },
	            always() { // temporary fix until DOM UTIL returns promise object.
	                alwaysCallback && alwaysCallback();
	            }
	        });
	    }
	}
	
	ZC.alterBorderRadius = function(options, clear) { // alternative names: change, modify
	    // options: element, forElement, direction, offset, hasSideAlignment ( set true if submenu )
	    let cls = 'zh-radiusbottomleft zh-radiustopleft zh-radiusbottomright zh-radiustopright zh-radiustop zh-radiusbottom zh-radiusright zh-radiusleft', // No I18N
	        ele = options.element,
	        target = options.forElement;
	    // Resetting the border radius which was set previously.
	    ele.add(target).removeClass(cls); // No I18N
	    if (clear) {
	        return;
	    }
	    let sideAdjustments = [ 'right-top', 'right-bottom', 'left-top', 'left-bottom' ], // No I18N
	        pairs = {
	            right: 'left', // No I18N
	            left: 'right', // No I18N
	            top: 'bottom', // No I18N
	            bottom: 'top' // No I18N
	        },
	        dir = options.direction,
	        pos = options.offset;
	    if (options.hasSideAlignment && sideAdjustments.indexOf(dir) < 0) { // denotes submenu like cases where the element will not open in top/bottom directions.
	        ele.addClass(dir.replace(/([a-z]+)-([a-z]+)/g, (match, w1, w2) => 'zh-radius' + pairs[w2] + pairs[w1])); // No I18N
	        pos.left += dir.indexOf('left') === 0 ? 1 : -1;
	    } else { // setting the border radius based on the element opening direction.
	        let pInt = parseInt,
	            topLeft = 0,
	            topRight = 0,
	            bottomLeft = 0,
	            bottomRight = 0;
	        if (target.length) { // usage of css method should be avoided ##revisit later
	            topLeft = pInt(target.css('border-top-left-radius')); // No I18N
	            topRight = pInt(target.css('border-top-right-radius')); // No I18N
	            bottomLeft = pInt(target.css('border-bottom-left-radius')); // No I18N
	            bottomRight = pInt(target.css('border-bottom-right-radius')); // No I18N
	        }
	        if (topLeft <= 5 && topRight <= 5 && bottomLeft <= 5 && bottomRight <= 5) { // circular type targets should be excluded.
	            let borderSuffix, targetSuffix;
	            if (dir.indexOf('top') === 0 || dir.indexOf('bottom') === 0) { // No I18N
	                dir.replace(/(\w+)-(\w+)/g, (match, w1, w2) => { // only top-right, top-left, bottom-right, bottom-left has to be considered
	                    // outer width is taken into account since width lacks border values.
	                    let twidth = target.outerWidth(),
	                        ewidth = ele.outerWidth(),
	                        isEqual = twidth === ewidth,
	                        isGreater = twidth < ewidth; // for select box like elements both the width are equal.
	                    if(isEqual){
	                        borderSuffix = pairs[w1];
	                        targetSuffix = w1;
	                    }else{
	                        borderSuffix = pairs[w1] + (isGreater ? w2 : '');
	                        targetSuffix = w1 + (isGreater ? '' : w2);
	                    }
	                    // let isGreater = target.outerWidth() <= ele.outerWidth(); // for select box like elements both the width are equal.
	                    // borderSuffix = pairs[w1] + (isGreater ? w2 : '');
	                    // targetSuffix = w1 + (isGreater ? '' : w2);
	                });
	                pos.top += dir.indexOf('top') === 0 ? 1 : -1; // This change is needed after Flex and RTL related CSS changes.
	            } else if ((/^right(-)?(\w)*$/).test(dir) || (/^left(-)?(\w)*$/).test(dir)) {
	                dir.replace(/^right|left(-)?(\w)*$/g, (w1) => {
	                    borderSuffix = pairs[w1.split('-')[0]];
	                });
	                targetSuffix = pairs[borderSuffix];
	            }
	            ele.addClass('zh-radius' + borderSuffix); // No I18N
	            target.addClass('zh-radius' + targetSuffix); // No I18N
	        } else { // adjust the top value of the element by 2 pixels.
	            pos.top = pos.top + 2;
	        }
	    }
	    return pos;
	}
	
	ZC.init = function(container, callback, attr) {
	    needToInit && this._init();
	    container = container ? $(container) : $('body');
	    let attr1 = attr || this.selector,
	        attrSelector = '[' + attr1 + ']', // No I18N
	        uiComponents = document.querySelectorAll ? container[0].querySelectorAll(attrSelector) : $(attrSelector, container);
	    if (container[0].attributes[attr1] || container[0].dataset && container[0].dataset[attr1]) {
	        uiComponents = $(container).add(uiComponents);
	    }
	    if (uiComponents.length) {
	        let base = this;
	        this.eachAsync(uiComponents, {
	            delay: 20,
	            loop(i, ele) {
	                base._initComponent(ele, undefined, attr);
	            },
	            end() {
	                base._end(container, uiComponents, callback);
	            }
	        });
	    } else {
	        this._end(container, uiComponents, callback);
	    }
	}
	ZC.destroy = function(container, callback, attr) {
	    container = container ? $(container) : $('body');
	    attr = attr || this.selector;
	    let attrSelector = '[' + attr + ']', // No I18N
	        uiComponents = $(attrSelector, container);
	    if (container.is(attrSelector)) {
	        uiComponents = $(container).add(uiComponents);
	    }
	    if (uiComponents.length) {
	        let base = this;
	        this.eachAsync(uiComponents, {
	            delay: 20,
	            loop(i, ele) {
	                $(ele)[ele.getAttribute(attr)]('destroy');
	            },
	            end() {
	                base._end(container, uiComponents, callback, true);
	            }
	        });
	    } else {
	        this._end(container, uiComponents, callback, true);
	    }
	}
	
	ZC.eachAsync = function(array, opts) { // will be modified later
	    let i = 0,
	        l = array.length,
	        loop = opts.loop || function() {};
	
	    this.whileAsync($.extend(opts, {
	        test() {
	            return i < l;
	        },
	        loop() {
	            let val = array[i];
	            return val && loop.call(val, i++, val);
	        }
	    }));
	}
	
	ZC.whileAsync = function(opts) { // async utility from jquery
	    let delay = Math.abs(opts.delay) || 10,
	        bulk = isNaN(opts.bulk) ? 500 : Math.abs(opts.bulk),
	        test = opts.test || function() {
	            return true;
	        },
	        loop = opts.loop || function() {},
	        end = opts.end || function() {};
	
	    (function executeLoop() {
	        let t = false,
	            begin = new Date();
	        while (t = test()) {
	            loop();
	            if (bulk === 0 || new Date() - begin > bulk) {
	                break;
	            }
	        }
	        if (t) {
	            setTimeout(executeLoop, delay);
	        } else {
	            end();
	        }
	    }());
	}
	
	ZC._end = function(mainDiv, uiComponents, callback, isDestroy) {
	    this.$document.trigger('zcomponent' + (isDestroy ? 'destroyed' : 'initialized'), mainDiv); // No I18N
	    callback && callback(uiComponents);
	}
	
	ZC._initDeferredComponents = function(componentsMap, timeout, callback) {
	    setTimeout(() => {
	        $.each(componentsMap, (ctype, componentGroup) => {
	            $(componentGroup).each(function(i, component) {
	                this._initComponent($(component), ctype);
	            });
	        });
	        callback && callback(componentsMap);
	    }, timeout || 10000); // Default is 10 seconds
	}
	
	ZC._initComponent = function(element, ctype, attr) {
	    element = $(element);
	    ctype = ctype || element.attr(attr || this.selector);
	    ctype = ctype.replace(/^z/, ''); // No I18N
	    ZC[ctype](element);
	}
	
	ZC.localeInfo = {
	    'en-US': { // No I18N
	        daysAbbreviated: [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ], // No I18N
	        days: [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ], // No I18N
	        months: [ 'January', // No I18N
	            'February', // No I18N
	            'March', // No I18N
	            'April', // No I18N
	            'May', // No I18N
	            'June', // No I18N
	            'July', // No I18N
	            'August', // No I18N
	            'September', // No I18N
	            'October', // No I18N
	            'November', // No I18N
	            'December' ], // No I18N
	        monthsAbbreviated: [ 'Jan', // No I18N
	            'Feb', // No I18N
	            'Mar', // No I18N
	            'Apr', // No I18N
	            'May', // No I18N
	            'Jun', // No I18N
	            'Jul', // No I18N
	            'Aug', // No I18N
	            'Sep', // No I18N
	            'Oct', // No I18N
	            'Nov', // No I18N
	            'Dec' ], // No I18N
	        firstDayOfWeek: 0, // No I18N
	        dateFormat: { // No I18N
	            'short': 'M/d/yyyy', // No I18N
	            medium: 'MMM d, yyyy', // No I18N
	            'long': 'MMMM d, yyyy', // No I18N
	            full: 'dddd, MMMM d, yyyy' // No I18N
	        },
	        timeFormat: { // No I18N
	            'short': 'h:mm tt', // No I18N
	            medium: 'h:mm:ss tt', // No I18N
	            'long': 'hh:mm:ss tt' // No I18N
	        },
	        dateTimeFormat: { // No I18N
	            'short': 'MMM d, yyyy, hh:mm:ss tt', // No I18N
	            medium: 'MMM d, yyyy, hh:mm:ss tt', // No I18N
	            'long': "dddd, MMMM d, yyyy 'at' h:mm tt", // No I18N
	            full: "dddd, MMMM d, yyyy 'at' h:mm tt" // No I18N
	        },
	        numberFormat: { // No I18N
	            thousandSeparator: ',', // No I18N
	            decimalSeparator: '.' // No I18N
	        },
	        currency: { // No I18N
	            code: 'USD', // No I18N
	            name: 'United States Dollar', // No I18N
	            symbol: '\u0024' // No I18N
	        }
	    }
	}
	
	ZC.getPrototype = function(prototype, core) {
	    if (prototype instanceof Function) {
	        let classProto = prototype;
	        while (classProto) {
	            let newBaseClass = Object.getPrototypeOf(classProto);
	            classProto = this._mergePrototypes(core.prototype, classProto.prototype);
	            if (newBaseClass && newBaseClass !== Object && newBaseClass.name) {
	                classProto = newBaseClass;
	            } else {
	                break;
	            }
	        }
	        return classProto;
	    }
	}
	
	ZC._mergePrototypes = function(proto, parentProto) {
	    let parentProp = Object.getOwnPropertyNames(parentProto),
	        exists, prop;
	    for (let i = 0, len = parentProp.length; i < len; i++) {
	        exists = false;
	        prop = Object.getOwnPropertyNames(proto);
	        for (let j = 0, length = prop.length; j < length; j++) {
	            if (parentProp[i] === prop[j] && (typeof parentProto[prop[j]] !== 'object' || parentProto[prop[j]] instanceof Array)) { // No I18N
	                exists = true;
	                break;
	            }
	        }
	        if (!exists && parentProp[i] !== 'SELECTORS') {
	            let parentProtoValue = parentProto[parentProp[i]];
	            proto[(parentProto.isCE ? '_' : '') + parentProp[i]] = typeof parentProtoValue === 'object' && !(parentProtoValue instanceof Array) ? $.extend(true, {}, parentProtoValue, proto[parentProp[i]]) : parentProtoValue; // No I18N
	        }
	    }
	    return proto.constructor;
	}
	 
})(window.$zc || jQuery);
(function(ZC){
	if(typeof module === 'object' && typeof module.exports === 'object'){
		module.exports = (function(){
			return ZC;
		})();
	}
})(ZComponents);
/* $Id$ */
ZComponents.localeInfo =
{
	"br": {
		"days": ["Sul", "Lun", "Meurzh", "Mercher", "Yaou", "Gwener", "Sadorn"],
		"months": ["Genver", "Chwevrer", "Meurzh", "Ebrel", "Mae", "Mezheven", "Gouere", "Eost", "Gwengolo", "Here", "Du", "Kerzu"],
		"monthsAbbreviated": ["Gen.", "Chwe.", "Meur.", "Ebr.", "Mae", "Mezh.", "Goue.", "Eost", "Gwen.", "Here", "Du", "Kzu."],
		"daysAbbreviated": ["Sul", "Lun", "Meu.", "Mer.", "Yaou", "Gwe.", "Sad."],
		"dateFormat": {
			"short": "yyyy-MM-dd",
			"medium": "yyyy MMM d",
			"long": "yyyy MMMM d",
			"full": "yyyy MMMM d, dddd"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "yyyy MMM d HH:mm:ss z",
			"medium": "yyyy MMM d HH:mm:ss z",
			"long": "yyyy MMMM d, dddd HH:mm",
			"full": "yyyy MMMM d, dddd HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "BRL",
			"name": "Brazilian real",
			"symbol": "\u0052\u0024",
			"position": "right"
		},
		"firstDayOfWeek": 0
	},
	"ca-IT": {
		"daysAbbreviated": ["dg.", "dl.", "dt.", "dc.", "dj.", "dv.", "ds."],
		"days": ["diumenge", "dilluns", "dimarts", "dimecres", "dijous", "divendres", "dissabte"],
		"months": ["de gener", "de febrer", "de mar", "dabril", "de maig", "de juny", "de juliol", "dagost", "de setembre", "doctubre", "de novembre", "de desembre"],
		"monthsAbbreviated": ["de gen.", "de febr.", "de mar", "dabr.", "de maig", "de juny", "de jul.", "dag.", "de set.", "doct.", "de nov.", "de des."],
		"dateFormat": {
			"short": "d/M/yy",
			"medium": "d/M/yyyy",
			"long": "d MMMM 'de' yyyy",
			"full": "dddd d MMMM 'de' yyyy"
		},
		"timeFormat": {
			"short": "H:mm",
			"medium": "H:mm:ss",
			"long": "H:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d/M/yyyy,  H:mm:ss z",
			"medium": "d/M/yyyy,  H:mm:ss z",
			"long": "d/M/yyyy,  H:mm:ss z",
			"full": "d/M/yyyy,  H:mm:ss z"
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		},
		"firstDayOfWeek": 1
	},
	"da": {
		"days": ["sndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lrdag"],
		"months": ["", "", "", "", "", "", "", "", "", "", "", ""],
		"monthsAbbreviated": [".", ".", ".", ".", "", ".", ".", ".", ".", ".", ".", "."],
		"daysAbbreviated": ["sn.", "man.", "tir.", "ons.", "tor.", "fre.", "lr."],
		"dateFormat": {
			"short": "d/M/yyyy",
			"medium": "d. MMM yyyy",
			"long": "d. MMMM yyyy",
			"full": "dddd d. MMMM yyyy"
		},
		"timeFormat": {
			"short": "HH.mm",
			"medium": "HH.mm.ss",
			"long": "HH.mm.ss z"
		},
		"dateTimeFormat": {
			"short": "d. MMM yyyy HH.mm.ss z",
			"medium": "d. MMM yyyy HH.mm.ss z",
			"long": "dddd d. MMMM yyyy HH.mm",
			"full": "dddd d. MMMM yyyy HH.mm"
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "DKK",
			"name": "Danish krone",
			"symbol": "\u006b\u0072",
			"position": "right"
		}
	},
	"de": {
		"monthsAbbreviated": ["Jan.", "Feb.", "Mrz", "Apr.", "Mai", "Juni", "Juli", "Aug.", "Sep.", "Okt.", "Nov.", "Dez."],
		"months": ["Januar", "Februar", "Mrz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
		"days": ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
		"daysAbbreviated": ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
		"dateFormat": {
			"short": "dd.MM.yy",
			"medium": "dd.MM.yyyy",
			"long": "d. MMMM yyyy",
			"full": "dddd, d. MMMM yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "dd.MM.yyyy HH:mm:ss z",
			"medium": "dd.MM.yyyy HH:mm:ss z",
			"long": "dddd, d. MMMM yyyy HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		},
		"firstDayOfWeek": 1
	},
	"de-IT": {
		"days": ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
		"months": ["Januar", "Februar", "Mrz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
		"monthsAbbreviated": ["Jan.", "Feb.", "Mrz", "Apr.", "Mai", "Juni", "Juli", "Aug.", "Sep.", "Okt.", "Nov.", "Dez."],
		"daysAbbreviated": ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
		"dateFormat": {
			"short": "dd.MM.yy",
			"medium": "dd.MM.yyyy",
			"long": "d. MMMM yyyy",
			"full": "dddd, d. MMMM yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "dd.MM.yyyy, HH:mm:ss z",
			"medium": "dd.MM.yyyy, HH:mm:ss z",
			"long": "dddd, d. MMMM yyyy 'um' HH:mm",
			"full": "dddd, d. MMMM yyyy 'um' HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		},
		"firstDayOfWeek": 1
	},
	"de-BE": {
		"daysAbbreviated": ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
		"days": ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
		"months": ["Januar", "Februar", "Mrz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
		"monthsAbbreviated": ["Jan.", "Feb.", "Mrz", "Apr.", "Mai", "Juni", "Juli", "Aug.", "Sep.", "Okt.", "Nov.", "Dez."],
		"dateFormat": {
			"short": "dd.MM.yy",
			"medium": "dd.MM.yyyy",
			"long": "d. MMMM yyyy",
			"full": "dddd, d. MMMM yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "dd.MM.yyyy, HH:mm",
			"medium": "dd.MM.yyyy, HH:mm",
			"long": "dddd, d. MMMM yyyy 'um' HH:mm",
			"full": "dddd, d. MMMM yyyy 'um' HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		},
		"firstDayOfWeek": 1
	},
	"en-GB": {
		"daysAbbreviated": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
		"days": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
		"months": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
		"monthsAbbreviated": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
		"firstDay": 1,
		"dateFormat": {
			"short": "dd/MM/yyyy",
			"medium": "d MMM yyyy",
			"long": "d MMMM yyyy",
			"full": "dddd, d MMMM yyyy",
			"other": {
				"dateMonth": "d MMMM",
				"yearMonth": "MMMM yyyy"
			}
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM yyyy, HH:mm:ss z",
			"medium": "d MMM yyyy, HH:mm:ss z",
			"long": "dddd, d MMMM yyyy 'at' HH:mm",
			"full": "dddd, d MMMM yyyy 'at' HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "GBP",
			"name": "Pound sterling",
			"symbol": "\u00a3",
			"position": "left"
		},
		"firstDayOfWeek": 1
	},
	"en-HK": {
		"daysAbbreviated": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
		"days": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
		"months": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
		"monthsAbbreviated": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
		"dateFormat": {
			"short": "d/M/yy",
			"medium": "d MMM, yyyy",
			"long": "d MMMM, yyyy",
			"full": "dddd, d MMMM, yyyy"
		},
		"timeFormat": {
			"short": "h:mm tt",
			"medium": "h:mm:ss tt",
			"long": "h:mm:ss tt z"
		},
		"dateTimeFormat": {
			"short": "d MMM, yyyy, h:mm:ss tt z",
			"medium": "d MMM, yyyy, h:mm:ss tt z",
			"long": "dddd, d MMMM, yyyy 'at' h:mm tt",
			"full": "dddd, d MMMM, yyyy 'at' h:mm tt"
		},
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "HKD",
			"name": "Hong Kong Dollar",
			"symbol": "\u0024",
			"position": "left"
		},
		"firstDayOfWeek": 0
	},
	"en-SE": {
		"daysAbbreviated": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
		"days": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
		"months": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
		"monthsAbbreviated": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
		"dateFormat": {
			"short": "yyyy-MM-dd",
			"medium": "d MMM yyyy",
			"long": "d MMMM yyyy",
			"full": "dddd, d MMMM yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM, yyyy, h:mm:ss tt z",
			"medium": "d MMM, yyyy, h:mm:ss tt z",
			"long": "dddd, d MMMM, yyyy 'at' h:mm tt",
			"full": "dddd, d MMMM, yyyy 'at' h:mm tt"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "SEK",
			"name": "Swedish krona",
			"symbol": "\u006b\u0072",
			"position": "right"
		},
		"firstDayOfWeek": 1
	},
	"en-US": {
		"daysAbbreviated": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
		"days": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
		"months": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
		"monthsAbbreviated": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
		"firstDay": 0,
		"dateFormat": {
			"short": "M/d/yyyy",
			"medium": "MMM d, yyyy",
			"long": "MMMM d, yyyy",
			"full": "dddd, MMMM d, yyyy"
		},
		"timeFormat": {
			"short": "h:mm tt",
			"medium": "h:mm:ss tt",
			"long": "hh:mm:ss tt"
		},
		"dateTimeFormat": {
			"short": "MMM d, yyyy, hh:mm:ss tt",
			"medium": "MMM d, yyyy, hh:mm:ss tt",
			"long": "dddd, MMMM d, yyyy 'at' h:mm tt",
			"full": "dddd, MMMM d, yyyy 'at' h:mm tt"
		},
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		},
		"firstDayOfWeek": 0
	},
	"en-IN": {
		"daysAbbreviated": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
		"days": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
		"months": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
		"monthsAbbreviated": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
		"dateFormat": {
			"short": "dd/M/yyyy",
			"medium": "dd-MMM-yyyy",
			"long": "d MMMM yyyy",
			"full": "dddd d MMMM yyyy"
		},
		"timeFormat": {
			"short": "h:mm tt",
			"medium": "h:mm:ss tt",
			"long": "h:mm:ss tt z"
		},
		"dateTimeFormat": {
			"short": "dd-MMM-yyyy, h:mm:ss tt z",
			"medium": "dd-MMM-yyyy, h:mm:ss tt z",
			"long": "dddd d MMMM yyyy 'at' h:mm tt",
			"full": "dddd d MMMM yyyy 'at' h:mm tt"
		},
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "INR",
			"name": "Indian rupee",
			"symbol": "\u20b9",
			"position": "left"
		},
		"firstDayOfWeek": 0
	},
	"es": {
		"daysAbbreviated": ["dom.", "lun.", "mar.", "mi.", "jue.", "vie.", "sb."],
		"monthsAbbreviated": ["ene.", "feb.", "mar.", "abr.", "may.", "jun.", "jul.", "ago.", "sept.", "oct.", "nov.", "dic."],
		"months": ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"],
		"days": ["domingo", "lunes", "martes", "mircoles", "jueves", "viernes", "sbado"],
		"dateFormat": {
			"short": "d/M/yy",
			"medium": "d/M/yyyy",
			"long": "d 'de' MMMM 'de' yyyy",
			"full": "dddd, d 'de' MMMM 'de' yyyy"
		},
		"timeFormat": {
			"short": "H:mm",
			"medium": "H:mm:ss",
			"long": "H:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d/M/yyyy, H:mm:ss z",
			"medium": "d/M/yyyy, H:mm:ss z",
			"long": "dddd, d 'de' MMMM 'de' yyyy H:mm",
			"full": "dddd, d 'de' MMMM 'de' yyyy H:mm"
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MXN",
			"name": "Mexican peso",
			"symbol": "\u0024",
			"position": "right"
		},
		"firstDayOfWeek": 1
	},
	"es-AR": {
		"days": ["domingo", "lunes", "martes", "mircoles", "jueves", "viernes", "sbado"],
		"months": ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"],
		"monthsAbbreviated": ["ene.", "feb.", "mar.", "abr.", "may.", "jun.", "jul.", "ago.", "sept.", "oct.", "nov.", "dic."],
		"daysAbbreviated": ["dom.", "lun.", "mar.", "mi.", "jue.", "vie.", "sb."],
		"dateFormat": {
			"short": "d/M/yy",
			"medium": "d MMM yyyy",
			"long": "d 'de' MMMM 'de' yyyy",
			"full": "dddd, d 'de' MMMM 'de' yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM yyyy HH:mm:ss z",
			"medium": "d MMM yyyy HH:mm:ss z",
			"long": "dddd, d 'de' MMMM 'de' yyyy, HH:mm",
			"full": "dddd, d 'de' MMMM 'de' yyyy, HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "ARS",
			"name": "Argentine peso",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"es-NI": {
		"days": ["domingo", "lunes", "martes", "mircoles", "jueves", "viernes", "sbado"],
		"months": ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"],
		"monthsAbbreviated": ["ene.", "feb.", "mar.", "abr.", "may.", "jun.", "jul.", "ago.", "sept.", "oct.", "nov.", "dic."],
		"daysAbbreviated": ["dom.", "lun.", "mar.", "mi.", "jue.", "vie.", "sb."],
		"dateFormat": {
			"short": "dd/MM/yy",
			"medium": "d/M/yyyy",
			"long": "d 'de' MMMM 'de' yyyy",
			"full": "dddd, d 'de' MMMM 'de' yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d/M/yyyy HH:mm:ss z",
			"medium": "d/M/yyyy HH:mm:ss z",
			"long": "dddd, d 'de' MMMM 'de' yyyy, HH:mm",
			"full": "dddd, d 'de' MMMM 'de' yyyy, HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "NIO",
			"name": "Nicaraguan crdoba",
			"symbol": "\u0043\u0024",
			"position": "left"
		},
		"firstDayOfWeek": 0
	},
	"es-PR": {
		"daysAbbreviated": ["dom.", "lun.", "mar.", "mi.", "jue.", "vie.", "sb."],
		"days": ["domingo", "lunes", "martes", "mircoles", "jueves", "viernes", "sbado"],
		"monthsAbbreviated": ["ene.", "feb.", "mar.", "abr.", "may.", "jun.", "jul.", "ago.", "sep.", "oct.", "nov.", "dic."],
		"months": ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"],
		"dateFormat": {
			"short": "MM/dd/yy",
			"medium": "MM/dd/yyyy",
			"long": "d 'de' MMMM 'de' yyyy",
			"full": "dddd, d 'de' MMMM 'de' yyyy"
		},
		"timeFormat": {
			"short": "h:mm tt",
			"medium": "h:mm:ss tt",
			"long": "h:mm:ss tt z"
		},
		"dateTimeFormat": {
			"short": "MM/dd/yyyy h:mm:ss tt z",
			"medium": "MM/dd/yyyy h:mm:ss tt z",
			"long": "dddd, d 'de' MMMM 'de' yyyy, h:mm tt",
			"full": "dddd, d 'de' MMMM 'de' yyyy, h:mm tt"
		},
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		},
		"firstDayOfWeek": 0
	},
	"es-SV": {
		"daysAbbreviated": ["dom.", "lun.", "mar.", "mi.", "jue.", "vie.", "sb."],
		"days": ["domingo", "lunes", "martes", "mircoles", "jueves", "viernes", "sbado"],
		"monthsAbbreviated": ["ene.", "feb.", "mar.", "abr.", "may.", "jun.", "jul.", "ago.", "sep.", "oct.", "nov.", "dic."],
		"months": ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"],
		"dateFormat": {
			"short": "dd/MM/yy",
			"medium": "d/M/yyyy",
			"long": "d 'de' MMMM 'de' yyyy",
			"full": "dddd, d 'de' MMMM 'de' yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d/M/yyyy HH:mm:ss z",
			"medium": "d/M/yyyy HH:mm:ss z",
			"long": "dddd, d 'de' MMMM 'de' yyyy, HH:mm",
			"full": "dddd, d 'de' MMMM 'de' yyyy, HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "SVC",
			"name": "Salvadoran coln",
			"symbol": "\u20A1",
			"position": "left"
		},
		"firstDayOfWeek": 0
	},
	"fr": {
		"daysAbbreviated": ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
		"days": ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
		"monthsAbbreviated": ["janv.", "fvr.", "mars", "avr.", "mai", "juin", "juil.", "aot", "sept.", "oct.", "nov.", "dc."],
		"months": ["janvier", "fvrier", "mars", "avril", "mai", "juin", "juillet", "aot", "septembre", "octobre", "novembre", "dcembre"],
		"dateFormat": {
			"short": "dd/MM/yyyy",
			"medium": "d MMM yyyy",
			"long": "d MMMM yyyy",
			"full": "dddd d MMMM yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM yyyy HH:mm:ss z",
			"medium": "d MMM yyyy HH:mm:ss z",
			"long": "dddd d MMMM yyyy '' HH:mm",
			"full": "dddd d MMMM yyyy '' HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		},
		"firstDayOfWeek": 1
	},
	"fr-BE": {
		"months": ["janvier", "fvrier", "mars", "avril", "mai", "juin", "juillet", "aot", "septembre", "octobre", "novembre", "dcembre"],
		"monthsAbbreviated": ["janv.", "fvr.", "mars", "avr.", "mai", "juin", "juil.", "aot", "sept.", "oct.", "nov.", "dc."],
		"daysAbbreviated": ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
		"days": ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
		"dateFormat": {
			"short": "d/MM/yy",
			"medium": "d MMM yyyy",
			"long": "d MMMM yyyy",
			"full": "dddd d MMMM yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM yyyy HH:mm:ss z",
			"medium": "dddd d MMMM yyyy '' HH:mm",
			"long": "dddd d MMMM yyyy '' HH:mm",
			"full": "dddd d MMMM yyyy '' HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		},
		"firstDayOfWeek": 1
	},
	"fr-BL": {
		"days": ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
		"months": ["janvier", "fvrier", "mars", "avril", "mai", "juin", "juillet", "aot", "septembre", "octobre", "novembre", "dcembre"],
		"monthsAbbreviated": ["janv.", "fvr.", "mars", "avr.", "mai", "juin", "juil.", "aot", "sept.", "oct.", "nov.", "dc."],
		"daysAbbreviated": ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
		"dateFormat": {
			"short": "dd/MM/yyyy",
			"medium": "d MMM yyyy",
			"long": "d MMMM yyyy",
			"full": "dddd d MMMM yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM yyyy HH:mm:ss z",
			"medium": "dddd d MMMM yyyy '' HH:mm",
			"long": "dddd d MMMM yyyy '' HH:mm",
			"full": "dddd d MMMM yyyy '' HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"fr-HT": {
		"days": ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
		"months": ["janvier", "fvrier", "mars", "avril", "mai", "juin", "juillet", "aot", "septembre", "octobre", "novembre", "dcembre"],
		"monthsAbbreviated": ["janv.", "fvr.", "mars", "avr.", "mai", "juin", "juil.", "aot", "sept.", "oct.", "nov.", "dc."],
		"daysAbbreviated": ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
		"dateFormat": {
			"short": "dd/MM/yyyy",
			"medium": "d MMM yyyy",
			"long": "d MMMM yyyy",
			"full": "dddd d MMMM yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM yyyy HH:mm:ss z",
			"medium": "d MMM yyyy HH:mm:ss z",
			"long": "dddd d MMMM yyyy '' HH:mm",
			"full": "dddd d MMMM yyyy '' HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "HTG",
			"name": "Haitian gourde",
			"symbol": "\u0047",
			"position": "right"
		}
	},
	"ha-GH": {
		"days": ["Lahadi", "Litinin", "Talata", "Laraba", "Alhamis", "Jummaa", "Asabar"],
		"months": ["Janairu", "Faburairu", "Maris", "Afirilu", "Mayu", "Yuni", "Yuli", "Agusta", "Satumba", "Oktoba", "Nuwamba", "Disamba"],
		"monthsAbbreviated": ["Jan", "Fab", "Mar", "Afi", "May", "Yun", "Yul", "Agu", "Sat", "Okt", "Nuw", "Dis"],
		"daysAbbreviated": ["Lah", "Lit", "Tal", "Lar", "Alh", "Jum", "Asa"],
		"dateFormat": {
			"short": "d/M/yy",
			"medium": "d MMM, yyyy",
			"long": "d MMMM, yyyy",
			"full": "dddd, d MMMM, yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM, yyyy HH:mm:ss z",
			"medium": "d MMM, yyyy HH:mm:ss z",
			"long": "dddd, d MMMM, yyyy HH:mm",
			"full": "dddd, d MMMM, yyyy HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "GHS",
			"name": "Ghanaian cedi",
			"symbol": "\u20b5",
			"position": "left"
		}
	},
	"hr-BA": {
		"daysAbbreviated": ["ned", "pon", "uto", "sri", "et", "pet", "sub"],
		"days": ["nedjelja", "ponedjeljak", "utorak", "srijeda", "etvrtak", "petak", "subota"],
		"monthsAbbreviated": ["sij", "velj", "ou", "tra", "svi", "lip", "srp", "kol", "ruj", "lis", "stu", "pro"],
		"months": ["sijenja", "veljae", "oujka", "travnja", "svibnja", "lipnja", "srpnja", "kolovoza", "rujna", "listopada", "studenoga", "prosinca"],
		"dateFormat": {
			"short": "dd. MM. yyyy.",
			"medium": "d. MMM yyyy.",
			"long": "d. MMMM yyyy.",
			"full": "dddd, d. MMMM yyyy."
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d. MMM yyyy. HH:mm:ss z",
			"medium": "d. MMM yyyy. HH:mm:ss z",
			"long": "dddd, d. MMMM yyyy. 'u' HH:mm",
			"full": "dddd, d. MMMM yyyy. 'u' HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "BAM",
			"name": "Bosnia and Herzegovina convertible mark",
			"symbol": "\u004b\u004d",
			"position": "right"
		},
		"firstDayOfWeek": 1
	},
	"ja": {
		"daysAbbreviated": ["", "", "", "", "", "", ""],
		"days": ["", "", "", "", "", "", ""],
		"monthsAbbreviated": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
		"months": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
		"dateFormat": {
			"short": "yyyy/MM/dd",
			"medium": "yyyy/MM/dd",
			"long": "yyyyMd",
			"full": "yyyyMddddd"
		},
		"timeFormat": {
			"short": "H:mm",
			"medium": "H:mm:ss",
			"long": "H:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "yyyy/MM/dd H:mm",
			"medium": "yyyy/MM/dd H:mm:ss",
			"long": "yyyyMd H:mm:ss z",
			"full": "yyyyMddddd Hmmss z"
		}
	},
	"nl": {
		"daysAbbreviated": ["ned", "pon", "uto", "sri", "et", "pet", "sub"],
		"days": ["nedjelja", "ponedjeljak", "utorak", "srijeda", "etvrtak", "petak", "subota"],
		"monthsAbbreviated": ["sij", "velj", "ou", "tra", "svi", "lip", "srp", "kol", "ruj", "lis", "stu", "pro"],
		"months": ["sijenja", "veljae", "oujka", "travnja", "svibnja", "lipnja", "srpnja", "kolovoza", "rujna", "listopada", "studenoga", "prosinca"],
		"dateFormat": {
			"short": "dd-MM-yy",
			"medium": "d MMM yyyy",
			"long": "d MMMM yyyy",
			"full": "dddd d MMMM yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM yyyy HH:mm:ss z",
			"medium": "d MMM yyyy HH:mm:ss z",
			"long": "dddd d MMMM yyyy 'om' HH:mm",
			"full": "dddd d MMMM yyyy 'om' HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "left"
		},
		"firstDayOfWeek": 1
	},
	"nl-AW": {
		"days": ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"],
		"months": ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
		"monthsAbbreviated": ["jan.", "feb.", "mrt.", "apr.", "mei", "jun.", "jul.", "aug.", "sep.", "okt.", "nov.", "dec."],
		"daysAbbreviated": ["zo", "ma", "di", "wo", "do", "vr", "za"],
		"dateFormat": {
			"short": "dd-MM-yy",
			"medium": "d MMM yyyy",
			"long": "d MMMM yyyy",
			"full": "dddd d MMMM yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM yyyy HH:mm:ss z",
			"medium": "d MMM yyyy HH:mm:ss z",
			"long": "dddd d MMMM yyyy 'om' HH:mm",
			"full": "dddd d MMMM yyyy 'om' HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "AWG",
			"name": "Aruban florin",
			"symbol": "\u0192",
			"position": "left"
		},
		"firstDayOfWeek": 1
	},
	"nl-SR": {
		"days": ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"],
		"months": ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
		"monthsAbbreviated": ["jan.", "feb.", "mrt.", "apr.", "mei", "jun.", "jul.", "aug.", "sep.", "okt.", "nov.", "dec."],
		"daysAbbreviated": ["zo", "ma", "di", "wo", "do", "vr", "za"],
		"dateFormat": {
			"short": "dd-MM-yy",
			"medium": "d MMM yyyy",
			"long": "d MMMM yyyy",
			"full": "dddd d MMMM yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM yyyy HH:mm:ss z",
			"medium": "d MMM yyyy HH:mm:ss z",
			"long": "dddd d MMMM yyyy 'om' HH:mm",
			"full": "dddd d MMMM yyyy 'om' HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "SRD",
			"name": "Surinamese dollar",
			"symbol": "\u0024",
			"position": "left"
		},
		"firstDayOfWeek": 1
	},
	"pl": {
		"days": ["niedziela", "poniedziaek", "wtorek", "roda", "czwartek", "pitek", "sobota"],
		"months": ["stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca", "lipca", "sierpnia", "wrzenia", "padziernika", "listopada", "grudnia"],
		"monthsAbbreviated": ["sty", "lut", "mar", "kwi", "maj", "cze", "lip", "sie", "wrz", "pa", "lis", "gru"],
		"daysAbbreviated": ["niedz.", "pon.", "wt.", "r.", "czw.", "pt.", "sob."],
		"dateFormat": {
			"short": "dd.MM.yyyy",
			"medium": "d MMM yyyy",
			"long": "d MMMM yyyy",
			"full": "dddd, d MMMM y"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss zzz"
		},
		"dateTimeFormat": {
			"short": "dd.MM.yyyy HH:mm:ss zzz",
			"medium": "d MMM yyyy HH:mm:ss zzz",
			"long": "d MMMM yyyy HH:mm:ss zzz",
			"full": "dddd, d MMMM y HH:mm:ss zzz"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "PLN",
			"name": "Polish zoty",
			"symbol": "\u007a\u0142",
			"position": "right"
		},
		"firstDayOfWeek": 1
	},
	"pt": {
		"daysAbbreviated": ["dom", "seg", "ter", "qua", "qui", "sex", "sb"],
		"days": ["domingo", "segunda-feira", "tera-feira", "quarta-feira", "quinta-feira", "sexta-feira", "sbado"],
		"monthsAbbreviated": ["jan", "fev", "mar", "abr", "mai", "jun", "jul", "ago", "set", "out", "nov", "dez"],
		"months": ["janeiro", "fevereiro", "maro", "abril", "maio", "junho", "julho", "agosto", "setembro", "outubro", "novembro", "dezembro"],
		"dateFormat": {
			"short": "dd/MM/yyyy",
			"medium": "dd/MM/yyyy",
			"long": "d 'de' MMMM 'de' yyyy",
			"full": "dddd, d 'de' MMMM 'de' yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "dd/MM/yyyy HH:mm:ss z",
			"medium": "dd/MM/yyyy HH:mm:ss z",
			"long": "dddd, d 'de' MMMM 'de' yyyy HH:mm",
			"full": "dddd, d 'de' MMMM 'de' yyyy HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "left"
		}
	},
	"pt-BR": {
		"daysAbbreviated": ["dom", "seg", "ter", "qua", "qui", "sex", "sb"],
		"days": ["domingo", "segunda-feira", "tera-feira", "quarta-feira", "quinta-feira", "sexta-feira", "sbado"],
		"monthsAbbreviated": ["jan", "fev", "mar", "abr", "mai", "jun", "jul", "ago", "set", "out", "nov", "dez"],
		"months": ["janeiro", "fevereiro", "maro", "abril", "maio", "junho", "julho", "agosto", "setembro", "outubro", "novembro", "dezembro"],
		"dateFormat": {
			"short": "dd/MM/yyyy",
			"medium": "dd/MM/yyyy",
			"long": "d 'de' MMMM 'de' yyyy",
			"full": "dddd, d 'de' MMMM 'de' yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "dd/MM/yyyy HH:mm:ss z",
			"medium": "dd/MM/yyyy HH:mm:ss z",
			"long": "dddd, d 'de' MMMM 'de' yyyy HH:mm",
			"full": "dddd, d 'de' MMMM 'de' yyyy HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "left"
		}
	},
	"pt-CV": {
		"days": ["domingo", "segunda-feira", "tera-feira", "quarta-feira", "quinta-feira", "sexta-feira", "sbado"],
		"months": ["janeiro", "fevereiro", "maro", "abril", "maio", "junho", "julho", "agosto", "setembro", "outubro", "novembro", "dezembro"],
		"monthsAbbreviated": ["jan", "fev", "mar", "abr", "mai", "jun", "jul", "ago", "set", "out", "nov", "dez"],
		"daysAbbreviated": ["domingo", "segunda", "tera", "quarta", "quinta", "sexta", "sbado"],
		"dateFormat": {
			"short": "d/M/yyyy",
			"medium": "dd/MM/yyyy",
			"long": "d 'de' MMMM 'de' yyyy",
			"full": "dddd, d 'de' MMMM 'de' yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "dd/MM/yyyy, HH:mm:ss z",
			"medium": "dd/MM/yyyy, HH:mm:ss z",
			"long": "dddd, d 'de' MMMM 'de' yyyy 's' HH:mm",
			"full": "dddd, d 'de' MMMM 'de' yyyy 's' HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CVE",
			"name": "Cape Verdean escudo",
			"symbol": "\u0045\u0073\u0063",
			"position": "right"
		},
		"firstDayOfWeek": 1
	},
	"pt-TL": {
		"days": ["domingo", "segunda-feira", "tera-feira", "quarta-feira", "quinta-feira", "sexta-feira", "sbado"],
		"months": ["janeiro", "fevereiro", "maro", "abril", "maio", "junho", "julho", "agosto", "setembro", "outubro", "novembro", "dezembro"],
		"monthsAbbreviated": ["jan", "fev", "mar", "abr", "mai", "jun", "jul", "ago", "set", "out", "nov", "dez"],
		"daysAbbreviated": ["domingo", "segunda", "tera", "quarta", "quinta", "sexta", "sbado"],
		"dateFormat": {
			"short": "d/M/yyyy",
			"medium": "dd/MM/yyyy",
			"long": "d 'de' MMMM 'de' yyyy",
			"full": "dddd, d 'de' MMMM 'de' yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "dd/MM/yyyy, HH:mm:ss z",
			"medium": "dd/MM/yyyy, HH:mm:ss z",
			"long": "dddd, d 'de' MMMM 'de' yyyy 's' HH:mm",
			"full": "dddd, d 'de' MMMM 'de' yyyy 's' HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "right"
		},
		"firstDayOfWeek": 1
	},
	"ru": {
		"days": ["", "", "", "", "", "", ""],
		"months": ["", "", "", "", "", "", "", "", "", "", "", ""],
		"monthsAbbreviated": [".", ".", ".", ".", "", ".", ".", ".", ".", ".", ".", "."],
		"daysAbbreviated": ["", "", "", "", "", "", ""],
		"dateFormat": {
			"short": "dd.MM.yyyy",
			"medium": "d MMM yyyy ''.",
			"long": "d MMMM yyyy ''.",
			"full": "dddd, d MMMM yyyy ''."
		},
		"timeFormat": {
			"short": "H:mm",
			"medium": "H:mm:ss",
			"long": "H:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM yyyy ''., H:mm:ss z",
			"medium": "d MMM yyyy ''., H:mm:ss z",
			"long": "dddd, d MMMM yyyy ''., H:mm",
			"full": "dddd, d MMMM yyyy ''., H:mm"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RUB",
			"name": "Russian ruble",
			"symbol": "\u20bd",
			"position": "right"
		},
		"firstDayOfWeek": 1
	},
	"ru-KG": {
		"days": ["", "", "", "", "", "", ""],
		"months": ["", "", "", "", "", "", "", "", "", "", "", ""],
		"monthsAbbreviated": [".", ".", ".", ".", "", ".", ".", ".", ".", ".", ".", "."],
		"daysAbbreviated": ["", "", "", "", "", "", ""],
		"dateFormat": {
			"short": "dd.MM.yyyy",
			"medium": "d MMM yyyy ''.",
			"long": "d MMMM yyyy ''.",
			"full": "dddd, d MMMM yyyy ''."
		},
		"timeFormat": {
			"short": "H:mm",
			"medium": "H:mm:ss",
			"long": "H:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM yyyy ''., H:mm:ss z",
			"medium": "d MMM yyyy ''., H:mm:ss z",
			"long": "d MMM yyyy ''., H:mm:ss z",
			"full": "d MMM yyyy ''., H:mm:ss z"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "KGS",
			"name": "Kyrgyzstani som",
			"symbol": "\u043b\u0432",
			"position": "right"
		},
		"firstDayOfWeek": 1
	},
	"ru-UA": {
		"days": ["", "", "", "", "", "", ""],
		"months": ["", "", "", "", "", "", "", "", "", "", "", ""],
		"monthsAbbreviated": [".", ".", ".", ".", "", ".", ".", ".", ".", ".", ".", "."],
		"daysAbbreviated": ["", "", "", "", "", "", ""],
		"dateFormat": {
			"short": "dd.MM.yyyy",
			"medium": "d MMM yyyy ''.",
			"long": "d MMMM yyyy ''.",
			"full": "dddd, d MMMM yyyy ''."
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM yyyy ''., HH:mm:ss z",
			"medium": "d MMM yyyy ''., HH:mm:ss z",
			"long": "dddd, d MMMM yyyy ''., HH:mm",
			"full": "dddd, d MMMM yyyy ''., HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "UAH",
			"name": "Ukrainian hryvnia",
			"symbol": "\u20b4",
			"position": "right"
		},
		"firstDayOfWeek": 1
	},
	"sv": {
		"daysAbbreviated": ["sn", "mn", "tis", "ons", "tors", "fre", "lr"],
		"months": ["januari", "februari", "mars", "april", "maj", "juni", "juli", "augusti", "september", "oktober", "november", "december"],
		"monthsAbbreviated": ["jan.", "feb.", "mars", "apr.", "maj", "juni", "juli", "aug.", "sep.", "okt.", "nov.", "dec."],
		"days": ["sndag", "mndag", "tisdag", "onsdag", "torsdag", "fredag", "lrdag"],
		"dateFormat": {
			"short": "yyyy-MM-dd",
			"medium": "d MMM yyyy",
			"long": "d MMMM yyyy",
			"full": "dddd d MMMM yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM yyyy HH:mm:ss z",
			"medium": "d MMM yyyy HH:mm:ss z",
			"long": "dddd d MMMM yyyy HH:mm",
			"full": "dddd d MMMM yyyy HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "SVC",
			"name": "Salvadoran coln",
			"symbol": "\u20A1",
			"position": "right"
		},
		"firstDayOfWeek": 0
	},
	"tr": {
		"days": ["Pazar", "Pazartesi", "Sal", "aramba", "Perembe", "Cuma", "Cumartesi"],
		"months": ["Ocak", "ubat", "Mart", "Nisan", "Mays", "Haziran", "Temmuz", "Austos", "Eyll", "Ekim", "Kasm", "Aralk"],
		"monthsAbbreviated": ["Oca", "ub", "Mar", "Nis", "May", "Haz", "Tem", "Au", "Eyl", "Eki", "Kas", "Ara"],
		"daysAbbreviated": ["Paz", "Pzt", "Sal", "ar", "Per", "Cum", "Cmt"],
		"dateFormat": {
			"short": "d.MM.yyyy",
			"medium": "d MMM yyyy",
			"long": "d MMMM yyyy",
			"full": "d MMMM yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM yyyy HH:mm:ss z",
			"medium": "d MMM yyyy HH:mm:ss z",
			"long": "d MMMM yyyy HH:mm",
			"full": "d MMMM yyyy HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "TRY",
			"name": "Turkish lira",
			"symbol": "\u20BA",
			"position": "left"
		},
		"firstDayOfWeek": 1
	},
	"uk": {
		"daysAbbreviated": ["", "", "", "", "", "", ""],
		"days": ["", "", "", "", "", "", ""],
		"months": ["", "", "", "", "", "", "", "", "", "", "", ""],
		"monthsAbbreviated": [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
		"dateFormat": {
			"short": "dd.MM.yy",
			"medium": "d MMM yyyy",
			"long": "d MMMM yyyy ''.",
			"full": "dddd, d MMMM yyyy ''."
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "d MMM yyyy HH:mm:ss z",
			"medium": "d MMM yyyy HH:mm:ss z",
			"long": "dddd, d MMMM yyyy ''. HH:mm",
			"full": "dddd, d MMMM yyyy ''. HH:mm"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "UAH",
			"name": "Ukrainian hryvnia",
			"symbol": "\u20b4",
			"position": "right"
		}
	},
	"am": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "AMD",
			"name": "Armenian dram",
			"symbol": "\u058F",
			"position": "left"
		}
	},
	"as": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"be": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"bm": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "BMD",
			"name": "Bermudian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"bn-IN": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "INR",
			"name": "Indian rupee",
			"symbol": "\u20b9",
			"position": "right"
		}
	},
	"bn": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "BND",
			"name": "Brunei dollar",
			"symbol": "\u0024",
			"position": "right"
		}
	},
	"bo-IN": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "INR",
			"name": "Indian rupee",
			"symbol": "\u20b9",
			"position": "left"
		}
	},
	"bo": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "BOB",
			"name": "Bolivian boliviano",
			"symbol": "\u0024\u0062",
			"position": "left"
		}
	},
	"cu": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "CUP",
			"name": "Cuban peso",
			"symbol": "\u20b1",
			"position": "left"
		}
	},
	"cy": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "left"
		}
	},
	"de-CH": {
		"numberFormat": {
			"thousandSeparator": "'",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "CHF",
			"name": "Swiss franc",
			"symbol": "\u0046\u0072",
			"position": "left"
		}
	},
	"de-LU": {
		"numberFormat": {
			"thousandSeparator": "'",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "CHF",
			"name": "Swiss franc",
			"symbol": "\u0046\u0072",
			"position": "left"
		}
	},
	"ee": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "left"
		}
	},
	"en-AG": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XCD",
			"name": "Eastern Caribbean dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-AI": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XCD",
			"name": "Eastern Caribbean dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-AS": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-AU": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "AUD",
			"name": "Australian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-BB": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "BBD",
			"name": "Barbadian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-BI": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "BIF",
			"name": "Burundian franc",
			"symbol": "\u0046\u0042\u0075",
			"position": "left"
		}
	},
	"en-BM": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "BMD",
			"name": "Bermudian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-BS": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "BSD",
			"name": "Bahamian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-BW": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "BWP",
			"name": "Botswana pula",
			"symbol": "\u0050",
			"position": "left"
		}
	},
	"en-BZ": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "BZD",
			"name": "Belize dollar",
			"symbol": "\u0042\u005a\u0024",
			"position": "left"
		}
	},
	"en-CA": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "CAD",
			"name": "Canadian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-CC": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "AUD",
			"name": "Australian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-CK": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "NZD",
			"name": "New Zealand dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-CM": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "left"
		}
	},
	"en-CK": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "NZD",
			"name": "New Zealand dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-CX": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "AUD",
			"name": "Australian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-CY": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"en-DM": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XCD",
			"name": "Eastern Caribbean dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-ER": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "ERN",
			"name": "Eritrean nakfa",
			"symbol": "\u004E\u0192\u0061",
			"position": "left"
		}
	},
	"en-FJ": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "FJD",
			"name": "Fijian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-FK": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "FKP",
			"name": "Fijian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-FM": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-GD": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XCD",
			"name": "Eastern Caribbean dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-GG": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "GBP",
			"name": "Pound sterling",
			"symbol": "\u00a3",
			"position": "left"
		}
	},
	"en-GH": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "GHS",
			"name": "Ghanaian cedi",
			"symbol": "\u20b5",
			"position": "left"
		}
	},
	"en-GI": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "GIP",
			"name": "Ghanaian cedi",
			"symbol": "\u20b5",
			"position": "left"
		}
	},
	"en-GM": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "GMD",
			"name": "Gambian dalasi",
			"symbol": "\u0044",
			"position": "left"
		}
	},
	"en-GU": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-GY": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "GYD",
			"name": "Guyanaese Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-IE": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "left"
		}
	},
	"en-IL": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "ILS",
			"name": "Israeli New Shekel",
			"symbol": "\u20aa",
			"position": "left"
		}
	},
	"en-IM": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "GBP",
			"name": "Pound sterling",
			"symbol": "\u00a3",
			"position": "left"
		}
	},
	"en-KE": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "KES",
			"name": "Kenyan shilling",
			"symbol": "\u004B\u0053\u0068",
			"position": "left"
		}
	},
	"en-IO": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-JE": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "GBP",
			"name": "Pound sterling",
			"symbol": "\u00a3",
			"position": "left"
		}
	},
	"en-JM": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "JMD",
			"name": "Jamaican dollar",
			"symbol": "\u004a\u0024",
			"position": "left"
		}
	},
	"en-KI": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "AUD",
			"name": "Australian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-KN": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XCD",
			"name": "Eastern Caribbean dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-KY": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "KYD",
			"name": "Eastern Caribbean dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-LC": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XCD",
			"name": "Eastern Caribbean dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-LR": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "LRD",
			"name": "Liberian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-LS": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "LSL",
			"name": "Lesotho loti",
			"symbol": "\u004c",
			"position": "left"
		}
	},
	"en-MG": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "MGA",
			"name": "Malagasy ariary",
			"symbol": "\u0041\u0072",
			"position": "left"
		}
	},
	"en-MH": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-MO": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "MOP",
			"name": "Macanese pataca",
			"symbol": "\u0050",
			"position": "left"
		}
	},
	"en-MP": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-MS": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XCD",
			"name": "Eastern Caribbean dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-MT": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"en-MU": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "MUR",
			"name": "Mauritian rupee",
			"symbol": "\u20a8",
			"position": "left"
		}
	},
	"en-MW": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "MWP",
			"name": "Mauritian rupee",
			"symbol": "\u20a8",
			"position": "left"
		}
	},
	"en-MY": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "MYR",
			"name": "Malaysian ringgit",
			"symbol": "\u0052\u004d",
			"position": "left"
		}
	},
	"en-NA": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "NAD",
			"name": "Namibian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-NF": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "AUD",
			"name": "Australian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-NG": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "NGN",
			"name": "Nigerian naira",
			"symbol": "\u20a6",
			"position": "left"
		}
	},
	"en-NR": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "AUD",
			"name": "Australian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-NU": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "NZD",
			"name": "New Zealand dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-NZ": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "NZD",
			"name": "New Zealand dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-PG": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "PGK",
			"name": "Papua New Guinean kina",
			"symbol": "\u004B",
			"position": "left"
		}
	},
	"en-PK": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "PKR",
			"name": "Pakistani Rupee",
			"symbol": "\u20a8",
			"position": "left"
		}
	},
	"en-PH": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "PHP",
			"name": "Philippine peso",
			"symbol": "\u20b1",
			"position": "left"
		}
	},
	"en-PN": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "NZD",
			"name": "New Zealand dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-PR": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-PW": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-RW": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "RWF",
			"name": "Rwandan franc",
			"symbol": "\u0052\u0046",
			"position": "left"
		}
	},
	"en-SB": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "SBD",
			"name": "Solomon Islands dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-SC": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "SCR",
			"name": "Seychellois rupee",
			"symbol": "\u20a8",
			"position": "left"
		}
	},
	"en-SD": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "SDG",
			"name": "Sudanese pound",
			"symbol": "\u00a3\u0053\u0064",
			"position": "left"
		}
	},
	"en-SG": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "SGD",
			"name": "Singapore dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-SH": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "SHP",
			"name": "Singapore dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-SL": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "SLL",
			"name": "Sierra Leonean leone",
			"symbol": "\u004C\u0065",
			"position": "left"
		}
	},
	"en-SS": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "SSP",
			"name": "South Sudanese pound",
			"symbol": "\u0053\u0053\u0050",
			"alternateSymbol": "\u00a3",
			"position": "left"
		}
	},
	"en-SX": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "ANG",
			"name": "Netherlands Antillean guilder",
			"symbol": "\u0192",
			"position": "left"
		}
	},
	"en-SZ": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "SZL",
			"name": "Swazi lilangeni",
			"symbol": "\u004c",
			"position": "left"
		}
	},
	"en-TC": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-TK": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "NZD",
			"name": "New Zealand dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-TO": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "TOP",
			"name": "Tongan paanga",
			"symbol": "\u0054\u0024",
			"position": "left"
		}
	},
	"en-TT": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "TTD",
			"name": "Trinidad and Tobago dollar",
			"symbol": "\u0054\u0054\u0024",
			"position": "left"
		}
	},
	"en-TV": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "AUD",
			"name": "Australian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-TZ": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "TZS",
			"name": "Tanzanian shilling",
			"symbol": "\u0054\u0053\u0068",
			"position": "left"
		}
	},
	"en-UG": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "UGX",
			"name": "Ugandan shilling",
			"symbol": "\u0055\u0053\u0068",
			"position": "left"
		}
	},
	"en-UM": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-VC": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XCD",
			"name": "Eastern Caribbean dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-VG": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-VI": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"en-VU": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "VUV",
			"name": "Vanuatu vatu",
			"symbol": "\u0056\u0054",
			"position": "left"
		}
	},
	"en-WS": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "WST",
			"name": "Samoan tl",
			"symbol": "\u0054",
			"position": "left"
		}
	},
	"en-ZM": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "ZMW",
			"name": "Zambian kwacha",
			"symbol": "\u005A\u004B",
			"position": "left"
		}
	},
	"en-ZW": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "ZWL",
			"name": "Zambian kwacha",
			"symbol": "\u005A\u004B",
			"position": "left"
		}
	},
	"en": {
		"days": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
		"months": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
		"monthsAbbreviated": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
		"daysAbbreviated": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
		"dateFormat": {
			"short": "M/d/yy",
			"medium": "MMM d, yyyy",
			"long": "MMMM d, yyyy",
			"full": "dddd, MMMM d, yyyy"
		},
		"timeFormat": {
			"short": "h:mm tt",
			"medium": "h:mm:ss tt",
			"long": "h:mm:ss tt z"
		},
		"dateTimeFormat": {
			"short": "M/d/yy, h:mm tt",
			"medium": "MMM d, yyyy, h:mm:ss tt",
			"long": "MMMM d, yyyy 'at' h:mm:ss tt z",
			"full": "dddd, MMMM d, yyyy 'at' h:mm:ss tt z"
		},
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"es-BR": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "BRL",
			"name": "Brazilian real",
			"symbol": "\u0052\u0024",
			"position": "left"
		}
	},
	"es-BZ": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "BZD",
			"name": "Belize dollar",
			"symbol": "\u0042\u005a\u0024",
			"position": "left"
		}
	},
	"es-CU": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "CUP",
			"name": "Cuban peso",
			"symbol": "\u20b1",
			"position": "left"
		}
	},
	"es-DO": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "DOP",
			"name": "Dominican peso",
			"symbol": "\u0052\u0044\u0024",
			"position": "left"
		}
	},
	"es-GT": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "GTQ",
			"name": "Guatemalan quetzal",
			"symbol": "\u0051",
			"position": "left"
		}
	},
	"es-HN": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "HNL",
			"name": "Honduran lempira",
			"symbol": "\u004c",
			"position": "left"
		}
	},
	"es-MX": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "MXN",
			"name": "Mexican peso",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"es-PA": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "PAB",
			"name": "Panamanian balboa",
			"symbol": "\u0042\u002f\u002e",
			"position": "left"
		}
	},
	"es-PE": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "PEN",
			"name": "Sol",
			"symbol": "\u0053\u002f\u002e",
			"position": "left"
		}
	},
	"es-US": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"ga": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "left"
		}
	},
	"gd": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XCD",
			"name": "Eastern Caribbean dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"gsw-FR": {
		"numberFormat": {
			"thousandSeparator": "'",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"gsw-LI": {
		"numberFormat": {
			"thousandSeparator": "'",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "CHF",
			"name": "Swiss franc",
			"symbol": "\u0046\u0072",
			"position": "right"
		}
	},
	"gu": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"ha-NE": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XOF",
			"name": "West African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "left"
		}
	},
	"it-CH": {
		"numberFormat": {
			"thousandSeparator": "'",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "CHF",
			"name": "Swiss franc",
			"symbol": "\u0046\u0072",
			"position": "left"
		}
	},
	"ki": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "AUD",
			"name": "Australian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"kn": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XCD",
			"name": "Eastern Caribbean dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"ko": {
		"daysAbbreviated": ["", "", "", "", "", "", ""],
		"days": ["", "", "", "", "", "", ""],
		"months": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
		"monthsAbbreviated": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
		"firstDay": 0,
		"dateFormat": {
			"short": "yy. M. d.",
			"medium": "yyyy. M. d.",
			"long": "yyyy M d",
			"full": "yyyy M d dddd"
		},
		"timeFormat": {
			"short": "tt h:mm",
			"medium": "tt h:mm:ss",
			"long": "tt h m ss zzz"
		},
		"dateTimeFormat": {
			"short": "yy. M. d tt h:mm",
			"medium": "yyyy. M. d. tt h:mm:ss",
			"long": "yyyy M d tt h m ss zzz",
			"full": "yyyy M d dddd tt h m ss zzz"
		}
	},
	"ko-KP": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "KPW",
			"name": "North Korean won",
			"symbol": "\u20a9",
			"position": "left"
		}
	},
	"kw": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "KWD",
			"name": "Kuwaiti dinar",
			"symbol": "\u062f\u002e\u0643",
			"position": "left"
		}
	},
	"mas-TZ": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "TZS",
			"name": "Tanzanian shilling",
			"symbol": "\u0054\u0053\u0068",
			"position": "left"
		}
	},
	"mg": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "MGA",
			"name": "Malagasy ariary",
			"symbol": "\u0041\u0072",
			"position": "left"
		}
	},
	"ml": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XOF",
			"name": "West African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "left"
		}
	},
	"mn": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "MNT",
			"name": "Mongolian tgrg",
			"symbol": "\u20ae",
			"position": "left"
		}
	},
	"mr": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "MRO",
			"name": "Mauritanian ouguiya",
			"symbol": "\u0055\u004D",
			"position": "right"
		}
	},
	"ms-SG": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "SGD",
			"name": "Singapore dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"ms": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XCD",
			"name": "Eastern Caribbean dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"mt": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "left"
		}
	},
	"my": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "MYR",
			"name": "Malaysian ringgit",
			"symbol": "\u0052\u004d",
			"position": "right"
		}
	},
	"nds-NL": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "left"
		}
	},
	"ne-IN": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "INR",
			"name": "Indian rupee",
			"symbol": "\u20b9",
			"position": "left"
		}
	},
	"ne": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XOF",
			"name": "West African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "left"
		}
	},
	"om-KE": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "KES",
			"name": "Kenyan shilling",
			"symbol": "\u004B\u0053\u0068",
			"position": "left"
		}
	},
	"om": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "OMR",
			"name": "Omani rial",
			"symbol": "\ufdfc",
			"position": "left"
		}
	},
	"pa": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "PAB",
			"name": "Panamanian balboa",
			"symbol": "\u0042\u002f\u002e",
			"position": "left"
		}
	},
	"qu-EC": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"si": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "left"
		}
	},
	"sn": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XOF",
			"name": "West African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "left"
		}
	},
	"so-DJ": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "DJF",
			"name": "Djiboutian franc",
			"symbol": "\u0046\u0064\u006A",
			"position": "left"
		}
	},
	"so-ET": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "ETB",
			"name": "Ethiopian birr",
			"symbol": "\u0042\u0072",
			"position": "left"
		}
	},
	"so-KE": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "KES",
			"name": "Kenyan shilling",
			"symbol": "\u004B\u0053\u0068",
			"position": "left"
		}
	},
	"so": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "SOS",
			"name": "Somali shilling",
			"symbol": "\u0053",
			"position": "left"
		}
	},
	"sw-KE": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "KES",
			"name": "Kenyan shilling",
			"symbol": "\u004B\u0053\u0068",
			"position": "left"
		}
	},
	"sw-UG": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "UGX",
			"name": "Ugandan shilling",
			"symbol": "\u0055\u0053\u0068",
			"position": "left"
		}
	},
	"ta-LK": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "LKR",
			"name": "Sri Lankan rupee",
			"symbol": "\u20a8",
			"position": "left"
		}
	},
	"ta-MY": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "MYR",
			"name": "Malaysian ringgit",
			"symbol": "\u0052\u004d",
			"position": "left"
		}
	},
	"ta-SG": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "SGD",
			"name": "Singapore dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"teo-KE": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "KES",
			"name": "Kenyan shilling",
			"symbol": "\u004B\u0053\u0068",
			"position": "left"
		}
	},
	"th": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "THB",
			"name": "Thai baht",
			"symbol": "\u0e3f",
			"position": "left"
		}
	},
	"ti-ER": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "ERN",
			"name": "Eritrean nakfa",
			"symbol": "\u004E\u0192\u0061",
			"position": "left"
		}
	},
	"to": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "TOP",
			"name": "Tongan paanga",
			"symbol": "\u0054\u0024",
			"position": "left"
		}
	},
	"ur-IN": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "INR",
			"name": "Indian rupee",
			"symbol": "\u20b9",
			"position": "left"
		}
	},
	"yo-BJ": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "XOF",
			"name": "West African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "left"
		}
	},
	"zh-Hans-HK": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "HKD",
			"name": "Hong Kong Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"zh-Hans-SG": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "SGD",
			"name": "Singapore dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"zh-Hant-HK": {
		"numberFormat": {
			"thousandSeparator": ",",
			"decimalSeparator": "."
		},
		"currency": {
			"code": "HKD",
			"name": "Hong Kong Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"zh-TW": {
		"months":["", "", "", "", "", "", "", "", "", "", "", ""],
		"monthsAbbreviated": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
		"days": ["", "", "", "", "", "", ""],
		"daysAbbreviated": ["", "", "", "", "", "", ""],
		"dateFormat": {
			"short": "yyyy/M/d",
			"medium": "yyyyMd",
			"long": "yyyyMd",
			"full": "yyyyMddddd"
		},
		"timeFormat": {
			"short": "tt h:mm",
			"medium": "tt h:mm:ss",
			"long": "z tt h:mm:ss"
		},
		"dateTimeFormat": {
			"short": "yyyy/M/d tt h:mm",
			"medium": "yyyyMdtt h:mm:ss",
			"long": "yyyyMd z tt h:mm:ss",
			"full": "yyyyMddddd z tt h:mm:ss"
		}
	},
	"zh": {
		"days": ["", "", "", "", "", "", ""],
		"daysAbbreviated": ["", "", "", "", "", "", ""],
		"months": ["", "", "", "", "", "", "", "", "", "", "", ""],
		"monthsAbbreviated": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
		"dateFormat": {
			"short": "yyyy/M/d",
			"medium": "yyyyMd",
			"long": "yyyyMd",
			"full": "yyyyMddddd"
		},
		"timeFormat": {
			"short": "tt h:mm",
			"medium": "tt h:mm:ss",
			"long": "z tt h:mm:ss"
		},
		"dateTimeFormat": {
			"short": "yyyy/M/d tt h:mm",
			"medium": "yyyyMdtt h:mm:ss",
			"long": "yyyyMd z tt h:mm:ss",
			"full": "yyyyMddddd z tt h:mm:ss"
		}
	},
	"af-NA": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "NAD",
			"name": "Namibian dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"af": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "AFN",
			"name": "Afghan afghani",
			"symbol": "\u060b",
			"position": "left"
		}
	},
	"ar-AE": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "AED",
			"name": "United Arab Emirates dirham",
			"symbol": "\u062f\u002e\u0625",
			"position": "left"
		}
	},
	"ar-BH": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "BHD",
			"name": "Bahraini dinar",
			"symbol": "\u0042\u0044",
			"position": "left"
		}
	},
	"ar-DJ": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "DJF",
			"name": "Djiboutian franc",
			"symbol": "\u0046\u0064\u006A",
			"position": "left"
		}
	},
	"ar-DZ": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "DZD",
			"name": "Algerian dinar",
			"symbol": "\u002f\u062c\u0006",
			"position": "right"
		}
	},
	"ar-EG": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EGP",
			"name": "Egyptian pound",
			"symbol": "\u00a3",
			"position": "right"
		}
	},
	"ar-EH": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MAD",
			"name": "Moroccan dirham",
			"symbol": "\u004D\u0041\u0044",
			"position": "right"
		}
	},
	"ar-ER": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "ERN",
			"name": "Eritrean nakfa",
			"symbol": "\u004E\u0192\u0061",
			"position": "left"
		}
	},
	"ar-IL": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "ILS",
			"name": "Israeli New Shekel",
			"symbol": "\u20aa",
			"position": "right"
		}
	},
	"ar-IQ": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "IQD",
			"name": "Iraqi dinar",
			"symbol": "\u0639\u002e\u062f",
			"position": "right"
		}
	},
	"ar-JO": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "JOD",
			"name": "Jordanian dinar",
			"symbol": "\u004a\u004f\u0044",
			"position": "right"
		}
	},
	"ar-KM": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "KMF",
			"name": "Kuwaiti dinar",
			"symbol": "\u062f\u002e\u0643",
			"position": "right"
		}
	},
	"ar-KW": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "KWD",
			"name": "Kuwaiti dinar",
			"symbol": "\u062f\u002e\u0643",
			"position": "right"
		}
	},
	"ar-LB": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "LBP",
			"name": "Lebanese pound",
			"symbol": "\u00a3",
			"position": "left"
		}
	},
	"ar-LY": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "LYD",
			"name": "Libyan dinar",
			"symbol": "\u062F\u002E\u0644",
			"position": "right"
		}
	},
	"ar-MA": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MAD",
			"name": "Moroccan dirham",
			"symbol": "\u004D\u0041\u0044",
			"position": "right"
		}
	},
	"ar-MR": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MRO",
			"name": "Mauritanian ouguiya",
			"symbol": "\u0055\u004D",
			"position": "right"
		}
	},
	"ar-OM": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "OMR",
			"name": "Omani rial",
			"symbol": "\ufdfc",
			"position": "right"
		}
	},
	"ar-PS": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "ILS",
			"name": "Israeli New Shekel",
			"symbol": "\u20aa",
			"position": "right"
		}
	},
	"ar-QA": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "QAR",
			"name": "Qatari Rial",
			"symbol": "\ufdfc",
			"position": "right"
		}
	},
	"ar-SA": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "SAR",
			"name": "Saudi riyal",
			"symbol": "\ufdfc",
			"position": "right"
		}
	},
	"ar-SD": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "SDG",
			"name": "Sudanese pound",
			"symbol": "\u00a3\u0053\u0064",
			"position": "right"
		}
	},
	"ar-SO": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "SOS",
			"name": "Somali shilling",
			"symbol": "\u0053",
			"position": "right"
		}
	},
	"ar-SS": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "SSP",
			"name": "South Sudanese pound",
			"symbol": "\u0053\u0053\u0050",
			"alternateSymbol": "\u00a3",
			"position": "right"
		}
	},
	"ar-SY": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "SYP",
			"name": "Syrian pound",
			"symbol": "\u00a3",
			"position": "right"
		}
	},
	"ar-TD": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"ar-TN": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "TND",
			"name": "Tunisian dinar",
			"symbol": "\u062f\u002e\u062a",
			"position": "right"
		}
	},
	"ar-YE": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "YER",
			"name": "Yemeni rial",
			"symbol": "\ufdfc",
			"position": "right"
		}
	},
	"ar": {
		"daysAbbreviated": ["", "", "", "", "", "", ""],
		"days": ["", "", "", "", "", "", ""],
		"months": ["", "", "", "", "", "", "", "", "", "", "", ""],
		"monthsAbbreviated": ["", "", "", "", "", "", "", "", "", "", "", ""],
		"firstDay": 0,
		"dateFormat": {
			"short": "d/M/yyyy",
			"medium": "dd/MM/yyyy",
			"long": "d MMMM yyyy",
			"full": "dddd d MMMM yyyy"
		},
		"timeFormat": {
			"short": "h:mm tt",
			"medium": "h:mm:ss tt",
			"long": "h:mm:ss tt zzz"
		},
		"dateTimeFormat": {
			"short": "d/M/yyyy, h:mm tt",
			"medium": "dd/MM/yyyy, h:mm:ss tt",
			"long": "d MMMM yyyy h:mm:ss tt zzz ",
			"full": "dddd d MMMM yyyy h:mm:ss a zzz "
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "ARS",
			"name": "Argentine peso",
			"symbol": "\u0024",
			"position": "right"
		}
	},
	"az-Cyrl": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "AZN",
			"name": "Azerbaijani manat",
			"symbol": "\u20bc",
			"position": "left"
		}
	},
	"az-Latn": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "AZN",
			"name": "Azerbaijani manat",
			"symbol": "\u20bc",
			"position": "left"
		}
	},
	"az": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "AZN",
			"name": "Azerbaijani manat",
			"symbol": "\u20bc",
			"position": "left"
		}
	},
	"be": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"bg": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "BGN",
			"name": "Bulgarian lev",
			"symbol": "\u043b\u0432",
			"position": "right"
		}
	},
	"ca-AD": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"ca-ES-VALENCIA": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"ca-FR": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"ca": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CAD",
			"name": "Canadian dollar",
			"symbol": "\u0024",
			"position": "right"
		}
	},
	"ckb-IR": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "IRR",
			"name": "Iranian rial",
			"symbol": "\ufdfc",
			"position": "left"
		}
	},
	"cs": {
		"days": ["nedle", "pondl", "ter", "steda", "tvrtek", "ptek", "sobota"],
		"months": ["ledna", "nora", "bezna", "dubna", "kvtna", "ervna", "ervence", "srpna", "z", "jna", "listopadu", "prosince"],
		"monthsAbbreviated": ["led", "no", "be", "dub", "kv", "vn", "vc", "srp", "z", "j", "lis", "pro"],
		"daysAbbreviated": ["ne", "po", "t", "st", "t", "p", "so"],
		"dateFormat": {
			"short": "dd.MM.yy",
			"medium": "d. M. yyyy",
			"long": "d. MMMM yyyy",
			"full": "dddd d. MMMM yyyy"
		},
		"timeFormat": {
			"short": "H:mm",
			"medium": "H:mm:ss",
			"long": "H:mm:ss zzz"
		},
		"dateTimeFormat": {
			"short": "dd.MM.yy H:mm",
			"medium": "d. M. yyyy HH:mm:ss",
			"long": "d. MMMM yyyy H:mm:ss zzz",
			"full": "dddd d. MMMM yyyy H:mm:ss zzz"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CSD",
			"name": "Danish krone",
			"symbol": "\u006b\u0072",
			"position": "right"
		}
	},
	"da-GL": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "DKK",
			"name": "Danish krone",
			"symbol": "\u006b\u0072",
			"position": "right"
		}
	},
	"de-AT": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "left"
		}
	},
	"el-CY": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"el": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"en-AT": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "left"
		}
	},
	"en-BE": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"en-CH": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CHF",
			"name": "Swiss franc",
			"symbol": "\u0046\u0072",
			"position": "left"
		}
	},
	"en-DE": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"en-DK": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "DKK",
			"name": "Danish krone",
			"symbol": "\u006b\u0072",
			"position": "right"
		}
	},
	"en-FI": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"en-NL": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "left"
		}
	},
	"en-SI": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"en-ZA": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "ZAR",
			"name": "South African Rand",
			"symbol": "\u0052",
			"position": "left"
		}
	},
	"eo": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "left"
		}
	},
	"es-BO": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "BOB",
			"name": "Bolivian boliviano",
			"symbol": "\u0024\u0062",
			"position": "left"
		}
	},
	"es-CL": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CLP",
			"name": "Chilean peso",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"es-CO": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "COP",
			"name": "Colombian peso",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"es-CR": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CRC",
			"name": "Costa Rican coln",
			"symbol": "\u20a1",
			"position": "left"
		}
	},
	"es-EA": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"es-EC": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"es-GQ": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "left"
		}
	},
	"es-IC": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"es-PH": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "PHP",
			"name": "Philippine peso",
			"symbol": "\u20b1",
			"position": "right"
		}
	},
	"es-PY": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "PYG",
			"name": "Paraguayan guaran",
			"symbol": "\u0047\u0073",
			"position": "left"
		}
	},
	"es-UY": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "UYU",
			"name": "Uruguayan peso",
			"symbol": "\u0024\u0055",
			"position": "left"
		}
	},
	"es-VE": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "VEF",
			"name": "Venezuelan bolvar",
			"symbol": "\u0042\u0073",
			"position": "left"
		}
	},
	"et": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"eu": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"ewo": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"fa-AF": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "AFN",
			"name": "Afghan afghani",
			"symbol": "\u060b",
			"position": "left"
		}
	},
	"fa": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "IRR",
			"name": "Iranian rial",
			"symbol": "\ufdfc",
			"position": "right"
		}
	},
	"ff-CM": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"ff-GN": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "GNF",
			"name": "Guinean franc",
			"symbol": "\u0046\u0047",
			"position": "right"
		}
	},
	"ff-MR": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MRO",
			"name": "Mauritanian ouguiya",
			"symbol": "\u0055\u004D",
			"position": "right"
		}
	},
	"ff": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XOF",
			"name": "West African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"fi": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"fo-DK": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "DKK",
			"name": "Danish krone",
			"symbol": "\u006b\u0072",
			"position": "right"
		}
	},
	"fo": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "DKK",
			"name": "Danish krone",
			"symbol": "\u006b\u0072",
			"position": "right"
		}
	},
	"fr-BF": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XOF",
			"name": "West African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"fr-BI": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "BIF",
			"name": "Burundian franc",
			"symbol": "\u0046\u0042\u0075",
			"position": "right"
		}
	},
	"fr-BJ": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XOF",
			"name": "West African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"fr-CA": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CAD",
			"name": "Canadian dollar",
			"symbol": "\u0024",
			"position": "right"
		}
	},
	"fr-CD": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CDF",
			"name": "Congolese franc",
			"symbol": "\u0046\u0043",
			"position": "right"
		}
	},
	"fr-CF": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"fr-CG": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"fr-CH": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CHF",
			"name": "Swiss franc",
			"symbol": "\u0046\u0072",
			"position": "right"
		}
	},
	"fr-CI": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XOF",
			"name": "West African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"fr-CM": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"fr-DJ": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "DJF",
			"name": "Djiboutian franc",
			"symbol": "\u0046\u0064\u006A",
			"position": "right"
		}
	},
	"fr-DZ": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "DZD",
			"name": "Algerian dinar",
			"symbol": "\u002f\u062c\u0006",
			"position": "right"
		}
	},
	"fr-GA": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"fr-GF": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"fr-GN": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "GNF",
			"name": "Guinean franc",
			"symbol": "\u0046\u0047",
			"position": "right"
		}
	},
	"fr-GP": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"fr-GQ": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"fr-KM": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "KMF",
			"name": "Comorian franc",
			"symbol": "\u0043\u0046",
			"position": "right"
		}
	},
	"fr-LU": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"fr-MA": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MAD",
			"name": "Moroccan dirham",
			"symbol": "\u004D\u0041\u0044",
			"position": "right"
		}
	},
	"fr-MC": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"fr-MF": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"fr-MG": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MGA",
			"name": "Malagasy ariary",
			"symbol": "\u0041\u0072",
			"position": "right"
		}
	},
	"fr-ML": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XOF",
			"name": "West African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"fr-MQ": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"fr-MR": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MRO",
			"name": "Mauritanian ouguiya",
			"symbol": "\u0055\u004D",
			"position": "right"
		}
	},
	"fr-MU": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MUR",
			"name": "Mauritian rupee",
			"symbol": "\u20a8",
			"position": "right"
		}
	},
	"fr-NC": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XPF",
			"name": "CFP Franc",
			"symbol": "\u0043\u0046\u0050",
			"position": "right"
		}
	},
	"fr-NE": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XOF",
			"name": "West African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"fr-PF": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XPF",
			"name": "CFP Franc",
			"symbol": "\u0043\u0046\u0050",
			"position": "right"
		}
	},
	"fr-PM": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"fr-RE": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"fr-RW": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RWF",
			"name": "Rwandan franc",
			"symbol": "\u0052\u0046",
			"position": "right"
		}
	},
	"fr-SC": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "SCR",
			"name": "Seychellois rupee",
			"symbol": "\u20a8",
			"position": "right"
		}
	},
	"fr-SN": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XOF",
			"name": "West African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"fr-SY": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "SYP",
			"name": "Syrian pound",
			"symbol": "\u00a3",
			"position": "right"
		}
	},
	"fr-TD": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"fr-TG": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XOF",
			"name": "West African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"fr-TN": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "TND",
			"name": "Tunisian dinar",
			"symbol": "\u062f\u002e\u062a",
			"position": "right"
		}
	},
	"fr-VU": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "VUV",
			"name": "Vanuatu vatu",
			"symbol": "\u0056\u0054",
			"position": "right"
		}
	},
	"fr-WF": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XPF",
			"name": "CFP Franc",
			"symbol": "\u0043\u0046\u0050",
			"position": "right"
		}
	},
	"fr-YT": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"fur": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "SDG",
			"name": "Sudanese pound",
			"symbol": "\u00a3\u0053\u0064",
			"position": "left"
		}
	},
	"fy": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "left"
		}
	},
	"gl": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"hi": {
		"daysAbbreviated": ["", "", "", "", "", "", ""],
		"days": ["", "", "", "", "", "", ""],
		"months": ["", "", "", "", "", "", "", "", "", "", "", ""],
		"monthsAbbreviated": ["", "", "", "", "", "", "", "", "", "", "", ""],
		"firstDay": 0,
		"dateFormat": {
			"short": "d/M/yy",
			"medium": "d MMM yyyy",
			"long": "d MMMM yyyy",
			"full": "dddd, d MMMM yyyy"
		},
		"timeFormat": {
			"short": "h:mm tt",
			"medium": "h:mm:ss tt",
			"long": "h:mm:ss tt zzz"
		},
		"dateTimeFormat": {
			"short": "d/M/yy, h:mm tt",
			"medium": "d MMM yyyy, h:mm:ss tt",
			"long": "d MMMM yyyy  h:mm:ss tt zzz",
			"full": "dddd, d MMMM yyyy  h:mm:ss tt zzz"
		}
	},
	"hr": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "HRK",
			"name": "Croatian kuna",
			"symbol": "\u006b\u006e",
			"position": "right"
		}
	},
	"hsb": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"hu": {
		"days": ["vasrnap", "htf", "kedd", "szerda", "cstrtk", "pntek", "szombat"],
		"months": ["janur", "februr", "mrcius", "prilis", "mjus", "jnius", "jlius", "augusztus", "szeptember", "oktber", "november", "december"],
		"monthsAbbreviated": ["jan.", "febr.", "mrc.", "pr.", "mj.", "jn.", "jl.", "aug.", "szept.", "okt.", "nov.", "dec."],
		"daysAbbreviated": ["V", "H", "K", "Sze", "Cs", "P", "Szo"],
		"dateFormat": {
			"short": "yyyy. MM. dd.",
			"medium": "yyyy. MMM d.",
			"long": "yyyy. MMMM d.",
			"full": "yyyy. MMMM d., dddd"
		},
		"timeFormat": {
			"short": "H:mm",
			"medium": "H:mm:ss",
			"long": "H:mm:ss zzz"
		},
		"dateTimeFormat": {
			"short": "yyyy. MM. dd. H:mm",
			"medium": "yyyy. MMM d. HH:mm:ss",
			"long": "yyyy. MMMM d. H:mm:ss zzz",
			"full": "yyyy. MMMM d., dddd H:mm:ss zzz"
		},
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "HUF",
			"name": "Hungarian forint",
			"symbol": "\u0046\u0074",
			"position": "right"
		}
	},
	"hy": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "AMD",
			"name": "Armenian dram",
			"symbol": "\u058F",
			"position": "right"
		}
	},
	"id": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "IDR",
			"name": "Indonesian Rupiah",
			"symbol": "\u0052\u0070",
			"position": "left"
		}
	},
	"is": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "ISK",
			"name": "Icelandic krna",
			"symbol": "\u006b\u0072",
			"position": "right"
		}
	},
	"it-SM": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"it-VA": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"it": {
		"daysAbbreviated": ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
		"days": ["domenica", "luned", "marted", "mercoled", "gioved", "venerd", "sabato"],
		"months": ["gennaio", "febbraio", "marzo", "aprile", "maggio", "giugno", "luglio", "agosto", "settembre", "ottobre", "novembre", "dicembre"],
		"monthsAbbreviated": ["gen", "feb", "mar", "apr", "mag", "giu", "lug", "ago", "set", "ott", "nov", "dic"],
		"dateFormat": {
			"short": "dd/MM/yy",
			"medium": "d MMM yyyy",
			"long": "d MMMM yyyy",
			"full": "dddd d MMMM yyyy"
		},
		"timeFormat": {
			"short": "HH:mm",
			"medium": "HH:mm:ss",
			"long": "HH:mm:ss z"
		},
		"dateTimeFormat": {
			"short": "dd/MM/yy, HH:mm",
			"medium": "d MMM yyyy, HH:mm:ss",
			"long": "d MMMM yyyy HH:mm:ss z",
			"full": "dddd d MMMM yyyy HH:mm:ss z"
		},
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"jgo": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "left"
		}
	},
	"ka": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "GEL",
			"name": "Georgian lari",
			"symbol": "\u20be",
			"position": "right"
		}
	},
	"kab": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "DZD",
			"name": "Algerian dinar",
			"symbol": "\u002f\u062c\u0006",
			"position": "right"
		}
	},
	"kea": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CVE",
			"name": "Cape Verdean escudo",
			"symbol": "\u0045\u0073\u0063",
			"position": "right"
		}
	},
	"kk": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "KZT",
			"name": "Kazakhstani tenge",
			"symbol": "\u043b\u0432",
			"position": "right"
		}
	},
	"kkj": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "left"
		}
	},
	"kl": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "DKK",
			"name": "Danish krone",
			"symbol": "\u006b\u0072",
			"position": "left"
		}
	},
	"km": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "KHR",
			"name": "Cambodian riel",
			"symbol": "\u17db",
			"position": "right"
		}
	},
	"ks": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "INR",
			"name": "Indian rupee",
			"symbol": "\u20b9",
			"position": "left"
		}
	},
	"ksf": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"ksh": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"ky": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "KGS",
			"name": "Kyrgyzstani som",
			"symbol": "\u043b\u0432",
			"position": "right"
		}
	},
	"lb": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"ln-AO": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "AOA",
			"name": "Angolan kwanza",
			"symbol": "\u004B\u007A",
			"position": "right"
		}
	},
	"ln-CF": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"ln-CG": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"ln": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CDF",
			"name": "Congolese franc",
			"symbol": "\u0046\u0043",
			"position": "right"
		}
	},
	"lo": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "LAK",
			"name": "Lao kip",
			"symbol": "\u20ad",
			"position": "left"
		}
	},
	"lrc-IQ": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "IQD",
			"name": "Iraqi dinar",
			"symbol": "\u0639\u002e\u062f",
			"position": "left"
		}
	},
	"lrc": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "IRR",
			"name": "Iranian rial",
			"symbol": "\ufdfc",
			"position": "left"
		}
	},
	"lt": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"lu": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"lv": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"mgh": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MZN",
			"name": "Mozambican metical",
			"symbol": "\u004d\u0054",
			"position": "left"
		}
	},
	"mk": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MKD",
			"name": "Macedonian denar",
			"symbol": "\u0434\u0435\u043d",
			"position": "right"
		}
	},
	"ms-BN": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "BND",
			"name": "Brunei dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"mua": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "left"
		}
	},
	"mzn": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "NOK",
			"name": "Norwegian krone",
			"symbol": "\u006b\u0072",
			"position": "left"
		}
	},
	"nb-SJ": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "NOK",
			"name": "Norwegian krone",
			"symbol": "\u006b\u0072",
			"position": "left"
		}
	},
	"nb": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "NOK",
			"name": "Norwegian krone",
			"symbol": "\u006b\u0072",
			"position": "left"
		}
	},
	"nl-BE": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"nl-BQ": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "USD",
			"name": "United States Dollar",
			"symbol": "\u0024",
			"position": "left"
		}
	},
	"nl-CW": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "ANG",
			"name": "Netherlands Antillean guilder",
			"symbol": "\u0192",
			"position": "left"
		}
	},
	"nl-SX": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "ANG",
			"name": "Netherlands Antillean guilder",
			"symbol": "\u0192",
			"position": "left"
		}
	},
	"nmg": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"nn": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "NOK",
			"name": "Norwegian krone",
			"symbol": "\u006b\u0072",
			"position": "right"
		}
	},
	"nnh": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "left"
		}
	},
	"os-RU": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RUB",
			"name": "Russian ruble",
			"symbol": "\u20bd",
			"position": "left"
		}
	},
	"os": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RUB",
			"name": "Russian ruble",
			"symbol": "\u20bd",
			"position": "left"
		}
	},
	"pa-Arab": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "INR",
			"name": "Indian rupee",
			"symbol": "\u20b9",
			"position": "left"
		}
	},
	"ps": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "AFN",
			"name": "Afghan afghani",
			"symbol": "\u060b",
			"position": "right"
		}
	},
	"pt-AO": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "AOA",
			"name": "Angolan kwanza",
			"symbol": "\u004B\u007A",
			"position": "right"
		}
	},
	"pt-CH": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CHF",
			"name": "Swiss franc",
			"symbol": "\u0046\u0072",
			"position": "right"
		}
	},
	"pt-GQ": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"pt-GW": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XOF",
			"name": "West African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "right"
		}
	},
	"pt-LU": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"pt-MO": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MOP",
			"name": "Macanese pataca",
			"symbol": "\u0050",
			"position": "right"
		}
	},
	"pt-MZ": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MZN",
			"name": "Mozambican metical",
			"symbol": "\u004d\u0054",
			"position": "right"
		}
	},
	"pt-PT": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"pt-ST": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "STD",
			"name": "So Tom and Prncipe dobra",
			"symbol": "\u0044\u0062",
			"position": "right"
		}
	},
	"qu-BO": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "BOB",
			"name": "Bolivian boliviano",
			"symbol": "\u0024\u0062",
			"position": "left"
		}
	},
	"rn": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RUB",
			"name": "Russian ruble",
			"symbol": "\u20bd",
			"position": "right"
		}
	},
	"ro-MD": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MDL",
			"name": "Moldovan leu",
			"symbol": "\u004c",
			"position": "right"
		}
	},
	"ro": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RON",
			"name": "Romanian leu",
			"symbol": "\u006c\u0065\u0069",
			"position": "right"
		}
	},
	"ru-BY": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "BYR",
			"name": "Belarusian ruble",
			"symbol": "\u0070\u002e",
			"position": "right"
		}
	},
	"ru-KZ": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "KZT",
			"name": "Kazakhstani tenge",
			"symbol": "\u043b\u0432",
			"position": "right"
		}
	},
	"ru-MD": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MDL",
			"name": "Moldovan leu",
			"symbol": "\u004c",
			"position": "right"
		}
	},
	"rw": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RWF",
			"name": "Rwandan franc",
			"symbol": "\u0052\u0046",
			"position": "left"
		}
	},
	"sah": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RUB",
			"name": "Russian ruble",
			"symbol": "\u20bd",
			"position": "right"
		}
	},
	"se-FI": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"se-SE": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "SEK",
			"name": "Swedish krona",
			"symbol": "\u006b\u0072",
			"position": "right"
		}
	},
	"se": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "SEK",
			"name": "Swedish krona",
			"symbol": "\u006b\u0072",
			"position": "right"
		}
	},
	"seh": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MZN",
			"name": "Mozambican metical",
			"symbol": "\u004d\u0054",
			"position": "right"
		}
	},
	"sg": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "XAF",
			"name": "Central African CFA franc",
			"symbol": "\u0043\u0046\u0041",
			"position": "left"
		}
	},
	"shi-Latn": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CDF",
			"name": "Congolese franc",
			"symbol": "\u0046\u0043",
			"position": "right"
		}
	},
	"shi-Tfng": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CDF",
			"name": "Congolese franc",
			"symbol": "\u0046\u0043",
			"position": "right"
		}
	},
	"shi": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CDF",
			"name": "Congolese franc",
			"symbol": "\u0046\u0043",
			"position": "right"
		}
	},
	"sk": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"sl": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"smn": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"sq-MK": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "ALL",
			"name": "Albanian lek",
			"symbol": "\u004c\u0065\u006b",
			"position": "right"
		}
	},
	"sq-XK": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "ALL",
			"name": "Albanian lek",
			"symbol": "\u004c\u0065\u006b",
			"position": "right"
		}
	},
	"sq": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "ALL",
			"name": "Albanian lek",
			"symbol": "\u004c\u0065\u006b",
			"position": "right"
		}
	},
	"sr-Cyrl-BA": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RSD",
			"name": "Serbian dinar",
			"symbol": "\u0052\u0053\u0044",
			"position": "right"
		}
	},
	"sr-Cyrl-ME": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RSD",
			"name": "Serbian dinar",
			"symbol": "\u0052\u0053\u0044",
			"position": "right"
		}
	},
	"sr-Cyrl-XK": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RSD",
			"name": "Serbian dinar",
			"symbol": "\u0052\u0053\u0044",
			"position": "right"
		}
	},
	"sr-Cyrl": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RSD",
			"name": "Serbian dinar",
			"symbol": "\u0052\u0053\u0044",
			"position": "right"
		}
	},
	"sr-Latn-BA": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RSD",
			"name": "Serbian dinar",
			"symbol": "\u0052\u0053\u0044",
			"position": "right"
		}
	},
	"sr-Latn-ME": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RSD",
			"name": "Serbian dinar",
			"symbol": "\u0052\u0053\u0044",
			"position": "right"
		}
	},
	"sr-Latn-XK": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RSD",
			"name": "Serbian dinar",
			"symbol": "\u0052\u0053\u0044",
			"position": "right"
		}
	},
	"sr-Latn": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RSD",
			"name": "Serbian dinar",
			"symbol": "\u0052\u0053\u0044",
			"position": "right"
		}
	},
	"sr": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "RSD",
			"name": "Serbian dinar",
			"symbol": "\u0052\u0053\u0044",
			"position": "right"
		}
	},
	"sv-AX": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"sv-FI": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "right"
		}
	},
	"sw-CD": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CDF",
			"name": "Congolese franc",
			"symbol": "\u0046\u0043",
			"position": "left"
		}
	},
	"tk": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "TMT",
			"name": "Turkmenistani Manat",
			"symbol": "\u006D",
			"position": "right"
		}
	},
	"tr-CY": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "EUR",
			"name": "Euro",
			"symbol": "\u20ac",
			"position": "left"
		}
	},
	"tzm": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MAD",
			"name": "Moroccan dirham",
			"symbol": "\u004D\u0041\u0044",
			"position": "right"
		}
	},
	"ug": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CNY",
			"name": "Yuan Renminbi",
			"symbol": "\u00a5",
			"position": "left"
		}
	},
	"uz-Arab": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "UZS",
			"name": "Uzbekistani som",
			"symbol": "\u043b\u0432",
			"position": "left"
		}
	},
	"uz-Cyrl": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "UZS",
			"name": "Uzbekistani som",
			"symbol": "\u043b\u0432",
			"position": "right"
		}
	},
	"uz-Latn": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "UZS",
			"name": "Uzbekistani som",
			"symbol": "\u043b\u0432",
			"position": "right"
		}
	},
	"uz": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "UZS",
			"name": "Uzbekistani som",
			"symbol": "\u043b\u0432",
			"position": "right"
		}
	},
	"vi": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "VND",
			"name": "Vietnamese dong",
			"symbol": "\u20ab",
			"position": "right"
		}
	},
	"vun": {
		"numberFormat": {
			"thousandSeparator": ".",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "TZS",
			"name": "Tanzanian shilling",
			"symbol": "\u0054\u0053\u0068",
			"position": "left"
		}
	},
	"wae": {
		"numberFormat": {
			"thousandSeparator": "'",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "CHF",
			"name": "Swiss franc",
			"symbol": "\u0046\u0072",
			"alternateSymbol": "\u0043\u0048\u0046",
			"position": "right"
		}
	},
	"yav": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "PEN",
			"name": "Sol",
			"symbol": "\u0053\u002f\u002e",
			"position": "right"
		}
	},
	"zgh": {
		"numberFormat": {
			"thousandSeparator": " ",
			"decimalSeparator": ","
		},
		"currency": {
			"code": "MAD",
			"name": "Moroccan dirham",
			"symbol": "\u004D\u0041\u0044",
			"position": "right"
		}
	}
}
;
/* $Id$ */
ZComponents.localeInformation =
{
	"decimalSeparator":{
		
		".": ["ak","am","as","asa","bem","bez","bm","bn-IN","bn","bo-IN","bo","brx","ce","cgg","chr","cu","cy","dav","de-CH","de-LI","dje","dz","ebu","ee-TG","ee","en-001","en-AG","en-AI","en-AS","en-AU","en-BB","en-BI","en-BM","en-BS","en-BW","en-BZ","en-CA","en-CC","en-CK","en-CM","en-CX","en-CY","en-DG","en-DM","en-ER","en-FJ","en-FK","en-FM","en-GB","en-GD","en-GG","en-GH","en-GI","en-GM","en-GU","en-GY","en-HK","en-IE","en-IL","en-IM","en-IN","en-IO","en-JE","en-JM","en-KE","en-KI","en-KN","en-KY","en-LC","en-LR","en-LS","en-MG","en-MH","en-MO","en-MP","en-MS","en-MT","en-MU","en-MW","en-MY","en-NA","en-NF","en-NG","en-NR","en-NU","en-NZ","en-PG","en-PH","en-PK","en-PN","en-PR","en-PW","en-RW","en-SB","en-SC","en-SD","en-SG","en-SH","en-SL","en-SS","en-SX","en-SZ","en-TC","en-TK","en-TO","en-TT","en-TV","en-TZ","en-UG","en-UM","en-US","en-VC","en-VG","en-VI","en-VU","en-WS","en-ZM","en-ZW","en","es-419","es-BR","es-BZ","es-CU","es-DO","es-GT","es-HN","es-MX","es-NI","es-PA","es-PE","es-PR","es-SV","es-US","fil","ga","gd","gsw-FR","gsw-LI","gsw","gu","guz","gv","ha-GH","ha-NE","ha","haw","he","hi","ig","ii","it-CH","ja","jmc","kam","kde","khq","ki","kln","kn","ko-KP","ko","kok","ksb","kw","lag","lg","lkt","luo","luy","mas-TZ","mas","mer","mfe","mg","mgo","ml","mn","mr","ms-SG","ms","mt","my","naq","nd","nds-NL","nds","ne-IN","ne","nus","nyn","om-KE","om","or","pa-Guru","pa","prg","qu-EC","qu","rm","rof","root","rwk","saq","sbp","ses","si","sn","so-DJ","so-ET","so-KE","so","sw-KE","sw-UG","sw","ta-LK","ta-MY","ta-SG","ta","te","teo-KE","teo","th","ti-ER","ti","to","twq","ur-IN","ur","vai-Latn","vai-Vaii","vai","vo","xog","yi","yo-BJ","yo","yue","zh-Hans-HK","zh-Hans-MO","zh-Hans-SG","zh-Hans","zh-Hant-HK","zh-Hant-MO","zh-Hant","zh","zu"],
		
		",": ["af-NA","af","agq","ar-AE","ar-BH","ar-DJ","ar-DZ","ar-EG","ar-EH","ar-ER","ar-IL","ar-IQ","ar-JO","ar-KM","ar-KW","ar-LB","ar-LY","ar-MA","ar-MR","ar-OM","ar-PS","ar-QA","ar-SA","ar-SD","ar-SO","ar-SS","ar-SY","ar-TD","ar-TN","ar-YE","ar","ast","az-Cyrl","az-Latn","az","bas","be","bg","br","bs-Cyrl","bs-Latn","bs","ca-AD","ca-ES-VALENCIA","ca-FR","ca-IT","ca","ckb-IR","ckb","cs","da-GL","da","de-AT","de-BE","de-IT","de-LU","de","dsb","dua","dyo","el-CY","el","en-150","en-AT","en-BE","en-CH","en-DE","en-DK","en-FI","en-NL","en-SE","en-SI","en-ZA","eo","es-AR","es-BO","es-CL","es-CO","es-CR","es-EA","es-EC","es-GQ","es-IC","es-PH","es-PY","es-UY","es-VE","es","et","eu","ewo","fa-AF","fa","ff-CM","ff-GN","ff-MR","ff","fi","fo-DK","fo","fr-BE","fr-BF","fr-BI","fr-BJ","fr-BL","fr-CA","fr-CD","fr-CF","fr-CG","fr-CH","fr-CI","fr-CM","fr-DJ","fr-DZ","fr-GA","fr-GF","fr-GN","fr-GP","fr-GQ","fr-HT","fr-KM","fr-LU","fr-MA","fr-MC","fr-MF","fr-MG","fr-ML","fr-MQ","fr-MR","fr-MU","fr-NC","fr-NE","fr-PF","fr-PM","fr-RE","fr-RW","fr-SC","fr-SN","fr-SY","fr-TD","fr-TG","fr-TN","fr-VU","fr-WF","fr-YT","fr","fur","fy","gl","hr-BA","hr","hsb","hu","hy","id","is","it-SM","it-VA","it","jgo","ka","kab","kea","kk","kkj","kl","km","ks","ksf","ksh","ky","lb","ln-AO","ln-CF","ln-CG","ln","lo","lrc-IQ","lrc","lt","lu","lv","mgh","mk","ms-BN","mua","mzn","nb-SJ","nb","nl-AW","nl-BE","nl-BQ","nl-CW","nl-SR","nl-SX","nl","nmg","nn","nnh","os-RU","os","pa-Arab","pl","ps","pt-AO","pt-CH","pt-CV","pt-GQ","pt-GW","pt-LU","pt-MO","pt-MZ","pt-PT","pt-ST","pt-TL","pt","qu-BO","rn","ro-MD","ro","ru-BY","ru-KG","ru-KZ","ru-MD","ru-UA","ru","rw","sah","se-FI","se-SE","se","seh","sg","shi-Latn","shi-Tfng","shi","sk","sl","smn","sq-MK","sq-XK","sq","sr-Cyrl-BA","sr-Cyrl-ME","sr-Cyrl-XK","sr-Cyrl","sr-Latn-BA","sr-Latn-ME","sr-Latn-XK","sr-Latn","sr","sv-AX","sv-FI","sv","sw-CD","tk","tr-CY","tr","tzm","ug","uk","uz-Arab","uz-Cyrl","uz-Latn","uz","vi","vun","wae","yav","zgh"]
	
	},
	"thousandSeparator":{
		
		".": ["ar-AE","ar-BH","ar-DJ","ar-DZ","ar-EG","ar-EH","ar-ER","ar-IL","ar-IQ","ar-JO","ar-KM","ar-KW","ar-LB","ar-LY","ar-MA","ar-MR","ar-OM","ar-PS","ar-QA","ar-SA","ar-SD","ar-SO","ar-SS","ar-SY","ar-TD","ar-TN","ar-YE","ar","ast","az-Cyrl","az-Latn","az","bs-Cyrl","bs-Latn","bs","ca-AD","ca-ES-VALENCIA","ca-FR","ca-IT","ca","chr","ckb-IR","ckb","da-GL","da","de-BE","de-IT","de-LU","de","dsb","el-CY","el","en-150","en-AT","en-BE","en-CH","en-DE","en-DK","en-NL","en-SI","es-AR","es-BO","es-CL","es-CO","es-EA","es-EC","es-GQ","es-IC","es-PH","es-PY","es-UY","es-VE","es","eu","fa-AF","fa","fo","fr-LU","fr-MA","fur","fy","gl","hr-BA","hr","hsb","id","is","it-SM","it-VA","it","jgo","kkj","kl","km","ks","lb","ln-AO","ln-CF","ln-CG","ln","lo","lrc-IQ","lrc","lu","mgh","mk","ms-BN","mua","mzn","nl-AW","nl-BE","nl-BQ","nl-CW","nl-SR","nl-SX","nl","nnh","pa-Arab","ps","pt","qu-BO","rn","ro-MD","ro","rw","seh","sg","sl","sr-Cyrl-BA","sr-Cyrl-ME","sr-Cyrl-XK","sr-Cyrl","sr-Latn-BA","sr-Latn-ME","sr-Latn-XK","sr-Latn","sr","sw-CD","tr-CY","tr","ug","uz-Arab","vi","vun"],
		
		",": ["ak","am","as","asa","bem","bez","bm","bn-IN","bn","bo-IN","bo","brx","ce","cgg","cu","cy","dav","dz","ebu","ee-TG","ee","en-001","en-AG","en-AI","en-AS","en-AU","en-BB","en-BI","en-BM","en-BS","en-BW","en-BZ","en-CA","en-CC","en-CK","en-CM","en-CX","en-CY","en-DG","en-DM","en-ER","en-FJ","en-FK","en-FM","en-GB","en-GD","en-GG","en-GH","en-GI","en-GM","en-GU","en-GY","en-HK","en-IE","en-IL","en-IM","en-IN","en-IO","en-JE","en-JM","en-KE","en-KI","en-KN","en-KY","en-LC","en-LR","en-LS","en-MG","en-MH","en-MO","en-MP","en-MS","en-MT","en-MU","en-MW","en-MY","en-NA","en-NF","en-NG","en-NR","en-NU","en-NZ","en-PG","en-PH","en-PK","en-PN","en-PR","en-PW","en-RW","en-SB","en-SC","en-SD","en-SG","en-SH","en-SL","en-SS","en-SX","en-SZ","en-TC","en-TK","en-TO","en-TT","en-TV","en-TZ","en-UG","en-UM","en-US","en-VC","en-VG","en-VI","en-VU","en-WS","en-ZM","en-ZW","en","es-419","es-BR","es-BZ","es-CU","es-DO","es-GT","es-HN","es-MX","es-NI","es-PA","es-PE","es-PR","es-SV","es-US","fil","fo-DK","ga","gd","gu","guz","gv","ha-GH","ha-NE","ha","haw","he","hi","ig","ii","ja","jmc","kam","kde","ki","kln","kn","ko-KP","ko","kok","ksb","kw","lag","lg","lkt","luo","luy","mas-TZ","mas","mer","mg","mgo","ml","mn","mr","ms-SG","ms","mt","my","naq","nd","nds-NL","nds","ne-IN","ne","nus","nyn","om-KE","om","or","pa-Guru","pa","prg","qu-EC","qu","rof","root","rwk","saq","sbp","si","sn","so-DJ","so-ET","so-KE","so","sw-KE","sw-UG","sw","ta-LK","ta-MY","ta-SG","ta","te","teo-KE","teo","th","ti-ER","ti","to","ur-IN","ur","vai-Latn","vai-Vaii","vai","vo","xog","yi","yo-BJ","yo","yue","zh-Hans-HK","zh-Hans-MO","zh-Hans-SG","zh-Hans","zh-Hant-HK","zh-Hant-MO","zh-Hant","zh","zu"],
		
		" ": ["af-NA","af","agq","bas","be","bg","br","cs","de-AT","dje","dua","dyo","en-FI","en-SE","en-ZA","eo","es-CR","et","ewo","ff-CM","ff-GN","ff-MR","ff","fi","fr-BE","fr-BF","fr-BI","fr-BJ","fr-BL","fr-CA","fr-CD","fr-CF","fr-CG","fr-CH","fr-CI","fr-CM","fr-DJ","fr-DZ","fr-GA","fr-GF","fr-GN","fr-GP","fr-GQ","fr-HT","fr-KM","fr-MC","fr-MF","fr-MG","fr-ML","fr-MQ","fr-MR","fr-MU","fr-NC","fr-NE","fr-PF","fr-PM","fr-RE","fr-RW","fr-SC","fr-SN","fr-SY","fr-TD","fr-TG","fr-TN","fr-VU","fr-WF","fr-YT","fr","hu","hy","ka","kab","kea","khq","kk","ksf","ksh","ky","lt","lv","mfe","nb-SJ","nb","nmg","nn","os-RU","os","pl","pt-AO","pt-CH","pt-CV","pt-GQ","pt-GW","pt-LU","pt-MO","pt-MZ","pt-PT","pt-ST","pt-TL","ru-BY","ru-KG","ru-KZ","ru-MD","ru-UA","ru","sah","se-FI","se-SE","se","ses","shi-Latn","shi-Tfng","shi","sk","smn","sq-MK","sq-XK","sq","sv-AX","sv-FI","sv","tk","twq","tzm","uk","uz-Cyrl","uz-Latn","uz","yav","zgh"],
		
		"'": ["de-CH","de-LI","gsw-FR","gsw-LI","gsw","it-CH","rm","wae"]
	},
	"timeSeparator":{
		
		":" : ["af-NA","af","agq","ak","am","ar-AE","ar-BH","ar-DJ","ar-DZ","ar-EG","ar-EH","ar-ER","ar-IL","ar-IQ","ar-JO","ar-KM","ar-KW","ar-LB","ar-LY","ar-MA","ar-MR","ar-OM","ar-PS","ar-QA","ar-SA","ar-SD","ar-SO","ar-SS","ar-SY","ar-TD","ar-TN","ar-YE","ar","as","asa","ast","az-Cyrl","az-Latn","az","bas","be","bem","bez","bg","bm","bn-IN","bn","bo-IN","bo","br","brx","bs-Cyrl","bs-Latn","bs","ca-AD","ca-ES-VALENCIA","ca-FR","ca-IT","ca","ce","cgg","chr","ckb-IR","ckb","cs","cu","cy","dav","de-AT","de-BE","de-CH","de-IT","de-LI","de-LU","de","dje","dsb","dua","dyo","dz","ebu","ee-TG","ee","el-CY","el","en-001","en-150","en-AG","en-AI","en-AS","en-AT","en-AU","en-BB","en-BE","en-BI","en-BM","en-BS","en-BW","en-BZ","en-CA","en-CC","en-CH","en-CK","en-CM","en-CX","en-CY","en-DE","en-DG","en-DM","en-ER","en-FJ","en-FK","en-FM","en-GB","en-GD","en-GG","en-GH","en-GI","en-GM","en-GU","en-GY","en-HK","en-IE","en-IL","en-IM","en-IN","en-IO","en-JE","en-JM","en-KE","en-KI","en-KN","en-KY","en-LC","en-LR","en-LS","en-MG","en-MH","en-MO","en-MP","en-MS","en-MT","en-MU","en-MW","en-MY","en-NA","en-NF","en-NG","en-NL","en-NR","en-NU","en-NZ","en-PG","en-PH","en-PK","en-PN","en-PR","en-PW","en-RW","en-SB","en-SC","en-SD","en-SE","en-SG","en-SH","en-SI","en-SL","en-SS","en-SX","en-SZ","en-TC","en-TK","en-TO","en-TT","en-TV","en-TZ","en-UG","en-UM","en-US","en-VC","en-VG","en-VI","en-VU","en-WS","en-ZA","en-ZM","en-ZW","en","eo","es-419","es-AR","es-BO","es-BR","es-BZ","es-CL","es-CO","es-CR","es-CU","es-DO","es-EA","es-EC","es-GQ","es-GT","es-HN","es-IC","es-MX","es-NI","es-PA","es-PE","es-PH","es-PR","es-PY","es-SV","es-US","es-UY","es-VE","es","et","eu","ewo","fa-AF","fa","ff-CM","ff-GN","ff-MR","ff","fil","fo-DK","fo","fr-BE","fr-BF","fr-BI","fr-BJ","fr-BL","fr-CA","fr-CD","fr-CF","fr-CG","fr-CH","fr-CI","fr-CM","fr-DJ","fr-DZ","fr-GA","fr-GF","fr-GN","fr-GP","fr-GQ","fr-HT","fr-KM","fr-LU","fr-MA","fr-MC","fr-MF","fr-MG","fr-ML","fr-MQ","fr-MR","fr-MU","fr-NC","fr-NE","fr-PF","fr-PM","fr-RE","fr-RW","fr-SC","fr-SN","fr-SY","fr-TD","fr-TG","fr-TN","fr-VU","fr-WF","fr-YT","fr","fur","fy","ga","gd","gl","gsw-FR","gsw-LI","gsw","gu","guz","gv","ha-GH","ha-NE","ha","haw","he","hi","hr-BA","hr","hsb","hu","hy","ig","ii","is","it-CH","it-SM","it-VA","it","ja","jgo","jmc","ka","kab","kam","kde","kea","khq","ki","kk","kkj","kl","kln","km","kn","ko-KP","ko","kok","ksb","ksf","ksh","kw","ky","lag","lb","lg","lkt","ln-AO","ln-CF","ln-CG","ln","lo","lt","lu","luo","luy","lv","mas-TZ","mas","mer","mfe","mg","mgh","mgo","mk","ml","mn","mr","ms-BN","ms-SG","ms","mt","mua","my","mzn","naq","nb-SJ","nb","nd","nds-NL","nds","ne-IN","ne","nl-AW","nl-BE","nl-BQ","nl-CW","nl-SR","nl-SX","nl","nmg","nn","nnh","nus","nyn","om-KE","om","or","os-RU","os","pa-Arab","pa-Guru","pa","pl","prg","pt-AO","pt-CH","pt-CV","pt-GQ","pt-GW","pt-LU","pt-MO","pt-MZ","pt-PT","pt-ST","pt-TL","pt","qu-BO","qu-EC","qu","rm","rn","ro-MD","ro","rof","root","ru-BY","ru-KG","ru-KZ","ru-MD","ru-UA","ru","rw","rwk","sah","saq","sbp","se-FI","se-SE","se","seh","ses","sg","shi-Latn","shi-Tfng","shi","sk","sl","sn","so-DJ","so-ET","so-KE","so","sq-MK","sq-XK","sq","sr-Cyrl-BA","sr-Cyrl-ME","sr-Cyrl-XK","sr-Cyrl","sr-Latn-BA","sr-Latn-ME","sr-Latn-XK","sr-Latn","sr","sv-AX","sv-FI","sv","sw-CD","sw-KE","sw-UG","sw","ta-LK","ta-MY","ta-SG","ta","te","teo-KE","teo","th","ti-ER","ti","tk","to","tr-CY","tr","twq","tzm","uk","ur-IN","ur","uz-Arab","uz-Cyrl","uz-Latn","uz","vai-Latn","vai-Vaii","vai","vi","vo","vun","wae","xog","yav","yi","yo-BJ","yo","yue","zgh","zh-Hans-HK","zh-Hans-MO","zh-Hans-SG","zh-Hans","zh-Hant-HK","zh-Hant-MO","zh-Hant","zh","zu"],
		
		"." : ["da-GL","da","en-DK","en-FI","fi","id","si","smn"],

		"," : ["ks","lrc-IQ","lrc","ps","ug"]
	},
	"currencySymbolPosition":{
		"left": ["af-NA","af","ak","am","ar-AE","ar-BH","ar-DJ","ar-ER","ar-LB","as","en-US","az-Cyrl","az-Latn","az","bem","bm","bo-IN","bo","brx","cgg","chr","ckb-IR","ckb","cu","cy","dav","de-AT","de-CH","dz","ebu","ee-TG","ee","en-001","en-AG","en-AI","en-AS","en-AT","en-AU","en-BB","en-BI","en-BM","en-BS","en-BW","en-BZ","en-CA","en-CC","en-CH","en-CK","en-CM","en-CX","en-CY","en-DG","en-DM","en-ER","en-FJ","en-FK","en-FM","en-GB","en-GD","en-GG","en-GH","en-GI","en-GM","en-GU","en-GY","en-HK","en-IE","en-IL","en-IM","en-IN","en-IO","en-JE","en-JM","en-KE","en-KI","en-KN","en-KY","en-LC","en-LR","en-LS","en-MG","en-MH","en-MO","en-MP","en-MS","en-MT","en-MU","en-MW","en-MY","en-NA","en-NF","en-NG","en-NL","en-NR","en-NU","en-NZ","en-PG","en-PH","en-PK","en-PN","en-PR","en-PW","en-RW","en-SB","en-SC","en-SD","en-SG","en-SH","en-SL","en-SS","en-SX","en-SZ","en-TC","en-TK","en-TO","en-TT","en-TV","en-TZ","en-UG","en-UM","en-VC","en-VG","en-VI","en-VU","en-WS","en-ZA","en-ZM","en-ZW","en","eo","es-419","es-AR","es-BO","es-BR","es-BZ","es-CL","es-CO","es-CR","es-CU","es-DO","es-EC","es-GQ","es-GT","es-HN","es-MX","es-NI","es-PA","es-PE","es-PR","es-PY","es-SV","es-US","es-UY","es-VE","fa-AF","fil","fur","fy","ga","gd","gu","guz","gv","ha-GH","ha-NE","ha","haw","hi","id","ig","ii","it-CH","ja","jgo","jmc","kam","kde","ki","kkj","kl","kln","kn","ko-KP","ko","kok","ks","kw","lag","lkt","lo","lrc-IQ","lrc","luy","mas-TZ","mas","mer","mfe","mg","mgh","ml","mn","mr","ms-BN","ms-SG","ms","mt","mua","mzn","naq","nb-SJ","nb","nd","nds-NL","nds","ne-IN","ne","nl-AW","nl-BQ","nl-CW","nl-SR","nl-SX","nl","nnh","nus","nyn","om-KE","om","or","os-RU","os","pa-Arab","pa-Guru","pa","prg","pt","qu-BO","qu-EC","qu","rof","root","rw","saq","sd","sg","si","sn","so-DJ","so-ET","so-KE","so","sw-CD","sw-KE","sw-UG","sw","ta-LK","ta-MY","ta-SG","ta","te","teo-KE","teo","th","ti-ER","ti","to","tr-CY","tr","ug","ur-IN","ur","uz-Arab","vai-Latn","vai-Vaii","vai","vo","vun","wae","wo","yi","yo-BJ","yo","yue-Hans","yue-Hant","zh-Hans-HK","zh-Hans-MO","zh-Hans-SG","zh-Hans","zh-Hant-HK","zh-Hant-MO","zh-Hant","zh","zu"],
		"right": ["agq","ar-DZ","ar-EG","ar-EH","ar-IL","ar-IQ","ar-JO","ar-KM","ar-KW","ar-LY","ar-MA","ar-MR","ar-OM","ar-PS","ar-QA","ar-SA","ar-SD","ar-SO","ar-SS","ar-SY","ar-TD","ar-TN","ar-YE","ar","asa","ast","bas","be","bez","bg","bn-IN","bn","br","bs-Cyrl","bs-Latn","bs","ca-AD","ca-ES-VALENCIA","ca-FR","ca-IT","ca","ce","cs","da-GL","da","de-BE","de-IT","de-LU","de","dje","dsb","dua","dyo","el-CY","el","en-150","en-BE","en-DE","en-DK","en-FI","en-SE","en-SI","es-EA","es-IC","es-PH","es","et","eu","ewo","fa","ff-CM","ff-GN","ff-MR","ff","fi","fo-DK","fo","fr-BE","fr-BF","fr-BI","fr-BJ","fr-BL","fr-CA","fr-CD","fr-CF","fr-CG","fr-CH","fr-CI","fr-CM","fr-DJ","fr-DZ","fr-GA","fr-GF","fr-GN","fr-GP","fr-GQ","fr-HT","fr-KM","fr-LU","fr-MA","fr-MC","fr-MF","fr-MG","fr-ML","fr-MQ","fr-MR","fr-MU","fr-NC","fr-NE","fr-PF","fr-PM","fr-RE","fr-RW","fr-SC","fr-SN","fr-SY","fr-TD","fr-TG","fr-TN","fr-VU","fr-WF","fr-YT","fr","gl","gsw-FR","gsw-LI","gsw","he","hr-BA","hr","hsb","hu","hy","is","it-SM","it-VA","it","ka","kab","kea","khq","kk","km","ksb","ksf","ksh","ky","lb","lg","ln-AO","ln-CF","ln-CG","ln","lt","lu","luo","lv","mk","my","nl-BE","nmg","nn","pl","ps","pt-AO","pt-CH","pt-CV","pt-GQ","pt-GW","pt-LU","pt-MO","pt-MZ","pt-PT","pt-ST","pt-TL","rm","rn","ro-MD","ro","ru-BY","ru-KG","ru-KZ","ru-MD","ru-UA","ru","rwk","sah","sbp","se-FI","se-SE","se","seh","ses","shi-Latn","shi-Tfng","shi","sk","sl","smn","sq-MK","sq-XK","sq","sr-Cyrl-BA","sr-Cyrl-ME","sr-Cyrl-XK","sr-Cyrl","sr-Latn-BA","sr-Latn-ME","sr-Latn-XK","sr-Latn","sr","sv-AX","sv-FI","sv","tg","tk","tt","twq","tzm","uk","uz-Cyrl","uz-Latn","uz","vi","xog","yav","zgh"]
	}
}
;
 (function(ZC){ 
let template = ZC.Templates.Utilities; 
template.WCIcon = (data) => ZT.html `<i class="${data.iconClassName}"> ${ZT.customHTML(data.SVGIconId ? `<svg class='${data.SVGIconClassName}' focusable=false > <use xlink:href='${data.SVGIconId}'></use></svg> </svg>` : '')} </i>`; 
template.WCCommandBar = (data) => ZT.html `<div class="zdatetimepicker__commandbar ${data.colClass ? data.colClass : ''}"> ${data.cols && data.cols.length ? data.cols.map((col) => ZT.html `<div class="zdatetimepicker__column"> ${template.WCCommandBarCol(col)} </div>`) : template.WCCommandBarCol(data)} </div>`; 
template.WCCommandBarCol = (data) => ZT.html `${data.left && data.left.length ? ZT.html `<div class=${data.leftClass || 'zdatetimepicker__commandbaractionsleft'}>${data.left.map((value) => template.WCButton(value))}</div>` : ''} ${data.center && data.center.length ? ZT.html `<div class=${data.centerClass || 'zdatetimepicker__commandbaractionscenter'}> ${data.center.map((value) => template.WCButton(value))}</div>` : ''} ${data.right && data.right.length ? ZT.html `<div class=${data.rightClass || 'zdatetimepicker__commandbaractionsright'}>${data.right.map((value) => template.WCButton(value))}</div>` : ''}`; 
template.WCButton = (data) => ZT.html `${data.isLink ? ZT.html `<a ?class=${data.className} tabindex=${data.tabindex} aria-label=${data.text}>${data.text}</a>` : data.initBtnComp ? ZC.createButton(data) : ZC.zbutton.Templates.WCContainer(data)}`; }(ZComponents)); 
 (function(ZC){
let svgs = 	 	`<symbol viewBox="0 0 16 16" width="100%" height="100%" id="zc__svg--add"> <polygon points="13,7.3 8.7,7.3 8.7,3 7.3,3 7.3,7.3 3,7.3 3,8.7 7.3,8.7 7.3,13 8.7,13 8.7,8.7 13,8.7 "></polygon> </symbol>` 	 	+ 	 	 	`<symbol viewBox="0 0 16 16" width="100%" height="100%" id="zc__svg--arrow"> <polygon points="6.5,12.5 5.5,11.5 9,8 5.5,4.5 6.5,3.5 11,8"></polygon> </symbol>` 	 	+ 	 	` <symbol id="zc__svg--arrowbottom" viewBox="0 0 10.70711 6.06066"> <polyline points="10.354 0.354 5.354 5.354 0.354 0.354"/> </symbol> 	` 	+ 	 	` <symbol id="zc__svg--arrowleft" viewBox="0 0 6.06066 10.70711"> <polyline points="5.707 10.354 0.707 5.354 5.707 0.354"/> </symbol> 	` 	+ 	 	` <symbol id="zc__svg--arrowright" viewBox="0 0 6.06066 10.70711"> <polyline points="0.354 0.354 5.354 5.354 0.354 10.354"/> </symbol>` 	+ 	 	` <symbol id="zc__svg--arrowup" viewBox="0 0 10.70711 6.06066"> <polyline points="0.354 5.707 5.354 0.707 10.354 5.707"/> </symbol> 	 	` 	+ 	 	`<symbol id="zc__svg--backward" viewBox="0 0 12 12" width="100%" height="100%"><polygon points="6.6,10.3 2.9,6.5 6.6,2.7 7.4,3.4 4.3,6.5 7.4,9.6"></polygon></symbol>` 	+ 	 	 	`<symbol viewBox="0 0 16 16" width="100%" height="100%" id="zc__svg--buttonarrow"> <polygon points="3.5,6.5 4.5,5.5 8,9 11.5,5.5 12.5,6.5 8,11"></polygon> </symbol>` 	 	+ 	 	`<symbol viewBox="0 0 14 14" width="100%" height="100%" id="zc__svg--calendaricon"> <rect x="-22.5" y="3.5" width="13" height="10"></rect> <path d="M-10,4v9h-12V4H-10 M-9,3h-14v11h14V3L-9,3z"></path> <rect x="-20.6" y="1.4" width="1.2" height="3.2"></rect> <path d="M-19.8,1.8v2.5h-0.5V1.8H-19.8 M-19,1h-2v4h2V1L-19,1z"></path> <rect x="-20.6" y="7.4" width="1.2" height="1.2"></rect> <path d="M-19.8,7.8v0.5h-0.5V7.8H-19.8 M-19,7h-2v2h2V7L-19,7z"></path> <rect x="-16.6" y="1.4" width="1.2" height="3.2"></rect> <path d="M-15.8,1.8v2.5h-0.5V1.8H-15.8 M-15,1h-2v4h2V1L-15,1z"></path> <rect x="-12.6" y="1.4" width="1.2" height="3.2"></rect> <path d="M-11.8,1.8v2.5h-0.5V1.8H-11.8 M-11,1h-2v4h2V1L-11,1z"></path> <rect x="-16.6" y="7.4" width="1.2" height="1.2"></rect> <path d="M-15.8,7.8v0.5h-0.5V7.8H-15.8 M-15,7h-2v2h2V7L-15,7z"></path> <rect x="-12.6" y="7.4" width="1.2" height="1.2"></rect> <path d="M-11.8,7.8v0.5h-0.5V7.8H-11.8 M-11,7h-2v2h2V7L-11,7z"></path> <rect x="-20.6" y="10.4" width="1.2" height="1.2"></rect> <path d="M-19.8,10.8v0.5h-0.5v-0.5H-19.8 M-19,10h-2v2h2V10L-19,10z"></path> <rect x="-16.6" y="10.4" width="1.2" height="1.2"></rect> <path d="M-15.8,10.8v0.5h-0.5v-0.5H-15.8 M-15,10h-2v2h2V10L-15,10z"></path> <rect x="-12.6" y="10.4" width="1.2" height="1.2"></rect> <path d="M-11.8,10.8v0.5h-0.5v-0.5H-11.8 M-11,10h-2v2h2V10L-11,10z"></path> <path d="M4,3c0.6,0,1-0.4,1-1V1H3v1C3,2.6,3.4,3,4,3z"></path> <rect x="2" y="7" width="2" height="2"></rect> <rect x="2" y="10" width="2" height="2"></rect> <rect x="6" y="7" width="2" height="2"></rect> <rect x="6" y="10" width="2" height="2"></rect> <rect x="10" y="7" width="2" height="2"></rect> <rect x="10" y="10" width="2" height="2"></rect> <path d="M12.8,2c0,1-0.8,1.8-1.8,1.8S9.2,3,9.2,2H5.8C5.8,3,5,3.8,4,3.8S2.2,3,2.2,2H0v3v9h14V5V2H12.8z M13,13H1V6h12V13z"></path> <path d="M11,3c0.6,0,1-0.4,1-1V1h-2v1C10,2.6,10.4,3,11,3z"></path> </symbol>` 	+ 	 	`<symbol viewBox="0 0 21.9 21.9" width="100%" height="100%" id="zc__svg--clear"> <path d="M14.1,11.3c-0.2-0.2-0.2-0.5,0-0.7l7.5-7.5c0.2-0.2,0.3-0.5,0.3-0.7s-0.1-0.5-0.3-0.7l-1.4-1.4C20,0.1,19.7,0,19.5,0 c-0.3,0-0.5,0.1-0.7,0.3l-7.5,7.5c-0.2,0.2-0.5,0.2-0.7,0L3.1,0.3C2.9,0.1,2.6,0,2.4,0S1.9,0.1,1.7,0.3L0.3,1.7C0.1,1.9,0,2.2,0,2.4 s0.1,0.5,0.3,0.7l7.5,7.5c0.2,0.2,0.2,0.5,0,0.7l-7.5,7.5C0.1,19,0,19.3,0,19.5s0.1,0.5,0.3,0.7l1.4,1.4c0.2,0.2,0.5,0.3,0.7,0.3 s0.5-0.1,0.7-0.3l7.5-7.5c0.2-0.2,0.5-0.2,0.7,0l7.5,7.5c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l1.4-1.4c0.2-0.2,0.3-0.5,0.3-0.7 s-0.1-0.5-0.3-0.7L14.1,11.3z"></path> </symbol>` 	+ 	 	`<symbol viewBox="0 0 16 16" width="100%" height="100%" id="zc__svg--close"> <rect x="1.5" y="7.4" transform="matrix(0.7071 -0.7071 0.7071 0.7071 -3.3137 8)" class="st0" width="13" height="1.1"></rect> <rect x="1.5" y="7.4" transform="matrix(0.7071 0.7071 -0.7071 0.7071 8 -3.3137)" class="st0" width="13" height="1.1"></rect> </symbol>` 	 	+ 	 	 	`<symbol viewBox="0 0 600 598" width="100%" height="100%" id="zc__svg--zcolorpicker-advancedpicker"> <path d="M299.7-0.2C128.3-0.2-7,134,0.2,305.2C7.4,476.9,138,577.3,259.7,595.9c88.2,13.4,107.8-45.1,87.3-67.3 c-35.5-38.3-22.6-68.6-7.3-82.5c17.4-15.7,50.3-17.3,77.3-13.8c65.5,8.5,175-40,182.2-144.8C611,116.5,471.1-0.2,299.7-0.2z M118.1,299.7c-27.7,0-50.1-22.4-50.1-50.1c0-27.7,22.4-50.1,50.1-50.1c27.7,0,50.1,22.4,50.1,50.1 C168.2,277.3,145.8,299.7,118.1,299.7z M217.6,166.6c-27.7,0-50.1-22.4-50.1-50.1c0-27.7,22.4-50.1,50.1-50.1 c27.7,0,50.1,22.4,50.1,50.1C267.7,144.1,245.2,166.6,217.6,166.6z M384.9,166.9c-27.7,0-50.1-22.4-50.1-50.1 c0-27.7,22.4-50.1,50.1-50.1c27.7,0,50.1,22.4,50.1,50.1C435,144.4,412.6,166.9,384.9,166.9z M485.2,299.9 c-27.7,0-50.1-22.4-50.1-50.1c0-27.7,22.4-50.1,50.1-50.1c27.7,0,50.1,22.4,50.1,50.1C535.2,277.5,512.8,299.9,485.2,299.9z"> </path> </symbol>` 	 	+ 	 	 	`<symbol viewBox="0 0 16 16" width="100%" height="100%" id="zc__svg--zcolorpicker-nocolor"> <path d="M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M8,1c1.8,0,3.3,0.7,4.6,1.7l-9.9,9.9C1.7,11.3,1,9.8,1,8 C1,4.1,4.1,1,8,1z M8,15c-1.8,0-3.3-0.7-4.6-1.7l9.9-9.9C14.3,4.7,15,6.2,15,8C15,11.9,11.9,15,8,15z"></path> </symbol>` 	 	+ 	 	`<symbol viewBox="0 0 48 48" width="100%" height="100%" id="zc__svg--confirm"> <g> <path d="M24,0C10.7,0,0,10.7,0,24s10.7,24,24,24s24-10.7,24-24C48,10.8,37.3,0,24,0z M24,44.1c-11,0-20-9-20-20s9-20,20-20s20,9,20,20C44,35.2,35,44.1,24,44.1z"></path> <g> <path d="M22.8,31.9c-1.7,0-2.6,0.9-2.6,2.7c0,0.9,0.2,1.5,0.7,2c0.4,0.5,1.1,0.7,1.9,0.7c0.8,0,1.5-0.2,1.9-0.7c0.5-0.5,0.7-1.1,0.7-2c0-0.8-0.2-1.5-0.7-2C24.3,32.2,23.6,31.9,22.8,31.9z"></path> <path d="M29.3,12.4c-1.3-1.1-3.2-1.7-5.5-1.7s-4.4,0.5-6.5,1.4c-1.1,0.5-0.6,1.7-0.6,1.7l0.5,1c0,0,0.5,0.9,1.7,0.5l0,0c0.5-0.2,1-0.4,1.5-0.6c0.9-0.3,2-0.5,3.1-0.5c1.2,0,2.2,0.3,2.8,0.8c0.7,0.5,1,1.3,1,2.3c0,0.8-0.2,1.6-0.6,2.2c-0.4,0.6-1.3,1.5-2.7,2.6c-1.2,0.9-2,1.8-2.5,2.7c-0.5,0.9-0.7,1.9-0.7,3.2c0,0.9,1.1,1.1,1.1,1.1h0.7c0,0,1.4,0,1.6-1.2l0,0c0-0.8,0.2-1.4,0.5-1.8c0.4-0.6,1.1-1.3,2.2-2.1c1.3-1,2.2-1.8,2.7-2.4s0.9-1.3,1.2-2s0.4-1.5,0.4-2.3C31.4,15.1,30.7,13.5,29.3,12.4z"></path> </g> </g> </symbol>` 	+ 	 	`<symbol viewBox="0 0 48 48" width="100%" height="100%" id="zc__svg--decrement"> <path class="cls-1" d="M11.76,13L24,26.521,37.147,13,41,16.9,24,35,7,16.9Z"></path> </symbol>` 	+ 	 	`<symbol viewBox="0 0 16 16" width="100%" height="100%" id="zc__svg--downarrow"> <polygon points="3.5,6.5 4.5,5.5 8,9 11.5,5.5 12.5,6.5 8,11"></polygon> </symbol>` 	+ 	 	`<symbol viewBox="0 0 17 16" id="zc__svg--download"> <path class="zpreview__fill" d="M17,16H0v-3h1v2h15v-2h1V16z M12.6,6.6L9,10.3V1H8v9.3L4.4,6.6L3.6,7.4l4.9,4.9l4.9-4.9L12.6,6.6z"></path> </symbol>` 	+ 	 	 	`<symbol viewBox="-3 -3 22 22" width="100%" height="100%" id="zc__svg--downscroller"> <path d="M16,4l-8,8L0,4H16z"></path> </symbol>` 	+ 	 	`<symbol viewBox="0 0 17 16" id="zc__svg--edit"> <path class="zpreview__fill" d="M13,0L1,12v4h3.8L17,4L13,0z M15.6,4l-2.5,2.4l-2.5-2.6L13,1.4L15.6,4z M4.3,15H2v-2.6l7.8-7.8l2.6,2.6L4.3,15z"></path> </symbol>` 	+ 	 	`<symbol viewBox="0 0 48 48" width="100%" height="100%" id="zc__svg--error"> <path d="M41.2,7.2C31.9-2.2,16.7-2.5,7.3,6.9c-9.5,9.3-9.7,24.5-0.4,33.9c9.3,9.5,24.5,9.7,33.9,0.4C50.3,31.9,50.4,16.8,41.2,7.2z M37.9,38.2C30,46,17.4,45.9,9.7,38S2.1,17.5,10,9.8S30.5,2.1,38.2,10C45.9,17.9,45.8,30.5,37.9,38.2z"></path> <path d="M31.7,17.5l-1.1-1.1c-0.8-0.8-1.7-0.1-2,0.1L24,21l-4.6-4.7c-0.3-0.3-1.1-0.8-1.9,0l-1.1,1.1c-0.8,0.8-0.1,1.7,0.1,2L21,24l-4.7,4.6c-0.9,0.9-0.3,1.6-0.1,1.8l1.3,1.3c0.2,0.2,0.9,0.8,1.8-0.1L24,27l4.6,4.7c0.9,0.9,1.6,0.3,1.8,0.1l1.3-1.3c0.2-0.2,0.8-0.9-0.1-1.8L27,24l4.7-4.6C32,19.1,32.5,18.4,31.7,17.5z"></path> </symbol>` 	+ 	 	`<symbol viewBox="0 0 12 12" id="zc__svg--fastbackward" width="100%" height="100%"><polygon points="5.6,10.3 1.9,6.5 5.6,2.6 6.3,3.4 3.3,6.5 6.4,9.6"></polygon><polygon points="9.6,10.3 5.9,6.5 9.6,2.6 10.3,3.4 7.3,6.5 10.4,9.6"></polygon></symbol>` 	+ 	 	`<symbol viewBox="1 0 12 12" id="zc__svg--fastforward" width="100%" height="100%"><polygon points="7.4,10.3 6.7,9.6 9.7,6.5 6.6,3.4 7.4,2.7 11.1,6.5"></polygon><polygon points="3.4,10.3 2.7,9.6 5.7,6.5 2.6,3.4 3.4,2.7 7.1,6.5"></polygon></symbol>` 	+ 	 	`<symbol viewBox="0 0 19 10" id="zc__svg--filmstrip"> <path class="zpreview__fill" d="M4,4v5H1V4H4 M5,3H0v7h5V3L5,3z M0,0h19v1H0V0z M18,4v5h-3V4H18 M19,3h-5v7h5V3L19,3z M11,4v5H8V4H11 M12,3H7v7h5V3L12,3z"> </path> </symbol>` 	+ 	 	`<symbol viewBox="1 0 12 12" id="zc__svg--forward" width="100%" height="100%"><polygon points="4.4,10.3 3.7,9.6 6.7,6.5 3.6,3.4 4.4,2.7 8.1,6.5"></polygon></symbol>` 	+ 	 	`<symbol viewBox="0 0 17 16" id="zc__svg--fullscreen"> <path class="zpreview__fill" d="M6.9,10.9L2.7,15H5v1H1v-4h1v2.3l4.1-4.1C6.3,10,6.7,10,6.9,10.1S7,10.7,6.9,10.9z M15,12v2.3l-4.1-4.2c-0.2-0.1-0.6-0.1-0.8,0s-0.1,0.6,0,0.8l4.1,4.1H12v1h4v-4H15z M12,1v1h2.3l-4.2,4.1c-0.1,0.2-0.1,0.6,0,0.8C10.2,7,10.4,7,10.5,7s0.3,0,0.4-0.1L15,2.7V5h1V1H12z M6.9,6.1L2.7,2H5V1H1v4h1V2.7l4.1,4.1C6.2,7,6.4,7,6.5,7s0.3,0,0.4-0.1C7,6.7,7,6.3,6.9,6.1z"> </path></symbol>` 	+ 	 	`<symbol viewBox="0 0 5 10" width="100%" height="100%" id="zc__svg--grippy"> <rect width="2" height="2"></rect><rect x="3" width="2" height="2"></rect> <rect y="4" width="2" height="2"></rect><rect x="3" y="4" width="2" height="2"></rect> <rect x="3" y="8" width="2" height="2"></rect><rect y="8" width="2" height="2"></rect> </symbol>` 	 	+ 	 	`<svg width="14" height="14" viewBox="0 0 14 14" id="zc__svg--grippy-listbox"> <g id="Group_1151" data-name="Group 1151" transform="translate(-485 -283)"> <g id="Rectangle_1152" data-name="Rectangle 1152" transform="translate(485 283)" fill="#fff" stroke="#a6a6a6" stroke-width="1"> <rect width="2" height="2" stroke="none"></rect> <rect x="0.5" y="0.5" width="1" height="1" fill="none"></rect> </g> <g id="Rectangle_1153" data-name="Rectangle 1153" transform="translate(489 283)" fill="#fff" stroke="#a6a6a6" stroke-width="1"> <rect width="2" height="2" stroke="none"></rect> <rect x="0.5" y="0.5" width="1" height="1" fill="none"></rect> </g> <g id="Rectangle_1155" data-name="Rectangle 1155" transform="translate(485 287)" fill="#fff" stroke="#a6a6a6" stroke-width="1"> <rect width="2" height="2" stroke="none"></rect> <rect x="0.5" y="0.5" width="1" height="1" fill="none"></rect> </g> <g id="Rectangle_1156" data-name="Rectangle 1156" transform="translate(489 287)" fill="#fff" stroke="#a6a6a6" stroke-width="1"> <rect width="2" height="2" stroke="none"></rect> <rect x="0.5" y="0.5" width="1" height="1" fill="none"></rect> </g> <g id="Rectangle_1157" data-name="Rectangle 1157" transform="translate(485 291)" fill="#fff" stroke="#a6a6a6" stroke-width="1"> <rect width="2" height="2" stroke="none"></rect> <rect x="0.5" y="0.5" width="1" height="1" fill="none"></rect> </g> <g id="Rectangle_1158" data-name="Rectangle 1158" transform="translate(489 291)" fill="#fff" stroke="#a6a6a6" stroke-width="1"> <rect width="2" height="2" stroke="none"></rect> <rect x="0.5" y="0.5" width="1" height="1" fill="none"></rect> </g> </g> </svg> 	` 	+ 	 	`<symbol viewBox="0 0 48 48" width="100%" height="100%" id="zc__svg--help"><g><path d="M24,0C10.7,0,0,10.7,0,24s10.7,24,24,24s24-10.7,24-24C48,10.8,37.3,0,24,0z M24,44.1c-11,0-20-9-20-20s9-20,20-20s20,9,20,20C44,35.2,35,44.1,24,44.1z"></path><g><path d="M22.8,31.9c-1.7,0-2.6,0.9-2.6,2.7c0,0.9,0.2,1.5,0.7,2c0.4,0.5,1.1,0.7,1.9,0.7c0.8,0,1.5-0.2,1.9-0.7c0.5-0.5,0.7-1.1,0.7-2c0-0.8-0.2-1.5-0.7-2C24.3,32.2,23.6,31.9,22.8,31.9z"></path><path d="M29.3,12.4c-1.3-1.1-3.2-1.7-5.5-1.7s-4.4,0.5-6.5,1.4c-1.1,0.5-0.6,1.7-0.6,1.7l0.5,1c0,0,0.5,0.9,1.7,0.5l0,0c0.5-0.2,1-0.4,1.5-0.6c0.9-0.3,2-0.5,3.1-0.5c1.2,0,2.2,0.3,2.8,0.8c0.7,0.5,1,1.3,1,2.3c0,0.8-0.2,1.6-0.6,2.2c-0.4,0.6-1.3,1.5-2.7,2.6c-1.2,0.9-2,1.8-2.5,2.7c-0.5,0.9-0.7,1.9-0.7,3.2c0,0.9,1.1,1.1,1.1,1.1h0.7c0,0,1.4,0,1.6-1.2l0,0c0-0.8,0.2-1.4,0.5-1.8c0.4-0.6,1.1-1.3,2.2-2.1c1.3-1,2.2-1.8,2.7-2.4s0.9-1.3,1.2-2s0.4-1.5,0.4-2.3C31.4,15.1,30.7,13.5,29.3,12.4z"></path></g></g></symbol>` 	 	+ 	 	`<symbol viewBox="1 2 9 9" width="100%" height="100%" id="zc__svg--horizontaldecrement"> <polygon points="6.6,10.3 2.9,6.5 6.6,2.7 7.4,3.4 4.3,6.5 7.4,9.6"></polygon> </symbol>` 	+ 	 	`<symbol viewBox="1 2 9 9" width="100%" height="100%" id="zc__svg--horizontalincrement"> <polygon points="4.4,10.3 3.7,9.6 6.7,6.5 3.6,3.4 4.4,2.7 8.1,6.5"></polygon> </symbol>` 	+ 	 	`<symbol viewBox="0 0 48 48" width="100%" height="100%" id="zc__svg--increment"> <path class="cls-1" d="M6,32l5,4L24,22,38,36l4-4L24,13Z"></path> </symbol>` 	+ 	 	`<symbol viewBox="0 0 48 48" width="100%" height="100%" id="zc__svg--info"> <g> <g> <path d="M23.9,17.4c1.5,0,2.5-1.1,2.4-2.3c0-1.3-0.9-2.4-2.3-2.4s-2.4,1.1-2.4,2.4C21.6,16.3,22.6,17.4,23.9,17.4z"></path> <path d="M26.2,35.5V21.8c0-1.2-1.4-1.3-1.8-1.3h-0.7c0,0-1.7,0-1.7,1.1v14.3c0,0.3,0.2,0.9,1.3,0.9h1.6C25.3,36.7,26.2,36.5,26.2,35.5z"></path> </g> <path d="M24,0C10.7,0,0,10.7,0,24s10.7,24,24,24s24-10.7,24-24S37.3,0,24,0z M24,44C13,44,4,35,4,24S13,4,24,4s20,9,20,20S35,44,24,44z"></path> </g> </symbol>` 	+ 	 	`<symbol id="zc__svg--lines" viewBox="0 0 12 12" width="100%" height="100%"> <line x1="11" y1="1" x2="1" y2="11"></line> <line x1="11" y1="5" x2="5" y2="11"></line> <line x1="11" y1="9" x2="9" y2="11"></line> </symbol>` 	+ 	 	`<symbol viewBox="0 0 16 16" width="100%" height="100%" id="zc__svg--maximize"> <g transform="translate(0,-1036.3622)"> <g> <path d="M13,1040.4v8H3v-8H13 M14,1039.4H2v10h12V1039.4L14,1039.4z"></path> </g> </g> </symbol>` 	+ 	 	`<symbol viewBox="0 0 16 16" width="100%" height="100%" id="zc__svg--minimize"> <rect x="2" y="12" width="12" height="1"></rect> </symbol>` 	+ 	 	`<symbol viewBox="0 0 12 10" width="100%" height="100%" id="zc__svg--minus"> <rect x="2" y="5" width="9" height="1"></rect> </symbol>` 	+ 	 	`<symbol viewBox="0 0 4 16" id="zc__svg--more"> <path class="zpreview__fill" d="M2,1c0.6,0,1,0.4,1,1S2.6,3,2,3S1,2.6,1,2S1.4,1,2,1 M2,0C0.9,0,0,0.9,0,2s0.9,2,2,2s2-0.9,2-2S3.1,0,2,0L2,0z"> </path><path class="zpreview__fill" d="M2,13c0.6,0,1,0.4,1,1s-0.4,1-1,1s-1-0.4-1-1S1.4,13,2,13 M2,12c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S3.1,12,2,12L2,12z"> </path><path class="zpreview__fill" d="M2,7c0.6,0,1,0.4,1,1S2.6,9,2,9S1,8.6,1,8S1.4,7,2,7 M2,6C0.9,6,0,6.9,0,8s0.9,2,2,2s2-0.9,2-2S3.1,6,2,6L2,6z"> </path> </symbol>` 	+ 	 	`<symbol viewBox="0 0 12 20" id="zc__svg--navigationnext"> <path class="zpreview__fill" d="M1.5,19.5c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4L9,10L0.8,2.2c-0.4-0.4-0.4-1,0-1.4c0.4-0.4,1-0.4,1.4,0l9,8.5c0.2,0.2,0.3,0.5,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-9,8.5C2,19.4,1.7,19.5,1.5,19.5z"> </path> </symbol>` 	+ 	 	`<symbol viewBox="0 0 12 20" id="zc__svg--navigationprevious"> <path class="zpreview__fill" d="M9.8,19.2l-9-8.5c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.2,0.1-0.5,0.3-0.7l9-8.5c0.4-0.4,1-0.4,1.4,0c0.4,0.4,0.4,1,0,1.4L3,10l8.2,7.8c0.4,0.4,0.4,1,0,1.4c-0.2,0.2-0.4,0.3-0.7,0.3C10.3,19.5,10,19.4,9.8,19.2z"></path> </symbol>` 	+ 	 	`<symbol viewBox="0 0 25 25" id="zc__svg--notfound"> <path class="zpreview__fill" d="M12.5,1.8c5.9,0,10.7,4.8,10.7,10.7s-4.8,10.7-10.7,10.7S1.8,18.4,1.8,12.5S6.6,1.8,12.5,1.8 M12.5,0C5.6,0,0,5.6,0,12.5S5.6,25,12.5,25S25,19.4,25,12.5S19.4,0,12.5,0L12.5,0z"> </path><line class="zpreview__stroke" stroke-width="2" x1="8" y1="8" x2="17" y2="17"> </line><line class="zpreview__stroke" stroke-width="2" x1="17" y1="8" x2="8" y2="17"> </line> </symbol>` 	+ 	 	`<symbol viewBox="0 0 12 12" width="100%" height="100%" id="zc__svg--plus"> <polygon points="11,6 7,6 7,2 6,2 6,6 2,6 2,7 6,7 6,11 7,11 7,7 11,7 "></polygon> </symbol>` 	+ 	 	`<symbol viewBox="0 0 16 16" id="zc__svg--print"> <path class="zpreview__fill" d="M16,3h-3.1L12,0H4L3.1,3H0v9h2.8L2,16h12l-0.8-4H16V3z M4.7,1h6.5l0.6,2H4.1L4.7,1z M3.2,15l1.1-6h7.3l1.1,6 H3.2z M15,11h-1.9l-0.6-3h-9l-0.6,3H1V4h14V11z"> </path><rect x="13" y="5" class="zpreview__fill" width="1" height="1"> </rect> </symbol>` 	+ 	 	`<symbol viewBox="0 0 16 16" width="100%" height="100%" id="zc__svg--restore"> <g transform="translate(0,-1036.3622)"> <path d="M2,1041.4v8h10v-8H2z M11,1048.4H3v-6h8V1048.4z"></path> </g> <g transform="translate(0,-1036.3622)"> <path d="M4,1039.4v3h1v-2h8v6h-2v1h3v-8H4z"></path> </g> </symbol>` 	+ 	 	`<symbol viewBox="0 0 5 12" id="zc__svg--rightarrow"> <polygon points="4.4,10.3 3.7,9.6 6.7,6.5 3.6,3.4 4.4,2.7 8.1,6.5"></polygon> </symbol>` 	+ 	 	 	`<symbol viewBox="-7 -7 64 64" width="100%" height="100%" id="zc__svg--round"> <circle cx="24.5" cy="24.5" r="15.5"></circle> </symbol>` 	+ 	 	 	`<symbol viewBox="0 0 15 15" width="100%" height="100%" id="zc__svg--search"> <g id="Ellipse_50" data-name="Ellipse 50" fill="none" stroke="gray" stroke-width="1.5"> <circle cx="6" cy="6" r="6" stroke="none"></circle> <circle cx="6" cy="6" r="5.25" fill="none"></circle> </g> <path id="Rectangle_270" data-name="Rectangle 270" d="M0,0H5A1,1,0,0,1,6,1V1A1,1,0,0,1,5,2H0A0,0,0,0,1,0,2V0A0,0,0,0,1,0,0Z" transform="translate(10.757 9.343) rotate(45)" fill="gray"></path> </symbol>` 	 	 	+ 	 	`<symbol viewBox="0 0 16 16" id="zc__svg--share"> <path class="zpreview__fill" d="M13.5,0.8c0.9,0,1.7,0.8,1.7,1.7s-0.8,1.7-1.7,1.7s-1.7-0.8-1.7-1.7S12.6,0.8,13.5,0.8 M13.5,0C12.1,0,11,1.1,11,2.5S12.1,5,13.5,5S16,3.9,16,2.5S14.9,0,13.5,0L13.5,0z"> </path> <path class="zpreview__fill" d="M2.5,6.3c0.9,0,1.7,0.8,1.7,1.7S3.4,9.7,2.5,9.7S0.8,8.9,0.8,8S1.6,6.3,2.5,6.3 M2.5,5.5C1.1,5.5,0,6.6,0,8s1.1,2.5,2.5,2.5S5,9.4,5,8S3.9,5.5,2.5,5.5L2.5,5.5z"> </path> <path class="zpreview__fill" d="M13.5,11.8c0.9,0,1.7,0.8,1.7,1.7s-0.8,1.7-1.7,1.7s-1.7-0.8-1.7-1.7S12.6,11.8,13.5,11.8 M13.5,11c-1.4,0-2.5,1.1-2.5,2.5s1.1,2.5,2.5,2.5s2.5-1.1,2.5-2.5S14.9,11,13.5,11L13.5,11z"> </path> <rect x="7.5" y="7" transform="matrix(0.4472 -0.8944 0.8944 0.4472 -5.2373 13.1252)" class="zpreview__fill" width="1" height="7.6"></rect> <rect x="4.2" y="4.8" transform="matrix(0.8944 -0.4472 0.4472 0.8944 -1.5256 4.1374)" class="zpreview__fill" width="7.6" height="1"></rect> </symbol>` 	 	+ 	 	`<symbol viewBox="0 0 18 17" id="zc__svg--slideshow"> <path class="zpreview__fill" d="M19,2V1h-9V0H9v1H0v1h1v11H0v1h9v0.7l-4,3.7L5.6,19L9,15.8V18h1v-2.2l3.4,3.2l0.5-0.6l-4-3.7V14h9v-1h-1V2H19zM17,13H2V2h15V13z M8,5v5l4.5-2.5L8,5z"></path> </symbol>` 	+ 	 	`<symbol viewBox="0 0 9 16" id="zc__svg--slideshow__next"> <polyline class="zpreview__fill" points="1,1 8,8 1,15"></polyline> </symbol>` 	+ 	 	`<symbol viewBox="0 0 10 14" width="100%" height="100%" id="zc__svg--slideshow__pause"> <path class="zpreview__fill" d="M3,1v12H1V1H3 M3,0H1C0.4,0,0,0.4,0,1v12c0,0.6,0.4,1,1,1h2c0.6,0,1-0.4,1-1V1C4,0.4,3.6,0,3,0L3,0z"> </path><path class="zpreview__fill" d="M9,1v12H7V1H9 M9,0H7C6.4,0,6,0.4,6,1v12c0,0.6,0.4,1,1,1h2c0.6,0,1-0.4,1-1V1C10,0.4,9.6,0,9,0L9,0z"> </path> </symbol>` 	+ 	 	`<symbol viewBox="0 0 12 14" id="zc__svg--slideshow__play"> <path fill="white" d="M1,1.2L11,7L1,12.8L1,1.2 M1,0.2c-0.5,0-1,0.4-1,1v11.5c0,0.6,0.5,1,1,1c0.2,0,0.3,0,0.5-0.1l10-5.8c0.7-0.4,0.7-1.3,0-1.7l-10-5.8C1.3,0.3,1.2,0.2,1,0.2L1,0.2z"> </path> </symbol>` 	+ 	 	`<symbol viewBox="0 0 9 16" id="zc__svg--slideshow__previous"> <polyline class="zpreview__fill" points="8,1 1,8 8,15"></polyline> </symbol>` 	+ 	 	`<symbol viewBox="0 0 48 48" width="100%" height="100%" id="zc__svg--success"> <g> <path d="M41.2,7.2C31.9-2.3,16.7-2.5,7.3,6.8c-9.5,9.3-9.7,24.5-0.4,33.9c9.3,9.5,24.5,9.7,33.9,0.4C50.3,31.9,50.4,16.7,41.2,7.2z M37.9,38.2c-7.9,7.7-20.5,7.6-28.2-0.3S2.1,17.4,10,9.7S30.5,2.1,38.2,10C45.9,17.8,45.8,30.5,37.9,38.2z"></path> <path d="M36,19.3L23.1,32.2c-1.1,1.1-2.9,1.1-4,0l-1-1l-4.5-4.6c-0.2-0.2-1-1.1-0.1-2l1.1-1.1c0.8-0.8,1.6-0.3,1.9,0l4.6,4.7l12-11.8c0.2-0.2,1.1-1,2-0.1l1.1,1.1C36.8,18.2,36.3,18.9,36,19.3z"></path> </g> </symbol>` 	+ 	 	 	`<symbol viewBox="-2 -2 20 20" width="100%" height="100%" id="zc__svg--tick"> <polygon points="14.6,2.4 4.9,12.1 1.2,8.5 0.4,9.3 4.9,13.8 15.4,3.2 "></polygon> </symbol>` 	+ 	 	`<symbol viewBox="0 0 16 16" id="zc__svg--time" width="100%" height="100%"> <path d="M8,0.6C3.9,0.6,0.6,3.9,0.6,8s3.3,7.4,7.4,7.4s7.4-3.3,7.4-7.4S12.1,0.6,8,0.6z M8,13.9c-3.3,0-5.9-2.6-5.9-5.9c0-3.3,2.6-5.9,5.9-5.9c3.3,0,5.9,2.6,5.9,5.9C13.9,11.3,11.3,13.9,8,13.9z"> </path> <polygon points="8.5,7.5 8.5,4.5 6.5,4.5 6.5,9.5 11.5,9.5 11.5,7.5"> </polygon> </symbol>` 	+ 	 	`<symbol viewBox="0 0 25 25" id="zc__svg--unableload"> <path class="zpreview__fill" d="M12.5,2c0.7,0,1.5,0.4,1.8,1.1l8.5,15c0.7,1.3-0.3,3-1.8,3H4.1c-1.6,0-2.6-1.7-1.8-3l8.4-15C11.1,2.3,11.8,2,12.5,2 M12.5,0.1c-1.4,0-2.7,0.7-3.4,2l-8.4,15c-0.7,1.2-0.7,2.6,0,3.9c0.7,1.2,2,2,3.5,2h16.8c1.4,0,2.7-0.7,3.4-1.9c0.7-1.2,0.7-2.6,0.1-3.8l-8.5-15C15.3,0.9,13.9,0.1,12.5,0.1L12.5,0.1z"> </path><path class="zpreview__fill" d="M13,14h-1l-0.8-6.5C11.1,6.7,11.7,6,12.5,6h0c0.8,0,1.4,0.7,1.3,1.5L13,14z"> </path><circle class="zpreview__fill" cx="12.5" cy="17.5" r="1.5"> </circle> </symbol>` 	+ 	 	`<symbol viewBox="0 0 17 16" id="zc__svg--upload"> <path class="zpreview__fill" d="M13.8,4.1C13.2,1.7,11.1,0,8.5,0S3.8,1.7,3.2,4.1C1.4,4.5,0,6.1,0,8c0,1.2,0.5,2.3,1.4,3C2.1,11.6,3,12,4,12h4v4h1v-4h4c1,0,1.9-0.4,2.6-1c0.8-0.7,1.4-1.8,1.4-3C17,6.1,15.6,4.5,13.8,4.1z M13,11h-2.6H9V5.7l2.6,2.7l0.8-0.8L8.5,3.8L4.6,7.6l0.8,0.8L8,5.7V11H6.6H4c-1.7,0-3-1.4-3-3c0-1.3,0.8-2.4,2-2.8C3.3,5.1,3.7,5,4,5c0-0.3,0.1-0.7,0.2-1c0.6-1.8,2.3-3,4.2-3c1.9,0,3.6,1.3,4.2,3c0.1,0.3,0.2,0.6,0.2,1c0.3,0,0.7,0.1,1,0.2c1.2,0.4,2,1.5,2,2.8C16,9.6,14.7,11,13,11z"> </path> </symbol>` 	+ 	 	 	`<symbol viewBox="-3 -3 22 22" width="100%" height="100%" id="zc__svg--upscroller"> <path d="M0,12l8-8l8,8H0z"></path> </symbol>` 	+ 	 	`<symbol viewBox="0 0 48 48" width="100%" height="100%" id="zc__svg--warning"> <g> <path d="M47.3,36.6L27.7,2.5c-0.9-1.4-2.4-2.2-3.9-2.1c-1.6,0-2.9,0.9-3.7,2.2L0.7,36.5c-0.9,1.3-1,3-0.2,4.4c0.8,1.5,2.3,2.4,4,2.4h39c1.6,0,3.1-0.8,3.9-2.2C48.2,39.7,48.2,38,47.3,36.6z M43.9,39.2c-0.1,0.1-0.2,0.2-0.4,0.2h-39c-0.3,0-0.4-0.2-0.5-0.3c-0.1-0.2,0-0.3,0-0.4L23.5,4.6c0,0,0.1-0.2,0.3-0.2c0,0,0,0,0,0c0.1,0,0.3,0,0.4,0.2l19.6,34C44,38.8,44,39,43.9,39.2z"></path> </g> <path d="M24.1,28.4L24.1,28.4c-0.8,0-1.3-0.4-1.4-1l-1-10c-0.1-1.1,1-2,2.4-2l0,0c1.4,0,2.5,0.9,2.4,2l-1,10C25.4,27.9,24.9,28.4,24.1,28.4z"></path> <circle cx="24" cy="33.4" r="2"></circle> </symbol>` ;var id ='zohocomponents__svg'; ZC.loadSVGIcons = function (){ var _svgSprite = document.getElementById(id); if (!_svgSprite) { _svgSprite = document.createElementNS('http://www.w3.org/2000/svg', 'svg'); _svgSprite.setAttribute('id', id); _svgSprite.setAttribute('class', 'zh-dnone'); } if('innerHTML' in _svgSprite){ _svgSprite.innerHTML = svgs; }else{ /* fallback - https://jsfiddle.net/microbians/8ztNU/ Ref - https://stackoverflow.com/questions/9723422/is-there-some-innerhtml-replacement-in-svg-xml https://stackoverflow.com/questions/28129956/get-innerhtml-of-svg-tag-result-in-undefined-in-ie */ var tempDiv = document.createElement('div'); tempDiv.innerHTML = '<svg>'+ svgs +'</svg>'; var children = tempDiv.childNodes[0].childNodes; while (children[0]) { _svgSprite.appendChild(children[0]); } } document.body.appendChild(_svgSprite); }; /*If scripts loaded dynamically after document is loaded, then eventListener won't be working. Hence, the check is added.*/ if(document.readyState !== 'complete'){ document.addEventListener('DOMContentLoaded', ZC.loadSVGIcons); }else{ ZC.loadSVGIcons(); } }(ZComponents)); 
 (function(ZC){ 
let template = ZC.Templates.Utilities; 
template.icon = (data) => ZT.html `<i class="${data.iconClassName}"> ${ZT.customHTML(data.SVGIconId ? `<svg class='${data.SVGIconClassName}' focusable=false > <use xlink:href='${data.SVGIconId}'></use></svg> </svg>` : '')} </i>`; 
template.commandBar = (data) => ZT.html `<div class="zdatetimepicker__commandbar ${data.colClass ? data.colClass : ''}"> ${data.cols && data.cols.length ? data.cols.map((col) => ZT.html `<div class="zdatetimepicker__column"> ${template.commandBarCol(col)} </div>`) : template.commandBarCol(data)} </div>`; 
template.commandBarCol = (data) => ZT.html `${data.left && data.left.length ? ZT.html `<div class=${data.leftClass || 'zdatetimepicker__commandbaractionsleft'}>${data.left.map((value) => template.button(value))}</div>` : ''} ${data.center && data.center.length ? ZT.html `<div class=${data.centerClass || 'zdatetimepicker__commandbaractionscenter'}> ${data.center.map((value) => template.button(value))}</div>` : ''} ${data.right && data.right.length ? ZT.html `<div class=${data.rightClass || 'zdatetimepicker__commandbaractionsright'}>${data.right.map((value) => template.button(value))}</div>` : ''}`; 
template.button = (data) => ZT.html `${data.isLink ? ZT.html `<a ?class=${data.className} tabindex=${data.tabindex} aria-label=${data.text}>${data.text}</a>` : data.initBtnComp ? ZC.createButton(data) : ZC.zbutton.Templates.container(data)}`; }(ZComponents)); 
/* $Id$ */
ZComponents.currencyInformation =
{
	"AFN": {
		"name"  : "Afghan afghani",
		"symbol": "\u060b"
	},
	"ALL": {
		"name"  : "Albanian lek",
		"symbol": "\u004c\u0065\u006b"
	},	
	"DZD": {
		"name"  : "Algerian dinar",
		"symbol": "\u002f\u062c\u0006"
	},
	"EUR":{
		"name"  : "Euro",
		"symbol": "\u20ac"
	},
	"AOA":{
		"name"  :"Angolan kwanza",
		"symbol":"\u004B\u007A"
	},
	"XCD":{
		"name"  : "Eastern Caribbean dollar",
		"symbol":"\u0024"
	},
	"ARS": {
		"name"  : "Argentine peso",
		"symbol" : "\u0024"
	},
	"AMD":{
		"name"  : "Armenian dram",
		"symbol":"\u058F"
	},
	"AWG": {
		"name"  : "Aruban florin",
		"symbol": "\u0192"
	},
	"AUD":{
		"name"  : "Australian dollar",
		"symbol": "\u0024"
	},
	"AZN": {
		"name"  : "Azerbaijani manat",
		"symbol": "\u20bc"
	},
	"BSD": {
		"name"  : "Bahamian dollar",
		"symbol": "\u0024"
	},
	"BHD": {
		"name"  : "Bahraini dinar",
		"symbol": "\u0042\u0044"
	},
	"BDT": {
		"name"  : "Bangladeshi taka",
		"symbol": "\u09f3"
	},
	"BBD": {
		"name"  : "Barbadian dollar",
		"symbol": "\u0024"
	},
	"BYR": {
		"name"  : "Belarusian ruble",
		"symbol": "\u0070\u002e"
	},
	"BZD": {
		"name"  : "Belize dollar",
		"symbol": "\u0042\u005a\u0024"
	},
	"XOF": {
		"name"  : "West African CFA franc",
		"symbol": "\u0043\u0046\u0041",
		"alternateSymbol": "\u062F\u002E\u0644"
	},
	"BTN": {
		"name"  : "Bhutanese ngultrum",
		"symbol": "\u004E\u0075\u002E"
	},
	"BOB": {
		"name"  : "Bolivian boliviano",
		"symbol": "\u0024\u0062"
	},
	"BAM": {
		"name"  : "Bosnia and Herzegovina convertible mark",
		"symbol": "\u004b\u004d"
	},
	"BMD": {
		"name"  : "Bermudian dollar",
		"symbol": "\u0024"
	},
	"BWP": {
		"name"  : "Botswana pula",
		"symbol": "\u0050"
	},
	"BRL": {
		"name"  : "Brazilian real",
		"symbol": "\u0052\u0024"
	},
	"BND": {
		"name"  : "Brunei dollar",
		"symbol": "\u0024"
	},
	"BGN": {
		"name"  : "Bulgarian lev",
		"symbol": "\u043b\u0432"
	},
	"MMK":{
		"name"  : "Burmese kyat",
		"symbol":"\u004B"
	},
	"BIF":{
		"name"  : "Burundian franc",
		"symbol": "\u0046\u0042\u0075"
	},
	"KHR": {
		"name"  : "Cambodian riel",
		"symbol": "\u17db"
	},
	"XAF": {
		"name"  : "Central African CFA franc",
		"symbol":"\u0043\u0046\u0041"
	},
	"XPF": {
		"name"  : "CFP Franc",
		"symbol":"\u0043\u0046\u0041"
	},
	"CAD": {
		"name"  : "Canadian dollar",
		"symbol": "\u0024"
	},
	"CVE": {
		"name"  : "Cape Verdean escudo",
		"symbol":"\u0045\u0073\u0063"
	},
	"CLP": {	
		"name"  : "Chilean peso",
		"symbol": "\u0024"
	},
	"COP": {
		"name"  : "Colombian peso",
		"symbol": "\u0024"
	},
	"KMF": {
		"name"  : "Comorian franc",
		"symbol": "\u0043\u0046"
	},
	"CDF": {
		"name"  : "Congolese franc",
		"symbol":"\u0046\u0043"
	},
	"CRC": {
		"name"  : "Costa Rican coln",
		"symbol": "\u20a1"
	},
	"HRK": {
		"name"  : "Croatian kuna",
		"symbol": "\u006b\u006e"
	},
	"CUP": {
		"name"  : "Cuban peso",
		"symbol": "\u20b1"
	},
	"ANG":{
		"name"  : "Netherlands Antillean guilder",
		"symbol": "\u0192"
	},	
	"CZK": {
		"name"  : "Czech koruna",
		"symbol": "\u004b\u010d"
	},
	"DKK": {
		"name"  : "Danish krone",
		"symbol": "\u006b\u0072"
	},
	"DJF": {
		"name"  : "Djiboutian franc",
		"symbol": "\u0046\u0064\u006A"
	},
	"DOP": {
		"name"  : "Dominican peso",
		"symbol": "\u0052\u0044\u0024"
	},
	"USD":{
		"name"  : "United States Dollar",
		"symbol": "\u0024"
	},
	"EGP": {
		"name"  : "Egyptian pound",
		"symbol": "\u00a3"
	},
	"ERN": {
		"name"  : "Eritrean nakfa",
		"symbol": "\u004E\u0192\u0061"
	},
	"ETB": {
		"name"  : "Ethiopian birr",
		"symbol": "\u0042\u0072"
	},
	"FJD": {
		"name"  : "Fijian dollar",
		"symbol": "\u0024"
	},
	"GMD": {
		"name"  : "Gambian dalasi",
		"symbol": "\u0044"
	},
	"GEL":{
		"name"  : "Georgian lari",
		"symbol": "\u20be"
	},
	"GHS": {
		"name"  : "Ghanaian cedi",
		"symbol": "\u20b5"
	},
	"GTQ": {
		"name"  : "Guatemalan quetzal",
		"symbol": "\u0051"
	},
	"GNF": {
		"name"  : "Guinean franc",
		"symbol": "\u0046\u0047"
	},
	"GYD": {
		"name"  : "Guyanaese Dollar",
		"symbol": "\u0024"
	},
	"HTG": {
		"name"  : "Haitian gourde",
		"symbol":"\u0047"
	},
	"HNL": {
		"name"  : "Honduran lempira",
		"symbol": "\u004c"
	},
	"HKD": {
		"name"  : "Hong Kong Dollar",
		"symbol": "\u0024"
	},
	"HUF": {
		"name"  : "Hungarian forint",
		"symbol": "\u0046\u0074"
	},
	"ISK": {
		"name"  : "Icelandic krna",
		"symbol": "\u006b\u0072"
	},
	"INR": {
		"name"  : "Indian rupee",
		"symbol": "\u20b9"
	},
	"IDR": {
		"name"  : "Indonesian Rupiah",
		"symbol": "\u0052\u0070"
	},
	"IRR": {
		"name"  : "Iranian rial",
		"symbol": "\ufdfc"
	},
	"IQD": {
		"name"  : "Iraqi dinar",
		"symbol": "\u0639\u002e\u062f"
	},
	"ILS": {
		"name"  : "Israeli New Shekel",
		"symbol": "\u20aa"
	},
	"JMD": {
		"name"  : "Jamaican dollar",
		"symbol": "\u004a\u0024"
	},
	"JPY": {
		"name"  : "Japanese yen",
		"symbol": "\u00a5"
	},
	"JOD": {
		"name"  : "Jordanian dinar",
		"symbol": "\u004a\u004f\u0044"
	},
	"KZT": {
		"name"  : "Kazakhstani tenge",
		"symbol": "\u043b\u0432"
	},
	"KES": {
		"name"  : "Kenyan shilling",
		"symbol": "\u004B\u0053\u0068"
	},
	"KPW": {
		"name"  : "North Korean won",
		"symbol": "\u20a9"
	},
	"KRW": {
		"name"  : "South Korean Won",
		"symbol": "\u20a9"
	},
	"KWD":{
		"name"  : "Kuwaiti dinar",
		"symbol": "\u062f\u002e\u0643"
	},
	"KGS": {
		"name"  : "Kyrgyzstani som",
		"symbol": "\u043b\u0432"
	},
	"LAK": {
		"name"  : "Lao kip",
		"symbol": "\u20ad"
	},
	"LBP": {
		"name"  : "Lebanese pound",
		"symbol": "\u00a3"
	},
	"LSL": {
		"name"  : "Lesotho loti",
		"symbol": "\u004c"
	},
	"LRD": {
		"name"  : "Liberian dollar",
		"symbol": "\u0024"
	},
	"LYD": {
		"name"  : "Libyan dinar",
		"symbol": "\u062F\u002E\u0644"
	},
	"CHF": {
		"name"  : "Swiss franc",
		"symbol": "\u0046\u0072",
		"alternateSymbol": "\u0043\u0048\u0046"
	},
	"MOP": {
		"name"  : "Macanese pataca",
		"symbol": "\u0050"
	},
	"MKD": {
		"name"  : "Macedonian denar",
		"symbol": "\u0434\u0435\u043d"
	},
	"MGA": {
		"name"  : "Malagasy ariary",
		"symbol": "\u0041\u0072"
	},
	"MWK": {
		"name"  : "Malawian kwacha",
		"symbol": "\u004D\u004B"
	},
	"MYR": {
		"name"  : "Malaysian ringgit",
		"symbol": "\u0052\u004d"
	},
	"MVR": {
		"name"  : "Maldivian rufiyaa",
		"symbol": "\u0052\u0066"
	},
	"MRO": {
		"name"  : "Mauritanian ouguiya",
		"symbol": "\u0055\u004D"
	},
	"MUR": {
		"name"  : "Mauritian rupee",
		"symbol": "\u20a8"
	},
	"MXN": {
		"name"  : "Mexican peso",
		"symbol": "\u0024"
	},
	"MDL": {
		"name"  : "Moldovan leu",
		"symbol": "\u004c"
	},
	"MNT": {
		"name"  : "Mongolian tgrg",
		"symbol": "\u20ae"
	},
	"MAD": {
		"name"  : "Moroccan dirham",
		"symbol": "\u004D\u0041\u0044"
	},
	"MZN": {
		"name"  : "Mozambican metical",
		"symbol": "\u004d\u0054"
	},
	"NAD": {
		"name"  : "Namibian dollar",
		"symbol": "\u0024"
	},
	"NPR": {
		"name"  : "Nepalese rupee",
		"symbol": "\u20a8"
	},
	"NZD": {
		"name"  : "New Zealand dollar",
		"symbol": "\u0024"
	},
	"NIO": {
		"name"  : "Nicaraguan crdoba",
		"symbol": "\u0043\u0024"
	},
	"NGN": {
		"name"  : "Nigerian naira",
		"symbol": "\u20a6"
	},
	"NOK": {
		"name"  : "Norwegian krone",
		"symbol": "\u006b\u0072"
	},
	"OMR": {
		"name"  : "Omani rial",
		"symbol": "\ufdfc"
	},
	"PKR": {
		"name"  : "Pakistani Rupee",
		"symbol": "\u20a8"
	},
	"PAB": {
		"name"  : "Panamanian balboa",
		"symbol": "\u0042\u002f\u002e"
	},
	"PGK": {
		"name"  : "Papua New Guinean kina",
		"symbol": "\u004B"
	},
	"PYG": {
		"name"  : "Paraguayan guaran",
		"symbol": "\u0047\u0073"
	},
	"PEN": {
		"name"  : "Sol",
		"symbol": "\u0053\u002f\u002e"
	},
	"PHP": {
		"name"  : "Philippine peso",
		"symbol": "\u20b1"
	},
	"PLN": {
		"name"  : "Polish zoty",
		"symbol": "\u007a\u0142"
	},
	"QAR": {
		"name"  : "Qatari Rial",
		"symbol": "\ufdfc"
	},
	"RON": {
		"name"  : "Romanian leu",
		"symbol": "\u006c\u0065\u0069"
	},
	"RUB": {
		"name"  : "Russian ruble",
		"symbol": "\u20bd"
	},
	"RWF": {
		"name"  : "Rwandan franc",
		"symbol": "\u0052\u0046"
	},
	"WST": {
		"name"  : "Samoan tl",
		"symbol": "\u0054"
	},
	"STD": {
		"name"  : "So Tom and Prncipe dobra",
		"symbol": "\u0044\u0062"
	},
	"SVC": {
		"name" : "Salvadoran coln",
		"symbol": "\u20A1"
	},
	"SAR": {
		"name"  : "Saudi riyal",
		"symbol": "\ufdfc"
	},
	"SCR": {
		"name"  : "Seychellois rupee",
		"symbol": "\u20a8"
	},
	"SLL": {
		"name"  : "Sierra Leonean leone",
		"symbol": "\u004C\u0065"
	},
	"SGD": {
		"name"  : "Singapore dollar",
		"symbol": "\u0024"
	},
	"SBD": {
		"name"  : "Solomon Islands dollar",
		"symbol": "\u0024"
	},
	"SOS": {
		"name"  : "Somali shilling",
		"symbol": "\u0053"
	},
	"ZAR": {
		"name"  : "South African Rand",
		"symbol": "\u0052"
	},
	"SSP": {
		"name"  : "South Sudanese pound",
		"symbol": "\u0053\u0053\u0050",
		"alternateSymbol":"\u00a3"
	},
	"LKR": {
		"name"  : "Sri Lankan rupee",
		"symbol": "\u20a8"
	},
	"SDG": {
		"name"  : "Sudanese pound",
		"symbol": "\u00a3\u0053\u0064"
	},
	"SRD": {
		"name"  : "Surinamese dollar",
		"symbol": "\u0024"
	},
	"SZL": {
		"name"  : "Swazi lilangeni",
		"symbol": "\u004c"
	},
	"SEK": {
		"name"  : "Swedish krona",
		"symbol": "\u006b\u0072"
	},
	"SYP": {
		"name"  : "Syrian pound",
		"symbol": "\u00a3"
	},
	"TWD": {
		"name"  : "New Taiwan dollar",
		"symbol": "\u004e\u0054\u0024"
	},
	"TJS": {
		"name"  : "Tajikistani somoni",
		"code" : "TJS",
		"symbol": "\u0053\u004D"
	},
	"TZS": {
		"name"  : "Tanzanian shilling",
		"symbol": "\u0054\u0053\u0068"
	},
	"THB": {
		"name"  : "Thai baht",
		"symbol": "\u0e3f"
	},
	"TOP": {
		"name" : "Tongan paanga",
		"symbol": "\u0054\u0024"
	},
	"TTD": {
		"name"  : "Trinidad and Tobago dollar",
		"symbol": "\u0054\u0054\u0024"
	},
	"TND": {
		"name"  : "Tunisian dinar",
		"symbol": "\u062f\u002e\u062a"
	},
	"TRY": {
		"name"  : "Turkish lira",
		"symbol": "\u20BA"
	},
	"TMT": {
		"name"  : "Turkmenistani Manat",
		"symbol": "\u006D"
	},
	"TVD": {
		"name"  : "Tuvaluan dollar",
		"symbol": "\u0024"
	},
	"UGX": {
		"name"  : "Ugandan shilling",
		"symbol": "\u0055\u0053\u0068"
	},
	"UAH": {
		"name"  : "Ukrainian hryvnia",
		"symbol": "\u20b4"
	},
	"AED": {
		"name"  : "United Arab Emirates dirham",
		"symbol": "\u062f\u002e\u0625"
	},
	"GBP": {
		"name"  : "Pound sterling",
		"symbol": "\u00a3"
	},
	"UYU": {
		"name"  : "Uruguayan peso",
		"symbol": "\u0024\u0055"
	},
	"UZS": {
		"name"  : "Uzbekistani som",
		"symbol": "\u043b\u0432"
	},
	"VUV": {
		"name"  : "Vanuatu vatu",
		"symbol": "\u0056\u0054"
	},
	"VEF": {
		"name"  : "Venezuelan bolvar",
		"symbol": "\u0042\u0073"
	},
	"VND": {
		"name"  : "Vietnamese dong",
		"symbol": "\u20ab"
	},
	"YER": {
		"name"  : "Yemeni rial",
		"symbol": "\ufdfc"
	},
	"ZMW": {
		"name"  : "Zambian kwacha",
		"symbol": "\u005A\u004B"
	},
	"ZWD": {
		"name"  : "Zimbabwean Dollar",
		"symbol": "\u005A\u0024"
	}
}
;
/* $Id$ */
/* eslint-disable */
ZComponents.Position = (function(ZC) {
    var $ = ZC.DOMUtil,
        $window = ZC.$window;
    ZC.getScrollWidth = function() {
        if (!ZC.scrollBarWidth) {
            var scrollEle = document.createElement('div');
            scrollEle.setAttribute('style', 'width:100px;height:100px;overflow:scroll;'); // No I18N
            var body = document.querySelector('body'); // No I18N
            body.appendChild(scrollEle);
            ZC.scrollBarWidth = scrollEle.offsetWidth - scrollEle.scrollWidth;
            body.removeChild(scrollEle);
        }
        return ZC.scrollBarWidth;
    }
    function PositionCalc() {

    }
    PositionCalc.resetWinDim = function() {
        PositionCalc.winDim = undefined;
    }
    PositionCalc.setWinDim = function() {
        PositionCalc.winDim = {
            scrollLeft: $window.scrollLeft(),
            scrollTop: $window.scrollTop(),
            height: document.documentElement.clientHeight,
            width: document.documentElement.clientWidth,
            docWidth: document.documentElement.scrollWidth,
            docHeight: document.documentElement.scrollHeight
        }
    }
    PositionCalc.getWinDim = function() {
        if (!PositionCalc.winDim) {
            PositionCalc.setWinDim();
        }
        return PositionCalc.winDim;
    }
    PositionCalc.DEFAULTS = {
        direction: 'bottom-left', // No I18N
        resetPosition: true,
        showWithinTarget: false,
        within: $window,
        computeElementDim: true,
        computeTargetDim: true,
        computeWithinDim: true,
        arrow: {
            minSpace: 0,
            margin: {
                left: 0,
                top: 0
            },
            callback: undefined
        },
        callbacks: {
            beforeComputingDir: {
                dimensionModifier: $.noop,
                directionModifier: $.noop
            },
            beforeComputingPos: {
                dimensionModifier: $.noop,
                directionModifier: $.noop
            }
        },
        withinPadding: 8,
        customDimensions: false,
        positionAlterable: 'flipallfit' // 'flipside'|flipsidefit'|flipall'|flipfit'|'fit'|false //No I18N
        /* newly added flipside, flipsideallfit */
    };
    PositionCalc.calloutPositions = {
        'top-right': 'bottom-right', // No I18N
        'top-left': 'bottom-left', // No I18N
        'bottom-right': 'top-right', // No I18N
        'bottom-left': 'top-left', // No I18N
        top: 'bottom', // No I18N
        bottom: 'top', // No I18N
        left: 'right', // No I18N
        right: 'left', // No I18N
        'left-top': 'right-bottom', // No I18N
        'left-bottom': 'right-top', // No I18N
        'right-top': 'left-bottom', // No I18N
        'right-bottom': 'left-top' // No I18N
    }
    PositionCalc.regex = {
        relDirections: /^(top|top-right|top-left|bottom|bottom-right|bottom-left|left|left-top|left-bottom|right|right-top|right-bottom|top-left-corner|top-right-corner|bottom-left-corner|bottom-right-corner)$/,
        withinDirections: /^(top|bottom|left|right|top-left|top-right|bottom-left|bottom-right|center)$/,
        fit: /^(fit|flipfit|flipallfit|flipsidefit|flipsideallfit|true)$/,
        flip: /^(flip|flipfit|flipall|flipallfit|flipside|flipsidefit|flipsideall|flipsideallfit|true)$/,
        flipside: /^(flipside|flipsidefit|flipsideall|flipsideallfit|flipsideonlyfit|true)$/,
        flipall: /^(flipall|flipallfit|flipsideall|flipsideallfit|true)$/
    };
    PositionCalc.prototype = {
        _getCorrectionOffset: function(useVanillaJs) {
            if (!this.correctionOffset) {
                this.correctionOffset = {
                    left: 0,
                    top: 0
                };
                // Correction in mobile browsers. --> Issue : https://github.com/jquery/jquery/issues/3187
                if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                    var $body = $('body'); // No I18N
                    var temp = $('<span>').css({
                        position: 'absolute', // No I18N
                        height: '20px', // No I18N
                        width: '20px', // NO I18N
                        top: '0px', // No I18N
                        left: '0px' // No I18N
                    }).appendTo($body);
                    this.correctionOffset = this._calcOffset(temp, useVanillaJs);
                    this.correctionOffset.left = this.correctionOffset.left - parseFloat($body.css('margin-left')) - parseFloat($body.css('border-left-width')); // No I18N
                    this.correctionOffset.top = this.correctionOffset.top - parseFloat($body.css('margin-top')) - parseFloat($body.css('border-top-width')); // No I18N
                    temp.remove();
                }
            }
            return this.correctionOffset;
        },
        _getDimensions: function(element) {
            if (element.preventDefault) {
                return {
                    width: 0,
                    height: 0,
                    isEvent: true,
                    offset: {
                        left: element.pageX,
                        top: element.pageY
                    }
                }
            }
            element = $(element);
            if (element[0].nodeType === 9) {
                return {
                    width: element.width(),
                    height: element.height(),
                    offset: {
                        left: 0,
                        top: 0
                    }
                }
            }
            if (element[0] === window) {
                return {
                    width: element.width(),
                    height: element.height(),
                    offset: {
                        left: element.scrollLeft(),
                        top: element.scrollTop()
                    }
                }
            }
            var dimension = {
                width: this._getDimension(element[0], 'outerWidth'), // No I18N
                height: this._getDimension(element[0], 'outerHeight'), // No I18N
                offset: this._getOffset(element)
            }
            return dimension;
        },
        _getOffset: function(element) {
            var usePlainJS = ZC.Browser.isSafari && element[0] instanceof SVGElement;
            var offset = this._calcOffset(element, usePlainJS);
            var excessoffset = this._getCorrectionOffset(usePlainJS);
            offset.left -= excessoffset.left;
            offset.top -= excessoffset.top;
            return offset;
        },
        _calcOffset: function(element, useVanillaJs){
            if(useVanillaJs){
                var rect = element[0].getBoundingClientRect();
                return {
                    top: rect.top + window.pageYOffset,
                    left: rect.left + window.pageXOffset,
                };
            }else{
                return element.offset();
            }
        },
        /* Direction if alterable is fixed based on within element */
        _fixDirection: function(direction) {
            var dir = direction.split('-'); // No I18N
            /* To filp in case of insufficient space
                top-left =>  bottom-left
                bottom-left => top-left
                left-top => right-top
                right-top => left-top
             */
            var collisionWidth, collisionHeight, dirInfo, newDirInfo;
            if (/^(top|bottom)$/.test(dir[0]) || /^corner$/.test(dir[2])) {
                this.callout && this.callout.callback.call(this, this.callout.element, PositionCalc.calloutPositions[dir[0]]);
                collisionWidth = this.floatingElemDim.width + (this.callout ? this.callout.width ? this.callout.width : this.callout.element.outerWidth() : 0);
                collisionHeight = this.floatingElemDim.height + (this.callout ? this.callout.height ? this.callout.height : this.callout.element.outerHeight() : 0);
                dirInfo = this._flip.top.call(this, direction, collisionHeight);
                direction = dirInfo.direction;
                if (dirInfo.overTop > 0 && PositionCalc.regex.flipall.test(this.options.positionAlterable)) {
                    newDirInfo = this._flip.left.call(this, 'right', collisionWidth); // No I18N
                    /* check - if space in top/bottom is inefficient left/right space is checked, if available left/right position is taken, else top/bottom position is fixed */
                    if (newDirInfo.overLeft <= 0) {
                        direction = newDirInfo.direction;
                    }
                }
            }
            dir = direction.split('-'); // No I18N

            if (/^(left|right)$/.test(dir[0]) || /^corner$/.test(dir[2])) {
                this.callout && this.callout.callback.call(this, this.callout.element, PositionCalc.calloutPositions[dir[0]]);
                collisionWidth = this.floatingElemDim.width + (this.callout ? this.callout.width ? this.callout.width : this.callout.element.outerWidth() : 0);
                collisionHeight = this.floatingElemDim.height + (this.callout ? this.callout.height ? this.callout.height : this.callout.element.outerHeight() : 0);
                dirInfo = this._flip.left.call(this, direction, collisionWidth);
                direction = dirInfo.direction;
                if (dirInfo.overLeft > 0 && PositionCalc.regex.flipall.test(this.options.positionAlterable)) {
                    newDirInfo = this._flip.top.call(this, 'bottom', collisionHeight); // No I18N
                    /* check - if space in left or right is inefficient, element is displayed in top/bottom */
                    direction = newDirInfo.direction;
                }
            }
            return direction;
        },
        /* To filp in case of insufficient space
            top-left =>  top-right
            bottom-left => bottom-right
            left-top => left-bottom
            right-top => right-bottom
        */
        _fixAlternateDirection: function(direction) {
            var dir = direction.split('-'), // No I18N
                calloutWidthLeft = 0,
                calloutHeightLeft = 0,
                dirInfo,
                secondDir;
            if (this.targetDim.isEvent && this.callout) {
            /* If target is an event, this.callout must point the mouse pointer, so collisionWidth is reduced */
                calloutWidthLeft = 2 * this.callout.width + this.callout.width / 2;
                calloutHeightLeft = 2 * this.callout.height + this.callout.height / 2;
            }
            if (/^(left|right)$/.test(dir[1])) {
            // var dirInfo = flip.left(dir[1], floatingElemDim.width - this.targetDim.width - calloutHeightLeft);
            // Since top-left && top-right, bottom-left && bottom-right positions are inverted.
                secondDir = dir[1] === 'left' ? 'right' : 'left'; // No I18N
                dirInfo = this._flip.left.call(this, secondDir, this.floatingElemDim.width - (dir[0] === 'corner' ? 0 : this.targetDim.width) - calloutHeightLeft);
                direction = direction.replace(dir[1], dirInfo.direction === 'left' ? 'right' : 'left'); // No I18N
            } else if (/^(top|bottom)$/.test(dir[1])) {
                dirInfo = this._flip.top.call(this, dir[1], this.floatingElemDim.height - this.targetDim.height - calloutWidthLeft);
                direction = direction.replace(dir[1], dirInfo.direction);
            }
            return direction;
        },
        /* To initiate callout element */
        _initCallout: function(elementDir) {
            if (this.options.arrow && this.options.arrow.element) {
                var callout = {};
                var element = this.options.arrow.element;
                if (typeof element === 'string' || element instanceof $ || element.nodeType) { // No I18N
                    element = $(element);
                    if (element.length) {
                        callout.element = element;
                    }
                }
                if (callout.element && callout.element.css('position') !== 'static') { // No I18N
                    callout.centeredToTarget = !!(/^(center|undefined)$/.test(this.options.arrow.direction) && !this.targetDim.isEvent);
                    callout.callback = typeof this.options.arrow.callback === 'function' ? this.options.arrow.callback : typeof this.options.arrowCallback === 'function' ? this.options.arrowCallback : $.noop; // No I18N
                    callout.direction = PositionCalc.calloutPositions[elementDir];
                    callout.callback.call(this, callout.element, callout.direction.split('-')[0]); // No I18N
                    callout.height = typeof this.options.arrow.height === 'number' ? this.options.arrow.height : 0; // No I18N
                    callout.width = typeof this.options.arrow.height === 'number' ? this.options.arrow.width : 0; // No I18N
                    callout.minSpace = this.options.arrow.minSpace;
                    callout.margin = this.options.arrow.margin || {
                        left: 0,
                        top: 0
                    };
                    return callout;
                }
                this.options.arrow = undefined;
            }
        },
        _getElementHeight: function() {
            var direction = this.options.direction;
            if (this.floatingElemDim.height > this._getAvailableHeight(direction)) {
                return this._getAvailableHeight(direction);
            }
            return this.floatingElemDim.height;
        },
        _getElementWidth: function() {
            var direction = this.options.direction;
            if (this.floatingElemDim.width > this._getAvailableWidth(direction)) {
                return this._getAvailableWidth(direction);
            }
            return this.floatingElemDim.width;
        },
        _fitCalloutPosition: function(callout, calloutPosition) {
            var dir = callout.direction.split('-'); // No I18N
            var maxValue,
                tempDir = dir[1],
                minValue = 0;
            var elemWidth1 = this._getElementWidth();
            var elemHeight1 = this._getElementHeight();
            if (/^(left|right)$/.test(dir[1])) {
                maxValue = elemWidth1 - callout.width;
            } else if (/^(top|bottom)$/.test(dir[1])) {
                maxValue = elemHeight1 - callout.height;
            } else if (/^(top|bottom)$/.test(dir[0])) {
                maxValue = elemWidth1 - callout.width;
                tempDir = 'left'; // No I18N
            } else if (/^(left|right)$/.test(dir[0])) {
                maxValue = elemHeight1 - callout.height;
                tempDir = 'top'; // No I18N
            }
            if (calloutPosition[tempDir] > maxValue) {
                calloutPosition[tempDir] = maxValue;
            }
            if (calloutPosition[tempDir] < minValue) {
                calloutPosition[tempDir] = minValue;
            }
        },
        /* Function to get the callout position `for a given direction */
        _getCalloutPosition: function(callout, correctionPixel) {
            var pos = {};
            var dir = callout.direction.split('-'); // No I18N
            var cPix;
            if (/^(top|bottom)$/.test(dir[0])) {
                pos[dir[0]] = -callout.height;
                if (!dir[1]) {
                    pos.left = this.floatingElemDim.width / 2 - callout.width / 2 - correctionPixel.left;
                }
            } else if (/^(left|right)$/.test(dir[0])) {
                pos[dir[0]] = -callout.width;
                if (!dir[1]) {
                    pos.top = this.floatingElemDim.height / 2 - callout.height / 2 - correctionPixel.top;
                }
            }
            if (/^(left|right)$/.test(dir[1])) {
                cPix = correctionPixel.left;
                if (dir[1] === 'left') { // No I18N
                    cPix = -cPix;
                    pos.right = 'auto'; // No I18N
                } else {
                    pos.left = 'auto'; // No I18N
                }
                if (this.targetDim.width && this.floatingElemDim.width > this.targetDim.width) {
                    pos[dir[1]] = this.targetDim.width / 2 - callout.width / 2 + cPix;
                } else {
                    pos.left = this.floatingElemDim.width / 2 - callout.width / 2;
                }
            } else if (/^(top|bottom)$/.test(dir[1])) {
                cPix = correctionPixel.top;
                if (dir[1] === 'top') { // No I18N
                    cPix = -cPix;
                    pos.bottom = 'auto'; // No I18N
                } else {
                    pos.top = 'auto'; // No I18N
                }
                if (this.targetDim.height && this.floatingElemDim.height > this.targetDim.height) {
                    pos[dir[1]] = this.targetDim.height / 2 - callout.height / 2 + cPix;
                } else {
                    pos.top = this.floatingElemDim.height / 2 - callout.height / 2;
                }
            }
            var doesHaveBoxShadow = this.floatingElement.css('box-shadow') !== 'none'; // No I18N
            /* This correction is done because the pointer always sits on the element rather than attached to the element */
            if (dir[0] === 'top') { // No I18N
                pos.top = pos.top + (parseFloat(this.floatingElement.css('border-top-width')) || doesHaveBoxShadow ? 1 : 0); // No I18N
            } else if (dir[0] === 'bottom') { // No I18N
                pos.bottom = pos.bottom + (parseFloat(this.floatingElement.css('border-bottom-width')) || doesHaveBoxShadow ? 1 : 0); // No I18N
            } else if (dir[0] === 'right') { // No I18N
                pos.right = pos.right + (parseFloat(this.floatingElement.css('border-right-width')) || doesHaveBoxShadow ? 1 : 0); // No I18N
            } else if (dir[0] === 'left') { // No I18N
                pos.left = pos.left + (parseFloat(this.floatingElement.css('border-left-width')) || doesHaveBoxShadow ? 1 : 0); // No I18N
            }
            if (/^(bottom|top)/.test(callout.direction)) {
                pos.top = pos.bottom = ''; // No I18N
            } else {
                pos.left = pos.right = ''; // No I18N
            }
            return pos;
        },
        _flip: {
            /* Filp north south position incase of insufficient height in the given direction */
            top: function(direction, collisionHeight) {
                var dir = direction.split('-')[0],
                    response = {
                        direction: direction
                    },
                    availHeight = this._getAvailableHeight(direction);
                response.overTop = collisionHeight - availHeight;
                if (response.overTop > 0) {
                    var newdir = dir === 'top' ? 'bottom' : 'top'; // No I18N
                    var newAvailableHeight = this._getAvailableHeight(direction.replace(dir, newdir));
                    if (newAvailableHeight > availHeight) {
                        response.direction = direction.replace(dir, newdir);
                        response.overTop = collisionHeight - newAvailableHeight;
                    }
                }
                return response;
            },
            /* Flip the left right position incase of insufficient width in the given direction */
            left: function(direction, collisionWidth) {
                var dir = direction.split('-'),
                    response = {
                        direction: direction
                    },
                    finalDir, newdir;
                var availWidth = this._getAvailableWidth(direction);
                response.overLeft = collisionWidth - availWidth;
                if (response.overLeft > 0) {
                    finalDir = dir[0];
                    if (dir[2] === 'corner') {
                        finalDir = dir[1];
                    }
                    newdir = finalDir === 'left' ? 'right' : 'left'; // No I18N
                    var newAvailableWidth = this._getAvailableWidth(direction.replace(finalDir, newdir));
                    if (newAvailableWidth > availWidth) {
                        response.direction = direction.replace(finalDir, newdir);
                        response.overLeft = collisionWidth - newAvailableWidth;
                    }
                }
                return response;
            }
        },
        /* Fit the element position based on the viewport */
        _fitPosition: function(position, direction) {
            var newPosition = $.extend({}, position),
                // collisionWidth = floatingElemDim.width + callout ? callout.width : 0,
                // collisionHeight = floatingElemDim.height + callout ? callout.height : 0,
                dir = direction.split('-'); // No I18N
            dir[1] = dir[1] === undefined ? /^(top|bottom)$/.test(dir[0]) ? 'left' : 'top' : dir[1]; // No I18N
            // var offset = within.isWindow ? {
            //     left: win.scrollLeft,
            //     top: win.scrollTop
            // } : within.offset;
            if (/^(top|bottom)$/.test(dir[1]) || this.targetDim.isEvent) {
                var overTop = this.within.scrollTop - newPosition.top;
                if (overTop > 0) {
                    newPosition.top += overTop;
                }
                var overBottom = newPosition.top + this.floatingElemDim.height - (this.within.scrollTop + this._getAvailableHeight().complete);
                if (overBottom > 0) {
                    newPosition.top -= overBottom;
                }
            }
            if (/^(left|right)$/.test(dir[1]) || this.targetDim.isEvent) {
                var overLeft = this.within.scrollLeft - newPosition.left;
                if (overLeft > 0) {
                    newPosition.left += overLeft;
                }
                var overRight = newPosition.left + this.floatingElemDim.width - (this.within.scrollLeft + this._getAvailableWidth().complete) + 1;
                if (overRight > 0) {
                    newPosition.left -= overRight;
                }
            }
            return newPosition;
        },
        _calculatePosition: function(newDirection) {
            var newPosition, position, recalculated;
            if (newDirection) {
                recalculated = true;
                this.options.direction = newDirection;
            }
            this.options.callbacks.beforeComputingDir.dimensionModifier(this.targetDim, this.floatingElemDim, this.within, this.options);
            if (!/corner/.test(this.options.direction)) {
                this.callout = this._initCallout(this.options.direction);
            }
            if (PositionCalc.regex.flip.test(this.options.positionAlterable) && !recalculated) {
                this.options.direction = this._fixDirection(this.options.direction);
            }
            /* Setting Callout properties */
            if (this.callout) {
                this.callout.direction = PositionCalc.calloutPositions[this.options.direction];
                this.callout.callback.call(this, this.callout.element, this.callout.direction.split('-')[0]); // No I18N
                if (!this.callout.height) {
                    this.callout.height = this.callout.element.outerHeight();
                }
                if (!this.callout.width) {
                    this.callout.width = this.callout.element.outerWidth();
                }
            }
            if (PositionCalc.regex.flipside.test(this.options.positionAlterable)) {
                this.options.direction = this._fixAlternateDirection(this.options.direction);
            }

            this.options.callbacks.beforeComputingPos.dimensionModifier(this.targetDim, this.floatingElemDim, this.within, this.options);

            position = this._fixPosition(this.options.direction);
            newPosition = $.extend({}, position);
            if (PositionCalc.regex.fit.test(this.options.positionAlterable)) {
                newPosition = this._fitPosition(position, this.options.direction);
            }
            if (newPosition.top < this.within.scrollTop) {
                newPosition.top = this.within.scrollTop;
            }
            if (newPosition.left < this.within.scrollLeft) {
                newPosition.left = this.within.scrollLeft;
            }
            if (this.callout && PositionCalc.regex.flipall.test(this.options.positionAlterable) && !recalculated && !this.targetDim.isEvent) {
                /* Calculate whether calloutminspace is available */
                // CALLOUTMINSPACE
                if (this.callout.minSpace !== undefined) {
                    var dir = this.options.direction.split('-'); // No I18N
                    var minElemLeft, minElemTop, maxEleLeft, maxEleTop;
                    var elemWidth1 = this._getElementWidth();
                    var elemHeight1 = this._getElementHeight();
                    var newdir;
                    minElemLeft = this.targetDim.offset.left - elemWidth1 + this.callout.width;
                    minElemTop = this.targetDim.offset.top - elemHeight1 + this.callout.height;
                    maxEleLeft = this.targetDim.offset.left + this.targetDim.width - this.callout.width;
                    maxEleTop = this.targetDim.offset.top + this.targetDim.height - this.callout.height;
                    if (/^(top|bottom)$/.test(dir[0])) {
                        if (newPosition.left < minElemLeft) {
                            newdir = 'left'; // No I18N
                        }
                        if (newPosition.left > maxEleLeft) {
                            newdir = 'right'; // No I18N
                        }
                    } else if (/^(left|right)$/.test(dir[0])) {
                        if (newPosition.top < minElemTop) {
                            newdir = 'top'; // No I18N
                        }
                        if (newPosition.top > maxEleTop) {
                            newdir = 'bottom'; // No I18N
                        }
                    }
                    if (newdir) {
                        return this._calculatePosition(newdir);
                    }
                }
            }
            var correctedPosition = {
                left: newPosition.left - this.finalCorrectionOffset.left,
                top: newPosition.top - this.finalCorrectionOffset.top
            }
            if (this.callout) {
                this.callout.direction = PositionCalc.calloutPositions[this.options.direction];
                var correctionPixel = {
                    left: newPosition.left - position.left,
                    top: newPosition.top - position.top
                }
                this.callout.position = this._getCalloutPosition(this.callout, correctionPixel);
                this._fitCalloutPosition(this.callout, this.callout.position);
            }
            return correctedPosition;
        },
        /* Function to get the available height in the given direction */
        _getAvailableHeight: function(direction) {
            if (!this.availableHeight) {
                if (this.within.isWindow || this.within.isDocument) {
                    this.availableHeight = {
                        top: this.targetDim.offset.top - this.within.scrollTop,
                        bottom: this.within.height - (this.targetDim.offset.top + this.targetDim.height - this.within.scrollTop),
                        complete: this.within.height
                    }
                } else {
                    this.availableHeight = {};
                    if (this.within.offset.top < this.win.scrollTop) {
                        this.availableHeight.top = this.targetDim.offset.top - this.win.scrollTop;
                    } else {
                        this.availableHeight.top = this.targetDim.offset.top - this.within.scrollTop;
                    }
                    this.availableHeight.bottom = this.within.offset.top + this.within.height - (this.targetDim.offset.top + this.targetDim.height);
                    var diffHeight = this.win.height + this.win.scrollTop - (this.within.offset.top + this.within.height);
                    if (diffHeight < 0) {
                        this.availableHeight.bottom += diffHeight;
                    }
                    this.availableHeight.complete = this.availableHeight.top + this.availableHeight.bottom + this.targetDim.height;
                }
            }
            if (!direction) {
                return this.availableHeight;
            }
            direction = direction.split('-')[0]; // No I18N
            if (direction === 'top') { // No I18N
                return this.availableHeight.top;
            } else if (direction === 'bottom') { // No I18N
                return this.availableHeight.bottom;
            }
            return this.availableHeight.complete;

        },
        /* Function to get the available width in the given direction */
        _getAvailableWidth: function(direction) {
            if (!this.availableWidth) {
                if (this.within.isWindow || this.within.isDocument) {
                    this.availableWidth = {
                        left: this.targetDim.offset.left - this.within.scrollLeft,
                        right: this.within.width - (this.targetDim.offset.left + this.targetDim.width - this.within.scrollLeft),
                        complete: this.within.width
                    }
                } else {
                    this.availableWidth = {};
                    if (this.within.offset.left < this.win.scrollLeft) {
                        this.availableWidth.left = this.targetDim.offset.left - this.win.scrollLeft;
                    } else {
                        this.availableWidth.left = this.targetDim.offset.left - this.within.scrollLeft;
                    }
                    this.availableWidth.right = this.within.offset.left + this.within.width - (this.targetDim.offset.left + this.targetDim.width);
                    var diffWidth = this.win.width + this.win.scrollLeft - (this.within.offset.left + this.within.width);
                    if (diffWidth < 0) {
                        this.availableWidth.right += diffWidth;
                    }
                    this.availableWidth.complete = this.availableWidth.left + this.availableWidth.right + this.targetDim.width;
                }
            }
            if (!direction) {
                return this.availableWidth;
            }
            var dir = direction.split('-'), // No I18N
                finaldir = dir[2] === 'corner' ? dir[1] : dir[0];
            if (finaldir === 'left') { // No I18N
                return this.availableWidth.left;
            } else if (finaldir === 'right') { // No I18N
                return this.availableWidth.right;
            }
            return this.availableWidth.complete;
        },
        /* Function to get element position for the given direction */
        _fixPosition: function(direction) {
            var dir = direction.split('-'); // No I18N
            var basePosition = $.extend({}, this.targetDim.offset);
            if (dir[0] === 'top') { // No I18N
                basePosition.top -= this.floatingElemDim.height + (this.callout ? this.callout.height : 0);
            } else if (dir[0] === 'bottom') { // No I18N
                basePosition.top += this.targetDim.height + (this.callout ? this.callout.height : 0);
            } else if (dir[0] === 'left') { // No I18N
                basePosition.left -= this.floatingElemDim.width + (this.callout ? this.callout.width : 0);
            } else if (dir[0] === 'right') { // No I18N
                basePosition.left += this.targetDim.width + (this.callout ? this.callout.width : 0);
            }
            if (dir[1] === undefined) {
                if (dir[0].match(/^left|right$/)) {
                    basePosition.top = basePosition.top - this.floatingElemDim.height / 2 + this.targetDim.height / 2;
                } else {
                    basePosition.left = basePosition.left - this.floatingElemDim.width / 2 + this.targetDim.width / 2;
                }
            } else if (dir[1] === 'top') { // No I18N
                basePosition.top = basePosition.top + this.targetDim.height - this.floatingElemDim.height;
            } else if (dir[1] === 'right') { // No I18N
                basePosition.left = basePosition.left - this.floatingElemDim.width + (dir[2] === 'corner' ? 0 : this.targetDim.width); // No I18N
            } else if (dir[1] === 'left' && dir[2] === 'corner') { // No I18N
                basePosition.left = basePosition.left + this.targetDim.width;
            }
            return basePosition;
        },
        _showHiddenParent: function(element) {
            element = $(element);
            if (element.is(':hidden')) { // No I18N
                var i = 1;
                var parent = element;
                while (i && parent && !parent.is('body')) { // No I18N
                    if (parent.css('display') === 'none') { // No I18N
                        this.hiddenParents.push(parent);
                        this.prevStylesOfHiddenParents.push(parent.attr('style') || ''); // No I18N
                        parent.css({
                            display: 'block', // No I18N
                            position: 'absolute', // No I18N
                            opacity: 1,
                            visibility: 'hidden' // No I18N
                        });
                        i = parent.is(':hidden'); // No I18N
                    }
                    parent = parent.parent();
                }
            }
        },
        _resetParent: function() {
            if (this.hiddenParents && this.hiddenParents.length) {
                this.hiddenParents.forEach(function(parent, i) {
                    parent.attr('style', this.prevStylesOfHiddenParents[i]); // No I18N
                });
                this.hiddenParents = [];
                this.prevStylesOfHiddenParents = [];
            }
        },
        /* Function to get the corrected element position based on the element positioning and relative parent positioning */
        _getCorrection: function(element) {
            // var offsetNew = $.extend({}, calculatedOffset);
            var position = element.css('position'); // No I18N
            var parent = element.parent()[0];
            // Dummy element is used to find the correction pixel. Actual element is not used as the offset(), position(), offsetTop, offsetLeft are not relevant when the actual element is being transformed or when there is margin for the element.
            var temp = $('<span>').css({
                position: position,
                height: '20px', // No I18N
                width: '20px', // NO I18N
                top: '0px', // No I18N
                left: '0px', // No I18N
                transform: 'none', // No I18N
                margin: '0px', // No I18N
                display: '', // No I18N
                visibility: 'hidden' // No I18N
            });
            parent.appendChild(temp[0]);
            var curOffset = temp.offset();
            parent.removeChild(temp[0]);
            // offsetNew.top = offsetNew.top - curOffset.top;
            // offsetNew.left = offsetNew.left - curOffset.left;
            return curOffset;
        },
        _appendScrollBar: function() {
            // doubt:
            var scrollEle = document.createElement('div');
            scrollEle.setAttribute('style', 'width:100px;height:100px;overflow:scroll;'); // No I18N
            var styleProps = 'width:100px;height:100px;overflow:scroll;'; // No I18N
            var body = document.querySelector('body'); // No I18N
            body.appendChild(scrollEle); // No I18N
            scrollEle.style.cssText = styleProps;
            return scrollEle;
        },
        _getWithinDimensions: function(element) {
            element = element.length ? element : $window;
            var isWindow = element[0] === window;
            var isDocument = !!element[0] && element[0].nodeType === 9;
            var offset = isWindow || isDocument ? {
                left: 0,
                top: 0
            } : this._getOffset(element) || {
                left: 0,
                top: 0
            };
            var scrollLeft = isWindow || isDocument ? this.win.scrollLeft : offset.left < this.win.scrollLeft ? this.win.scrollLeft : offset.left;
            var scrollTop = isWindow || isDocument ? this.win.scrollTop : offset.top < this.win.scrollTop ? this.win.scrollTop : offset.top;
            /* For window, documentElements.clienWidth is used instead of window.innerWidth ==> because
               When mouse is scrollBar is shown permanently, window.innerWidth gives (width + scrollbarwidth)
               documentElement.clientWidth gives width excluding scrollbar width.
            */
            var width, height, scrollEle;
            if (isWindow) {
                width = this.win.width;
                height = this.win.height;
                /* width = window.innerWidth;
                height = window.innerHeight; */
                // scrollEle = $('body'); //No I18N
            } else if (isDocument) {
                width = this.win.docWidth;
                height = this.win.docHeight;
            } else {
                width = element.outerWidth();
                height = element.outerHeight();
                scrollEle = element;
            }
            if (scrollEle) {
                var overflowX = scrollEle.css('overflow-x'); // No I18N
                var overflowY = scrollEle.css('overflow-y'); // No I18N
                var hasOverflowX = overflowX === 'scroll' || (overflowX === 'auto' || scrollEle.is('body') && overflowX === 'visible') && width < scrollEle[0].scrollWidth; // No I18N
                var hasOverflowY = overflowY === 'scroll' || (overflowY === 'auto' || scrollEle.is('body') && overflowY === 'visible') && height < scrollEle[0].scrollHeight; // No I18N
                var scrollWidth;
                if (hasOverflowY) {
                    width -= scrollWidth = ZC.getScrollWidth();
                }
                if (hasOverflowX) {
                    height -= scrollWidth === undefined ? ZC.getScrollWidth() : scrollWidth;
                }
            }
            /*
                For window|document, to find with and height, javascript functions are used, becos jquery produces buggy results in some cases
            */
            return {
                element: element,
                isWindow: isWindow,
                isDocument: isDocument,
                offset: offset,
                scrollLeft: scrollLeft,
                scrollTop: scrollTop,
                width: width,
                height: height
            }

        },
        _getDimension: function(element, dimension) {
            var value;
            // When an element is on transformation,  Boundingrect gives the transformed width and height. So inorder to get actual width and ht inspite of transformation we use jquery which uses offsetWidth, offsetHeight to calculate height and width of the element.This gives the original size of the element.
            var transform = window.getComputedStyle(element).transform;
            // var methodName = "getBoundingClientRect"; //No I18N
            var isSVG;
            if (element instanceof SVGElement) {
                isSVG = true;
                // methodName = "getBBox"; //No I18N
            }
            if (/* element[methodName] &&  */ isSVG || !transform || transform === 'none') { // No I18N
                var styles = element.getBoundingClientRect();
                if (styles) {
                    switch (dimension) {
                        case 'outerWidth': // No I18N
                            value = styles.width;
                            break;
                        case 'outerHeight': // No I18N
                            value = styles.height;
                            break;
                    }
                }
            }
            if (isNaN(value) || !value) {
                value = $(element)[dimension]();
            }
            return value;
        },
        _getPosition: function(targetElement, elementPositioned, options) {
            options = this.options = $.extend(true, {}, PositionCalc.DEFAULTS, options); // make a copy of options
            var prevDirection = options.direction;
            if (!PositionCalc.regex.relDirections.test(options.direction)) {
                options.direction = 'bottom-left'; // No I18N
            }
            var originalDirection = options.direction;
            options.direction = ZC.getRTLBasedDir(options.direction, options.rtl);
            var response = {
                prevDirection: prevDirection,
                elementPosition: {
                    left: 0,
                    right: 0
                },
                actualDirection: options.direction,
                direction: originalDirection,
                arrowPosition: {
                    left: 0,
                    right: 0
                }
            }
            if (!this._isInDOM(elementPositioned)) {
                return response;
            }
            if (!options.customDimensions && !targetElement.preventDefault && !this._isInDOM(targetElement)) {
                return response;
            }
            this.floatingElement = $(elementPositioned);
            if (options.considerHiddenElements) {
                this.hiddenparents = [];
                this.prevStylesOfHiddenParents = [];
                if (!targetElement.preventDefault) {
                    this._showHiddenParent($(targetElement));
                }
                this._showHiddenParent(this.floatingElement);
            }
            // To retain its previous position
            var previousStyle = this.floatingElement.attr('style'); // No I18N
            // This is included becos the this.floatingElement that are at the edge of the window results in incorrect dimension calculation
            options.resetPosition && this.floatingElement.css({
                top: '-99999px', // No I18N
                left: '-99999px', // No I18N
                overflow: 'hidden' // No I18N
            });
            /* Element Dimensions */
            this.floatingElemDim = options.computeElementDim ? this._getDimensions(this.floatingElement) : {};
            // doubt:
            // this.floatingElement[0].style.overflow = 'hidden'; // No I18N

            // If the floating floatingElement size exceeds the document size, it results in incorrect within dimension calculation hence the floating floatingElement is hidden and then the within dimension is calculated.
            // if (floatingElemDim.height > document.documentElement.clientHeight && regex.flip.test(options.positionAlterable)) {
            //     previousStyle.display = floatingElement[0].style.display;
            //     floatingElement[0].style.display = 'none'; //No I18N
            // } else {
            //     previousStyle.overflow = floatingElement[0].style.overflow;
            //     floatingElement[0].style.overflow = 'hidden'; //No I18N
            // }
            var windowDim = PositionCalc.getWinDim();
            this.win = {
                scrollLeft: windowDim.scrollLeft + options.withinPadding,
                scrollTop: windowDim.scrollTop + options.withinPadding,
                height: windowDim.height - options.withinPadding * 2,
                width: windowDim.width - options.withinPadding * 2
            };
            // Target Dimension
            this.targetDim = options.customDimensions ? targetElement : options.computeTargetDim ? this._getDimensions(targetElement) : {};
            // Within Dimension
            this.within = options.computeWithinDim ? this._getWithinDimensions($(options.within)) : {};
            this.finalCorrectionOffset = this._getCorrection(this.floatingElement);
            // Revert the this.floatingElement to the original style
            options.resetPosition && this.floatingElement.attr('style', previousStyle); // No I18N
            var position = this._calculatePosition();
            if (options.considerHiddenElements) {
                this._resetParent();
            }
            response.elementPosition = position || response.elementPosition;
            response.arrowPosition = this.callout ? this.callout.position : response.arrowPosition;
            response.arrowDirection = PositionCalc.calloutPositions[options.direction] && PositionCalc.calloutPositions[options.direction].split('-')[0] // No I18N
            response.actualDirection = options.direction;
            response.direction = ZC.getRTLBasedDir(options.direction, options.rtl);

            var dir = options.direction.split('-'); // No I18N
            if (/^(top|bottom)$/.test(dir[0])) {
                response.availableHeight = this._getAvailableHeight(dir[0]) - (this.callout ? this.callout.height : 0);
                response.availableWidth = this._getAvailableWidth(dir[0]);
            } else if (/^(left|right)$/.test(dir[0])) {
                response.availableHeight = this._getAvailableHeight(dir[0]);
                response.availableWidth = this._getAvailableWidth(dir[0]) - (this.callout ? this.callout.width : 0);
            }
            return response;
        },
        _isInDOM: function(element) {
            return element && element.nodeType === 1 && document.body.contains(element);
        }
    }
    ZC.debounce = function(func, wait, immediate) {
        var timeout;
        return function() {
            var context = this,
                args = arguments;
            var later = function() {
                timeout = null;
                if (!immediate) {func.apply(context, args);}
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) {func.apply(context, args);}
        };
    }
    var resetWinDimFn = ZC.debounce(PositionCalc.resetWinDim, 250);
    window.addEventListener('resize', resetWinDimFn); // No I18N
    window.addEventListener('scroll', resetWinDimFn); // No I18N
    return {
        get: function(targetElement, elementPositioned, options) {
            if (targetElement && $(elementPositioned).length) {
                if (targetElement instanceof $) {
                    targetElement = targetElement[0];
                }
                if (elementPositioned instanceof $) {
                    elementPositioned = elementPositioned[0];
                }
                options = options || {};
                var instance = new PositionCalc();
                var positionObject = instance._getPosition(targetElement, elementPositioned, options);
                instance.options = undefined;
                return positionObject;
            }
        }
    }
}(ZComponents));

/* $Id$ */
/*
    Alternative Names
        mustBeShown / forceShow
        withinPadding / viewportPadding
*/
(function(ZC) {
    let $ = ZC.DOMUtil;
    ZC.Helpers = {
        open: function(ele, opts) {
            return ZC.ShowHideHandler.show(ele, opts);
        },
        close: function(ele, opts = ele.data('zshowhide') || {}) {
            return ZC.ShowHideHandler.hide(ele, opts) // No I18N
        },
        fixHeight: function(ele, opts) {
            return ZC.ShowHideHandler.fixHeight(ele, $.extend(true, {}, ele.data('zshowhide'), opts || {})); // No I18N
        },
        fixGridWidth: function(ele, opts) {
            return ZC.ShowHideHandler.fixGridWidth(ele, $.extend(true, {}, ele.data('zshowhide'), opts || {})); // No I18N
        },
        removeScrollClass: function(ele) {
            return ZC.ShowHideHandler.removeScrollCls(ele); // No I18N
        }
    }
    ZC.ShowHideHandler = (function(ZC, $) {
        'use strict'; // No I18N
        return {
        /* Callbacks: onShow, onShowWithAnimation, beforeFocus, onHide, onHideWithAnimation, displayScrollers */
            _DEFAULTS: {
                forElement: undefined,
                appendTo: undefined,
                width: undefined,
                height: undefined,
                withinPadding: 8, // 8px gap should be maintained between the dropdown list element and the window similar to OS right click menu's.
                isGrid: false,
                renderInPlace: false,
                position: null,
                direction: 'auto', // No I18N
                offset: null,
                mustBeShown: false,
                viewport: null,
                minWidth: 200,
                displayType: 'box', // No I18N
                arrowCallback: undefined,
                alterBorderRadius: true, // No I18N
                scroll: 'default', // No I18N
                toggle: true,
                isSubList: false,
                arrowElement: undefined,
                closeOnBodyClick: true,
                cname: '', // No I18N
                hideMethodName: 'hide', // No I18N
                hideEventName: 'hide', // No I18N
                bodyCls: 'zmenu__body', // No I18N
                headerCls: 'zmenu__header', // No I18N
                footerCls: 'zmenu__footer', // No I18N
                gridCls: 'zmenu--thumbnail', // No I18N
                mainCls: 'zmenu', // No I18N
                widthCls: 'zmenu__width' // No I18N
            },
            show: function(ele, options) {
                ele = $(ele);
                let opts = $.extend(true, {}, this._DEFAULTS, options),
                    isVisible = ele.is(':visible'), // No I18N
                    prevForEle = ele.data('forElement') || '', // No I18N
                    forEle = $(opts.forElement),
                    isSubList = opts.isSubList,
                    isSameForEle = forEle && forEle[0] === prevForEle[0],
                    force = opts.mustBeShown,
                    retainFocus = isVisible && force,
                    inPlace = opts.renderInPlace,
                    appendedTo = $(opts.appendTo),
                    showCallback = opts.onShow;
                // Hide the element if its for same 'forElement'
                if (isSameForEle && isVisible && !force) {
                    if (opts.toggle && !isSubList) { // toggling the dropdown list whenever toggle option is set to true.
                        opts.onToggle && opts.onToggle(ele);
                    }
                    return;
                }
                if (force) {
                    this._fetchScrollVal(ele);
                }
                // appending the element
                if ((!inPlace || isSubList) && !force) {
                    let parentEle = (appendedTo && appendedTo.length ? appendedTo : $('body'))[0], // No I18N
                        actualEle = ele[0];
                    if (!parentEle.contains(actualEle) || Array.prototype.slice.call(parentEle.childNodes).indexOf(actualEle) === -1) {
                        parentEle.appendChild(actualEle);
                    }
                }
                let vp = opts.viewport || (appendedTo.length ? appendedTo : undefined);
                if (vp) {
                    vp = vp === 'window' ? ZC.$window : vp === 'document' ? ZC.$document : $(vp); // No I18N
                    opts.within = vp;
                }
                let res = {};
                if (inPlace) {
                    ele.addClass('zmenu--inline'); // No I18N
                    ZC.display(undefined, ele); // showing the renderInPlace element
                    showCallback && showCallback(ele, opts);
                } else {
                    res = this._calcDimensions(ele, opts, forEle, retainFocus, isSubList);
                    if (!res) {
                        return;
                    }
                }
                // setting data before triggering show method since in select boxes, direction datas are used.
                if (isSubList) {
                    res.parent = forEle;
                }
                res.direction = res.pos && res.pos.direction;
                ele.data(res);
                !opts.isSubList && this._setFocus(ele, opts); // setFocus is called after setting list's position to retrieve its value (this._offset) in the triggerEvent that is called inside _setFocus method
                // check for animation option existence
                if (ZC.isEmpty(opts.animation) || !opts.animation.open) {
                    !retainFocus && ZC.display(undefined, ele);
                    opts.arrowElement && opts.arrowElement.show();
                    showCallback && showCallback(ele, opts);
                } else {
                    opts.onShowWithAnimation && opts.onShowWithAnimation(ele, opts);
                }
                ele.data('zshowhide', opts); // No I18N
                /* Retaining the old scroll top value since setting height as auto will reset the scrollTop value to zero. */
                ele.data('zscrEle') && ele.data('zscrEle').scrollTop(ele.data('zscrVal')); // No I18N
                return res;
            },
            _calcDimensions: function(ele, opts, forEle, retainFocus, isSubList) { // set the width and height provided in the option.
                let dir = opts.direction,
                    pos = opts.position,
                    isContextual = opts.isRightClick || dir === 'at-cursor'; // No I18N
                if (opts.closeOnBodyClick && ZC.bindDocumentEvents) {
                    ZC.bindDocumentEvents({
                        isCE: opts.isCE,
                        element: opts.originalElement || ele,
                        container: ele,
                        forElement: !isContextual && forEle,
                        ctype: opts.cname,
                        closeMethodName: opts.hideMethodName,
                        closeEvent: opts.hideEventName
                    });
                }
                let eveObj = opts.event || {},
                    bsCallback = opts.beforeShow && opts.beforeShow(ele, eveObj, {
                        currentTarget: isContextual ? eveObj.target : forEle
                    });
                if (bsCallback === false) {
                    return;
                }
                !retainFocus && ZC.display(undefined, ele).css('opacity', '0'); // No I18N
                let widObj = this.fixWidth(ele, opts);
                ele.removeClass(opts.widthCls);
                if (opts.isGrid) {
                    this.fixGridWidth(ele, opts); // Fixing the width of the grid type dropdown list.
                }
                ele.css('height', 'auto'); // No I18N
                let mainBodyEle = ele.find('.' + opts.bodyCls), // No I18N
                    hasScroll = false;
                mainBodyEle.length && mainBodyEle.css('height', 'auto'); // No I18N
                if (opts.height && parseFloat(opts.height) <= ele.outerHeight()) { // No I18N
                // Fixing the ele height,which is provided in the option only if it is less than actual height of the dropdown list.
                    ele.outerHeight(parseInt(opts.height)); // No I18N
                    hasScroll = true;
                }
                let utilRes = {};
                if (!pos) {
                    utilRes = this.calcPosition(ele, opts, isContextual, isSubList, eveObj, forEle);
                    pos = utilRes.elementPosition;
                }
                this.fixHeight(ele, opts);
                this._checkForScroll(ele, hasScroll, pos, widObj, utilRes.actualDirection || dir, opts.scroll);
                if (opts.alterBorderRadius && !opts.arrowElement) { // If callout is present, border corrections should not be done.
                    ZC.alterBorderRadius({
                        element: ele,
                        forElement: forEle,
                        hasSideAlignment: isSubList,
                        offset: pos,
                        direction: utilRes.actualDirection || dir
                    });
                }
                if (pos) {
                    if (isContextual) { /* Adjusting two pixel for right click menu's since mouseup events will not be triggered for the clicked portions if we open the dropdown list in the same location as that of cursor. */
                        let isRtl = opts.rtl;
                        pos.top += (isRtl ? -2 : 2);
                        pos.left += (isRtl ? -2 : 2);
                    }
                    ele.css(pos);
                }
                if (!retainFocus) {
                    ZC.display(true, ele); // hiding the dropdown list
                    ele.css('opacity', ''); // No I18N
                // resetting the opacity
                }
                return utilRes;
            },
            _checkForScroll: function(ele, hasScroll, pos, widObj, actualDir, scroll) {
                hasScroll = (hasScroll || ele.hasClass('zh-scroll_y') || ele.find('.zh-scroll_y').length) && scroll !== 'slider'; // No I18N
                let actualWidth = widObj.actualWidth,
                    minW = widObj.minW;
                if (hasScroll) { // fixing the width of list type /grid type dropdown list whose height doesn't fit into viewport.
                    let incValue = 0,
                        sWidth = this.scrollWidth || this.getScrollWidth();
                    if (minW) { /* Fix for having ellipsis in select boxes due to minWidth provided by them. */
                        if ((minW - actualWidth) < (sWidth + 1)) { // 1px is included in the calculation to include default scrollbar border. If scrollbar is present within the dropdown list, scroll border width has to be added.
                            incValue = actualWidth + sWidth + 1 - minW;
                        }
                    } else {
                        incValue = sWidth;
                    }
                    if (pos && (actualDir === 'bottom-right' || actualDir === 'top-right')) { // since position utility calculates the left value based on the previously set width, we have to adjust the left value by the newly incremented width value.
                        pos.left -= incValue;
                    }
                    /* innerWidth is changed to width since dropdownlist with padding results in wrong width calculation. */
                    ele.width(ele.width() + incValue);

                }
            },
            getScrollWidth: function() {
                let scrollEle = document.createElement('div'),
                    bodyEle = document.querySelector('body'); // No I18N
                bodyEle.appendChild(scrollEle); // No I18N
                scrollEle.style.cssText = 'width:50px;height:50px;overflow:scroll;'; // No I18N
                this._scrollWidth = $(scrollEle).width() - scrollEle.scrollWidth;
                bodyEle.removeChild(scrollEle); // No I18N
                return this._scrollWidth;
            },
            _setFocus: function(ele, opts) {
                clearTimeout(ele._focusTimer); // timer is stored in element itself.
                let bFCallback = opts.beforeFocus;
                if (bFCallback === undefined || bFCallback(ele)) { // No I18N
                    ele._focusTimer = setTimeout(() => ele.focus(), 100);
                }
            },
            _fetchScrollVal: function(ele) {
                /* Retaining the old scroll top value since setting height as auto will reset the scrollTop value to zero. */
                let scrEle = ele.find('.zh-scroll_y');
                scrEle = scrEle.length ? scrEle : ele;
                let scrVal = scrEle.scrollTop();
                ele.data('zscrEle', scrEle); // No I18N
                ele.data('zscrVal', scrVal); // No I18N
            },
            fixGridWidth: function(ele, opts) {
                let columns = parseInt(opts.columns),
                    gridSel = '.' + opts.gridCls, // No I18N
                    bodySel = '.' + opts.bodyCls, // No I18N
                    mainSel = '.' + opts.mainCls, // No I18N
                    gridDivisions = ele.find(gridSel),
                    actualEle = ele;
                if (gridDivisions.length) {
                    let opt, data,
                        columns = 0;
                    for (let j = 0; j < gridDivisions.length; j++) {
                        data = ZC._getOpts(gridDivisions[j]);
                        opt = data.columns;
                        if (opt && opt > columns) {
                            columns = opt;
                            actualEle = $(gridDivisions[j]);
                        }
                    }
                }
                if (!columns || columns === -1) {
                    let _ele = ele.closest(mainSel), // No I18N
                        data = ZC._getOpts(_ele);
                    columns = _ele.data('isExternalSubmenu') ? data.columns : columns; // No I18N
                    if (!columns || columns === -1) {
                        return;
                    }
                }
                if (actualEle[0] === ele[0] && !ele.hasClass(opts.gridCls)) { // No I18N
                    actualEle = ele.find(gridSel); // No I18N
                } else if (actualEle.find(bodySel).length) { // No I18N
                // menu may contain thumbnail class as a whole but header and footer items will be of list type.
                    actualEle = ele.find(bodySel); // No I18N
                }
                let items = opts.getAllMenuItems(actualEle, false, false, true),
                    floatingMenuWidth = 0,
                    itemStyle;
                for (let i = 0; i < columns && i < items.length; i++) {
                // outerWidth is replaced by native javascript method since it truncates the floating point values.
                    itemStyle = window.getComputedStyle(items[i]);
                    floatingMenuWidth += Math.round(parseFloat(itemStyle.width)) + Math.round(parseFloat(itemStyle.marginLeft)) + Math.round(parseFloat(itemStyle.marginRight)); // rounding the values since width/margins might contain floating point numbers.
                    if (ZC.Browser.isIE && ZC.Browser.getIEVersion() <= 11) { // IE check is added since item's width doesn't include padding and border there.
                        floatingMenuWidth += Math.round(parseFloat(itemStyle.paddingLeft)) + Math.round(parseFloat(itemStyle.paddingRight)) + Math.round(parseFloat(itemStyle.borderRightWidth)) + Math.round(parseFloat(itemStyle.borderLeftWidth));
                    }
                }
                ele.width(floatingMenuWidth); // setting width here in order to retrieve correct height before menu show. scroll bar width will be added after fixing height in show method.
                ele.data('width', floatingMenuWidth); // No I18N
            },
            fixHeight: function(ele, opts) { // No I18N
                let hgt = 'auto', // No I18N
                    bodyEle = ele.find('.' + opts.bodyCls),
                    actualEle = bodyEle.length ? bodyEle : undefined;
                ele.height(hgt);
                actualEle && actualEle.height(hgt);
                let alterPos = opts.direction === 'auto' || opts.direction === 'at-cursor', // No I18N
                    height = ele.outerHeight(),
                    top = parseInt(ele.css('top').split('px')[0] * 1 - $(window).scrollTop()) || 0, // No I18N
                    winHgt = ZC.windowObject ? ZC.windowObject.height : $(window).height(), // window object stored on the ZC is undefined sometimes while trying to show the dropdown list on load events.So included $(window).height()
                    openingDir = opts.actualDirection || opts.direction,
                    availHgt = opts.availableHeight,
                    isContextual = opts.isRightClick, // ##revisit - isRightClick key should be stored
                    limit = openingDir && (openingDir.indexOf('bottom') === 0 || openingDir.indexOf('top') === 0) ? (isContextual ? winHgt : availHgt) : winHgt, // No I18N
                    space = limit - height;
                if (isContextual) { // 2px is added since in show method, 2px will be added for the right click dropdown list.
                    top += 2;
                }
                if (top + height >= limit && (space < 0) || !alterPos) {
                    hgt = isContextual ? winHgt - top : availHgt;
                }
                let specHeight = parseInt(opts.height);
                if (specHeight) {
                    hgt = specHeight >= availHgt ? availHgt : specHeight;
                } else if (space > 0 && alterPos) {
                    hgt = height;
                }
                // slider type scroll is applicable only to container type elements.
                let sliderType = opts.scroll === 'slider' && actualEle, // No I18N
                    scrollCls = sliderType ? 'zh-overflowhidden' : 'zh-scroll_y', // No I18N
                    isGreater = false;
                if (height > hgt) {
                    isGreater = true;
                    if (actualEle) {
                        let headerEle = ele.find('.' + opts.headerCls),
                            footerEle = ele.find('.' + opts.footerCls), // No I18N
                            headerHeight = headerEle.length ? parseInt(headerEle.outerHeight(true)) : 0,
                            footerHeight = footerEle.length ? parseInt(footerEle.outerHeight(true)) : 0,
                            elePadding = parseInt(ele.css('padding-top')) + parseInt(ele.css('padding-bottom')), // No I18N
                            eleBorder = parseInt(ele.css('border-top-width')) + parseInt(ele.css('border-bottom-width')), // No I18N
                            // ele padding is included since padding top and padding bottom is set as 5px each for list type.
                            remaining = eleBorder + headerHeight + elePadding + (footerEle.length > 1 ? footerEle.length * footerHeight : footerHeight); // No I18N
                        // we might have two footer containers if the ele containing search box opens at the top position
                        actualEle.innerHeight(hgt - remaining);
                    }
                    ele.outerHeight(hgt); // setting height after list body's height calculation because retrieving the footer/header elements height after setting the height returns incorrect values.
                }
                sliderType && opts.displayScrollers && opts.displayScrollers(isGreater, ele); // isGreater -> show
                (actualEle || ele)[isGreater ? 'addClass' : 'removeClass'](scrollCls); // No I18N
            },
            fixWidth: function(ele, opts) {
                ele.addClass(opts.widthCls);
                let actualWidth = ele.outerWidth(),
                    width;
                if (opts.width) { // No I18N
                    actualWidth = parseInt(opts.width); // No I18N
                    ele.removeClass(opts.widthCls);
                    ele.width(actualWidth);
                } else if (opts.minWidth && (actualWidth < parseInt(opts.minWidth) && opts.contentType !== 'icon')) { // No I18N
                // contentType: icon check needed.
                // min-width for the list.
                // Subtract border width if box-sizing is ele's box-sizing is border-box. 1px is added extra by default while setting width. So subtracted 1px.
                    width = parseInt(opts.minWidth);
                    ele.removeClass(opts.widthCls);
                    ele.outerWidth(width - 1); // outerWidth should be set since for calculation, we are considering only outerWidth.
                }
                // innerWidth is changed to width since dropdownlist with padding results in wrong width calculation.
                // ele.width(ele.innerWidth() + 1); // To consider width in floating numbers, added 1px to innerWidth value.
                ele.width(ele.width() + 1); // To consider width in floating numbers, added 1px to innerWidth value.
                return {
                    actualWidth: actualWidth, // No I18N
                    minW: width // No I18N
                }
            },
            calcPosition: function(ele, opts, isContextual, isSubList, eveObj, forEle) {
            // direction, positionAlterable, arrowElement, arrowCallback details should be provided by the component itself.
                let offVal = opts.offset,
                    pos,
                    arrowEle = opts.arrowElement,
                    utilRes = ZC.Position.get(isContextual && !isSubList ? eveObj : forEle, ele, $.extend(true, {}, {
                        arrow: {
                            element: isSubList ? null : arrowEle,
                            callback: opts.arrowCallback
                        }
                    }, opts), arrowEle || undefined);

                opts.availableHeight = utilRes.availableHeight;
                if (offVal) {
                    opts.availableHeight -= parseInt(offVal.top) || 0;
                }
                pos = utilRes.elementPosition;
                opts.actualDirection = pos.direction = utilRes.actualDirection;
                utilRes.pos = pos;
                if (arrowEle && !isSubList) {
                    let arrowPos = utilRes.arrowPosition;
                    if (offVal) {
                        // There are only 2 conditions, hence regeex is remvoed.
                        let arrowDirection = utilRes.arrowDirection;
                        if (arrowDirection === 'top' || arrowDirection === 'bottom') { // adjust left position.
                            let prop = opts.rtl ? 'right' : 'left'; // No I18N
                            let flag = opts.rtl ? 1 : -1;
                            if (offVal.left !== undefined) {
                                // arrowPos.left -= offVal.left;
                                arrowPos[prop] += offVal.left * flag;
                            }
                        } else if (offVal.top !== undefined) { // adjust top position.
                            arrowPos.top -= offVal.top;
                        }
                    }
                    arrowEle.css(arrowPos);
                }
                if (offVal) {
                    utilRes.pos.top += parseInt(offVal.top) || 0;
                    utilRes.pos.left += parseInt(offVal.left) || 0; // parseInt(undefined) will be NaN
                }
                return utilRes;
            },
            hide: function(ele, opts) {
            // renderInPlace list will not open
                if (!ele.is(':visible') || opts.renderInPlace) { // No I18N
                    return;
                }
                let bhCallback = opts.beforeHide && opts.beforeHide();
                if (bhCallback !== false) {
                    let utilOpts = ele.data('zshowhide') || {}; // No I18N
                    utilOpts.alterBorderRadius && ZC.alterBorderRadius({
                        element: ele,
                        forElement: utilOpts.forElement // No I18N
                    }, true); // true is passed to clear the already changed border-radius
                    this._fetchScrollVal(ele);
                    if (ZC.isEmpty(opts.animation) || !opts.animation.close) {
                        ZC.display(true, ele);
                        this.removeScrollCls(ele);
                        let hideCallback = opts.onHide;
                        hideCallback && hideCallback(ele, opts);
                    } else {
                        let hideWithAnimation = opts.onHideWithAnimation;
                        hideWithAnimation && hideWithAnimation(ele, opts);
                    }
                }
            },
            removeScrollCls(ele) { // scroll related classes has to be removed after animation is completed otherwise scrollTop reset will be visible in the UI.
                ele.removeClass('zh-scroll_y zh-overflowhidden'); // No I18N
                ele.find('.zh-scroll_y, .zh-overflowhidden').removeClass('zh-scroll_y zh-overflowhidden'); // No I18N
            }
        }
    }(ZC, $));
}(ZComponents));

(function(ZC, $){
	let keyCodes = ZC.keyCode,
	    headKeys = [ keyCodes.HOME, keyCodes.PAGE_UP ],
	    tailKeys = [ keyCodes.END, keyCodes.PAGE_DOWN ];
	// handled keys: UP, DOWN, RIGHT, LEFT, PAGE_UP, PAGE_DOWN, HOME, END, ESCAPE, TAB
	class ZKeyboardNavigation extends ZC.CoreComponent {
			get name(){
				return "zkeyboardnavigation";
			}
	    get props() {
	        return {
	            direction: 'vertical', // No I18N
	            hoverClassName: 'on-hover', // No I18N
	            focusClassName: 'has-focus', // No I18N
	            items: '', // No I18N
	            wrapAround: false,
	            scrollToView: true,
	            handleHover: true,
	            selectOnEnterKey: true, // having as separate options for fontlibrary case
	            selectOnSpaceKey: true,
	            characterKeyFocus: true,
	            keyMatchAttribute: 'label', // No I18N
	            focusItemOnItemMouseover: true,
	            keyNavigation: true,
	            inputSelectors: 'input, textarea, div[contentEditable]' // No I18N
	        }
	    }
	    get EVENTS() {
	        return [ 'beforefocusmove', 'focusmove', 'mouseenter', 'mouseleave', 'keydown', 'arrowkeydown', 'blur' ]; // No I18N
	    }
	    _create(ele) { // ele holds this.element
	        this._prevSKey = ''; // No I18N
	        this._bindEvents(ele);
	    }
	    _bindEvents(ele) {
	        this._addEvents({
	            keyDown: 'keydown', // No I18N
	            blur: 'focusout', // No I18N
	            itemFocus: 'click' // No I18N
	            // using focusout for the sake of list box.
	        }, ele);
	        let opts = this._opts,
	            suffix = this.name,
	            hoverCls = opts.hoverClassName;
	        if (opts.handleHover) {
	            ele.on('mouseenter.' + suffix, opts.items, (event) => { // No I18N
	                if (opts.focusItemOnItemMouseover) {
	                    this._mouseEntered = true;
	                }
	                this._mouseHoverHandler(event, true);
	                this._dispatchEvent('mouseenter', event, { // No I18N
	                    item: hoverCls && ele.find('.' + hoverCls) // No I18N
	                });
	            }).on('mouseleave.' + suffix, opts.items, (event) => { // No I18N
	                if (opts.focusItemOnItemMouseover) {
	                    this._mouseEntered = false;
	                }
	                this._dispatchEvent('mouseleave', event, { // No I18N
	                    item: hoverCls && ele.find('.' + hoverCls) // No I18N
	                });
	                this._mouseHoverHandler(event);
	            });
	        }
	    }
	    moveFocus(event) { // triggered event -- public method
	        let isSubmitAction = event.keyCode === ZC.keyCode.ENTER || event.keyCode === ZC.keyCode.SPACE;
	        if (isSubmitAction || this._opts.keyNavigation) {
	            return this._keyDownHandler(event);
	        }
	    }
	    _mouseHoverHandler(event, isEnter, execCallback, obj = {}) {
	        let target = $(event.target),
	            isKeyDown = event.type === 'keydown', // No I18N
	            opts = this._opts,
	            itemSel = this._opts.items;
	        target = target.is(itemSel) ? target : target.closest(itemSel);
	        if (!target.length) {
	            return;
	        }
	        let ele = this.element,
	            isFocusable = isKeyDown || opts.focusItemOnItemMouseover,
	            hoverCls = opts.hoverClassName,
	            focusCls = opts.focusClassName,
	            currHover = isKeyDown ? this._getCurrItem(ele, opts) : ele.find('.' + hoverCls); // No I18N
	        if (!currHover || !isEnter || (currHover[0] !== target[0])) {
	            // isEnter && currHover && currHover.removeClass(hoverCls + ' ' + (isFocusable ? focusCls : '')); // No I18N
	            isEnter && currHover && !isKeyDown && currHover.removeClass(hoverCls); // No I18N
	            let focRes = true;
	            if (isFocusable) {
	                focRes = this['_' + (isEnter ? '' : 'un') + 'focus'](target, opts, event, obj);
	            }
	            if (focRes !== false) {
	                isEnter && currHover && currHover.removeClass((opts.focusItemOnItemMouseover ? hoverCls + ' ' : '') + (isFocusable ? focusCls : '')); // No I18N
	            }
	            // target[(isEnter ? 'add' : 'remove') + 'Class'](hoverCls); // No I18N
	            (!isKeyDown || (focRes !== false && opts.focusItemOnItemMouseover)) && target[(isEnter ? 'add' : 'remove') + 'Class'](hoverCls); // No I18N
	            this.element.data('prevHover', currHover); // No I18N
	            if (execCallback) {
	                let callName = 'onMouse' + (isEnter ? 'Enter' : 'Leave'); // No I18N
	                opts[callName] && opts[callName](event, target);
	            }
	        }
	        return true;
	    }
	    _itemFocusHandler(event) {
	        let opts = this._opts,
	            target = $(event.target),
	            itemSel = opts.items,
	            item = target.is(itemSel) ? target : target.closest(itemSel);
	        if (item && item.length) {
	            let prevFoc = this.element.find('.' + opts.focusClassName); // No I18N
	            if (prevFoc.length) {
	                this._unfocus(prevFoc, opts, event);
	            }
	            this._focus(item, opts, event);
	        }
	    }
	    _keyDownHandler(event) {
	        let code = event.keyCode,
	            opts = this._opts,
	            ele = this.element,
	            obj = {},
	            tar = $(event.target),
	            isInput = tar.closest(this._opts.inputSelectors).length,
	            inputEle = isInput && tar.is('input'), // No I18N
	            retVal = true;
	        if (isInput && !inputEle) { // No I18N
	            return;
	        }
	        let list = ele.find(opts.items),
	            handleNav = opts.keyNavigation,
	            length = list.length,
	            direction = opts.direction,
	            key = (Object.keys(keyCodes).find((lhs) => keyCodes[lhs] === code) || '').replace('_', '').toLowerCase(), // No I18N
	            isDown = key === 'down', // No I18N
	            isUp = key === 'up', // No I18N
	            isRt = key === 'right', // No I18N
	            isLt = key === 'left', // No I18N
	            isHorList = direction === 'horizontal', // No I18N
	            isVerList = direction === 'vertical', // No I18N
	            isGrid = direction === 'both', // No I18N
	            currItem = this._getCurrItem(ele, opts),
	            nextItem,
	            toPrevent = false;
	        let isDownNav = isVerList ? isDown : (isHorList && currItem.length ? isRt : (isDown || isRt)),
	            isUpNav = isVerList ? isUp : (isHorList && currItem.length ? isLt : (isUp || isLt));
	        if (currItem.length > 1) {
	            currItem = $(currItem[isDownNav ? currItem.length - 1 : 0]);
	        }
	        if (inputEle && [ 'up', 'down', 'enter' ].indexOf(key) === -1) { // No I18N
	            // UP and DOWN only will be allowed for input element
	            return;
	        }
	        if (opts.focusItemOnItemMouseover && this._mouseEntered) {
	            this._bindMouseMove();
	        }
	        if ((opts.selectOnEnterKey && key === 'enter') || (opts.selectOnSpaceKey && key === 'space')) { // No I18N
	            this._enterKeyHandler && this._enterKeyHandler(event, currItem);
	            obj.isEnterKey = key === 'enter'; // No I18N
	            obj.isSpaceKey = key === 'space'; // No I18N
	            retVal = false;
	        }
	        obj.key = key;
	        let isArrowKeys = isUp || isDown || isRt || isLt;
	        if (isArrowKeys) {
	            obj['is' + key[0].toUpperCase() + key.slice(1) + 'Key'] = true; // No I18N
	        }
	        let isCommand = event.metaKey || event.ctrlKey;
	        if (!isCommand && (isDownNav || isUpNav) && handleNav) { // No I18N
	            if (!currItem || !currItem.length) { // first item has to be hovered if there is no hovered item.
	                nextItem = $(list[isDownNav ? 0 : list.length - 1]);
	            } else if (isGrid) {
	                let index = list.index(currItem),
	                    listItems = currItem[isUpNav ? 'prevAll' : 'nextAll'](opts.items); // No I18N
	                nextItem = this._gridNavigation && this._gridNavigation(event, currItem, key, listItems, index, isUp, isDown, isLt, isRt);
	            } else {
	                let index = list.index(currItem);
	                index += isDownNav ? 1 : -1;
	                if (index < 0 || index === length) {
	                    if (opts.wrapAround) {
	                        index = isDownNav ? 0 : length - 1;
	                    } else {
	                        index += isDownNav ? -1 : 1;
	                    }
	                }
	                nextItem = list[index];
	            }
	        } else if (key === 'escape') { // No I18N
	            obj.isEscapeKey = true;
	        } else if (handleNav && (headKeys.indexOf(code) >= 0 || (isCommand && isUpNav))) { // No I18N
	            nextItem = list[0];
	            toPrevent = true;
	        } else if (handleNav && (tailKeys.indexOf(code) >= 0 || (isCommand && isDownNav))) { // No I18N
	            nextItem = list[length - 1];
	            toPrevent = true;
	        } else if (key === 'tab') { // No I18N
	            return this._blurHandler(event);
	        } else if (handleNav && opts.characterKeyFocus && this._callSearch && key !== 'enter' && key !== 'space') { // No I18N
	            nextItem = this._callSearch(event.key, event, currItem);
	        }
	        nextItem = $(nextItem);
	        if (nextItem.length) {
	            opts.scrollToView && this._scrollToView(nextItem, ele, isCommand && isUpNav, isCommand && isDownNav);
	            event.target = nextItem;
	            retVal = this._mouseHoverHandler(event, true, true);
	        }
	        obj.item = currItem;
	        obj.nextItem = nextItem;
	        this._dispatchEvent('keydown', event, obj); // No I18N
	        isArrowKeys && this._dispatchEvent('arrowkeydown', event, obj); // No I18N
	        if (handleNav && !inputEle && (this._isNonModKey(event) || toPrevent)) {
	            // checking whether the key pressed is a short cut key or not. Shortcutkey events should not be prevented.
	            return false; // preventing default and stopping propagation.
	        }
	        return retVal;
	    }
	    _bindMouseMove() {
	        /* Fix for not getting the mouseenter for an item if the mouse is already present in that item and hover/focus state is changed using but focus is navigated using keydown */
	        let ele = this.element,
	            suffix = '.' + this.name, // No I18N
	            opts = this._opts;
	        ele.on('mousemove' + suffix, function(event) { // No I18N
	            let target = $(event.target).closest(opts.items);
	            if (target && target.length) {
	                target.trigger('mouseenter'); // No I18N
	            }
	            ele.off('mousemove' + suffix); // No I18N
	        });
	    }
	    _focus(item, opts = this._opts, event, obj = {}) {
	        let focCls = opts.focusClassName;
	        if (focCls && !item.hasClass(focCls)) {
	            obj.item = item;
	            if (this._dispatchEvent('beforefocusmove', event, obj) !== false) { // No I18N
	                item.addClass(focCls + (!event && opts.focusItemOnItemMouseover ? ' ' + opts.hoverClassName : '')); // No I18N
	                this._dispatchEvent('focusmove', event, obj); // No I18N
	                return true;
	            }
	            return false;
	        }
	    }
	    _unfocus(item, opts = this._opts) {
	        let focCls = opts.focusClassName;
	        if (focCls && item.hasClass(focCls)) {
	            item.removeClass(focCls);
	        }
	    }
	    focusItem(item, event, scrollToView = true) {
	        if (scrollToView && this._opts.scrollToView) {
	            this._scrollToView(item, this.element);
	        }
	        this._focus(item, this._opts, event);
	    }
	    _getCurrItem(ele, opts) {
	        let list = ele.find(opts.items),
	            considerHover = opts.focusItemOnItemMouseover,
	            firstPrior = (considerHover ? 'hover' : 'focus'), // No I18N
	            item = list.filter('.' + opts[firstPrior + 'ClassName']); // No I18N
	        if (!item.length && considerHover && opts.focusClassName) {
	            item = list.filter('.' + opts.focusClassName); // No I18N
	        }
	        return item;
	    }
	    _isNonModKey(event) {
	        return (!event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey && event.keyCode !== ZC.keyCode.ESCAPE);
	    }
	    _blurHandler(event) {
	        if (document.activeElement === this.element[0]) {
	            return;
	        }
	        if (!this._dispatchEvent('beforeblur', event)) { // No I18N
	            return;
	        }
	        let ele = this.element,
	            opts = this._opts,
	            hoverCls = opts.hoverClassName,
	            focusCls = opts.focusClassName,
	            relTarget = event && event.relatedTarget;
	        if (!relTarget || !$(relTarget).closest(this.element).length) {
	            ele.find((hoverCls ? ('.' + hoverCls) : '') + (hoverCls ? ',' : '') + '.' + focusCls).removeClass(hoverCls + ' ' + focusCls); // No I18N
	        }
	        this._dispatchEvent('blur', event); // No I18N
	    }
	    _scrollToView(item, container, setZero, setFullHgt) {
	        let scrollableEle = (this._opts.scrollableEle || (container.find('.zh-scroll_y').length ? container.find('.zh-scroll_y') : (container.find('.zh-overflowhidden').length ? container.find('.zh-overflowhidden') : container))), // No I18N
	            isFirst = !item[0].previousElementSibling,
	            isLast = !isFirst && !item[0].nextElementSibling;
	        setZero = setZero || isFirst;
	        if (!this.element.is(':visible') || !scrollableEle[0].contains(item[0])) { // No I18N
	            return;
	        }
	        setFullHgt = setFullHgt || isLast;
	        let topValue = setZero ? 0 : (setFullHgt ? scrollableEle[0].scrollHeight : 0);
	        if (!setZero && !setFullHgt) {
	            let iTop = item.offset().top - scrollableEle.offset().top,
	                prevTop = scrollableEle[0].scrollTop;
	            // iTop < 0 means scrolling backward
	            topValue = iTop < 0 ? (prevTop + iTop) : Math.max(prevTop, iTop + prevTop + item.outerHeight(true) - scrollableEle.outerHeight());
	        }
	        scrollableEle.scrollTop(topValue); // animation is removed because in fast repeat keyboards animation produces incorrect results.
	    }
	    setAttribute(optionName, value) {
	        this._opts[optionName] = value;
	    }
	    destroy() {
	        let name = this.name;
	        this.element.off('.' + name).removeData(name); // No I18N
	        this.element.removeData('prevHover'); // No I18N
	        this.element = undefined;
	    }
		_callSearch  (key, event, currItem) {
		    // fromKeyCode doesn't return key pressed correctly/
		    // key = String.fromCharCode(key);
		    let sameKey = false,
		        currTime = +(new Date());
		    key = key.toLowerCase();
		    if (this._prevKTime && currTime - this._prevKTime > 700) { // No I18N
		        sameKey = this._prevSKey === key;
		        this._prevSKey = key;
		    } else {
		        this._prevSKey = this._prevSKey + key;
		    }
		    this._prevKTime = currTime;
		    return this._itemSearch(sameKey, event, currItem);
		}
		_itemSearch  (sameKey, event, currItem) {
		    let opts = this._opts,
		        arr = this.element.find(opts.items);
		    arr = arr.filter('[data-' + opts.keyMatchAttribute + '^="' + this._prevSKey + '"]'); // No I18N
		    if (arr.length) {
		        if (sameKey) {
		            let cIndex = arr.toArray().indexOf(currItem[0]);
		            cIndex += 1;
		            if (cIndex >= arr.length) {
		                cIndex = 0;
		            }
		            return $(arr[cIndex]);
		        }
		        return $(arr[0]);
		    }
		}
		_gridNavigation  (event, currItem, key, list, currIndex, isUp, isDown, isLt, isRt) {
		    let currPos = currItem.position(),
		        nextItem = this._getNextGridMenuItem(currPos, list, isUp, isLt || isRt); // No I18N
		    if (!nextItem || !nextItem.length) {
		        let sec1, sec2,
		            index = -1,
		            opts = this._opts,
		            wrapAround = opts.wrapAround,
		            isPrev = isUp || isLt, // No I18N
		            itemSel = opts.items,
		            headerCls = '.' + opts.headerClassName, // No I18N
		            footerCls = '.' + opts.footerClassName, // No I18N
		            rootCls = opts.ctype,
		            portion = currItem.closest(headerCls).length ? 'header' : currItem.closest(footerCls).length ? 'footer' : 'body', // No I18N
		            isHeader = portion === 'header', // No I18N
		            isBody = portion === 'body'; // No I18N
		        // sec1 = portion === 'header' ? 'footer' : 'header'; // No I18N
		        // sec2 = portion === 'body' ? isPrev ? 'header' : 'footer' : ''; // No I18N
		        sec1 = isHeader ? 'footer' : (isBody ? 'header' : 'body'); // No I18N
		        sec2 = isHeader ? 'body' : (isBody ? 'footer' : 'header'); // No I18N
		        if (!isPrev) {
		            let temp = sec1;
		            sec1 = sec2;
		            sec2 = temp;
		        }
		        if (this.element.find(`.${rootCls}__${sec1}`).length) {
		            itemSel = `.${rootCls}__${sec1} ${itemSel}`;
		        } else if (this.element.find(`.${rootCls}__${sec2}`).length) { // No I18N
		            itemSel = `.${rootCls}__${sec2} ${itemSel}`;
		        } else {
		            itemSel = this.element.find(`.${rootCls}__body`).length ? `.${rootCls}__body ${itemSel}` : itemSel;
		        }
		        list = this.element.find(itemSel);
		        if (portion === 'footer') { // No I18N
		            index = isPrev ? (isLt ? list.length - 1 : this._getLRFItem($(list[list.length - 1]).position(), list)) : 0; // No I18N
		        } else {
		            if (isUp || isDown) {
		                key = isUp ? 'down' : (isDown ? 'up' : key); // No I18N
		                isUp = key === 'up'; // No I18N
		                nextItem = this._getNextGridMenuItem(currPos, isUp ? list.toArray().splice(0, currIndex) : list.toArray().splice(currIndex + 1).reverse(), isUp, isLt || isRt); // No I18N
		            }
		            if ((!nextItem || !nextItem.length) && (!(isLt || isRt) || wrapAround)) {
		                index = isPrev ? list.length - 1 : 0;
		            }
		        }
		        nextItem = nextItem && nextItem.length ? nextItem : (index !== -1 && list[index]);
		    }
		    return nextItem;
		}
		_getNextGridMenuItem  (currentItemPos, items, isPrev, compareTop) {
		    let next,
		        key = compareTop ? 'top' : 'left', // No I18N
		        total = items.length;
		    for (let i = 0, item; i < total; i++) {
		        item = $(items[i]);
		        let ipos = item.position();
		        if (ipos[key] === currentItemPos[key] || key === 'top') { // No I18N
		            // Top key check is added to allow Navigation to next row items (example: open office application)
		            next = item;
		            break;
		        }
		    }
		    return next;
		}
		_getLRFItem  (itemPos, items) { // get last row first item
		    let prev,
		        total = items.length - 1,
		        ipos;
		    for (let i = total; i >= 0; i--) {
		        ipos = $(items[i]).position();
		        if (ipos.top === itemPos.top) {
		            prev = items[i];
		        } else {
		            break;
		        }
		    }
		    return items.index(prev);
		}
	}
	ZC.registerComponent('ZKeyboardNavigation', ZKeyboardNavigation); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
	class ZSelectable extends ZC.ZKeyboardNavigation {
			get name(){
				return "zselectable";
			}
	    get props() {
	        return {
	            multiple: false,
	            selectedClassName: 'is-selected', // No I18N
	            selectOnFocus: false,
	            selectOnEnterKey: true,
	            selectOnSpaceKey: true,
	            allowDragToSelect: true,
	            allowShiftSelection: true,
	            keyNavigation: true,
	            keyNavigationOptions: {
	                direction: 'vertical',
	                wrapAround: false,
	                characterKeyFocus: true
	            }
	        }
	    }
	    get EVENTS() {
	        return [ 'beforeselect', 'select', 'beforedeselect', 'deselect', 'contextmenu', 'reset', 'beforereset', 'change' ]; // No I18N
	    }
	    _create(ele, options) {
	        this._opts = $.extend(true, {}, this._opts, options.keyNavigationOptions || {}); // currently merging the key nav options in this._opts itself.
	        super._create(ele, options);
	    }
	    _bindEvents(ele) {
	        super._bindEvents(ele);
	        this._addEvents({
	            mouseDown: 'mousedown', // No I18N
	            mouseUp: 'mouseup', // No I18N
	            keyUp: 'keyup' // No I18N
	        }, ele);
	    }
	    _keyUpHandler(event) {
	        if (!event.shiftKey) {
	            this.element.removeClass('zh-userselectnone'); // No I18N
	        }
	    }
	    _keyDownHandler(event) {
	        let code = event.keyCode,
	            ele = this.element,
	            opts = this._opts,
	            currItem = this._getCurrItem(ele, opts),
	            shtPressed = event.shiftKey,
	            tar = $(event.target),
	            isInput = tar.closest(this._opts.inputSelectors).length;
	        if (!isInput) {
	            if (!this._shiftPressed && shtPressed && code === 16) { // shift key is alone pressed
	                let selItem = ele.find('.'+opts.selectedClassName), // No I18N
	                    len = selItem.length;
	                this._shiftPressed = len && len === 1 ? selItem : (opts.focusItemOnItemMouseover ? this._lastSelItem : currItem);
	                let selection = window.getSelection();
	                // containsNode is not support in IE and Edge browsers.
	                (!selection.containsNode || selection.containsNode(ele[0], true)) && selection.removeAllRanges();
	                ele.addClass('zh-userselectnone'); // No I18N
	            } else if (!shtPressed) {
	                this._shiftPressed = undefined;
	            }
	        }
	        // (Ctrl/Cmd) + A support added.
	        if (!isInput && opts.multiple && (event.metaKey || event.ctrlKey) && code === 65) {
	            event.preventDefault();
	            this.selectAllItems(true);
	        } else {
	            return super._keyDownHandler(event);
	        }
	    }
	    _enterKeyHandler(event, item) {
	        if (item.hasClass(this._opts.hoverClassName) || item.hasClass(this._opts.focusClassName)) {
	            event.target = item; // event.target contains search box in list box component. so, changing the target item
	            this._handleSelection(item, undefined, event);
	            return false; // false is returned to avoid page scrolling.
	        }
	    }
	    _mouseDownHandler(event) {
	        if (this._dispatchEvent('beforemousedown', event)) { // No I18N
	            this._md = true;
	            this._mdy = event.pageY;
	            this._mdx = event.pageX;
	            this._mdEle = $(event.target).closest(this._opts.items);
	            if (!event.shiftKey) {
	                this._shiftPressed = undefined;
	            }
	            // Currently user selection is not allowed at all. Have to revisit in future.
	            this.element.addClass('zh-userselectnone'); // No I18N
	            this._bindMouseDrag && this._bindMouseDrag();
	        }
	    }
	    _mouseMoveHandler(event) {
	        if (this._md) {
	            let tar = $(event.target),
	                opts = this._opts,
	                focCls = opts.focusClassName,
	                selCls = opts.selectedClassName,
	                item = tar.closest(opts.items);
	            if (item.length) {
	                let toggle = item.hasClass(selCls);
	                item[(toggle ? 'toggle' : 'add') + 'Class'](selCls + ' ' + focCls); // No I18N
	            }
	            event.preventDefault();
	        }
	    }
	    _mouseUpHandler(event) {
	        if (this._dispatchEvent('beforemouseup', event)) {// No I18N
	            this.element.off('mousemove.' + this.name); // No I18N
	            this._md = false;
	            if (event.which === 3) {
	                this._dispatchEvent('contextmenu', event); // No I18N
	            }
	            let target = $(event.target),
	                opts = this._opts,
	                item = target.closest(opts.items);
	            if (!item.length) {
	                return;
	            }
	            if (this._mdEle && item[0] === this._mdEle[0]) { // mousedown and mouseup occurs on the same element
	                this._mdEle = undefined;
	            }
	            this._handleSelection(item, opts, event);
	            this._scrollToView(item, this.element);
	            this._mdEle = this._mdy = this._mdx = undefined;
	            if (!this._shiftPressed) {
	                this.element.removeClass('zh-userselectnone'); // No I18N
	                let selection = window.getSelection();
	                if (ZC.Browser.isIE) { // containsNode not supported in IE, hence document.activeElement check added.
	                    let doc = document.activeElement;
	                    !$(doc).closest(opts.inputSelectors).length && selection.removeAllRanges();
	                } else {
	                    (!selection.containsNode || selection.containsNode(this.element[0], true)) && selection.removeAllRanges();
	                }
	            }
	        }
	    }
	    _handleSelection(item, opts = this._opts, event, isMulti, isUp, eleToFocus, doesClr) {
	        let selectableSel = opts.selSelector;
	        if (selectableSel && !$(event.target).closest(selectableSel).length) {
	            return;
	        }
	        let ele = this.element,
	            focCls = opts.focusClassName,
	            selCls = opts.selectedClassName;
	        // if (focCls) {
	            // ele.find('.' + focCls).not(item).removeClass(focCls + (opts.focusItemOnItemMouseover ? ' ' + opts.hoverClassName : '')); // No I18N
	        // }
	        if (opts.multiple && opts.selectOnFocus && event.type !== 'keydown' && !(event.metaKey || event.ctrlKey || event.shiftKey)) { // No I18N
	            // multiple selection via cmd/ctrl + click allowed - finder like behavior.
	            this._clearAll(event, item, true);
	        }
	        // clearing the previous selection is done before dragToSelect also.
	        if (opts.multiple && event.type !== 'keydown') { // No I18N
	            // mousedrag or shift+click
	            let isRange = (opts.allowDragToSelect && this._mdEle) || (opts.allowShiftSelection && this._shiftPressed && this._shiftPressed.hasClass(selCls));
	            if (isRange) {
	                return this._selectMultipleItems(event, opts, item, isUp);
	            }
	        }
	        let selList = ele.find('.' + selCls).toArray(); // No I18N
	        if ((!opts.multiple && !isMulti) && selList.length && selList[0] !== item[0]) {
	            this._deselect($(selList[0]), opts, event, item);
	        }
	        let isDown = event.keyCode === ZC.keyCode.DOWN,
	            selectOnUp = event.type === 'keydown' && (isUp || isDown) ? item.data('selectOnUp') : undefined, // No I18N
	            isSelected = item.hasClass(selCls) && (selectOnUp === undefined || (isUp ? !selectOnUp : selectOnUp)), // No I18N
	            // ctrl+click -> deselection
	            toRemove = (opts.toggle || event.ctrlKey || event.metaKey || event.shiftKey) && (isSelected && !doesClr) && (!this._shiftPressed || item[0] !== this._shiftPressed[0]),
	            focRes = this._focus(eleToFocus || item, opts, event, {
	                ahead: toRemove ? 'deselect' : 'select' // No I18N
	            });
	        if (focRes !== false && focCls) {
	            ele.find('.' + focCls).not(eleToFocus || item).removeClass(focCls + (opts.focusItemOnItemMouseover ? ' ' + opts.hoverClassName : '')); // No I18N
	        }
	        if (toRemove) {
	            this._deselect(item, opts, event, item);
	        } else {
	            if(!item.hasClass('is-selected')){ // No I18N
	                if (event.shiftKey && (!this._shiftPressed || !this._shiftPressed.hasClass(selCls))) {
	                    this._shiftPressed = item;
	                }
	                this._select(item, opts, isUp, event);
	            }
	        }
	        this._dispatchEvent('change', event, {// No I18N
	            item
	        });
	    }
	    _select(item, opts = this._opts, isUp, event, ignoreFocus) {
	        let selCls = opts.selectedClassName;
	        if (!item.hasClass(selCls)) {
	            let obj = {
	                item: item
	            };
	            if (this._dispatchEvent('beforeselect', event, obj)) { // No I18N
	                opts.selectOnFocus && !ignoreFocus && this._focus(item, opts, event);
	                item.addClass(selCls);
	                this._lastSelItem = item;
	                if (isUp || (!isUp && (!event || event.type !== 'keydown' || (!event.shiftKey && event.keyCode === ZC.keyCode.DOWN)))) { // No I18N
	                    // fix for pressing ENTER while selecting the items via shift key.
	                    item.data('selectOnUp', isUp); // No I18N
	                }
	                this._dispatchEvent('select', event, obj)
	            }
	        }
	    }
	    _deselect(item, opts = this._opts, event, relatedItem) {
	        let selCls = opts.selectedClassName;
	        if (item.hasClass(selCls)) {
	            let obj = {
	                item: item,
	                relatedItem: relatedItem
	            };
	            if (this._dispatchEvent('beforedeselect', event, obj)) { // No I18N
	                item.removeClass(selCls);
	                // if (!event || event.type !== 'keydown' || (!event.shiftKey && event.keyCode !== ZC.keyCode.UP)) { // No I18N
	                    item.removeData('selectOnUp'); // No I18N
	                // }
	                if(this._lastSelItem && this._lastSelItem[0] === item[0]){
	                    this._lastSelItem = undefined;
	                }
	                this._dispatchEvent('deselect', event, obj); // No I18N
	            }
	        }
	    }
	    selectItem(item, event, scrollToView = true) {
	        if (scrollToView && this._opts.scrollToView) {
	            this._scrollToView(item, this.element);
	        }
	        this._select(item, this._opts, undefined, event);
	    }
	    deSelectItem(item, event) {
	        this._deselect(item, undefined, event);
	    }
	    selectAllItems(viaShortcut) {
	        this._changeAll(false, true); // second param - ignore focus
	        let opts = this._opts,
	            focCls = opts.focusClassName;
	        if (viaShortcut && focCls) {
	            let items = this.element.find(opts.items);
	            this.element.find('.' + focCls).removeClass(focCls + (opts.focusItemOnItemMouseover ? ' ' + opts.hoverClassName : '')); // No I18N
	            this._focus($(items[items.length - 1]), opts);
	        }
	    }
	    deselectAllItems() {
	        this._changeAll(true);
	    }
	    _changeAll(reset, ignoreFocus) {
	        let items = this.element.find(this._opts.items),
	            len = items.length;
	        for (let i = 0; i < len; i++) {
	            this['_' + (reset ? 'de' : '') + 'select']($(items[i]), undefined, undefined, undefined, ignoreFocus); // No I18N
	        }
	    }
	    _mouseHoverHandler(event, isEnter, execCallback) {
	        let opts = this._opts,
	            focSel = event.type === 'keydown' && opts.selectOnFocus; // No I18N
	        super._mouseHoverHandler(event, isEnter, execCallback, {
	            ahead: focSel ? ($(event.target).hasClass(opts.selectedClassName) ? 'deselect' : 'select') : undefined // No I18N
	        });
	        if (focSel) {
	            return this._selectOnKeyNav(event, opts);
	        }
	    }
	    _getCurrItem(ele, opts) {
	        let list = ele.find(opts.items),
	            considerHover = opts.focusItemOnItemMouseover,
	            item = {};
	        if (considerHover) {
	            item = list.filter('.' + opts.hoverClassName); // No I18N
	        }
	        if (!item.length) {
	            item = opts.focusClassName && list.filter('.' + opts.focusClassName); // No I18N
	            if (!item.length && !considerHover) {
	                item = list.filter('.' + opts.selectedClassName); // No I18N
	            }
	        }
	        return item;
	    }
	    setAttribute(optionName, value) {
	        if (optionName === 'keyNavigationOptions') { // No I18N
	            let keys = [ 'direction', 'wrapAround', 'characterKeyFocus' ], // No I18N
	                len = keys.length,
	                key;
	            for (let i = 0; i < len; i++) {
	                key = keys[i];
	                if (value[key] !== undefined) {
	                    this._opts[key] = value[key];
	                }
	            }
	        }
	        this._opts[optionName] = value;
	    }
	    destroy() {
	        this.element.removeClass('zh-userselectnone'); // No I18N
	        super.destroy();
	    }
		_selectMultipleItems  (event, opts, item, isUp) {
		    let list = this.element.find(opts.items).toArray(),
		        prevEle = this._mdEle || this._shiftPressed,
		        selCls = opts.selectedClass,
		        prevFocus = this.element.find('.' + opts.focusClassName), // No I18N
		        sInd, eInd;
		    if (this._prevEle && this._prevEle[0] === prevEle[0]) { // shift key is not removed yet
		        let prevIndex = list.indexOf(prevEle[0]),
		            lfIndex = list.indexOf(this._lastFocused[0]),
		            itemIndex = list.indexOf(item[0]),
		            invertedCase = (lfIndex < prevIndex && itemIndex > prevIndex) || (lfIndex > prevIndex && itemIndex < prevIndex),
		            downCase = (lfIndex > prevIndex && itemIndex > prevIndex && itemIndex < lfIndex),
		            upCase = (lfIndex < prevIndex && itemIndex < prevIndex && itemIndex > lfIndex),
		            isEql = prevIndex === itemIndex;
		        // case 1 & 2 => inverted cases
		        if (invertedCase || upCase || downCase) {
		            /* deselect the previous selection and retain the new */
		            let start = invertedCase ? (lfIndex < prevIndex ? lfIndex : prevIndex + 1) : (downCase ? itemIndex : lfIndex),
		                end = invertedCase ? (lfIndex < prevIndex ? prevIndex : lfIndex + 1) : (downCase ? lfIndex + 1 : itemIndex);
		            for (let i = start; i < end; i++) {
		                this._deselect($(list[i]), opts, event, item);
		            }
		            sInd = prevIndex;
		            eInd = itemIndex;
		        } else if (isEql) { // clear all except the item
		            let start = (lfIndex < prevIndex ? lfIndex : prevIndex + 1),
		                end = (lfIndex < prevIndex ? prevIndex : lfIndex + 1);
		            // end = opts.toggle ? end + 1 : end;
		            for (let j = start; j < end; j++) {
		                this._deselect($(list[j]), opts, event, item);
		            }
		        } else {
		            sInd = list.indexOf(prevEle[0]);
		            eInd = list.indexOf(item[0]);
		        }
		        // if (opts.toggle) {
		        //     eInd = eInd + (sInd < eInd ? -1 : 1);
		        // }
		    } else {
		        sInd = list.indexOf(prevEle[0]);
		        eInd = list.indexOf(item[0]);
		        // if (sInd === eInd && opts.toggle) {
		        //     this['_' + (item.hasClass(opts.selectedClassName) ? 'de' : '') + 'select'](item, opts, event); // No I18N
		        // }
		    }
		    let focLast = false;
		    if (sInd < eInd) { // select from top to bottom
		        list = list.splice(sInd, eInd - sInd + 1);
		        focLast = true;
		    } else { // select from bottom to top
		        let temp = sInd;
		        sInd = eInd;
		        eInd = temp;
		        list = list.splice(sInd, eInd - sInd + 1);
		    }
		    let newList = list.filter(function(lItem) {
		        if (!$(lItem).hasClass(selCls)) {
		            return lItem;
		        }
		    });
		    let newLen = newList.length;
		    if ((this._mdEle && this._movingUp) || (this._shiftPressed && !focLast)) {
		        newList = newList.reverse();
		    }
		    for (let i = 0; i < newLen; i++) {
		        this._select($(newList[i]), opts, isUp, event, true);
		    }
		    let focusEle = $((newLen ? newList : list)[newLen ? newLen - 1: list.length - 1]);
		    if (focusEle.length) {
		        prevFocus && prevFocus.length && this._unfocus(prevFocus, opts, event);
		        this._focus(focusEle, opts, event);
		        this._lastFocused = focusEle;
		    }
		    newLen && this._dispatchEvent('rangeselect', event, { // No I18N
		        selList: $(newList)
		    });
		    this._prevEle = prevEle;
		    this._dispatchEvent('change', event, {// No I18N
		        item
		    });
		}
		_bindMouseDrag  () {
		    let ele = this.element,
		        opts = this._opts,
		        tar, cItem,
		        base = this,
		        dir = opts.keyNavigationOptions.direction,
		        suffix = '.' + this.name; // No I18N
		    ele.on('mousemove' + suffix, function(event) { // No I18N
		        tar = $(event.target);
		        cItem = tar.closest(opts.items);
		        if (!cItem.length || !base._mdEle || cItem[0] !== base._mdEle[0]) {
		            // ele[cItem.length ? 'addClass' : 'removeClass']('zh-userselectnone'); // No I18N
		            base._movingUp = (dir === 'vertical' && event.pageY <= base._mdy) || (dir === 'horizontal' && event.pageX <= base._mdx); // No I18N
		            ele.off('mousemove' + suffix); // No I18N
		        }
		    });
		}
		_selectOnKeyNav  (event, opts) {
		    /* Remove the previous selections and select only the current item */
		    let selCls = opts.selectedClassName,
		        target = $(event.target),
		        itemSel = opts.items;
		    target = target.is(itemSel) ? target : target.closest(itemSel);
		    let isMulti = opts.multiple && (event.shiftKey || event.ctrlKey || event.metaKey),
		        code = event.keyCode,
		        isUp = code === ZC.keyCode.UP,
		        doesClr = false;
		    if (!isMulti) { // remove all previous selections
		        this._clearAll(event, target);
		        doesClr = true;
		    }
		    if (!this._shiftPressed && isMulti) {
		        this._shiftPressed = target[isUp ? 'next' : 'prev'](opts.items); // No I18N
		    }
		    let isTarSel = target.hasClass(selCls),
		        prevHover = this.element.data('prevHover'), // No I18N
		        isPrevSel = prevHover && prevHover.hasClass(selCls),
		        isSelOnUp = isPrevSel && prevHover.data('selectOnUp'), // No I18N
		        cond1 = isTarSel && isPrevSel,
		        cond2 = !isTarSel && isPrevSel && isSelOnUp && !isUp,
		        cond3 = !isTarSel && isPrevSel && !isSelOnUp && isUp,
		        eleToFocus;
		        // target already selected and target is going to be selected.
		    if (isMulti && (cond1 || cond2 || cond3)) {
		        if (isSelOnUp) {
		            if (isUp) {
		                return !isMulti;
		            } // down pressed
		            eleToFocus = target;
		            target = prevHover;
		        } else {
		            if (!isUp) {
		                return !isMulti;
		            }
		            eleToFocus = target;
		            target = prevHover;
		        }
		        if(cond2 || cond3){ // prevHover element selected state has to be changed.
		            this._handleSelection(target, opts, event, isMulti, isUp, eleToFocus, doesClr);
		            target = eleToFocus;
		        }
		    }
		    this._handleSelection(target, opts, event, isMulti, isUp, eleToFocus, doesClr);
		    return !isMulti;
		}
		_clearAll  (event, currItem, ignoreCurrItem) {
		    let opts = this._opts,
		        selList = this.element.find('.' + opts.selectedClassName).toArray(), // No I18N
		        index = selList.indexOf(currItem[0]);
		    if (!ignoreCurrItem && index > -1) { // already curr item is selected.
		        selList.splice(index, 1); // remove it from the array.
		    }
		    let len = selList ? selList.length : 0;
		    if (len) {
		        let obj = {
		            list: selList,
		            item: currItem
		        };
		        if (this._dispatchEvent('beforereset', event, obj)) { // No I18N
		            let item;
		            for (let i = 0; i < len; i++) {
		                item = $(selList[i]);
		                this._deselect(item, opts, event, currItem);
		            }
		            this._dispatchEvent('reset', event, obj); // No I18N
		        }
		    }
		}
	}
	ZC.registerComponent('ZSelectable', ZC.ZKeyboardNavigation, ZSelectable); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC) {
    ZC.animationHandler = function(options) {
        let action = options.action,
            element = options.element,
            callback = options.callback,
            animation = options.animation || options.default,
            effect, duration,
            _ANIMATION = {
                slide: {
                    show: 'slideDown', // No I18N
                    open: 'slideDown', // No I18N
                    close: 'slideUp', // No I18N
                    hide: 'slideUp' // No I18N
                },
                fade: {
                    show: 'fadeIn', // No I18N
                    open: 'fadeIn', // No I18N
                    close: 'fadeOut', // No I18N
                    hide: 'fadeOut' // No I18N
                }
            },
            isString = (typeof animation === 'string'); // No I18N
        if (animation && (typeof animation === 'object' || isString)) { // No I18N
            if (isString) {
                animation = {
                    name: animation
                };
            }
            let actionInfo = animation[action];
            duration = actionInfo && actionInfo.duration ? actionInfo.duration : animation.duration;
            if (actionInfo) {
                animation = actionInfo;
            }
            if (typeof animation === 'string' || animation.name) { // No I18N
                effect = animation.name || animation;
                if (_ANIMATION[effect]) {
                    effect = _ANIMATION[effect][action];
                }
            } else {
                effect = animation.className;
            }
            element.finish ? element.finish() : element.stop(true, true);
            if (effect) {
                if (typeof effect === 'object') { // No I18N
                    element.animate(effect, duration, callback);
                } else if (/^(fadeIn|fadeOut|slideDown|slideUp)$/.test(effect)) {
                    element[effect](duration, callback);
                } else {
                    element
                        .removeClass(element.data('zanimationclass')) // No I18N
                        .data('zanimationclass', effect) // No I18N
                        .addClass(effect)
                        .off(ZC._animationEnd)
                        .on(ZC._animationEnd, () => {
                            callback && callback();
                            element.off(ZC._animationEnd);
                        });
                }
                return;
            }
        }
        callback && callback();
    }
    ZC.clearAnimationData = function(element) {
        element.removeClass(element.data('zanimationclass')); // No I18N
        element.removeData('zanimationclass'); // No I18N
        element.off(ZC._animationEnd);
    }
}(ZComponents));


/* $Id$ */
ZComponents.ShortCut = (function(ZC) {
	var $ = ZC.DOMUtil;
	"use strict"	// No I18N
	var broswerObj = ZC.OS,
		allowedModifiers = ["ctrl","cmd","shift","alt"],	 // No I18N
		isMac = broswerObj.isMac(),
		handleAction = true,
		isWindows = broswerObj.isWindows(),
		allKeys = {},
		keyMap = {},
		options = {},
		isShortcutEnabled = true,
		keyUpBinded = false,
		spCharArr= {
			"<F1>": "112",	// No I18N
			"<F2>": "113",	// No I18N
			"<F3>": "114", 	// No I18N
			"<F4>": "115", 	// No I18N
			"<F5>": "116", 	// No I18N
			"<F6>": "117", 	// No I18N
			"<F7>": "118", 	// No I18N
			"<F8>": "119", 	// No I18N
			"<F9>": "120",	// No I18N
			"<F10>": "121", // No I18N	
			"<F11>": "122", // No I18N
			"<F12>": "123",	// No I18N
			"PRINTSCREEN": "44", // No I18N
			"NUMLOCK": "144", // No I18N
			"PAUSE": "19", // No I18N
			"INSERT": "45", // No I18N
			"HOME": "36", // No I18N
			"PAGEUP": "33",	// No I18N
			"PAGEDOWN": "34", // No I18N
			"DELETE": "46", // No I18N
			"END": "35",// No I18N
			"TAB": "9", 	// No I18N
			"CAPSLOCK": "20", // No I18N
			"WINDOWS": "91",// No I18N
			"ARROW_UP": "38", // No I18N
			"ARROW_DOWN": "40", // No I18N
			"ARROW_LEFT": "37", // No I18N
			"ARROW_RIGHT": "39", // No I18N
			"ENTER": "13", // No I18N
			"BACKSPACE": "8", // No I18N
			'SPACE': "32", // No I18N
			"ESCAPE": "27",// No I18N
			"DOT": "190", //key - .  Dot, Delete  keys have the same keycode. '.'.charCodeAt(0) = 46, keyCode for delete = 46. In this case we have to consider dot as a special char like TAB, SPACE, DELETE ....    // No I18N
			".": "190", // User can register either (.) or (dot/DOT).
			"": "226", //To handle (<)&(>) keys in same button in GERMAN keyboard.	//No I18N			
			"91": "219", //Key - \  // No I18N
			"92": "220", //key - ] // No I18N
			"93": "221", //Key - [ // No I18N
			"61": "187", //key - = // No I18N
			"45": "189", //key - - // No I18N
			"96": "192", //key - ` // No I18N
			"44": "188" ,//key - , // No I18N
			"47": "191", //key - / // No I18N
			"39": "222", //key - ' // No I18N
			"59": "186",  //key - ; // No I18N
			"123": "219", //key - |	 // No I18N
			"124": "220", //Key - }	 // No I18N
			"125": "221", //Key - {   // No I18N
			"43": "187", //Key - +    // No I18N
			"95": "189", //Key - _    // No I18N
			"126": "192", //Key - ~   // No I18N
			"60": "188" ,//Key - <    // No I18N
			"62": "190", //Key - >    // No I18N
			"63": "191", //Key - ?   // No I18N
			"34": "222", //Key - "   // No I18N
			"58": "186",//Key - :     // No I18N
			"33" : "49",  //Key - !  // No I18N
			"64" : "50", //key - @    // No I18N
			"35" : "51", //key - #   // No I18N
			"36" : "52", //key - $   // No I18N
			"37" : "53", //key - %    // No I18N
			"94" : "54", //key - ^    // No I18N
			"38" : "55", //key - &   // No I18N
			"42" : "56", //key - *    // No I18N
			"40" : "57", //key - (  // No I18N
			"41" : "48" //key - )    // No I18N
	};
	var tagNames = ["BUTTON","INPUT","TEXTAREA","OPTION","SELECT","TEXTAREA","OPTGROUP","FIELDSET"];	// No I18N
	ZC.$document.on("keydown.shortcut", function(orgEvent){	 // No I18N
		triggerShortcut(orgEvent, true);
	});
	function triggerShortcut(eventObj, isKeyDown){
		if(isShortcutEnabled && isInputElement(eventObj)){
			var keyCode = eventObj.keyCode, key ="";	// No I18N
			if(eventObj.ctrlKey){
				key = "ctrl+";	 // No I18N
			}
			if(broswerObj.isMac() && eventObj.metaKey){
				key += "cmd+";	 // No I18N
			}
			if(eventObj.shiftKey){
				key += "shift+";	 // No I18N
			}
			if(eventObj.altKey){
				key += "alt+";	 // No I18N
			}
			var charCode = String.fromCharCode(keyCode);
			if(keyCode >= 65 && keyCode <= 90){
				keyCode = charCode.charCodeAt();
			}
			var tempKey = key;
			key+=keyCode;
			var eventObject = allKeys[key];
			if(!eventObject){
				for(var i in spCharArr){
					if(spCharArr[i] === keyCode.toString()){
						key = tempKey+(i.toLowerCase());
						eventObject = allKeys[key];
						if(eventObject){
							break;
						}
					}
				}
			}
			if(eventObject){
				var shortcutKey = key,
					keyInfo = (eventObject.keyInfo || {}),
					element = (eventObject.element || ""),	// No I18N
					handleOn = eventObject.handleOn,
					isDirectInit = eventObject.isDirectInit;
					element = $(element);
				if((isDirectInit && keyInfo.disabled !== true) || 
					(element && ((isKeyDown && handleOn !== "keyup") ||	(!isKeyDown && handleOn === "keyup"))))// No I18N
				{
					if(isDirectInit){
						var elementId = keyInfo.elementIds;
						elementId = (elementId && elementId[0]);
						element = $("#"+elementId);
					}
					var isSupportDisabledAttr = element && (tagNames.indexOf(element[0].tagName) !== -1 );
					if( (isDirectInit && !element.length) ||
						(!element.is(":disabled") && isSupportDisabledAttr) || // No I18N
						(!isSupportDisabledAttr && !element.is("[disabled]"))	// No I18N
					){
						var triggerData = {
							ele: element,
							shortcutKey: eventObject.shortcutKey,
							fromShortCut: true
						};
						if(isDirectInit){
							executionFunction(keyInfo.action, element, eventObj, keyInfo.params)
						}
						else{
							if(element.is(":checkbox") && eventObject.event === "click"){	 // No I18N
								element.each(function(){
									triggerData.ele = $(this);
									$(this).triggerHandler(eventObject.event, triggerData);
								})
							}else{
								element.trigger(eventObject.event, triggerData);
							}
						}
					}
					eventObj.stopPropagation();
					eventObj.preventDefault();
				}
			}
		}
	}
	function executionFunction(callback, element, eventObj, data){
		var value = undefined;
		if(callback && typeof callback === "string"){ // No I18N
		    var executableFnc = _getAsFunction(callback);
			value = executableFnc.callable(data);
		}else{
			value = typeof callback === "function" ? callback.apply(element, data) : undefined; // No I18N
		}
		return value !== undefined ? value : !eventObj.isDefaultPrevented();
	}
	function _getAsFunction(strValue){
	    if (!strValue) { return; }

	    var _action = strValue.split("."), fn = window, base = "", methodIdx;
	    $(_action).each(function(i, action){
	        methodIdx = action.indexOf('()');
	        fn = methodIdx>0?fn[action.substring(0, methodIdx)]():fn[action];
	        if (i == _action.length-2) { base = fn; }
	    });
	    //closure issue with callable needs to be addressed
	    return {'fn': fn, 'base': base, 'callable': function(){ fn && fn.call(base,arguments[0]); }}; //No I18N
	}
	function getKey(element, keyInfo){
		keyInfo = keyInfo || ZC._getOpts(element);
		var shortcut = keyInfo.shortcutkey || keyInfo.shortcutKey || keyInfo.key;
		if(shortcut){
			var keys= (typeof shortcut === 'object' && shortcut instanceof Array) ? shortcut : [shortcut];	 // No I18N
			for(var i=0;i<keys.length;i++){
				var key = keys[i];
				if(typeof keys[i] === 'object'){	 // No I18N
					key = !isMac ? keys[i].key : (keys[i].macKey ? keys[i].macKey : keys[i].key);
					if(!keys[i].key && !isMac){
						return false;
					}
				}
				if(key && !key.macKey && isMac){
					key = key.replace(/ctrl/i, keyInfo.skipShortcutFormat ? "Cmd": 'cmd');	 // No I18N
				}
				if(!keyInfo.skipShortcutFormat){
					key = key.toString().toLowerCase();
				}
				keys[i] = key;
			}
			return keys;
		}
	}
	function isInputElement(orgEvent){
		if(ZC.ShortCut.discardInputElement){
			var element = $(orgEvent.srcElement);
			if(element.length === 0){
				element = $(orgEvent.target);
			}
			if(element.is("input") || element.is("textarea")){
				return false;
			}
		}
		return true;
	}
	function sortKeyCombination(key){
		var splittedKeys = key.split("+"),	 // No I18N
			arrangedKeys = "",splittedKey;	// No I18N
			key = "";	// No I18N	
		for(var i=0;i<allowedModifiers.length;i++){
			for(var j=0;j<splittedKeys.length;j++){
				splittedKey = splittedKeys[j].trim();
				if(allowedModifiers[i] === splittedKey){
					arrangedKeys += splittedKey+"+";	 // No I18N
				}else if($.inArray(splittedKey, allowedModifiers) === -1){
					key = splittedKey;
				}
				if(splittedKey === ''){	 // No I18N
					key = "+";	 // No I18N
				}
			}
		}
		if(!spCharArr[key.toUpperCase()]){
			key = key.toUpperCase().charCodeAt(0);
		}
		return (arrangedKeys += key);
	}
	function registerKey(element, key, orgEvent, handleOn, isDirectInit, keyInfo){
		var arrangedKeys = sortKeyCombination(key);
		if(arrangedKeys){
			var registerObj = {element: element, event: orgEvent, handleOn: handleOn };
			if(isDirectInit){
				registerObj.isDirectInit = true;
				registerObj.keyInfo = keyInfo;
			}
			allKeys[arrangedKeys] = registerObj;
		}
	}
	function getFormattedKey(key){
		var splitKeys = key.split("+"),	 // No I18N
			dkey = "",
			base = this;
		for(var i=0;i<splitKeys.length;i++){
			if(splitKeys[i].charAt(0) == splitKeys[i].charAt(0).toUpperCase()){
				splitKeys[i] = splitKeys[i].toUpperCase();
			}else{
				splitKeys[i] = splitKeys[i].charAt(0).toUpperCase()+splitKeys[i].substring(1, splitKeys[i].length);
			}
			if(splitKeys.length - 1 !== i){
				splitKeys[i]+="+";	 // No I18N
			}
			dkey+=splitKeys[i]
		}
		return dkey;
	}
	function bindKeyUpEvent(){
		keyUpBinded = true;
		ZC.$document.on("keyup.shortcut", function(orgEvent){	 // No I18N
			triggerShortcut(orgEvent, false);
		});
	}
	function deregisterKey(key){
		var arrangedKeys = sortKeyCombination(key);
		arrangedKeys && delete(allKeys[arrangedKeys]);
	}
	function _handleRegister(keyInfo, element, isDirectInit){
		var eventName = keyInfo.eventName || "click",	// No I18N
			handleOn = keyInfo.handleOn,
			keys = getKey(null, keyInfo);
		if(!isWindows && !keyUpBinded && handleOn === "keyup"){	// No I18N
			bindKeyUpEvent();
		}
		if(keys){
			var skipRegister =  keyInfo.skipshortcutregister || keyInfo.skipRegistration;
			for(var i=0;i<keys.length;i++){
				if(!skipRegister){
					registerKey(element, keys[i], eventName, handleOn, isDirectInit, keyInfo);
				}
				if(!keyInfo.skipShortcutFormat){
					keys[i] = getFormattedKey(keys[i]);
				}
			}
		}
		return keys ? keys : false;
	};
	return {
		init: function(options) {
			options = options || {};
			handleAction = (options.handleAction !== false);
			if (!handleAction) {
				ZC.$document.off("keydown.shortcut"); // No I18N
			}
		},
		discardInputElement: true,
		disableAction: function(actionName){
			var keyInfo = keyMap[actionName];
			if(keyInfo){
				keyInfo.disabled = true
			}
		},
		enableAction: function(actionName){
			var keyInfo = keyMap[actionName];
			if(keyInfo){
				keyInfo.disabled = false;
			}
		},
		addShortcuts: function(keysList){
			var keysList = (keysList instanceof Array)? keysList : [keysList],keyInfo;
			for(var i=0;i<keysList.length;i++){
				keyInfo = keysList[i];
				var newKey = _handleRegister(keyInfo, keyInfo.elements, true);
				keyMap[keyInfo.actionName] = keyInfo;
				keyMap[keyInfo.actionName].shortcutKey = newKey[0];
			}
		},
		register: function(element){
			var keyInfo = ZC._getOpts(element),
				shortcut = keyInfo.shortcutkey || keyInfo.shortcutKey;
				keyInfo.eventName = shortcut && shortcut.event ? shortcut.event : "click";	// No I18N
			return _handleRegister(keyInfo, element);
		},
		getShortcutKey: function(element){
			var keys = getKey(element);
			if(keys){
				for(var i=0;i<keys.length;i++){
					keys[i] = getFormattedKey(keys[i])
				}
				return keys;
			}
			return false;
		},
		getInfo: function(actionName, element, registerElement){
			if(actionName){
				var keyInfo = keyMap[actionName] || {};
				return keyInfo.shortcutKey || keyInfo.key || "";	// No I18N
			}
			else if(registerElement !== false && element){
				return this.register(element);
			}
			else if(element){
				return this.getShortcutKey(element);
			}
		},
		enable: function(){
			isShortcutEnabled = true;
		},
		disable: function(){
			isShortcutEnabled = false;
		},
		deregister: function(element){
			var keys = getKey(element);
			for(var i=0;i<keys.length;i++){
				deregisterKey(keys[i]);
			}
		}
	}
})(ZComponents);
/*
	{
	action: "bold",	// No I18N
	disabled: true,
	hidden: false,
	checked: true,
	group: "",	// No I18N
	key: ""	// No I18N
	eventName: "keyup|keydown|click"	// No I18N
	handleOn: "keyup|keydown"	// No I18N
	elements:[]
}
*/

/* eslint-disable */
(function(ZC) {
    var openedInstance = [],
        openedEle,
        $ = ZC.DOMUtil;
    function _bindEvents(element, options) {
        ((openedInstance) => {
            var componentName = options.componentName,
                forElement,
                container,
                openMethod,
                closeMethod,
                instance = element.data(componentName);
            if (instance) {
                forElement = options.forElement || $(instance._opts.forElement);
                if (!forElement || !forElement.length) {
                    return;
                }
                openMethod = componentName === 'zmenu' ? 'show' : 'open'; // No I18N
                closeMethod = componentName === 'zmenu' ? 'hide' : 'close'; // No I18N
                container = instance.element;
                if (!instance.openHandler) {
                    instance.openHandler = {
                        forElement: [ forElement ],
                        closeMethod,
                        openMethod
                    };
                } else {
                    instance.openHandler.forElement.push(forElement);
                }
                var eventPrefix = instance.isCE ? 'z' : componentName; //No I18N
                element.on(eventPrefix+'beforedestroy.'+componentName, () => ZC.removeOpenListener(componentName.slice(1), element))
                       .on(eventPrefix+'close.'+componentName , () => openedInstance.splice(openedInstance.indexOf(instance), 1));
                forElement.off('.'+componentName).data(componentName, {});
                var data = forElement.data(componentName);
                data.componentName = componentName;
                data.openMethod = openMethod;
                data.element = element;
                if (options.popOn === 'click') { // No I18N
                    forElement.off('mousedown.'+componentName).on('mousedown.'+componentName, (ev) => { // No I18N
                        closeOpened($(ev.currentTarget));
                        if (!container.is(':visible') || openedEle !== ev.currentTarget) { // No I18N
                            openedEle = ev.currentTarget;
                            instance[openMethod](options);
                            openedInstance.push(instance);
                        } else {
                            instance[closeMethod]();
                        }
                    });
                } else {
                    var eventName = options.popOn;
                    if (!/focus|mouseover/.test(eventName)) {
                        return;
                    }
                    var enterEv = eventName === 'mouseover' ? 'mouseenter.' : 'focusin.', // No I18N
                        exitEv = eventName === 'mouseover' ? 'mouseleave.' : 'focusout.'; // No I18N

                    forElement.off(enterEv+componentName+' '+exitEv+componentName)
                        .on(enterEv+componentName, (ev) => {
                            data._mouseEntered = true;
                            closeOpened($(ev.currentTarget), closeMethod);
                            if (!container.is(':visible')) {
                                instance[openMethod](options);
                                openedInstance.push(instance);
                            }
                            clearTimeout(data._mouseLeaveTimeout);
                        })
                        .on(exitEv+componentName, () => {
                            data._mouseEntered = false;
                            data._mouseLeaveTimeout = setTimeout(() => {
                                container.is(':visible') && instance[closeMethod](); // No I18N
                            }, options.mouseLeaveTime || 1500);
                        });
                    container.off(enterEv+componentName+' '+exitEv+componentName)
                        .on(enterEv+componentName, () => {
                            clearTimeout(data._mouseLeaveTimeout);
                        })
                        .on(exitEv+componentName, () => {
                            setTimeout(() => {
                                !data._mouseEntered && instance[closeMethod]();
                            }, 100);
                        });
                }
            }
        })(openedInstance);
    }
    function closeOpened(forElement) {
        for (var i = 0; i < openedInstance.length; i++) {
            var instance = openedInstance[i]
            if (instance && instance.element.is(':visible') && !forElement.closest(instance.element).length && checkElement(forElement, instance.openHandler)) {
                instance[instance.openHandler.closeMethod]();
                openedInstance.splice(i,1);
                i--;
            }
        }
    }
    function checkElement(forElement, instance) {
        var match = false;
        for (var i = 0; i < instance.forElement.length; i++) {
            var ele = instance.forElement[i];
            if (forElement[0] === ele[0]) {
                match = true;
                break;
            }
        }
        return !match;
    }
    ZC.removeOpenListener = function(componentName, element) {
        componentName = 'z'+componentName; // No I18N
        for (var i = 0; i < element.length; i++) {
            var tempEle = $(element[i]);
            var openHandlerData = tempEle.data(componentName) && tempEle.data(componentName).openHandler; // component data will be undefined if removeOpenListener is called while removing the DOM element parallely. [ Faced in Ember Application ]
            if (openHandlerData) {
                for (var j = 0; j < openHandlerData.forElement.length; j++) {
                    var ele = openHandlerData.forElement[j];
                    ele.off('.'+componentName);
                    ele.removeData(componentName);
                }
            }
        }
    }
    ZC.addOpenListener = function(componentName, bindingList) {
        componentName = 'z'+componentName; // No I18N
        for (var i = 0; i < bindingList.length; i++) {
            bindingList[i].options.componentName = componentName;
            _bindEvents(bindingList[i].element, bindingList[i].options);
        }
    }
}(ZComponents));


(function(ZC) {
    // Revisit - Can be put as a separate module in zgeneral and can be loaded based on the need. By doing so, we can avoid most of the arguments that is passed.
    let $ = ZC.DOMUtil,
        bindedElements = [],
        closeHandlerDatas = [],
        // Function to get the closehandler data associated with the component
        getHandlerData = (element) => closeHandlerDatas[bindedElements.indexOf(element)],
        // Function to check whether the component should be closed
        isToBeClosed = (target, baseElement) => {
            let handlerData = getHandlerData(baseElement);
            if (!handlerData || !document.documentElement.contains(baseElement)) {
                ZC.unBindDocumentEvents(baseElement);
                return false;
            }
            if (target.closest(handlerData.container.add(handlerData.forElement)).length) {
                return false;
            }
            let componentsInContext = handlerData.componentsInContext;
            for (let i = 0; i < componentsInContext.length; i++) {
                if (!isToBeClosed(target, componentsInContext[i])) {
                    return false;
                }
            }
            return true;
        }
    let closeHandlerNamespace = '.zclosehandler'; // No I18N
    let $window = ZC.$window;

    ZC.bindDocumentEvents = (options) => {
        let _eventSuffix = closeHandlerNamespace + '-' + (Math.floor(Math.random() * 1000000)); // No I18N
        let ctype = options.ctype;
        let element = $(options.element);
        let container = options.container && $(options.container) || element;
        let forElement = $(options.forElement);
        let closeFn = options.closeMethodName;
        let isCE = options.isCE || element.data(ctype).isCE;
        let eventPrefix = (isCE ? 'z' : ctype); // No I18N
        let closeEvent = eventPrefix + (options.closeEvent || closeFn) + closeHandlerNamespace; // No I18N
        let destroyEvent = eventPrefix + 'beforedestroy' + closeHandlerNamespace; // No I18N
        let data = getHandlerData(element[0]);
        if (data && forElement.is(data.forElement)) {
            return;
        }
        ZC.unBindDocumentEvents(element);
        bindedElements.forEach((bindedEle) => {
            let data = getHandlerData(bindedEle);
            let index = data.componentsInContext.indexOf(element[0]);
            if (forElement.closest(data.container).length) {
                if (index < 0) {
                    data.componentsInContext.push(element[0]);
                }
            } else if (index > -1) {
                data.componentsInContext.splice(index, 1);
            }
        });
        bindedElements.push(element[0]);
        let eleOptions = {
            _eventSuffix: _eventSuffix,
            forElement: forElement,
            container: container,
            ctype: ctype,
            closeFn: closeFn,
            componentsInContext: []
        }
        closeHandlerDatas.push(eleOptions);
        element.on(closeEvent + ' ' + destroyEvent, () => { // No I18N
            ZC.unBindDocumentEvents(element);
        });
        eleOptions.timer = setTimeout(() => {
            let isClosable;
            function mousedownHandler(origEvent){
                isClosable = isToBeClosed($(origEvent.target), element[0]);
            }
            $window[0].addEventListener('mousedown', mousedownHandler, true); //No I18N
            $window[0].addEventListener('contextmenu', mousedownHandler, true); //No I18N
            eleOptions.mousedownHandler = mousedownHandler;
            $window.on('mousedown' + _eventSuffix + ' contextmenu' + _eventSuffix, function(origEvent){ //No I18N
                if(isClosable){
                    let customEvent = $.Event('zclosehandlerbeforehide', { // No I18N
                        originalEvent: origEvent
                    });
                    element.trigger(customEvent);
                    if (!customEvent.isDefaultPrevented()) {
                        ZC.unBindDocumentEvents(element, true, origEvent);
                        // ZC[ctype.substr(1)](element)[closeFn]();
                    }    
                }
            });
          
        }, 10);
    }

    ZC.unBindDocumentEvents = function(element, close, origEvent) {
        let index = bindedElements.indexOf(element[0]);
        if (index !== -1) {
            let data = closeHandlerDatas[index];
            clearTimeout(data.timer);
            element.off(closeHandlerNamespace);
            $window[0].removeEventListener('mousedown', data.mousedownHandler, true); //No I18N
            $window[0].removeEventListener('contextmenu', data.mousedownHandler, true); //No I18N
            $window.off(data._eventSuffix);
            bindedElements.splice(index, 1);
            closeHandlerDatas.splice(index, 1);
            let contextEle = data.componentsInContext;
            for (let i = 0; i < contextEle.length; i++) {
                ZC.unBindDocumentEvents($(contextEle[i]), true, origEvent);
            }
            bindedElements.forEach((bindedEle) => {
                let handlerData = getHandlerData(bindedEle);
                if (handlerData.componentsInContext.length) {
                    let componentsInContext = handlerData.componentsInContext;
                    let elementIndex = componentsInContext.indexOf(element[0]);
                    if (elementIndex > -1) {
                        componentsInContext.splice(elementIndex, 1);
                    }
                }
            });
            if (close) {
                let instance = ZC[data.ctype.replace('z', '')](element); // No I18N
                instance[data.closeFn](origEvent);
            }
        }
    };
}(ZComponents));

/* $Id$ */
/*
   Prevent TAB focus from moving outside of the container like components.
   Example: Contents inside Dialog Component.
   Components using this utility: Dialog, Alert Dialog and Popover.
*/
/* eslint-disable */
ZComponents.FocusHandler = (function(ZC) {
    var $ = ZC.DOMUtil;
    'use strict'; // No I18N
    return {
        init: function(container, excludeFocus) { // prevent focus from outside of the component. Example: contents inside dialog component.
            this._setInitialFocus(container, excludeFocus);
            this._bindEvents(container, excludeFocus);
        },
        _setInitialFocus: function(container, excludeFocus = '') {
            var inputElements = container.find('input[autofocus],input[tabindex]:not([tabindex="-1"]):not([disabled]):not('+excludeFocus+'),textarea[autofocus],textarea[tabindex]:not([tabindex="-1"]):not([disabled]):not('+excludeFocus+'),button[tabindex]:not([tabindex="-1"]):not([disabled]):not('+excludeFocus+'),z-button[tabindex]:not([tabindex="-1"]):not([disabled]):not('+excludeFocus+'),.zselectbox[autofocus],.zselectbox[tabindex]:not([tabindex="-1"]):not([tabindex="0"]):not('+excludeFocus+'),li[tabindex]:not([tabindex="-1"]):not([disabled]):not('+excludeFocus+'),a[tabindex]:not([tabindex="-1"]):not([disabled]):not('+excludeFocus+')').filter(":visible");
            if (!inputElements.length) {
                inputElements = container.find('input:not([tabindex="-1"]):not([disabled]):not('+excludeFocus+'),label[tabindex]:not([tabindex="-1"]):not([disabled]):not('+excludeFocus+'),textarea:not([tabindex="-1"]):not([disabled]):not('+excludeFocus+'),button:not([tabindex="-1"]):not([disabled]):not('+excludeFocus+'),z-button:not([tabindex="-1"]):not([disabled]):not('+excludeFocus+'),li[tabindex]:not([tabindex="-1"]):not([disabled]):not('+excludeFocus+'),.zselectbox:not([tabindex="-1"]):not([disabled]):not('+excludeFocus+'),a:not([tabindex="-1"]):not([disabled]):not('+excludeFocus+')').filter(":visible"); // No I18N
                if (!inputElements.length) {
                    container.focus(); // making the container to have focus in the absence of focusable elements. Need: Dialog component's closeOnEsc feature works whenever the focus is present in the container. 
                    return;
                }
            }
            var inputObj = $(inputElements.get(inputElements.length - 1)),
                tabIndex = inputObj.prop('tabindex'); // No I18N
            inputElements.toArray().forEach(function(inputEle) {
                if ($(inputEle).prop('tabindex') < tabIndex || $(inputEle).attr('autofocus')) { // No I18N
                    inputObj = $(inputEle);
                    tabIndex = $(inputEle).prop('tabindex');
                }
            });
            if (inputObj.hasClass('zselectbox') || inputObj.hasClass('zselectbox__textbox')) {	// No I18N
                inputObj = inputObj.closest('.zselectbox'); // No I18N
                if (inputObj.hasClass('zcombobox')) {
                    inputObj.prev().zcombobox('setFocus');	// No I18N
                } else {
                    inputObj.prev().zselect('setFocus');	// No I18N
                }
            } else {
                inputObj.focus();
            }

        },
        _bindEvents: function(container, excludeFocus = '') {
            var base = this,
                childElements = container.find('input:not([tabindex="-1"]):not('+excludeFocus+'),label[tabindex]:not([tabindex="-1"]):not('+excludeFocus+'),textarea:not([tabindex="-1"]):not('+excludeFocus+'),li[tabindex]:not([tabindex="-1"]):not('+excludeFocus+'),button:not([tabindex="-1"]):not('+excludeFocus+'),z-button:not([tabindex="-1"]):not('+excludeFocus+'),.zselectbox:not([tabindex="-1"]):not('+excludeFocus+'),a:not([tabindex="-1"]):not('+excludeFocus+'),div[tabindex]:not([tabindex="-1"]):not('+excludeFocus+'),div[contenteditable]:not([tabindex="-1"]):not('+excludeFocus+')').filter(":visible"); // No I18N
            container.off('keydown.zfocushandler').on('keydown.zfocushandler', function(event) { // No I18N
                if (event.which === ZC.keyCode.TAB) {
                    var len = childElements.length,
                        currIndex = childElements.index(event.target);
                    currIndex += event.shiftKey ? -1 : 1;
                    if (currIndex === len) {
                        currIndex = 0;
                    } else if (currIndex === -1) {
                        currIndex = len - 1;
                    }
                    var nextEle = $(childElements[currIndex]);
                    if (currIndex === 0 || currIndex === len - 1 || nextEle[0].disabled) {
                        if (nextEle[0].disabled) {
                            nextEle = base._findNextActiveElement(currIndex, childElements, event.shiftKey);
                        }
                        nextEle.focus();
                        event.preventDefault();
                        event.stopPropagation();
                    }
                }
            });
        },
        _findNextActiveElement: function(currIndex, arr, backward) {
            var len = arr.length;
            if(!backward && currIndex === arr.length - 1){
                currIndex = -1;
            }
            if(backward && currIndex === 0){
                currIndex = len;
            }
            var i = currIndex + (backward ? -1 : 1),
                toIndex = currIndex + (backward ? 1 : -1);
            while (backward ? (i >= toIndex || i >= 0) : (i <= toIndex || i < len)) {
                if (!arr[i].disabled) {
                    return $(arr[i]);
                }
                i = i === 0 && backward ? len - 1 : (i === len - 1 && !backward ? 0 : (backward ? i - 1 : i + 1));
            }
        },
        destroy: function(container) {
            container.off('keydown.zfocushandler'); // No I18N
        },
        refresh: function(container, excludeFocus, setFocus) {
            this._bindEvents(container, excludeFocus);
            setFocus && this._setInitialFocus(container, excludeFocus);
        }
    }
}(ZComponents));

/** $Id$ */
/*
 * Contains library methods for color , math , array.
 * Contributors :
 * J.Karthik - jkarthik@zohocorp.com ,
 * Sridhar P.G - sridharpg@zohocorp.com ,
 * Padmanabhan - padmanabhan.p@zohocorp.com
 */

(function(ZC) {
    let $ = ZC.DOMUtil;
    ZC.ColorUtil = {
        // rgb - An Array containing values for red, green, blue.
        //Ref
        //sass
        //https://cdnjs.cloudflare.com/ajax/libs/tinycolor/1.4.1/tinycolor.js
        /**
         * determinant value 0.25 means 25% darken.
         * which internally means (100 - 25) 75% luminance modulated.
         * luminance_new = (1 - determinant) * luminance.
         */
        darken: function(rgb, determinant) {
            determinant = this.limit(determinant, 0, 1);
            let a = [ {
                mode: 'MODIFY', // No I18N
                value: 1 - determinant
            } ];
            return this.hsl(rgb, {
                luminance: a
            });
        },  

        /**
         * determinant value 0.6 means 60% lighten.
         * which internally means (100 - 60) 40% luminance modulated and 60% luminance shifted.
         * luminance_new = (1 - determinant) * luminance + determinant
         */
        lighten: function(rgb, determinant) {
            determinant = this.limit(determinant, 0, 1);
            let a = [ {
                mode: 'MODIFY', // No I18N
                value: 1 - determinant
            }, {
                mode: 'OFFSET', // No I18N
                value: determinant
            } ];
            return this.hsl(rgb, {
                luminance: a
            });
        },
        /**
         * Modification done accoring to MS Format.
         * social.msdn.microsoft.com/Forums/en-US/oxmlsdk/thread/f6d26f2c-114f-4a0d-8bca-a27442aec4d0
         * Based on https://www.w3.org/TR/css-color-4/#tint-shade-adjusters
         * 10% shade means - 10% black mixed with 90% pure color
         */
        shade: function(rgb, determinant) {
            determinant = this.limit(determinant, 0, 1);
            let a = [ {
                mode: 'MODIFY', // No I18N
                value: 1 - determinant
            } ];
            return this.rgb(rgb, {
                red: a,
                green: a,
                blue: a
            });
        },
        /* 10% tint means - 10% white mixed with 90% pure color
            */
        tint: function(rgb, determinant) {
            determinant = this.limit(determinant, 0, 1);
            let a = [ {
                mode: 'MODIFY', // No I18N
                value: 1 - determinant
            }, {
                mode: 'OFFSET', // No I18N
                value: determinant
            } ];
            return this.rgb(rgb, {
                red: a,
                green: a,
                blue: a
            });
        },

        rgb: function(rgb, rgbMod) {
            return this.modify(rgb, rgbMod, 'linearRGB'); // No I18N
        },

        /**
         * social.msdn.microsoft.com/Forums/en-US/oxmlsdk/thread/f6d26f2c-114f-4a0d-8bca-a27442aec4d0
         */
        tolinearRGB: function(rgb) {
            return rgb.map((value) => {
                value = value / 255;
                if (value < 0) {
                    return 0;
                }
                if (value <= 0.0405) {
                    return value / 12.92;
                }
                if (value <= 1) {
                    let x = (value + 0.055) / 1.055;
                    return Math.pow(x, 2.4);
                }
                return 1;
            });
        },

        /*
            * social.msdn.microsoft.com/Forums/en-US/oxmlsdk/thread/f6d26f2c-114f-4a0d-8bca-a27442aec4d0
            */
        linearRGBtoRGB: function(scrgb) {
            return scrgb.map((value) => {
                if (value < 0) {
                    value = 0;
                } else if (value <= 0.0031308) {
                    value *= 12.92;
                } else if (value <= 1) {
                    let y = 1 / 2.4;
                    value = 1.055 * Math.pow(value, y) - 0.055;
                } else {
                    value = 1;
                }
                return Math.round(value *= 255);
            });
        },

        modify: function(rgb, modObjects, mode) {
            let clrArr = this[`to${mode}`](rgb); // No I18N
            let mapping = {
                red: 0,
                green: 1,
                blue: 2,
                luminance: 2
            }
            for (let key in modObjects) {
                let index = mapping[key];
                modObjects[key].forEach((modObject) => {
                    clrArr[index] = this.modifyValue(clrArr[index], modObject);
                });
            }
            return this[`${mode}toRGB`](clrArr); // No I18N
        },

        modifyValue: function(value, modObject) {
            if (modObject.mode === 'MODIFY') { // No I18N
                value *= parseFloat(modObject.value);
            } else if (modObject.mode === 'OFFSET') { // No I18N
                value += parseFloat(modObject.value);
            }
            return value;
        },

        hsl: function(rgb, hslMod) {
            return this.modify(rgb, hslMod, 'HSL'); // No I18N
        },

        /**
         * en.wikipedia.org/wiki/HSL_and_HSV
         * returns hsl , h ranges from 0 - 1, s from 0 - 1 ,  l from 0 - 1
         */
        toHSL: function(rgb) {
            let r = rgb[0];
            let g = rgb[1];
            let b = rgb[2];
            let max = Math.max(...rgb);
            let min = Math.min(...rgb);

            let h = 0;
            let n;
            if (max === min) {
                h = 0;
            } else if (max === r) {
                n = (g - b) / (max - min);
                h = (60 * n + 360) % 360;
            } else if (max === g) {
                n = (b - r) / (max - min);
                h = 60 * n + 120;
            } else { // b
                n = (r - g) / (max - min);
                h = 60 * n + 240;
            }
            h /= 360;

            let l = (max + min) / (255 * 2);

            let s = 0;
            if (max === min) {
                s = 0;
            } else if (l <= 0.5) {
                s = (max - min) / (2 * l);
            } else {
                s = (max - min) / (2 - 2 * l);
            }
            s /= 255;

            return [ h, s, l ];
        },

        /**
         * en.wikipedia.org/wiki/HSL_and_HSV
         * argument hsl , h ranges from 0 - 1 , s from 0 - 1 ,  l from 0 - 1
         * returns rgb
         */
        HSLtoRGB: function(hsl) {
            let h = hsl[0];
            let s = hsl[1];
            let l = hsl[2];

            let q;
            if (l < 0.5) {
                q = l * (1 + s);
            } else {
                q = l + s - l * s;
            }

            let p = 2 * l - q;
            let hk = h;

            let tr = hk + 1 / 3;
            let tg = hk;
            let tb = hk - 1 / 3;

            return [ tr, tg, tb ].map((value) => {
                if (value < 0) {
                    value += 1;
                } else if (value > 1) {
                    value -= 1;
                }

                value = value % 1;

                if (value < 1 / 6) {
                    value = p + (q - p) * 6 * value;
                } else if (value >= 1 / 6 && value < 0.5) {
                    value = q;
                } else if (value >= 0.5 && value < 2 / 3) {
                    value = p + (q - p) * 6 * (2 / 3 - value);
                } else {
                    value = p;
                }
                return Math.round(this.limit(value, 0, 1) * 255);
            });
        },
        /* https://en.wikipedia.org/wiki/Talk%3ACMYK_color_model */
        cmykToRGB: function(cmyk) {
            let r = 255 * (1 - cmyk[0]) * (1 - cmyk[3]);
            let g = 255 * (1 - cmyk[1]) * (1 - cmyk[3]);
            let b = 255 * (1 - cmyk[2]) * (1 - cmyk[3]);
            return [ r, g, b ];
        },
        /* https://en.wikipedia.org/wiki/Talk%3ACMYK_color_model */
        rgbToCMYK: function(rgb) {
            let c = 1 - rgb[0] / 255;
            let m = 1 - rgb[1] / 255;
            let y = 1 - rgb[2] / 255;

            let minCMY = Math.min(c, m, y);
            c = (c - minCMY) / (1 - minCMY);
            m = (m - minCMY) / (1 - minCMY);
            y = (y - minCMY) / (1 - minCMY);
            let k = minCMY;

            // 0/0 may result in **NaN**
            c = isNaN(c) ? 0 : c;
            m = isNaN(m) ? 0 : m;
            y = isNaN(y) ? 0 : y;
            return [ c, m, y, k ];
        },
        isDark: function(rgb) {
            return this.brightness(rgb) < 0.5 * 255;
        },
        rgbToHex: function(rgb) {
            let hex = '#';// No I18N
            rgb.forEach((value) => {
                hex += ZC.ColorUtil.numToHex(value);
            });
            return hex;
        },
        rgbToHSV: function(rgb) {
            let r = rgb[0] / 255;
            let g = rgb[1] / 255;
            let b = rgb[2] / 255;

            let min = Math.min(r, g, b);
            let max = Math.max(r, g, b);

            let v = max * 100;
            let h = 0;
            let s = 0;

            let delta = max - min;
            if (max === 0) {
                // #000
                s = h = 0;
                return [ h, s, v ];

            }
            s = delta / max * 100;
            let sector = 0;
            if (delta) {
                if (r === max) {
                    sector = (g - b) / delta;
                } else if (g === max) {
                    sector = 2 + (b - r) / delta;
                } else {
                    sector = 4 + (r - g) / delta;
                }
            }
            h = sector * 60;
            if (h < 0) {
                h += 360;
            }
            let _r = Math.round;
            h = _r(h * 100) / 100;
            s = _r(s * 100) / 100;
            v = _r(v * 100) / 100;
            return [ h, s, v ];
        },
        hsvToRGB: function(hsv) {
            // www.cs.rit.edu/~ncs/color/t_convert.html
            let h = hsv[0];
            let s = hsv[1];
            let v = hsv[2];

            let _s = s / 100;
            let _v = v / 100;
            let r, g, b;
            r = g = b = 0;
            let set = function(_r, _g, _b) {
                let _rd = Math.round;
                r = _rd(_r * 255);
                g = _rd(_g * 255);
                b = _rd(_b * 255);
            };

            if (_s === 0) {
                set(_v, _v, _v);
                return [ r, g, b ];
            }

            if (h === 360) {
                h = 0;
            }

            let _sector = h / 60;
            let sector = Math.floor(_sector);
            let factorial = _sector - sector;

            let p = _v * (1 - _s);
            let q = _v * (1 - _s * factorial);
            let t = _v * (1 - _s * (1 - factorial));

            switch (sector) {
                case 0:
                    set(_v, t, p);
                    break;
                case 1:
                    set(q, _v, p);
                    break;
                case 2:
                    set(p, _v, t);
                    break;
                case 3:
                    set(p, q, _v);
                    break;
                case 4:
                    set(t, p, _v);
                    break;
                default:
                    set(_v, p, q);
            }

            return [ r, g, b ];
        },
        /* number -> 0 - 255 */
        numToHex: function(number) {
            let hexCode = parseInt(number).toString(16);
            return hexCode.length === 1 ? `0${hexCode}` : hexCode;
        },

        hexToNum: function(hex) {
            return parseInt(hex, 16);
        },
        // Algorithm to find brightness www.w3.org/TR/AERT
        brightness: function(rgb) {
            let r = rgb[0];
            let g = rgb[1];
            let b = rgb[2];
            return r * 0.299 + g * 0.587 + b * 0.114;
        },
        limit: function(val, min, max) {
            return Math.max(Math.min(val, max), min);
        },
        getColorInstance: function(color) {
            return new ZC.Color(color);
        },
        REGEX: {
            colorMode: /^(rgb|rgba|hsl|hsla|hsv|hsva|hex|hex8|cmyk)$/
        }

    }

    ZC.Color = function(color) {
        this.init(color);
        return this;
    }
    ZC.Color.prototype = {
        init: function(color) {
            this.initialColor = color;
            color = inputToRGB(color);
            if (color) {
                this._r = color.r;
                this._g = color.g;
                this._b = color.b;
                this._a = color.a;
                this.format = color.format;
                this.colorInFormat = color.colorInFormat;
                this._valid = true;
            } else {
                this._valid = false;
            }
        },
        isValid: function() {
            return this._valid;
        },
        colorCodeMapping: {
            hue: 'decimal', // No I18N
            saturation: 'percent', // No I18N
            brightness: 'percent', // No I18N
            lightness: 'percent', // No I18N
            rgb: 'decimal', // No I18N
            cmyk: 'percent', // No I18N
            opacity: 'decimal' // No I18N
        },
        getObject: function(format, colorCodeMapping) {
            /* var rgb = [ this._r, this._g, this._b ];
            var r = Math.round;
            if( /(hsv)/.test(format)  ){
            	var hsv = ZC.ColorUtil.rgbToHSV( rgb );
            	return { h: r( hsv[0] ), s: r(hsv[1])+'%', v:r(hsv[2])+'%', a: this._a };
            }else if( /(hsl)/.test(format) ){
            	var hsl = ZC.ColorUtil.toHSL( rgb );
            	return { h: r( hsl[0]*360 ), s: r(hsl[1]*100) +'%', l:r(hsl[2]*100) +'%', a: this._a };
            }else if(/(cmyk)/.test(format)){
            	var cmyk = ZC.ColorUtil.rgbToCMYK( rgb );
            	return {c: r(  ) }
            }else if( format === 'hex'){
            	return ZC.ColorUtil.rgbToHex( rgb ).replace(/#/,'');
            }else if( format === 'hex8' ){
            	return ZC.ColorUtil.rgbToHex( rgb ).replace(/#/,'') + ZC.ColorUtil.numToHex( this._a*255 );
            }else{
            	return { r: r( this._r ), g: r( this._g ), b: r( this._b ), a: this._a };
            } */
            colorCodeMapping = colorCodeMapping ? $.extend({}, this.colorCodeMapping, colorCodeMapping) : this.colorCodeMapping;
            let rgb = [ this._r, this._g, this._b ];
            let r = Math.round;
            let fixTo2 = function(value) {
                return r(value * 100) / 100;
            }
            let getHue = function(type, frac) {
                return type === 'percent' ? fixTo2(frac * 100) + '%' : r(frac * 360); // No I18N
            }
            let getRGB = function(type, frac) {
                return type === 'percent' ? fixTo2(frac * 100) + '%' : r(frac * 255); // No I18N
            }
            let getDefault = function(type, frac) {
                return type === 'decimal' ? fixTo2(frac) : r(frac * 100) + '%'; // No I18N
            }
            if (/(hsv)/.test(format)) {
                let hsv = [];
                if (/(hsv)/.test(this.format)) {
                    hsv[0] = this.colorInFormat.h;
                    hsv[1] = this.colorInFormat.s;
                    hsv[2] = this.colorInFormat.v;
                } else {
                    hsv = ZC.ColorUtil.rgbToHSV(rgb);
                    if (/(hsl)/.test(this.format)) {
                        hsv[0] = this.colorInFormat.h * 360;
                    }
                }
                return {
                    h: getHue(colorCodeMapping.hue, hsv[0] / 360),
                    s: getDefault(colorCodeMapping.saturation, hsv[1] / 100),
                    v: getDefault(colorCodeMapping.brightness, hsv[2] / 100),
                    a: getDefault(colorCodeMapping.opacity, this._a)
                }
            } else if (/(hsl)/.test(format)) {
                let hsl = [];
                if (/(hsl)/.test(this.format)) {
                    hsl[0] = this.colorInFormat.h;
                    hsl[1] = this.colorInFormat.s;
                    hsl[2] = this.colorInFormat.l;
                } else {
                    hsl = ZC.ColorUtil.toHSL(rgb);
                    if (/(hsv)/.test(this.format)) {
                        hsl[0] = this.colorInFormat.h / 360;
                    }
                }
                return {
                    h: getHue(colorCodeMapping.hue, hsl[0]),
                    s: getDefault(colorCodeMapping.saturation, hsl[1]),
                    l: getDefault(colorCodeMapping.lightness, hsl[2]),
                    a: getDefault(colorCodeMapping.opacity, this._a)
                }
            } else if (/(cmyk)/.test(format)) {
                let cmyk = [];
                if (/(cmyk)/.test(this.format)) {
                    cmyk[0] = this.colorInFormat.c;
                    cmyk[1] = this.colorInFormat.m;
                    cmyk[2] = this.colorInFormat.y;
                    cmyk[3] = this.colorInFormat.k;
                } else {
                    cmyk = ZC.ColorUtil.rgbToCMYK(rgb);
                }
                return {
                    c: getDefault(colorCodeMapping.cmyk, cmyk[0]),
                    m: getDefault(colorCodeMapping.cmyk, cmyk[1]),
                    y: getDefault(colorCodeMapping.cmyk, cmyk[2]),
                    k: getDefault(colorCodeMapping.cmyk, cmyk[3])
                }
            } else if (/(hex)/.test(format)) {
                return {
                    hex: ZC.ColorUtil.rgbToHex(rgb).replace(/#/, ''), // No I18N
                    a: getDefault(colorCodeMapping.opacity, this._a)
                }
            }
            return {
                r: getRGB(colorCodeMapping.rgb, rgb[0] / 255),
                g: getRGB(colorCodeMapping.rgb, rgb[1] / 255),
                b: getRGB(colorCodeMapping.rgb, rgb[2] / 255),
                a: getDefault(colorCodeMapping.opacity, this._a)
            }

        },
        getPercentageObject: function(format) {
            let color = this.getObject(format);
            if (/(hsv|hsl)/.test(format)) {
                color.h = color.h / 360 * 100 + '%'; // No I18N
                color.a = color.a * 100 + '%'; // No I18N
            } else if (/(rgb)/.test(format)) {
                color.r = color.r / 255 * 100 + '%'; // No I18N
                color.g = color.g / 255 * 100 + '%'; // No I18N
                color.b = color.b / 255 * 100 + '%'; // No I18N
                color.a = color.a * 100 + '%'; // No I18N
            }
            return color;
        },
        getColor: function(format, colorCodeMapping, flexible) {
            let color = this.getObject(format, colorCodeMapping);
            if (color) {
                let isAlpha = this._a !== 1;
                flexible = flexible === undefined ? true : flexible;
                if (/^(hsv)/.test(format)) {
                    format = flexible ? isAlpha ? 'hsva' : 'hsv' : format; // No I18N
                    if (/^(hsva)/.test(format)) {
                        return 'hsva(' + color.h + ', ' + color.s + ', ' + color.v + ', ' + color.a + ')'; // No I18N
                    }
                    return 'hsv(' + color.h + ', ' + color.s + ', ' + color.v + ')'; // No I18N
                } else if (/^(hsl)/.test(format)) {
                    format = flexible ? isAlpha ? 'hsla' : 'hsl' : format; // No I18N
                    if (/^(hsla)/.test(format)) {
                        return 'hsla(' + color.h + ', ' + color.s + ', ' + color.l + ', ' + color.a + ')'; // No I18N
                    }
                    return 'hsl(' + color.h + ', ' + color.s + ', ' + color.l + ')'; // No I18N
                } else if (/^(cmyk)$/.test(format)) {
                    return 'cmyk(' + color.c + ',' + color.m + ',' + color.y + ',' + color.k + ')'; // No I18N
                } else if (/^(hex)/.test(format)) {
                    format = flexible ? isAlpha ? 'hex8' : 'hex' : format; // No I18N
                    if (/^(hex8)/.test(format)) {
                        return '#' + color.hex + ZC.ColorUtil.numToHex(this._a * 255); // No I18N
                    }
                    return '#' + color.hex; // No I18N
                }
                format = flexible || !/(rgb)/.test(format) ? isAlpha ? 'rgba' : 'rgb' : format; // No I18N
                if (/^(rgba)/.test(format)) {
                    return 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + color.a + ')'; // No I18N
                }
                return 'rgb(' + color.r + ', ' + color.g + ', ' + color.b + ')'; // No I18N

            }
        },
        setAlpha: function(alpha) {
            this._a = validate('a', alpha); // No I18N
        },
        getAlpha: function() {
            return this._a;
        },
        setColor: function(color) {
            this.init(color);
        }
    }
    // <http://www.w3.org/TR/css3-color/#svg-color>
    let colornames = {
        aliceblue: '#f0f8ff', // No I18N
        antiquewhite: '#faebd7', // No I18N
        aqua: '#00ffff', // No I18N
        aquamarine: '#7fffd4', // No I18N
        azure: '#f0ffff', // No I18N
        beige: '#f5f5dc', // No I18N
        bisque: '#ffe4c4', // No I18N
        black: '#000000', // No I18N
        blanchedalmond: '#ffebcd', // No I18N
        blue: '#0000ff', // No I18N
        blueviolet: '#8a2be2', // No I18N
        brown: '#a52a2a', // No I18N
        burlywood: '#deb887', // No I18N
        cadetblue: '#5f9ea0', // No I18N
        chartreuse: '#7fff00', // No I18N
        chocolate: '#d2691e', // No I18N
        coral: '#ff7f50', // No I18N
        cornflowerblue: '#6495ed', // No I18N
        cornsilk: '#fff8dc', // No I18N
        crimson: '#dc143c', // No I18N
        cyan: '#00ffff', // No I18N
        darkblue: '#00008b', // No I18N
        darkcyan: '#008b8b', // No I18N
        darkgoldenrod: '#b8860b', // No I18N
        darkgray: '#a9a9a9', // No I18N
        darkgreen: '#006400', // No I18N
        darkgrey: '#a9a9a9', // No I18N
        darkkhaki: '#bdb76b', // No I18N
        darkmagenta: '#8b008b', // No I18N
        darkolivegreen: '#556b2f', // No I18N
        darkorange: '#ff8c00', // No I18N
        darkorchid: '#9932cc', // No I18N
        darkred: '#8b0000', // No I18N
        darksalmon: '#e9967a', // No I18N
        darkseagreen: '#8fbc8f', // No I18N
        darkslateblue: '#483d8b', // No I18N
        darkslategray: '#2f4f4f', // No I18N
        darkslategrey: '#2f4f4f', // No I18N
        darkturquoise: '#00ced1', // No I18N
        darkviolet: '#9400d3', // No I18N
        deeppink: '#ff1493', // No I18N
        deepskyblue: '#00bfff', // No I18N
        dimgray: '#696969', // No I18N
        dimgrey: '#696969', // No I18N
        dodgerblue: '#1e90ff', // No I18N
        firebrick: '#b22222', // No I18N
        floralwhite: '#fffaf0', // No I18N
        forestgreen: '#228b22', // No I18N
        fuchsia: '#ff00ff', // No I18N
        gainsboro: '#dcdcdc', // No I18N
        ghostwhite: '#f8f8ff', // No I18N
        gold: '#ffd700', // No I18N
        goldenrod: '#daa520', // No I18N
        gray: '#808080', // No I18N
        green: '#008000', // No I18N
        greenyellow: '#adff2f', // No I18N
        grey: '#808080', // No I18N
        honeydew: '#f0fff0', // No I18N
        hotpink: '#ff69b4', // No I18N
        indianred: '#cd5c5c', // No I18N
        indigo: '#4b0082', // No I18N
        ivory: '#fffff0', // No I18N
        khaki: '#f0e68c', // No I18N
        lavender: '#e6e6fa', // No I18N
        lavenderblush: '#fff0f5', // No I18N
        lawngreen: '#7cfc00', // No I18N
        lemonchiffon: '#fffacd', // No I18N
        lightblue: '#add8e6', // No I18N
        lightcoral: '#f08080', // No I18N
        lightcyan: '#e0ffff', // No I18N
        lightgoldenrodyellow: '#fafad2', // No I18N
        lightgray: '#d3d3d3', // No I18N
        lightgreen: '#90ee90', // No I18N
        lightgrey: '#d3d3d3', // No I18N
        lightpink: '#ffb6c1', // No I18N
        lightsalmon: '#ffa07a', // No I18N
        lightseagreen: '#20b2aa', // No I18N
        lightskyblue: '#87cefa', // No I18N
        lightslategray: '#778899', // No I18N
        lightslategrey: '#778899', // No I18N
        lightsteelblue: '#b0c4de', // No I18N
        lightyellow: '#ffffe0', // No I18N
        lime: '#00ff00', // No I18N
        limegreen: '#32cd32', // No I18N
        linen: '#faf0e6', // No I18N
        magenta: '#ff00ff', // No I18N
        maroon: '#800000', // No I18N
        mediumaquamarine: '#66cdaa', // No I18N
        mediumblue: '#0000cd', // No I18N
        mediumorchid: '#ba55d3', // No I18N
        mediumpurple: '#9370db', // No I18N
        mediumseagreen: '#3cb371', // No I18N
        mediumslateblue: '#7b68ee', // No I18N
        mediumspringgreen: '#00fa9a', // No I18N
        mediumturquoise: '#48d1cc', // No I18N
        mediumvioletred: '#c71585', // No I18N
        midnightblue: '#191970', // No I18N
        mintcream: '#f5fffa', // No I18N
        mistyrose: '#ffe4e1', // No I18N
        moccasin: '#ffe4b5', // No I18N
        navajowhite: '#ffdead', // No I18N
        navy: '#000080', // No I18N
        oldlace: '#fdf5e6', // No I18N
        olive: '#808000', // No I18N
        olivedrab: '#6b8e23', // No I18N
        orange: '#ffa500', // No I18N
        orangered: '#ff4500', // No I18N
        orchid: '#da70d6', // No I18N
        palegoldenrod: '#eee8aa', // No I18N
        palegreen: '#98fb98', // No I18N
        paleturquoise: '#afeeee', // No I18N
        palevioletred: '#db7093', // No I18N
        papayawhip: '#ffefd5', // No I18N
        peachpuff: '#ffdab9', // No I18N
        peru: '#cd853f', // No I18N
        pink: '#ffc0cb', // No I18N
        plum: '#dda0dd', // No I18N
        powderblue: '#b0e0e6', // No I18N
        purple: '#800080', // No I18N
        rebeccapurple: '#663399', // No I18N
        red: '#ff0000', // No I18N
        rosybrown: '#bc8f8f', // No I18N
        royalblue: '#4169e1', // No I18N
        saddlebrown: '#8b4513', // No I18N
        salmon: '#fa8072', // No I18N
        sandybrown: '#f4a460', // No I18N
        seagreen: '#2e8b57', // No I18N
        seashell: '#fff5ee', // No I18N
        sienna: '#a0522d', // No I18N
        silver: '#c0c0c0', // No I18N
        skyblue: '#87ceeb', // No I18N
        slateblue: '#6a5acd', // No I18N
        slategray: '#708090', // No I18N
        slategrey: '#708090', // No I18N
        snow: '#fffafa', // No I18N
        springgreen: '#00ff7f', // No I18N
        steelblue: '#4682b4', // No I18N
        tan: '#d2b48c', // No I18N
        teal: '#008080', // No I18N
        thistle: '#d8bfd8', // No I18N
        tomato: '#ff6347', // No I18N
        turquoise: '#40e0d0', // No I18N
        violet: '#ee82ee', // No I18N
        wheat: '#f5deb3', // No I18N
        white: '#ffffff', // No I18N
        whitesmoke: '#f5f5f5', // No I18N
        yellow: '#ffff00', // No I18N
        yellowgreen: '#9acd32' // No I18N
    }
    let matchers = (function() {
        // <http://www.w3.org/TR/css3-values/#integers>
        let INT = '[-\\+]?\\d+%?'; // No I18N

        // <http://www.w3.org/TR/css3-values/#number-value>
        let NUM = '[-\\+]?\\d*\\.\\d+%?'; // No I18N

        // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
        let VALUEPATTERN = '(?:' + NUM + ')|(?:' + INT + ')'; // No I18N

        // Actual matching.
        // Parentheses and commas are optional, but not required.
        // Whitespace can take the place of commas or opening paren
        let MATCH3 = '[\\s|\\(]+(' + VALUEPATTERN + ')[,|\\s]+(' + VALUEPATTERN + ')[,|\\s]+(' + VALUEPATTERN + ')\\s*\\)?'; // No I18N
        let MATCH4 = '[\\s|\\(]+(' + VALUEPATTERN + ')[,|\\s]+(' + VALUEPATTERN + ')[,|\\s]+(' + VALUEPATTERN + ')[,|\\s]+(' + VALUEPATTERN + ')\\s*\\)?'; // No I18N

        return {
            value: new RegExp(VALUEPATTERN),
            rgb: new RegExp('rgb' + MATCH3), // No I18N
            rgba: new RegExp('rgba' + MATCH4), // No I18N
            hsl: new RegExp('hsl' + MATCH3), // No I18N
            hsla: new RegExp('hsla' + MATCH4), // No I18N
            hsv: new RegExp('hsv' + MATCH3), // No I18N
            hsva: new RegExp('hsva' + MATCH4), // No I18N
            cmyk: new RegExp('cmyk' + MATCH4), // No I18N
            hex3: /^#?([0-9a-f]{1})([0-9a-f]{1})([0-9a-f]{1})$/,
            hex6: /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/,
            hex8: /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/
            // hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        };
    }());
    let validate = function(prop, value) {
        let isper = /%/.test(value);
        value = isper ? parseFloat(value) / 100 : parseFloat(value);
        if (prop === 'h') { // No I18N
            return Math.round(ZC.ColorUtil.limit(isper ? value * 360 : value, 0, 360));
        } else if (/(s|v|l)/.test(prop)) {
            return Math.round(ZC.ColorUtil.limit(value * 100, 0, 100));
        } else if (/(c|m|y|k)/.test(prop)) {
            return Math.round(ZC.ColorUtil.limit(value, 0, 1) * 100) / 100;
        } else if (/(r|g|b)/.test(prop)) {
            return Math.round(ZC.ColorUtil.limit(isper ? value * 255 : value, 0, 255));
        } else if (prop === 'a') { // No I18N
            return value === undefined || isNaN(value) || value < 0 || value > 1 ? 1 : value;
        }
    }
    let inputToRGB = function(color) {
        color = inputToObject(color);
        if (typeof color === 'object') { // No I18N
            let format = color.format;
            let rgb;
            if (color.hasOwnProperty('h') && color.hasOwnProperty('s') && color.hasOwnProperty('v')) { // No I18N
                format = format || 'hsva'; // No I18N
                color.h = validate('h', color.h); // No I18N
                color.s = validate('s', color.s); // No I18N
                color.v = validate('v', color.v); // No I18N
                rgb = ZC.ColorUtil.hsvToRGB([ color.h, color.s, color.v ]);
            } else if (color.hasOwnProperty('h') && color.hasOwnProperty('s') && color.hasOwnProperty('l')) { // No I18N
                format = format || 'hsla'; // No I18N
                color.h = validate('h', color.h) / 360; // No I18N
                color.s = validate('s', color.s) / 100; // No I18N
                color.l = validate('l', color.l) / 100; // No I18N
                rgb = ZC.ColorUtil.HSLtoRGB([ color.h, color.s, color.l ]);
            } else if (color.hasOwnProperty('r') && color.hasOwnProperty('g') && color.hasOwnProperty('b')) { // No I18N
                format = format || 'rgba'; // No I18N
                color.r = validate('r', color.r); // No I18N
                color.g = validate('g', color.g); // No I18N
                color.b = validate('b', color.b); // No I18N
                rgb = [ color.r, color.g, color.b ];
            } else if (color.hasOwnProperty('c') && color.hasOwnProperty('m') && color.hasOwnProperty('y') && color.hasOwnProperty('k')) { // No I18N
                format = format || 'cmyk'; // No I18N
                color.c = validate('c', color.c); // No I18N
                color.m = validate('m', color.m); // No I18N
                color.y = validate('y', color.y); // No I18N
                color.k = validate('k', color.k); // No I18N
                rgb = ZC.ColorUtil.cmykToRGB([ color.c, color.m, color.y, color.k ]);
            } else if (color.hasOwnProperty('hex')) { // No I18N
                format = format || 'hex'; // No I18N
                rgb = inputToObject(color.hex);
                if (!rgb) {
                    return;
                }
                rgb = [ rgb.r, rgb.g, rgb.b ];
            }
            if (rgb) {
                return {
                    r: rgb[0],
                    g: rgb[1],
                    b: rgb[2],
                    a: validate('a', color.a), // No I18N
                    format: format,
                    colorInFormat: color
                }
            }
        }
    }
    let inputToObject = function(color) {
        if (typeof color === 'string' || typeof color === 'number') { // No I18N
            color = color.trim().toLowerCase();
            let isName = false;
            if (colornames[color]) {
                color = colornames[color];
                isName = true;
            } else if (color === 'transparent') { // No I18N
                return {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0
                };
            }
            let match = matchers.rgb.exec(color)
            if (match) {
                return {
                    r: match[1],
                    g: match[2],
                    b: match[3],
                    format: 'rgb' // No I18N
                };
            }
            match = matchers.rgba.exec(color);
            if (match) {
                return {
                    r: match[1],
                    g: match[2],
                    b: match[3],
                    a: match[4],
                    format: 'rgba' // No I18N
                };
            }
            match = matchers.hsl.exec(color)
            if (match) {
                return {
                    h: match[1],
                    s: match[2],
                    l: match[3],
                    format: 'hsl' // No I18N
                };
            }
            match = matchers.hsla.exec(color)
            if (match) {
                return {
                    h: match[1],
                    s: match[2],
                    l: match[3],
                    a: match[4],
                    format: 'hsla' // No I18N
                };
            }
            match = matchers.hsv.exec(color)
            if (match) {
                return {
                    h: match[1],
                    s: match[2],
                    v: match[3],
                    format: 'hsv' // No I18N
                };
            }
            match = matchers.hsva.exec(color)
            if (match) {
                return {
                    h: match[1],
                    s: match[2],
                    v: match[3],
                    a: match[4],
                    format: 'hsva' // No I18N
                };
            }
            match = matchers.cmyk.exec(color)
            if (match) {
                return {
                    c: match[1],
                    m: match[2],
                    y: match[3],
                    k: match[4],
                    format: 'cmyk' // No I18N
                };
            }
            match = matchers.hex8.exec(color)
            if (match) {
                return {
                    r: ZC.ColorUtil.hexToNum(match[1]),
                    g: ZC.ColorUtil.hexToNum(match[2]),
                    b: ZC.ColorUtil.hexToNum(match[3]),
                    a: Math.round(ZC.ColorUtil.hexToNum(match[4]) / 255 * 100) / 100,
                    format: 'hex8' // No I18N
                };
            }
            match = matchers.hex6.exec(color)
            if (match) {
                return {
                    r: ZC.ColorUtil.hexToNum(match[1]),
                    g: ZC.ColorUtil.hexToNum(match[2]),
                    b: ZC.ColorUtil.hexToNum(match[3]),
                    format: isName ? 'rgba' : 'hex' // No I18N
                };
            }
            match = matchers.hex3.exec(color)
            if (match) {
                return {
                    r: ZC.ColorUtil.hexToNum(match[1] + match[1]),
                    g: ZC.ColorUtil.hexToNum(match[2] + match[2]),
                    b: ZC.ColorUtil.hexToNum(match[3] + match[3]),
                    format: 'hex' // No I18N
                };
            }
        } else if (Array.isArray(color)) {
            return {
                r: color[0],
                g: color[1],
                b: color[2],
                a: color[3],
                format: 'rgba' // No I18N
            }
        } else {
            return Object.assign({}, color);
        }
    }
}(ZComponents));

(function(ZC, $){
	class ZButton extends ZC.CoreComponent {
			get name(){
				return "zbutton";
			}
	    get attrs() {
	        return {
	            type: 'button', // No I18N
	            appearance: 'normal', // No I18N
	            action: null,
	            actionInProgress: false,
	            size: 'medium', // No I18N
	            text: null,
	            iconClass: null,
	            SVGIconId: null,
	            disabled: false,
	            isCustomHTMLEncoded: true,
	            contentType: '', // No I18N
	            // Added for internal button construction
	            defaultIconClassName: '',
	            defaultSVGIconId: null
	        }
	    }
	    get props() {
	        return {
	            iconClassName: null,
	            // Removed null present in inner objects as it has no significance
	            progressIndicator: {
	                type: 'circular', // No I18N
	                position: 'left', // No I18N
	                direction: 'left-to-right', // No I18N
	                loadingText: '', // No I18N
	                value: 5 // No I18N
	            }
	        }
	    }
	    get EVENTS() {
	        return [ 'click', 'change', 'statechange' ]; // No I18N
	    }
	    get compoundAttrs() {
	        return {
	            disabled: 'disabled aria-disabled' // No I18N
	        }
	    }
	    static getBtnProps(_opts, element, update) {
	        let options = Object.create(_opts), // memory reference problem occurs if we assign directly
	            btnLabel,
	            hasEle = element !== undefined, // element check added to use this method for templateRender buttons.
	            _element = hasEle && element[0],
	            attrs = options.customAttributes || {};
	        btnLabel = options.text || options.label || '';
	        if (!btnLabel && !update && hasEle) { // text passed in options is given preference over text present in the element.
	            btnLabel = _element.innerText.trim();
	        }
	        if (btnLabel) {
	            attrs['aria-label'] = _opts.text = options.text = btnLabel; // No I18N
	        }
	        let isInput = hasEle && _element.tagName === 'INPUT'; // No I18N
	        if (isInput) {
	            attrs.for = _element.id;
	            // options.className = _element.className,
	            options.title = options.title || _element.title;
	            options.type = _element.type;
	            element.addClass('zh-dnone'); // No I18N
	            options.hasInput = true;
	            options.alwaysSetAttrs = true;
	        }
	        // tabindex is set since custom buttons didn't receive tab focus automatically.
	        // tab index is set inorder to make the element focusable.
	        attrs.tabIndex = attrs.tabindex !== undefined ? attrs.tabindex : ((hasEle && _element.tabIndex) || 0);
	        // tabIndex prop is always set as -1 for web component element.
	        if (_opts.isCE && hasEle && !_element.getAttribute('tabindex')) { // No I18N
	            attrs.tabIndex = 0;
	        }
	        options = ZButton.getIconInfo(options);
	        let custHTML = _opts.innerHTML;
	        if (_opts.contentType === 'custom' && custHTML) { // No I18N
	            options.innerHTML = _opts.isCustomHTMLEncoded ? custHTML : ZC.encodeHTML(custHTML);
	        }
	        // instead of merging with _DEFAULTS, default size and appearance classes are added here itself.
	        let className = `zbutton  ${options.size ? ` zbutton--${options.size} ` : 'zbutton--medium'}${options.appearance ? ` zbutton--${options.appearance}` : ' zbutton--normal'} ${options.templateRender ? (options.className || '') + (options.icon && !options.text ? ' zbutton--icononly' : '') : ''}`; // No I18N
	        if (options.title) {
	            attrs.title = options.title;
	        }
	        options._prevTabIndex = attrs.tabIndex;
	        if (options.disabled) { // No I18N
	            className += ' is-disabled'; // No I18N
	            if (options.hasInput) {
	                attrs.tabIndex = -1;
	            }
	        }
	        if (attrs.class) {
	            className += ' ' + attrs.class; // No I18N
	            delete attrs.class;
	        }
	        attrs.disabled = options.disabled;
	        if (ZC.Browser.isFirefox && ZC.Browser.getFirefoxVersion() <= 52) {
	            // since display:flex is not supported for button elements in firefox browser, setting display as inline-block.
	            className += ' zbutton--ffsupport'; // No I18N
	        }
	        _opts.cls = className;
	        options.className = className;
	        attrs.role = options.role || 'button'; // No I18N
	        if (options.name && hasEle && _element.name) {
	            attrs.name = options.name;
	        }
	        // type attribute is set as property since jquery 1.8.0 version produces error when we use attr() method for type.
	        // Button can be present inside the form element. So assigning the type attribute as button.
	        options.type = options.type || 'button'; // No I18N
	        options.attrs = attrs;
	        // options.attrStr = JSON.stringify(attrs).replace(/:/g, '=').replace(/\{|\}|"/g, '').replace(/,/g, ' ');
	        // options.attrStr = JSON.stringify(attrs).replace(/":/g, '=').replace(/,"/g, ' ').replace(/\{"|\}/g, '');
	        return options;
	    }
	    _init(ele, opts) {
	        opts.isCE = this.isCE;
	        opts.disabled = opts.disabled || ele[0].disabled;
	        this._data = ZButton.getBtnProps(opts, ele);
	        this._prevTabIndex = this._data._prevTabIndex; // save the tabindex while disabling for the first time.
	        this._skipParent = !this._data.hasInput;
	    }
	    _initialRender() {
	        let ele = this.element;
	        if (this._opts.contentType === 'custom' && !this._data.innerHTML) { // No I18N
	            // HTML content is provided in the element itself.
	            this.container = ele;
	            this._postRender(ele, this._opts);
	            this._postEachRender(ele, this._data);
	        } else {
	            this._render();
	        }
	    }
	    _postRender(ele) {
	        let data = this._data;
	        data.className += ' ' + this._opts.cls; // No I18N
	        this._container = data.hasInput ? this.container : ele; // assigning this.container equal to this.element produces issue in color picker component because of templating. So, using _container
	        this._container[0].type = data.type; // type attribute is set explicitly since jquery 1.8.0 produces error.
	    }
	    _postEachRender() { // update zbutton--icononly class here
	        let data = this._data,
	            iconExists = data.icon && !data.text,
	            iconOnlyCls = 'zbutton--icononly'; // No I18N
	        this._updateClass(iconExists ? iconOnlyCls : '', iconExists ? null : iconOnlyCls);
	    }
	    _handleStates() {
	        let disable = this._opts.disabled,
	            data = this._data;
	        data.attrs.disabled = disable;
	        this._disable(disable);
	        if (!this.isCE) { // setting disabled for custom button will invoke set method recursively.
	            this._disable(disable, this.element);
	        }
	        if (data.hasInput) {
	            // this._currentTab = this._data._prevTabIndex;
	            if (disable) {
	                this._currentTab = this.container.attr('tabindex'); // No I18N
	            }
	            this.container.attr('tabindex', disable ? -1 : this._currentTab); // No I18N
	            data.attrs.tabIndex = disable ? -1 : this._currentTab;
	        }
	        // state change event is triggered in order to use in tooltip JS
	        this._dispatchEvent('statechange', {}, { // No I18N
	            button: this.element, // No I18N
	            disabled: disable, // No I18N
	            fromUI: false
	        });
	    }
	    _bindEvents() {
	        let componentName = this.name,
	            ele = this.getElement();
	        this._handleFocus(this._container);
	        ele.on('click.' + componentName, (event) => { // No I18N
	            if (!ele.hasClass('is-disabled')) {
	                // ele.focus(); // focusing the element explicitly as firefox/safari doesnot set focus automatically.
	                if (this._opts.actionInProgress && this.showProgressIndicator) {
	                    this.showProgressIndicator();
	                }
	                this._dispatchEvent('click', event, { // No I18N
	                    button: this.element, // No I18N
	                    fromUI: true
	                });
	            }
	        }).on('mousedown.' + componentName, (event) => {
	            // mousedown event is binded inorder to prevent focus event from happening whenever the button is in disabled state.
	            if (ele.hasClass('is-disabled')) {
	                event.stopImmediatePropagation();
	                return false;
	            }
	        });
	        if (ZC.ShortCut) {
	            ZC.ShortCut.register(this.element);
	        }
	    }
	    static getIconInfo(_opts, update, data) {
	        let haveIcon = _opts.iconClassName || _opts.iconClass || _opts.SVGIconId || _opts.defaultSVGIconId,
	            defIconCls = ''; // No I18N
	        if (haveIcon) {
	            defIconCls = _opts.defaultIconClassName + ' zbutton__icon'; // No I18N
	        }
	        _opts.defaultIconClassName = defIconCls;
	        let props = ZC._getIconInfo(_opts.iconClassName || _opts.iconClass, _opts.SVGIconId, _opts.defaultSVGIconId, _opts.defaultIconClassName, !update && _opts);
	        if (update) {
	            let options = [ 'icon', 'iconClass', 'SVGIconId', 'iconClassName', 'SVGIconClassName' ], // No I18N
	                len = options.length,
	                opt;
	            for (let i = 0; i < len; i++) {
	                opt = options[i];
	                data[opt] = props[opt];
	            }
	        } else {
	            return props;
	        }
	    }
	    _setAttribute(optionName, value, container = this.getElement()) {
	        let _opts = this._opts,
	            data = this._data,
	            oldValue = _opts[optionName];
	        _opts[optionName] = value;
	        if (optionName === 'appearance' || optionName === 'size') { // No I18N
	            this._updateClass('zbutton--' + value, 'zbutton--' + oldValue); // No I18N
	            if (optionName === 'size' && _opts.actionInProgress) { // No I18N
	                value = value.trim() === '' || value === 'default' ? 'medium' : value; // No I18N
	                container.find('.zbutton__loader circle').attr({
	                    cx: this._CIRCLEX[value], // No I18N
	                    cy: this._CIRCLEY[value], // No I18N
	                    r: this._CIRCLER[value] // No I18N
	                });
	            }
	        } else if (optionName === 'disabled') { // No I18N
	            this._handleStates();
	        } else if (optionName === 'text') {
	            this._domChanged = true;
	            data[optionName] = value;
	        } else if ([ 'iconClassName', 'iconClass', 'SVGIconId', 'defaultSVGIconId' ].indexOf(optionName) > -1) { // No I18N
	            !_opts.actionInProgress && ZButton.getIconInfo(_opts, true, data);
	            this._domChanged = true;
	        } else if (optionName === 'actionInProgress' || optionName === 'progressIndicator') { // No I18N
	            this._setProgressAttribute(optionName, value);
	        } else if (optionName === 'title') { // No I18N
	            let attrs = data.attrs || {};
	            attrs.title = value;
	            data.attrs = attrs;
	            this._domChanged = true;
	        }
	        if (this._domChanged && data.hasInput) { // ##revisit - Aishwarya
	            this._render(data, undefined, this.container[0], this._skipParent);
	            this._domChanged = false;
	        }
	    }
	    destroy() { // will be revisited
	        let cont = this.getElement(),
	            data = this._data;
	        data.className = ' '; // No I18N
	        super.destroy();
	        cont.text(data.text);
	    }
		get _CIRCLEX (){
			return	 {
		    medium: '8px', // No I18N
		    large: '10.5px', // No I18N
		    small: '7.5px', // No I18N
		    mini: '7px' // No I18N
		}
		 }
  
	get _CIRCLEY (){
			return	 {
		    medium: '8px', // No I18N
		    large: '10.5px', // No I18N
		    small: '7.5px', // No I18N
		    mini: '7px' // No I18N
		}
		 }
  
	get _CIRCLER (){
			return	 {
		    medium: '6.5', // No I18N
		    large: '9px', // No I18N
		    small: '6px', // No I18N
		    mini: '5.5px' // No I18N
		}
		 }
  setProgressValue  (value, whileCreating) {
		    if (value > 100) {
		        value = 100;
		    }
		    this._data.progressInfo.value = this._opts.progressIndicator.value = value;
		    !whileCreating && this._render();
		}
		getProgressValue  () {
		    // return  100 * parseFloat( this._progressBar.outerWidth(true) / (this.element.outerWidth(true) - parseInt(this.element.css('border')) * 2 ) ); // No I18N
		    return this._opts.progressIndicator.value;
		}
		showProgressIndicator  (options) {
		    options = options || {};
		    let loaderInfo = this._opts.progressIndicator,
		        btnText = options.loadingText || loaderInfo.loadingText,
		        data = this._data;
		    data.showProgress = true;
		    if (btnText !== '') { // No I18N
		        this._prevText = data.text;
		        data.text = btnText;
		    }
		    if (!data.progressInfo) {
		        this._setProgressData(options, true);
		        this._opts.actionInProgress = true;
		    }
		    this._updateClass('is-disabled zbutton--loading zh-transition'); // No I18N
		    this._render();
		}
		_setProgressData  (options, dontRender) {
		    let loaderInfo = this._opts.progressIndicator,
		        position = options.position || loaderInfo.position,
		        direction = options.direction || loaderInfo.direction,
		        type = options.type || loaderInfo.type,
		        SVGIconId = options.SVGIconId || loaderInfo.SVGIconId,
		        percentage = options.value || loaderInfo.value,
		        iconClassName = options.iconClassName || loaderInfo.iconClassName;
		    let size = this._opts.size,
		        cy = this._CIRCLEY,
		        cx = this._CIRCLEX,
		        _options = {
		            trackCX: cy[size],
		            trackCY: cy[size],
		            trackRadius: cy[size],
		            progressCX: cx[size],
		            progressCY: cx[size],
		            progressRadius: cx[size]
		        };
		    if (SVGIconId || iconClassName) {
		        _options.progressIcon = ZC._getIconInfo(iconClassName, SVGIconId, null, 'zbutton__icon zbutton--loader'); // No I18N
		    }
		    if (type === 'circular') { // No I18N
		        _options['circular' + position[0].toUpperCase() + position.slice(1)] = true;
		    } else {
		        _options[type === 'linear-bar' ? 'linearBar' : 'linearFill'] = true; // No I18N
		        _options.direction = direction === 'right-to-left' ? 'fromright' : 'fromleft'; // No I18N
		    }
		    _options.position = type === 'linear-bar' ? position === 'top' || position === 'bottom' ? position : 'bottom' : position === 'left' || position === 'right' ? position : 'left'; // No I18N
		    _options.className = _options.circularRight && !this._container.is('.zbutton--icononly') ? 'zh-floatright ' : ''; // No I18N
		    this._data.progressInfo = _options;
		    if (type !== 'circular') { // No I18N
		        this.setProgressValue(percentage, true);
		    }
		    !dontRender && this._render();
		}
		hideProgressIndicator  () {
		    let data = this._data;
		    data.showProgress = this._opts.actionInProgress = false;
		    data.text = this._prevText || data.text;
		    this._updateClass('', 'zbutton--loading zh-transition'); // No I18N
		    if (!this._opts.disabled) {
		        this._container.removeAttr(this.compoundAttrs.disabled);
		        this._updateClass('', 'is-disabled'); // No I18N
		    }
		    this._render();
		}
		_setProgressAttribute  (optionName, value) {
		    let opts = this._opts;
		    if (optionName === 'actionInProgress') { // No I18N
		        this[(value ? 'show' : 'hide') + 'ProgressIndicator'](); // No I18N
		    } else if (optionName === 'progressIndicator') { // No I18N
		        value = $.extend({}, opts[optionName], value);
		        this._setProgressData(value);
		    }
		    opts[optionName] = value;
		}
	}
	ZC.registerComponent('ZButton', ZButton); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zbutton.Templates, utilities = ZC.Templates.Utilities; 
template.WCContainer = (data) => ZT.html `${data.mainElement || ZT.html `<button ?aria-label="${data.text}" ?id="${data.id}" ?role="${data.role}" ?type="${data.type}" tabindex="${(data.attrs && data.attrs.tabIndex) || data.tabIndex || 0}" ?title="${data.title}" class="${data.className}" ?data-action-name=${data.attrs && data.attrs.actionName} >${data.templateRender ? ZT.html `${template.WCChildren(data)}` : ''}${data.children && template.WCChildren(data)}</button>`}`; 
template.WCChildren = (data) => ZT.html ` ${data.innerHTML ? ZT.html `${ZT.customHTML(data.innerHTML)}` : template.WCDefaultChild(data)} ` 
template.WCDefaultChild = (data) => ZT.html ` ${data.showProgress && data.progressInfo.circularLeft ? ZT.html `${template.WCLoader(data.progressInfo)}` : data.icon && ZT.html `${utilities.WCIcon(data)}`} ${data.text && ZT.html `<span class='zbutton__text'>${data.text}</span>`} ${data.showProgress && !data.progressInfo.circularLeft && ZT.html `${template.WCLoader(data.progressInfo)}` }` 
template.WCLoader = (data) => ZT.html ` ${data.linearBar && ZT.html `<span class="zbutton__${data.position}line" style="width:${data.value}%;" ></span>`} ${data.linearFill && ZT.html `<span class="zbutton__bgprogress zbutton__bgprogress--${data.direction}" style="width:${data.value}%;" ></span>`} ${(data.circularLeft || data.circularRight) && (data.progressIcon ? icon(data.progressIcon) : ZT.customHTML(`<i class="zbutton__icon zbutton--loader ${data.className}"><svg class="zbutton__svg zbutton__loader zeffects--rotate" width="100%" height="100%"> <circle class="circle__track" cx="${data.trackCX}" cy="${data.trackCY}" r="${data.trackRadius}"></circle> <circle class="circle__load" cx="${data.progressCX}" cy="${data.progressCY}" r="${data.progressRadius}"></circle> </svg></i>`))}` }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zbutton.Templates, utilities = ZC.Templates.Utilities; 
template.container = (data) => ZT.html `${data.mainElement || ZT.html `<button ?aria-label="${data.text}" ?id="${data.id}" ?role="${data.role}" ?type="${data.type}" tabindex="${(data.attrs && data.attrs.tabIndex) || data.tabIndex || 0}" ?title="${data.title}" class="${data.className}" ?data-action-name=${data.attrs && data.attrs.actionName} >${data.templateRender ? ZT.html `${template.children(data)}` : ''}${data.children && template.children(data)}</button>`}`; 
template.children = (data) => ZT.html ` ${data.innerHTML ? ZT.html `${ZT.customHTML(data.innerHTML)}` : template.defaultChild(data)} ` 
template.defaultChild = (data) => ZT.html ` ${data.showProgress && data.progressInfo.circularLeft ? ZT.html `${template.loader(data.progressInfo)}` : data.icon && ZT.html `${utilities.icon(data)}`} ${data.text && ZT.html `<span class='zbutton__text'>${data.text}</span>`} ${data.showProgress && !data.progressInfo.circularLeft && ZT.html `${template.loader(data.progressInfo)}` }` 
template.loader = (data) => ZT.html ` ${data.linearBar && ZT.html `<span class="zbutton__${data.position}line" style="width:${data.value}%;" ></span>`} ${data.linearFill && ZT.html `<span class="zbutton__bgprogress zbutton__bgprogress--${data.direction}" style="width:${data.value}%;" ></span>`} ${(data.circularLeft || data.circularRight) && (data.progressIcon ? icon(data.progressIcon) : ZT.customHTML(`<i class="zbutton__icon zbutton--loader ${data.className}"><svg class="zbutton__svg zbutton__loader zeffects--rotate" width="100%" height="100%"> <circle class="circle__track" cx="${data.trackCX}" cy="${data.trackCY}" r="${data.trackRadius}"></circle> <circle class="circle__load" cx="${data.progressCX}" cy="${data.progressCY}" r="${data.progressRadius}"></circle> </svg></i>`))}` }(ZComponents)); 
(function(ZC, $){
		class ZMenuButton extends ZC.ZButton {
			get name(){
				return "zmenubutton";
			}
		    get attrs() {
		        return {
		            openOn: 'click', // No I18N
		            menuId: null, // No I18N
		            delay: 0, // No I18N
		            arrowIcon: true, // No I18N
		            arrowIconClass: null, // No I18N
		            arrowSVGIconId: null, // No I18N
		            activeClass: 'is-selected' // No I18N
		        }
		    }
		    get props() {
		        return {
		            arrowIconClassName: null // No I18N
		        }
		    }
		    static getIconInfo(_opts) {
		        let iconInfo = ZC._getIconInfo(_opts.arrowIconClassName || _opts.arrowIconClass, _opts.arrowSVGIconId, 'zc__svg--downarrow zbutton__svg zbutton__menuarrow', 'zbutton__icon zh-floatright'); // No I18N
		        _opts.arrowIcon = true;
		        _opts.arrowIconInfo = iconInfo;
		        return _opts;
		    }
		    static init(options) {
		        options.className += ' zbutton--menu'; // No I18N
		        let attrs = options.customAttributes || {};
		        attrs['aria-haspopup'] = true; // No I18N
		        attrs['aria-expanded'] = false; // No I18N
		        attrs['aria-controls'] = options.menuId; // No I18N
		        options.customAttributes = attrs;
		        return options.arrowIcon ? ZMenuButton.getIconInfo(options) : options;
		    }
		    _init() {
		        this._opts = ZC.ZMenuButton.init(this._opts);
		        super._init(...arguments);
		    }
		    _updateIcon() {
		        let _opts = this._opts;
		        if (_opts.arrowIcon) {
		            ZC.ZMenuButton.getIconInfo(_opts);
		        }
		    }
		    _mousedownHandler(event) {
		        let isRightClick = event.which === 3,
		            _opts = this._opts,
		            _eventPrefix = this._getID(this.element),
		            disabled = _opts.disabled;
		        // event.which is added since right click on the menu button should not open the menu.
		        // It should open the browser's default right click menu. Referred in Chrome's finder menu.
		        // we should close the previously opened menu on right click.
		        if (!disabled && ZC.menu) {
		            window.setTimeout(() => this._showHideMenu(isRightClick, _eventPrefix), _opts.delay || 0);
		        }
		        if (disabled || isRightClick) {
		            event.stopImmediatePropagation();
		            return false;
		        }
		    }
		    _keydownHandler(event) {
		        let prevent = false,
		            showMenu = false,
		            handleKeyCode = false,
		            keyCode = event.keyCode,
		            key = ZC.keyCode,
		            menu = this._activeMenu || $('#' + this._opts.menuId); // No I18N
		        if (keyCode === key.ESCAPE || keyCode === key.TAB) {
		            if (menu.is(':visible')) { // No I18N
		                if (!menu.find('.on-hover').hasClass('zmenu--submenu')) { // No I18N
		                    ZC.menu(menu).hide();
		                    keyCode === key.ESCAPE && event.stopPropagation(); // event propagation is prevented since having menubutton inside dialog closes the dialog on escape key press
		                } else {
		                    handleKeyCode = true;
		                }
		            }
		        } else if ((keyCode === key.ENTER || keyCode === key.SPACE) && menu) {
		            if (document.activeElement === this.element[0]) {
		                prevent = true;
		                if (menu.find('.on-hover').length) { // No I18N
		                    handleKeyCode = true;
		                } else {
		                    showMenu = true;
		                }
		            }
		        } else {
		            prevent = true;
		            if (menu.is(':visible')) {
		                handleKeyCode = true;
		            } else if (keyCode === key.UP || keyCode === key.DOWN) {
		                showMenu = true;
		            }
		        }
		        // removed the focus set on menu as pressing TAB key from within the menu will have no effect
		        // menu.focus(); // focus should be set to menu inorder to handle submenu opening and closing behaviors. Need to revisit.
		        if (handleKeyCode) {
		            ZC.menu(menu).handleKeyCode(event);
		        } else if (showMenu) {
		            this._showHideMenu();
		        }
		        if (prevent) { // preventing the default event because while opening the menu, document scroll occurs.
		            return false;
		        }
		    }
		    _clickHandler(event) {
		        this._dispatchEvent('click', event, { // No I18N
		            button: this.element
		        });
		    }
		    _bindEvents() {
		        let listeners = {
		            mousedown: 'mousedown', // No I18N
		            keydown: 'keydown', // No I18N
		            click: 'click' // No I18N
		        };
		        if (this._opts.openOn === 'mouseover') { // No I18N
		            listeners = {
		                mouseEnter: 'mouseenter', // No I18N
		                mouseLeave: 'mouseleave' // No I18N
		            };
		        }
		        this._addEvents(listeners);
		        this._handleFocus(this._container);
		        if (ZC.ShortCut) { // shortcut key registration
		            ZC.ShortCut.register(this.element);
		        }
		    }
		    _showHideMenu(canClose, _eventPrefix) {
		        let _opts = this._opts,
		            menu = $('#' + _opts.menuId);
		        /* ||
		            (_opts.splitbutton && forElement && forElement[0] !== this.element.closest(`.${this._CLASSES.$splitmodifier}`).get(0))
		                || (!_opts.splitbutton && forElement && forElement[0] !== this.element.get(0))) */
		        if (!canClose && !menu.is(':visible')) { // No I18N
		            // open the menu
		            let eventHideEvents = 'zmenuhide.' + _eventPrefix + ' zhide.' + _eventPrefix, // No I18N
		                eventHandlers = {
		                    menuHide: eventHideEvents,
		                    menuShow: 'zmenushow.' + _eventPrefix + ' zshow.' + _eventPrefix + ' zmenusubmenushow.' + _eventPrefix + ' zsubmenushow.' + _eventPrefix, // No I18N
		                    menuSubmenuHide: 'zmenusubmenuhide.' + _eventPrefix + ' zsubmenuhide.' + _eventPrefix // No I18N
		                };
		            if (_opts.openOn === 'mouseover') { // No I18N
		                eventHandlers.menuMouseEnter = 'mouseenter'; // No I18N
		                eventHandlers.menuMouseLeave = 'mouseleave'; // No I18N
		            }
		            if (!ZC.Browser.isFirefox) {
		                eventHandlers.menuFocus = 'zmenubeforefocus zbeforefocus zmenubeforesubmenufocus zbeforesubmenufocus' // No I18N
		            }
		            this._addEvents(eventHandlers, menu);
		            // If menu button's direction is set as rtl, then menu should also have rtl direction.
		            ZC.menu(menu, {
		                rtl: _opts.rtl
		            }); // No I18N
		            ZC.menu(menu).show({ // No I18N
		                forElement: this._container.data('menuForElement') || this._container // No I18N
		            });
		            this._handleState(true);
		            this._addEvents({
		                windowResize: 'resize' // No I18N
		            }, ZC.$window);
		        } else if (this._opts.openOn !== 'mouseover') { // No I18N
		            // close the menu
		            this._handleState();
		            ZC.menu(menu).hide();
		        }
		    }
		    _windowResizeHandler() {
		        ZC.currentMenu && ZC.menu(ZC.currentMenu).hide();
		    }
		    _menuFocusHandler() {
		        // focusing the menu is prevented inorder to avoid the jerk whenever focus switches from button to menu.
		        return false;
		    }
		    _mouseLeaveHandler(orgEvent) {
		        let _opts = this._opts,
		            menuId = ('#' + _opts.menuId);
		        this._mouseEnterFired = false;
		        this._mouseLeaveTimeout = setTimeout(() => {
		            this._durationLeft && (this._durationLeft -= new Date().getTime() - this._closeAfterStartTime);
		            let relatedTarget = $(orgEvent.relatedTarget);
		            // !this._cursorInMenu &&
		            if (!((relatedTarget.parents(menuId).length) ||
		                    (relatedTarget.attr('id') === menuId))) { // No I18N
		                this._handleState();
		                ZC.menu($('#' + _opts.menuId)).hide(); // No I18N
		            }
		        }, 50);
		    }
		    _menuMouseEnterHandler() {
		        // this._cursorInMenu = true;
		        this._resetLeaveTimer();
		    }
		    _menuMouseLeaveHandler(orgEvent) {
		        // this._cursorInMenu = false;
		        this._mouseLeaveHandler(orgEvent);
		    }
		    _mouseEnterHandler(orgEvent) {
		        this._mouseEnterFired = true;
		        this._resetLeaveTimer();
		        this._mousedownHandler(orgEvent);
		    }
		    _resetLeaveTimer(orgEvent) {
		        this._durationLeft && (this._durationLeft -= new Date().getTime() - this._closeAfterStartTime);
		        this._mouseLeaveTimeout && clearTimeout(this._mouseLeaveTimeout);
		    }
		    _menuHideHandler(event, ui) {
		        let menuitem = (event.detail || ui || {}).menuitem,
		            orgEvent = event.originalEvent;
		        if (orgEvent) {
		            // Setting focus on menu button on menu close is excluded for footer items
		            // since footer items might open dialog element.
		            let isFooterItem = menuitem && menuitem.is('.is-fixed'), // No I18N
		                isMouseUp = orgEvent.type === 'mouseup'; // No I18N
		            if (!isFooterItem && isMouseUp) {
		                this.element.focus();
		                // has-kfocus is removed manually since menu hide should not contain has-kfocus visual
		                this.element.removeClass('has-kfocus'); // No I18N
		            }
		            if (isMouseUp || isFooterItem) { // No I18N
		                this.element.removeClass('has-focus');
		            }
		        }
		        this._handleState();
		        this._removeEvents('resize', ZC.$window); // No I18N
		        let _eventPrefix = this._getID(this.element);
		        this._removeEvents('zmenuhide.' + _eventPrefix + ' zhide.' + _eventPrefix, event.detail.element); // No I18N
		        this._removeEvents('zmenusubmenuhide.' + _eventPrefix + ' zsubmenuhide.' + _eventPrefix, event.detail.element); // No I18N
		        this._activeMenu = undefined;
		    }
		    _menuSubmenuHideHandler(event) {
		        this._activeMenu = event.detail.element;
		    }
		    _menuShowHandler(event) {
		        let detail = event.detail;
		        this._activeMenu = detail.menu || detail.element;
		    }
		    _handleState(openMenu) {
		        this._container[openMenu ? 'addClass' : 'removeClass'](this._opts.activeClass); // No I18N
		        this.element.attr('aria-expanded', openMenu); // No I18N
		    }
		    _destroy() {
		        // Revisit - removeClass Not necessary
		        this.element.removeClass('zbutton--menu').removeAttr('aria-haspopup'); // No I18N
		        let menu = $('#' + this._opts.menuId), // No I18N
		            ePre = this._getID(this.element);
		        this._removeEvents('zmenuhide.' + ePre + ' zhide.' + ePre + ' zmenubeforefocus zbeforefocus zmenubeforesubmenufocus zbeforesubmenufocus', menu); // No I18N
		        this._removeEvents('zmenushow.' + ePre + ' zshow.' + ePre + ' zmenusubmenushow.' + ePre + ' zsubmenushow.' + ePre + ' zmenusubmenuhide.' + ePre + ' zsubmenuhide.' + ePre, menu); // No I18N
		        this._activeMenu = undefined;
		        super._destroy();
		    }
		    _setAttribute(optionName, value) {
		        if (optionName === 'menuId') { // No I18N
		            this.element[0].setAttribute('aria-controls', value); // No I18N
		        }
		        let opts = this._opts;
		        if (optionName === 'arrowIconClassName' || optionName === 'arrowIconClass' // No I18N
		            || optionName === 'arrowSVGIconId') { // No I18N
		            opts[optionName] = value;
		            this._updateIcon();
		            this._domChanged = true;
		        } else if (optionName === 'rtl') { // No I18N
		            ZC.menu($(`#${opts.menuId}`)).setAttribute('rtl', value); // No I18N
		        } else {
		            return super._setAttribute(optionName, value);
		        }
		    }
		}
	ZC.registerComponent('ZMenuButton', ZC.ZButton, ZMenuButton); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zmenubutton.Templates, icon = ZC.Templates.Utilities.icon; 
template.WCContainer = (data) => ZT.html `<button ?aria-label="${data.text}" id="${data.id}" role="${data.role}" ?type="${data.type}" class="zbutton ${data.className}">${data.children && template.WCChildren(data)}</button>` 
template.WCChildren = (data) => ZT.html `${data.icon && ZT.html `<i class="zbutton__icon ${data.iconClassName} "> ${data.SVGIconId && ZT.customHTML(`<svg class="${data.SVGIconClassName}"> <use xlink:href="${data.SVGIconId}" ></use> </svg>`)} </i>`} ${data.text && ZT.html `<span class="zbutton__text">${data.text}</span>`} ${data.arrowIcon && icon(data.arrowIconInfo)}` }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zmenubutton.Templates, icon = ZC.Templates.Utilities.icon; 
template.container = (data) => ZT.html `<button ?aria-label="${data.text}" id="${data.id}" role="${data.role}" ?type="${data.type}" class="zbutton ${data.className}">${data.children && template.children(data)}</button>` 
template.children = (data) => ZT.html `${data.icon && ZT.html `<i class="zbutton__icon ${data.iconClassName} "> ${data.SVGIconId && ZT.customHTML(`<svg class="${data.SVGIconClassName}"> <use xlink:href="${data.SVGIconId}" ></use> </svg>`)} </i>`} ${data.text && ZT.html `<span class="zbutton__text">${data.text}</span>`} ${data.arrowIcon && icon(data.arrowIconInfo)}` }(ZComponents)); 
(function(ZC, $){
		class ZSplitButton  extends ZC.CoreComponent{
			get name(){
				return "zsplitbutton";
			}
		    get attrs() {
		        return {
		            appearance: 'normal', // No I18N
		            size: 'medium', // No I18N
		            text: null, // No I18N
		            icon: null, // No I18N
		            iconClass: null, // No I18N
		            SVGIconId: null, // No I18N
		            disabled: false, // No I18N
		            arrowIcon: true, // No I18N
		            arrowIconClass: null, // No I18N
		            arrowSVGIconId: null, // No I18N
		            menuId: null, // No I18N
		            updateButtonOnMenuItemClick: true, // No I18N
		            activeClass: '' // No I18N
		        }
		    }
		    get props() {
		        return {
		            iconClassName: null, // No I18N
		            arrowIconClassName: null, // No I18N
		            splitbuttonAttributes: {} // No I18N
		        }
		    }
		    get EVENTS() {
		        return [ 'click', 'change' ]; // No I18N
		    }
		    _init(element, _opts) {
		        _opts.isCE = this.isCE;
		        _opts.disabled = _opts.disabled || this.element[0].disabled;
		        let menuButtonId,
		            _element = element[0],
		            buttonId = element.attr('id'); // No I18N
		        _opts.text = _opts.text || _element.textContent;
		        if (buttonId) {
		            menuButtonId = buttonId + 'DropDown'; // No I18N
		        }
		        // Revisit - Many properties are similar. Have a common function and assign
		        _opts.primaryButton = ZC.ZButton.getBtnProps({
		            text: _opts.text,
		            isCE: _opts.isCE,
		            className: 'zbutton--action', // No I18N
		            appearance: _opts.appearance,
		            disabled: _opts.disabled,
		            templateRender: true,
		            iconClass: _opts.iconClass,
		            iconClassName: _opts.iconClassName,
		            size: _opts.size,
		            SVGIconId: _opts.SVGIconId
		        }, element);
		        _opts.menuButton = ZC.ZMenuButton.init({
		            id: menuButtonId, // No I18N
		            templateRender: true,
		            className: 'zbutton zbutton--icononly', // No I18N
		            // zbutton is passed since createElement syntax will not run container template.
		            appearance: _opts.appearance,
		            size: _opts.size,
		            disabled: _opts.disabled || false,
		            delay: _opts.delay,
		            arrowIcon: true,
		            arrowIconClass: _opts.arrowIconClass,
		            arrowIconClassName: _opts.arrowIconClassName,
		            isCE: _opts.isCE,
		            menuId: _opts.menuId,
		            arrowSVGIconId: _opts.arrowSVGIconId,
		            customAttributes: _opts.splitbuttonAttributes
		        });
		        // Menu Id is removed since menu is opened for this button whenever eventhandler JS is incorporated.
		        element.removeAttr('data-menu-id'); // No I18N
		    }
		    _postRender() {
		        let element = this.element,
		            container = this.container,
		            _opts = this._opts,
		            title = element.attr('title'); // No I18N
		        // title attribute should be set for the container element only. So removing the title present in the individual button.
		        if (title) {
		            element.removeAttr('title'); // No I18N
		            container.attr('title', title); // No I18N
		        }
		        let menuButton = container.find('.zbutton--menu');
		        if (!_opts.isCE) {
		            container.attr('id', element.attr('id') + 'Container'); // No I18N
		        }
		        this._data.className += ' zbutton--split  zbutton--split' + (_opts.appearance || 'normal'); // No I18N
		        menuButton.data('menuForElement', container); // No I18N
		        // action button class will not be added for custom elements since passed classNames will be added via setProperties method only.
		        this.actionBtn = container.find('.zbutton--action').length ? container.find('.zbutton--action') : $(container.find('.zbutton')[0]); // No I18N
		        this.menuButton = menuButton;
		    }
		    _bindEvents() {
		        let menu = $('#' + this._opts.menuId),
		            componentName = this.name,
		            actionBtn = this.actionBtn,
		            menuButton = this.menuButton;
		        // Removing the click event binded on the button.
		        // Revisit - Use bindEleEvents
		        this.container.on('click.' + componentName, (event) => { // No I18N
		            if (!actionBtn.hasClass('is-disabled')) {
		                let element = $(event.target).closest('.zbutton'),
		                    isMenuButton = element[0] === menuButton[0];
		                if (!isMenuButton) {
		                    ZC.menu && ZC.menu(menu).hide(); // No I18N
		                }
		                this._dispatchEvent('click', event, { // No I18N
		                    isMenuButton: isMenuButton,
		                    button: this.element,
		                    menuButton: menuButton
		                }, this.isCE ? this.container : this.element);
		            }
		        });
		        actionBtn.off('click.zbutton').off('mousedown.' + componentName).on('mousedown.' + componentName, (event) => { // No I18N
		            if (actionBtn.hasClass('is-disabled')) { // No I18N
		                event.stopImmediatePropagation();
		                return false;
		            }
		        });
		        if (ZC.ShortCut) {
		            ZC.ShortCut.register(actionBtn);
		            ZC.ShortCut.register(this.menuButton);
		        }
		        menu.on('zmenushow.' + componentName + ' zshow.' + componentName, (event) => { // No I18N
		            let container = this.container[0];
		            // Revisit - Simplify
		            if (menu.data('forElement')[0] === container) { // No I18N
		                let style = window.getComputedStyle(container, null);
		                let className = event.detail.menu.attr('class'), // No I18N
		                    isRtl = this._opts.rtl;
		                if (className.match('top')) { // reset bottom radius
		                    actionBtn.css('border-bottom-' + (isRtl ? 'right' : 'left') + '-radius', style['borderBottom' + (isRtl ? 'Right' : 'Left') + 'Radius']); // No I18N
		                    menuButton.css('border-bottom-' + (isRtl ? 'left' : 'right') + '-radius', style['borderBottom' + (isRtl ? 'Left' : 'Right') + 'Radius']); // No I18N
		                } else if (className.match('bottom')) { // reset top radius
		                    actionBtn.css('border-top-' + (isRtl ? 'right' : 'left') + '-radius', style['borderTop' + (isRtl ? 'Right' : 'Left') + 'Radius']); // No I18N
		                    menuButton.css('border-top-' + (isRtl ? 'left' : 'right') + '-radius', style['borderTop' + (isRtl ? 'Left' : 'Right') + 'Radius']); // No I18N
		                }
		                menu.off('zmenubeforeshow.' + componentName + ' zbeforeshow.' + componentName); // No I18N
		                this.container.addClass(this._opts.activeClass);
		            }
		        }).on('zmenuhide.' + componentName + ' zhide.' + componentName, () => { // No I18N
		            let radiusObj = {
		                'border-bottom-left-radius': '', // No I18N
		                'border-top-left-radius': '', // No I18N
		                'border-bottom-right-radius': '', // No I18N
		                'border-top-right-radius': '' // No I18N
		            }; // No I18N
		            actionBtn.css(radiusObj);
		            menuButton.css(radiusObj);
		            this.container.removeClass(this._opts.activeClass);
		        });
		        if (this._opts.updateButtonOnMenuItemClick) {
		            menu.on('zmenubeforeshow.' + componentName + ' zbeforeshow.' + componentName, (event) => { // No I18N
		                if (this._opts.updateButtonOnMenuItemClick) {
		                    this._hideMenuItem(true);
		                }
		            }).on('zmenuitemclick.' + componentName + ' zitemclick.' + componentName, (event) => { // No I18N
		                let ui = event.detail,
		                    menuData = ZC.menu(ui.menu)._opts,
		                    haveIcon = this._opts.iconClassName || this._opts.iconClass || this._opts.SVGIconId,
		                    buttonText = ZC.button(this.actionBtn)._opts.text,
		                    buttonType = haveIcon ? buttonText ? 'icon-text' : 'icon' : 'text'; // No I18N
		                if (menuData.contentType === buttonType) {
		                    this._hideMenuItem(false);
		                    let data = ui.data;
		                    ZC.menu(menu).hideMenuItems([ ui.menuitem ]); // No I18N
		                    if (haveIcon) {
		                        if (data.SVGIconId) {
		                            this._setAttribute('SVGIconId', data.SVGIconId); // No I18N
		                        } else if (data.iconClassName) {
		                            this._setAttribute('iconClassName', data.iconClassName); // No I18N
		                        }
		                    }
		                    buttonText && this._setAttribute('text', data.label); // No I18N
		                    this._dispatchEvent('change', event, { // No I18N
		                        button: this.element,
		                        menuButton: this.menuButton
		                    }, this.isCE ? this.container : this.element); // No I18N
		                }
		            });
		        }
		    }
		    _hideMenuItem(hide) {
		        let menu = $('#' + this._opts.menuId),
		            currentText = ZC.button(this.actionBtn)._opts.text, // No I18N
		            currentSVGIcon = (this._opts.SVGIconId && this._opts.SVGIconId.indexOf('#') === -1 ? ('#' + this._opts.SVGIconId) : this._opts.SVGIconId), // No I18N
		            currentIconCls = this._opts.iconClassName || this._opts.iconClass,
		            menuItems = menu.find('.zmenu__item'),
		            menuType = ZC.menu(menu)._opts.contentType;
		        currentText = currentText && currentText.trim();
		        for (let i = 0; i < menuItems.length; i++) {
		            let metadata = menuItems[i].itemData,
		                _label = metadata.label || $(menuItems[i]).text().trim(),
		                hasIcon = metadata.contentType !== 'text', // No I18N
		                svgMatch = hasIcon && currentSVGIcon ? currentSVGIcon === metadata.SVGIconId : false,
		                iconClsMatch = hasIcon && currentIconCls && metadata.iconClassName ? metadata.iconClassName.replace('zmenu__icon', '').trim() === currentIconCls : false, // No I18N
		                iconMatch = svgMatch || iconClsMatch || !hide,
		                textMatch = _label && currentText ? _label === currentText : !hide;
		            if (menuType === 'icon-text' ? (iconMatch && textMatch) : menuType === 'icon' ? iconMatch : textMatch) { // No I18N
		                ZC.menu(menu)[hide ? 'hideMenuItems' : 'showMenuItems']([ menuItems[i] ]); // No I18N
		            }
		        }
		    }
		    _setAttribute(optionName, value) {
		        // Revisit - Simplify
		        if (optionName === 'disabled' || optionName === 'menuId' || optionName === 'size' || optionName === 'appearance' // No I18N
		            || optionName === 'arrowIconClassName' || optionName === 'arrowIconClass' || optionName === 'arrowSVGIconId' || optionName === 'rtl') { // No I18N
		            ZC.menubutton(this.menuButton).setAttribute(optionName, value); // No I18N
		            if (optionName === 'appearance') { // No I18N
		                let isPrimary = value === 'primary', // No I18N
		                    cls = 'zbutton--splitnormal'; // No I18N
		                this._updateClass(isPrimary ? '' : cls, isPrimary ? cls : ''); // No I18N
		            }
		        }
		        this._opts[optionName] = value;
		        return ZC.button(this.actionBtn).setAttribute(optionName, value);
		    }
		    _destroy() {
		        this.actionBtn.removeClass('zbutton zbutton--icononly is-selected is-disabled zbutton--' + this._opts.size + ' zbutton--' + this._opts.appearance).removeAttr('role aria-label'); // No I18N
		        let menu = $('#' + this._opts.menuId); // No I18N
		        menu.off('zmenubeforeshow.zsplitbutton zbeforeshow.zsplitbutton zmenushow.zsplitbutton zshow.zsplitbutton zmenuitemclick.zsplitbutton zitemclick.zsplitbutton zmenuhide.zsplitbutton zhide.zsplitbutton'); // No I18N
		    }
		}
	ZC.registerComponent('ZSplitButton', ZSplitButton); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zsplitbutton.Templates; 
let zmenubutton = ZC.zmenubutton.Templates.button; 
let zbutton = ZC.zbutton.Templates.button; 
template.WCContainer = (data) => ZT.html `<div ?aria-label="${data.text}" id="${data.id}" role="splitbutton" class="zbutton--split ${data.className}">${data.children && template.WCChildren(data)}</div>` 
template.WCChildren = (data) => ZT.html `${ZC.createButton(data.primaryButton)} ${ZC.createMenuButton(data.menuButton)}` }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zsplitbutton.Templates; 
let zmenubutton = ZC.zmenubutton.Templates.button; 
let zbutton = ZC.zbutton.Templates.button; 
template.container = (data) => ZT.html `<div ?aria-label="${data.text}" id="${data.id}" role="splitbutton" class="zbutton--split ${data.className}">${data.children && template.children(data)}</div>` 
template.children = (data) => ZT.html `${ZC.createButton(data.primaryButton)} ${ZC.createMenuButton(data.menuButton)}` }(ZComponents)); 
(function(ZC, $){
		ZC.createFileUpload = function(options = {}) { // tagName has to be overrided from what is present in ZC.tagNames
		    options.tagName = options.isCE ? 'z-fileupload' : 'input'; // No I18N
		    return ZC.createElement(options, 'fileupload');
		}
	class ZFileUpload extends ZC.ZButton {
			get name(){
				return "zfileupload";
			}
	    get attrs() {
	        return {
	            type: 'file',	// No I18N
	            directory: false,
	            accept: '',	// No I18N
	            maxAllowedSize: null,
	            maxAllowedFiles: null,
	            multiple: false
	        }
	    }
	    get props() {
	        return {
	            labels: {
	                exceedsAllowedSize: 'File size exceeds the maximum allowed size of {0}.', // No I18N
	                exceedsAllowedFiles: 'Number of Files Exceeded.' // No I18N
	            },
	            errorMessage: {
	                exceedsAllowedSize: null,
	                exceedsAllowedFiles: null
	            }
	        }
	    }
	    get EVENTS() {
	        return [ 'change' ]; // No I18N
	    }
	    static dirAttrValue() {
	        return {
	            webkitdirectory: '',
	            directory: '', // No I18N
	            mozdirectory: '', // No I18N
	            odirectory: '',
	            msdirectory: ''
	        };
	    }
	    _postRender() {
	        let _input = this.element,
	            _opts = this._opts,
	            attrs = _opts.directory ? ZFileUpload.dirAttrValue() : {};
	        attrs.type = _opts.type;
	        if (this.isCE) {
	            let buttonId = _input.attr('id');	// No I18N
	            _input.removeAttr('tabindex');	// No I18N
	            $("<input type=file id='" + buttonId + "Input' tabindex=-1 style='display:none' /><label for='" + buttonId + "Input' class='zbutton--fileupload'></label>").appendTo(_input);	// No I18N
	            // removing the class names added to z-fileupload element.
	            _input = _input.find('input');	// No I18N
	            this._label = _input.find('label');	// No I18N
	        }
	        this._input = _input;
	        attrs.role = 'fileupload'; // No I18N
	        if (_opts.multiple) {
	            attrs.multiple = true;
	        }
	        if (_opts.accept) {
	            attrs.accept = _opts.accept;
	        }
	        this.element.attr(attrs);
	        super._postRender(...arguments);
	    }
	    _bindEvents() {
	        this._addEvents({
	            change: 'change' // No I18N
	        }, this.element);
	        this._addEvents({
	            containerKeydown: 'keydown', // No I18N
	            containerClick: 'click mousedown'// No I18N
	        });
	        this._handleFocus();
	        if (ZC.ShortCut) {
	            ZC.ShortCut.register(this.element);
	        }
	    }
	    _changeHandler(event) {
	        let ele = this._input,
	            files = ele.prop('files'), // No I18N
	            validatedFiles = {},	// No I18N
	            maxFileCount = this._opts.maxAllowedFiles,
	            maxFilesSize = this._opts.maxAllowedSize,
	            exceeds = false;
	            // added undefined and null check explicitly since user can provide 0 as value.
	        if (this._isNotNull(maxFileCount)) {
	            exceeds = this._checkFilesCount(files, maxFileCount);
	            if (exceeds) {
	                return;
	            }
	        }
	        if (parseInt(maxFilesSize) > 0) {
	            validatedFiles = this._checkFilesSize(files, maxFilesSize);
	        }
	        if (((validatedFiles && validatedFiles.length) || (maxFilesSize === undefined || maxFilesSize === null))) {
	            this._dispatchEvent('change', event, {	// No I18N
	                input: ele,
	                value: ele.val(),	// No I18N
	                files: validatedFiles.length < files.length ? validatedFiles : files 	// No I18N
	            }, ele);
	        }
	    }
	    _containerKeydownHandler(event) {
	        if (event.keyCode === ZC.keyCode.ENTER || event.keyCode === ZC.keyCode.SPACE) {
	            this[this.isCE ? '_label' : 'container'].trigger('click');	// No I18N
	            // preventing the propagation since uploadbutton may be present inside the
	            // dialog component which inturn triggers primary action button click.
	            event.stopImmediatePropagation();
	            // prevent default is added since ENTER opens the file chooser two times.
	            return false;
	        }
	    }
	    _containerClickHandler(event) {
	        // false is returned to prevent focus while clicking the disabled button.
	        if (this.container.hasClass('is-disabled')) {	// No I18N
	            event.type === 'mousedown' && event.stopImmediatePropagation();	// No I18N
	            return false;
	        }
	    }
	    _showAlert(sizeExceeds) {
	        let errorMessage = this._getI18NText(sizeExceeds ? 'exceedsAllowedSize' : 'exceedsAllowedFiles', [ this._opts[sizeExceeds ? 'maxAllowedSize' : 'maxAllowedFiles' ] ], 'errorMessage');	// No I18N
	        if (ZC.AlertDialog) {
	            ZC.AlertDialog.close();
	            ZC.AlertDialog.open({
	                type: 'error',	// No I18N
	                rtl: this._opts.rtl,	// No I18N
	                primaryMessage: errorMessage
	            });
	        } else {
	            window.alert(errorMessage);
	        }
	        // clearing the input value as change event will not be triggered in such case.
	        this._input[0].value = ''; // No I18N
	    }
	    _setAttribute(optionName, value) {
	        let inputEle = this._input;
	        if (optionName === 'directory') { // No I18N
	            let dirAttrValue = ZFileUpload.dirAttrValue();
	            if (value) {
	                inputEle.attr(dirAttrValue);
	            } else {
	                inputEle.removeAttr(Object.keys(dirAttrValue).join(' '));
	            }
	        } else if (optionName === 'accept') { // No I18N
	            inputEle[value ? 'attr' : 'removeAttr'](optionName, value); // No I18N
	        } else {
	            super._setAttribute(optionName, value);
	            if (optionName === 'multiple' || optionName === 'disabled') { // No I18N
	                inputEle[value ? 'attr' : 'removeAttr'](optionName, value); // No I18N
	            }
	        }
	        this._opts[optionName] = value;
	    }
	    _destroy() {
	        this.element.off('change.zfileupload'); // No I18N
	        super._destroy();
	    }
		_checkFilesSize  (files) {
		    let len = files.length,
		        size = 0,
		        validatedFiles = {},
		        file;
		    for (let i = 0; i < len; i++) {
		        file = files[i];
		        size = size + parseFloat(file.size); // size obtained will be in bytes
		        if (this._checkAllowedSize(size)) {
		            return this._showAlert(true);
		        }
		        validatedFiles[i] = file;
		        validatedFiles.length = i + 1;
		    }
		    return validatedFiles;
		}
		_checkAllowedSize  (totalSize) {
		    let allowedSize = this._opts.maxAllowedSize,
		        sizeType = allowedSize.substring(allowedSize.length - 2).toLowerCase(),
		        pow = [ 'kb', 'mb', 'gb', 'tb' ].indexOf(sizeType) + 1; // No I18N
		    allowedSize = parseInt(allowedSize);
		    // converting the kb,mb,gb and tb to bytes because file object contains the size in bytes only.
		    return Math.ceil(totalSize) > Math.ceil((allowedSize * (pow ? Math.pow(1024, pow) : 1)));
		}
		_checkFilesCount  (files, count) {
		    let exceeds = files.length > parseInt(count);
		    if (exceeds) {
		        // clearing the file lists value
		        this.value = ''; // No I18N
		        this._showAlert();
		    }
		    return exceeds;
		}
	}
	ZC.registerComponent('ZFileUpload', ZC.ZButton, ZFileUpload); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zfileupload.Templates; 
template.WCContainer = (data) => ZT.html `<z-fileupload ?aria-label="${data.text}" ?id="${data.id}" ?role="${data.role}" ?type="${data.type}" class="zbutton ${data.className}">${data.children && template.WCChildren(data)}</z-fileupload>` 
template.WCChildren = ZC.zbutton.Templates.children }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zfileupload.Templates; 
template.container = (data) => ZT.html `<label ?aria-label="${data.text}" ?id="${data.id}" ?role="${data.role}" ?type="${data.type}" class="zbutton ${data.className}">${data.children && template.children(data)}</label>` 
template.children = ZC.zbutton.Templates.children }(ZComponents)); 
(function(ZC, $){
		class ZCheckboxButton extends ZC.ZButton {
			get name(){
				return "zcheckboxbutton";
			}
		    get attrs() {
		        return {
		            type: 'checkbox', // No I18N
		            name: null,
		            checked: false
		        }
		    }
		    _init(element, options, role) {
		        options.checked = !!(options.checked || this.element[0].checked);
		        options.role = role || 'checkbox'; // No I18N
		        super._init(...arguments);
		    }
		    _initialRender() {
		        let ele = this.isCE ? this.element : $('div[for="' + this.element.attr('id') + '"]'); // No I18N
		        let data = this._data;
		        ele.attr('type', data.type); // No I18N
		        if (this._opts.contentType === 'custom' && (this.isCE ? !data.innerHTML : ele.length)) { // No I18N
		            // HTML content is provided in the element itself.
		            ele.attr(data.attrs);
		            this.container = ele;
		            this._postRender(ele, this._opts);
		            this._postEachRender(ele, data);
		        } else {
		            this._render();
		        }
		    }
		    _applyChange(isChecked, isInitial) { // since web component lacks container property, _container is used.
		        let role = this._opts.role;
		        if (role === 'checkbox' || isInitial) {
		            this._container[isChecked ? 'addClass' : 'removeClass' ]('is-selected'); // No I18N
		        }
		        if (role === 'radio') {
		            this._container.attr('tabindex', isChecked ? this._data._prevTabIndex : -1); // No I18N
		            this._data.attrs.tabIndex = isChecked ? this._data._prevTabIndex : -1;
		        }
		        this._addedByComponent = true;
		        this._container.prop('checked', isChecked).attr('aria-checked', isChecked); // No I18N
		        this.element.prop('checked', isChecked); // No I18N
		        this._addedByComponent = false;
		    }
		    _bindEvents() {
		        this._applyChange(this._opts.checked, true);
		        this._addEvents({
		            click: 'click', // No I18N
		            keydown: 'keydown' // No I18N
		        });
		        super._bindEvents();
		    }
		    _clickHandler(event, isChecked = true, force) {
		        if (!this._container.hasClass('is-disabled')) { // No I18N
		            let checkedStatus = isChecked;
		            if(this._container.prop('checked') && !force){    // No I18N
		                checkedStatus = false;
		            }
		            this._opts.checked = checkedStatus;
		            this._applyChange(checkedStatus, false, event);
		            event && this._dispatchEvent('change', event, { // No I18N
		                button: this.element,
		                fromUI: !ZC.isEmpty(event)
		            });
		        }
		    }
		    _keydownHandler(event) {
		        let key = ZC.keyCode;
		        if (event.keyCode === key.ENTER || event.keyCode === key.SPACE) {
		            this._container.trigger('click'); // No I18N
		            event.preventDefault(); // preventing the default behavior since page scroll occurs.
		        }
		    }
		    _setAttribute(optionName, value) {
		        if (optionName === 'checked') {
		            this._clickHandler({}, value);
		        } else {
		            super._setAttribute(optionName, value); // No I18N
		        }
		    }
		    _destroy() {
		        this.element.removeClass('zh-dnone'); // No I18N
		        super._destroy();
		    }
		}
	ZC.registerComponent('ZCheckboxButton', ZC.ZButton, ZCheckboxButton); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zcheckboxbutton.Templates, buttonTemplate = ZC.zbutton.Templates; 
template.WCContainer = (data) => ZT.html `<z-checkboxbutton ?aria-label="${data.text}" ?id="${data.id}" ?role="${data.role}" ?type="${data.type}" class="zbutton ${data.className}">${data.children && template.WCChildren(data)}</z-checkboxbutton>` 
template.WCChildren = (data) => ZT.html `${buttonTemplate.WCChildren(data)}` }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zcheckboxbutton.Templates, buttonTemplate = ZC.zbutton.Templates; 
template.container = (data) => ZT.html `<div ?aria-label="${data.text}" ?id="${data.id}" ?role="${data.role}" ?type="${data.type}" class="zbutton ${data.className}">${data.children && template.children(data)}</div>` 
template.children = (data) => ZT.html `${buttonTemplate.children(data)}` }(ZComponents)); 
(function(ZC, $){
	class ZRadioButton extends ZC.ZCheckboxButton {
			get name(){
				return "zradiobutton";
			}
	    get attrs() {
	        return {
	            type: 'radio', // No I18N
	            name: null,
	            checked: false
	        }
	    }
	    _init(element, options) {
	        /* Rendering label element is replaced by button element for radio and checkbox inputs since firefox browser doesn't allow us to focus label elements. */
	        this._opts.templateName = 'zcheckboxbutton'; // No I18N
	        super._init(element, options, 'radio'); // No I18N
	    }
	    _bindEvents() {
	        this._selector = this._opts.isCE ? 'z-radiobutton' : "input[type='radio']"; // No I18N
	        super._bindEvents();
	        /* Code to handle tabbing behavior like the one in HTML radio buttons */
	        let ele = this.element,
	            gname = ele.attr('name'), // No I18N
	            bGroup = $(`${this._selector}[name=${gname}]`), // No I18N
	            res = bGroup.filter((index, item) => {
	                let isInited = $(item).data('zradiobutton'), // No I18N
	                    c1 = isInited && item.checked,
	                    c2 = !isInited && item !== ele[0],
	                    c3 = !c2 && this._opts.checked;
	                if (c1 || c2 || c3) {
	                    return item;
	                }
	            });
	        if (!res || !res.length || (bGroup && bGroup.length === 1 && bGroup[0] === ele[0])) {
	            bGroup = bGroup.filter((i, item) => {
	                if (!item.disabled && item.getAttribute('data-disabled') !== 'true') { // No I18N
	                    return item;
	                }
	            });
	            if (bGroup && bGroup.length) {
	                let fbtn = bGroup[0];
	                if (fbtn === ele[0]) {
	                    this._container[0].setAttribute('tabindex', this._data._prevTabIndex); // No I18N
	                } else {
	                    let fbtninstance = ZC.radiobutton(fbtn);
	                    fbtninstance.getElement()[0].setAttribute('tabindex', fbtninstance.getData()._prevTabIndex); // No I18N
	                }
	            }
	        }
	        if (!ele.closest('.zbutton--group').length && ZC.selectable && this._handleSeparateRadio) { // No I18N
	            this._handleSeparateRadio();
	        }
	    }
	    getData() {
	        return this._data;
	    }
	    _applyChange(isChecked, isInitial) {
	        isInitial = isInitial || !this.element.closest('.zbutton--group').length; // No I18N
	        super._applyChange(isChecked, isInitial);
	    }
	    handleSelection(isChecked, event) {
	        isChecked && this._container.trigger('focus'); // No I18N
	        this._applyChange(isChecked);
	        event && event.originalEvent && event.originalEvent.type !== 'mouseup' && isChecked && this._dispatchEvent('change', event, { // No I18N
	            button: this.element,
	            fromUI: !ZC.isEmpty(event)
	        });
	    }
	    _clickHandler(event, isChecked) {
	        if (!this.element.closest('.zbutton--group').length) {
	            return super._clickHandler(event, isChecked, true); // Radio button should not contain toggle behavior
	        }
	        event && this._dispatchEvent('change', event, { // No I18N
	            button: this.element,
	            fromUI: !ZC.isEmpty(event)
	        });
	    }
		_handleSeparateRadio  () { // radio button is not present under button group.
		    let ele = this.element,
		        parentNode = ele.parent();
		    if (!parentNode.data('zselectable')) { // No I18N
		        ZC.selectable(parentNode, {
		            items: '.zbutton[type="radio"]:not(.is-disabled)', // No I18N
		            selectOnFocus: true,
		            focusItemOnItemMouseover: false,
		            keyNavigationOptions: {
		                direction: 'horizontal', // No I18N
		                wrapAround: true
		            },
		            select: ((event) => {
		                this._updateSelection(event, true);
		            }),
		            deselect: ((event) => {
		                this._updateSelection(event, false);
		            })
		        });
		    }
		}
		_updateSelection  (event, canSelect) {
		    let item = event.detail.item;
		    ZC.radiobutton(this.isCE ? item[0] : item.prev('input')).handleSelection(canSelect, event); // No I18N
		}
	}
	ZC.registerComponent('ZRadioButton', ZC.ZCheckboxButton, ZRadioButton); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
		ZC.createButtonGroup = function(options) {
		    options.tagName = options.isCE ? 'z-buttongroup' : 'div'; // No I18N
		    let len = options.items.length,
		        item, cname, tagNames, attrs,
		        container = ZC.createElement(options, 'buttongroup', true);
		    for (let i = 0; i < len; i++) {
		        item = options.items[i];
		        item.isCE = options.isCE;
		        if (item.type) {
		            attrs = item.customAttributes || {};
		            attrs.type = item.type;
		            item.customAttributes = attrs;
		        }
		        cname = 'z' + (item.type || '') + 'button'; // No I18N
		        tagNames = ZC.tagNames[cname];
		        item.tagName = options.isCE ? tagNames[1] : (item.type !== 'radio' && item.type !== 'checkbox' ? tagNames[0] : 'input'); // No I18N
		        container.append(ZC.createElement(item, cname.slice(1), true)); // No I18N
		    }
		    if (!options.isCE) {
		        ZC.buttongroup(container, options);
		    }
		    return container;
		}
	class ZButtonGroup  extends ZC.CoreComponent{
			get name(){
				return "zbuttongroup";
			}
	    get attrs() {
	        return {
	            appearance: 'normal', // No I18N
	            disabled: false,
	            size: 'medium', // No I18N
	            selectors: 'button, input, a, div', // No I18N
	            nospriteIcon: false,
	            spriteIconClass: '', // No I18N
	            label: '', // No I18N
	            labelPosition: '', // No I18N
	            constructButtonGroup: true
	        }
	    }
	    get props() {
	        return {
	            spriteIconClassName: '' // No I18N
	        }
	    }
	    get EVENTS() {
	        return [ 'click', 'change' ]; // No I18N
	    }
	    get _validCESelectors() {
	        return 'z-button,z-radiobutton,z-checkboxbutton,z-anchor,z-colorsplitbutton,z-colorbutton,z-menubutton,z-splitbutton,z-fileupload,z-buttongroup,div'; // No I18N
	    }
	    get SELECTORS() {
	        let isCE = this.isCE;
	        return {
	            items: isCE ? this._validCESelectors : 'button, input, a, div:not([for])' // No I18N
	        };
	    }
	    _render() {
	    }
	    _construct(element, options) {
	        this._items = this.element[0].querySelectorAll((this._SELECTORS.items + ':not([ctype])')); // No I18N
	        // Revisit - Use this._data.className
	        this.element.addClass('zbutton--group ' + this._opts.className + (this._opts.rtl ? ' h-rtl' : '')); // No I18N
	        this.element[0].setAttribute('role', 'buttongroup'); // No I18N
	        if (this.isCE) {
	            // Revisit - Simplify
	            this._handleChange('appearance'); // No I18N
	            this._handleChange('size'); // No I18N
	            this._handleChange('disabled'); // No I18N
	        } else {
	            let button, data, ctype, tagIndex,
	                _opts = this._opts,
	                icon,
	                spriteIconClassName = _opts.spriteIconClassName,
	                spriteIconClass = _opts.spriteIconClass,
	                componentsList = this._validCESelectors
	                    .replace(/-/g, '')// No I18N
	                    .split(','); // No I18N
	            for (let index in this._items) {
	                if (this._items.hasOwnProperty(index) && index !== 'length') { // No I18N
	                    button = $(this._items[index]);
	                    data = ZC._getOpts(button);
	                    icon = data.icon || data.iconClass || data.iconClassName;
	                    data.constructButton = _opts.constructButtonGroup;
	                    if (!_opts.nospriteIcon && !data.nospriteIcon && icon && (spriteIconClassName || spriteIconClass)) {
	                        data.icon = (spriteIconClassName || spriteIconClass) + ' ' + icon;
	                    }
	                    if (data.ctype === 'zbuttongroup') { // buttongroup can contain nested buttongroup
	                        // mainButtonGroup and innerButtonGroup datas are stored inorder to use in toolbar component.
	                        this.element.data('mainButtonGroup', true); // No I18N
	                        button.data('innerButtonGroup', true).addClass('zbutton--group__inner'); // No I18N
	                        button.zbuttongroup(data);
	                    } else {
	                        data.appearance = _opts.appearance;
	                        data.size = _opts.size;
	                        tagIndex = [ 'INPUT', 'BUTTON', 'A', 'DIV' ].indexOf(button[0].tagName);// No I18N
	                        ctype = data.ctype;
	                        if (tagIndex > -1) {
	                            if (!ctype && tagIndex === 0) {
	                                button.attr('data-ignoretrack', 'true'); // No I18N
	                                ctype = button.attr('type') === 'radio' ? 'zradiobutton' : 'zcheckboxbutton'; // No I18N
	                            }
	                            if (componentsList.indexOf(ctype) < 0) {
	                                ctype = 'zbutton'; // No I18N
	                            }
	                            button[ctype](data);
	                            data.ctype = ctype; // reassign the computed ctype to fetch in destroy method.
	                        }
	                    }
	                }
	            }
	        }
	    }
	    _handleStates() {
	        let disable = this._opts.disabled;
	        this._disable(disable, this.element);
	        this._handleChange('disabled'); // No I18N
	    }
	    _bindEvents() {
	        let componentName = this.name,
	            ele = this.element;
	        ele.on('zbuttonchange.' + componentName + ' zradiobuttonchange.' + componentName + ' zcheckboxbuttonchange.' + componentName, (event) => { // No I18N
	            this._dispatchEvent('change', event, event.detail); // No I18N
	        }).on('zbuttonclick.' + componentName, (event) => { // No I18N
	            // click should be triggered explicitly since component name differs
	            this._dispatchEvent('click', event, event.detail); // No I18N
	        });
	        this._handleStates();
	        if (ZC.selectable && ele.find('[type="radio"]').length) { // No I18N
	            ZC.selectable(ele, {
	                items: '.zbutton[type="radio"]:not(.is-disabled)', // No I18N
	                selectOnFocus: true,
	                focusItemOnItemMouseover: false,
	                keyNavigationOptions: {
	                    direction: 'horizontal', // No I18N
	                    wrapAround: true
	                },
	                select: ((event) => {
	                    let item = event.detail.item;
	                    this._handleSelection(event, item, true);
	                }),
	                deselect: ((event) => {
	                    let item = event.detail.item;
	                    this._handleSelection(event, item, false);
	                })
	            });
	        }
	    }
	    _handleSelection(event, item, toSelect) {
	        // if (this.isCE) { // web component element
	        //     // item[0].$c --> previously used to test whether item is web component or not.
	        //     item[0].handleSelection(toSelect, event);
	        // } else {
	        item = this.isCE ? item : $('#' + item.attr('for')); // No I18N
	        ZC.radiobutton(item).handleSelection(toSelect, event);
	        // }
	    }
	    setButtonsAttribute(buttonIds, optionName, value) {
	        this._handleChange(optionName, value, buttonIds);
	    }
	    _handleChange(optionName, value, buttonIds) {
	        let buttons = typeof buttonIds === 'string' ? buttonIds.split(',') : (buttonIds || this._items), // No I18N
	            i = 0,
	            element, componentName, tagName, isCE;
	        value = (value || this._opts[optionName]);
	        for (i = 0; i < buttons.length; i++) {
	            element = $(buttons[i]);
	            tagName = element[0].tagName.toLowerCase();
	            isCE = tagName.indexOf('z-') > -1;
	            if (element.length) {
	                componentName = (isCE ? tagName : element.data('componentName')).substring(isCE ? 2 : 1); // No I18N
	                if (componentName) {
	                    ZC[componentName](element).setAttribute(optionName, value);
	                }
	            }
	        }
	    }
	    _setAttribute(optionName, value) {
	        this._opts[optionName] = value;
	        if (optionName === 'disabled') { // No I18N
	            this._handleStates();
	        } else if (optionName === 'appearance' || optionName === 'size' || optionName === 'rtl') { // No I18N
	            this._handleChange(optionName, value);
	        } else if (optionName === 'spriteIconClassName' || optionName === 'spriteIconClass' || optionName === 'nospriteIcon') { // No I18N
	            let len = this._items.length,
	                button, data, instance;
	            for (let i = 0; i < len; i++) {
	                button = $(this._items[i]);
	                data = ZC._getOpts(button);
	                instance = button.is('input') ? button.next('div.zbutton') : button.zbutton('getElement'); // No I18N
	                if (!data.nospriteIcon) {
	                    instance.find('.zbutton__icon').removeClass(this._opts.spriteIconClass + ' ' + this._opts.spriteIconClassName).addClass(value + ' ' + data.icon); // No I18N
	                }
	            }
	        } else if (optionName === 'selectors') { // No I18N
	            this.destroy();
	            this._opts.selectors = value;
	            this.element[this.name](this._opts);
	        }
	    }
	    _destroy() {
	        let _items = this._items,
	            len = _items.length,
	            options, button,
	            component,
	            componentName = this.name;
	        ZC.selectable && this.element.find('[type="radio"]').length && ZC.selectable(this.element).destroy(); // No I18N
	        for (let i = 0; i < len; i++) {
	            button = _items[i];
	            options = ZC._getOpts(button);
	            component = options.ctype || 'zbutton';// No I18N
	            if (options.buttongroup) {
	                component = componentName;
	            }
	            $(button)[component]('destroy'); // No I18N
	        }
	        this.element.removeAttr('role aria-disabled').removeClass('zbutton--group').off('.' + componentName).removeData('zbuttongroup'); // No I18N
	    }
	}
	ZC.registerComponent('ZButtonGroup', ZButtonGroup); 
})(ZComponents, ZComponents.DOMUtil);
/* $Id$ */
/* eslint-disable */
ZComponents.Date = (function (ZC) {
	var $ = ZC.DOMUtil;
	"use strict"  // No I18N
	return {
		monthsAbbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],	// No I18N
		daysAbbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],  // No I18N
		days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],  // No I18N
		months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], // No I18N
		invalidInput: "Invalid date/time provided. Please provide correct input", // No I18N
		century: 21,
		AM: "AM",  // No I18N
		PM: "PM",  // No I18N
		_setMonth: function (date, val) {
			var day = date.getDate();
			if (isNaN(date)) {
				return date;
			}
			val -= 1;
			val %= 12;
			date.setMonth(val);
			while (val > 0 && date.getMonth() !== val) {
				date.setDate(--day);
			}
			return date;
		},
		_parseDateValue: function (date, pattern, otherFormats) {
			if (!date) {
				return;
			}
			var val, parsedDate = {}, pattern, formattedDate, matchFound = false, finalValue;
			var patterns = [];
			if (date instanceof Date) {
				return { date: date, isValid: true };
			}
			if (otherFormats.length) {
				patterns = otherFormats.slice();
			}
			patterns.unshift(pattern);
			var date1 = date;
			var dateParts = date.match(/[^ -/:-@\u5e74\u6708\u65e5[-`{-~\t\n\r]+/g) || []
			for (var j = 0; j < patterns.length; j++) {
				date = date1;
				// typeof patterns[j] === "string" && (patterns[j] = this.parsePattern(patterns[j]));	// No I18N	 
				finalValue = this.parseDate(date, patterns[j]);
				if (finalValue && finalValue.isValid) {
					matchFound = true;
					break;
				}
			}
			if (!matchFound) {
				finalValue = this.getDateFromOffset(date1, finalValue ? finalValue.date : undefined, patterns[0], dateParts);
			}
			return finalValue;
		},
		_getFormattedDate: function (parsedDate, date) {
			var executionOrder = ["yyyy", "yy", "M", "MM", "MMM", "MMMM", "d", "dd", "ddd", "dddd", "H", "HH", "h", "hh", "m", "mm", "s", "ss"], formattedDate, pattern;  // No I18N
			if (!date) {
				return;
			}
			for (var i = 0; i < executionOrder.length; i++) {
				pattern = executionOrder[i];
				if (pattern in parsedDate && !isNaN(parsedDate[pattern])) {
					formattedDate = new Date(date);
					switch (pattern) {
						case "M": case "MM": case "MMM": case "MMMM":  // No I18N
							formattedDate = this._setMonth(formattedDate, parsedDate[pattern]);
							break;
						case "yyyy":  // No I18N
							parsedDate[pattern] > 9999 ? formattedDate.setFullYear(9999) : formattedDate.setFullYear(parsedDate[pattern]);
							break;
						case "yy":
							var century = this.century - 1;
							var year = century.toString() + parsedDate[pattern];
							formattedDate.setFullYear(parseInt(year));
							break;
						case "d": case "dd": case "ddd": case "dddd":   	// No I18N      					
							formattedDate.setDate(parsedDate[pattern]);
							break
						case "H": case "HH": // No I18N 
							formattedDate.setHours(parsedDate[pattern]);
							break;
						case "h": case "hh":  // No I18N 
							formattedDate.setHours(parsedDate[pattern]);
							break;
						case "m": case "mm":  // No I18N 
							formattedDate.setMinutes(parsedDate[pattern]);
							break;
						case "s": case "ss":  // No I18N 
							formattedDate.setSeconds(parsedDate[pattern]);
							break;
					}
					if (!isNaN(formattedDate)) {
						date = formattedDate;
					}
				}
			}
			return formattedDate;
		},
		_getDateByIntelligence: function (date, pattern, dateParts) {
			var dateObject = new Date(date), matches = date.match(new RegExp("[-/. ?]", "g")) || [], noMatchFound;
			if (!isNaN(dateObject)) {
				if (matches.length === 1) {
					if (dateObject.getFullYear() === 2001) {
						dateObject.setFullYear(new Date().getFullYear());
					}
				}
				return dateObject;
			} else {
				var values = dateParts, colonMatch = date.match(new RegExp(":", "g")), colonCount;
				if (colonMatch) {
					var invalidTime = false, hourValue, minuteValue, secondValue;
					colonCount = colonMatch.length;
					var elements = ["AM", "PM", "am", "pm"], periodIndex; // No I18N
					if (values) {
						values[0] && (values[0] = parseInt(values[0]));
						values[1] && (values[1] = parseInt(values[1]));
						values[2] && !isNaN(values[2]) && (values[2] = parseInt(values[2]));
					}
					for (var i = 0; i < elements.length; i++) {
						if (values.indexOf(elements[i]) > -1) {
							periodIndex = values.indexOf(elements[i]);
							break;
						}
					}
					if (colonCount === 0) {
						invalidTime = true;
					} else if (colonCount === 1) {
						if (periodIndex && periodIndex > -1) {
							var period = values[periodIndex].toUpperCase();
							if (values[0] >= 1 && values[0] <= 12 && values[1] >= 0 && values[1] <= 59) {
								var modValue = values[0] % 12
								if (period === "AM") {  // No I18N	
									hourValue = modValue === 0 ? 0 : values[0];
								}
								if (period === "PM") { // No I18N	
									hourValue = modValue === 0 ? 12 : values[0] + 12;
								}
								minuteValue = values[1];
							} else {
								invalidTime = true;
							}
						} else {
							if (values[0] >= 0 && values[0] <= 23 && values[1] >= 0 && values[1] <= 59) {
								hourValue = values[0], minuteValue = values[1];
							} else {
								invalidTime = true;
							}
						}
					} else if (colonCount === 2) {
						if (periodIndex && periodIndex > -1) {
							var period = values[periodIndex].toUpperCase();
							if (values[0] >= 1 && values[0] <= 12 && values[1] >= 0 && values[1] <= 59 && values[2] >= 0 && values[2] <= 59) {
								var modValue = values[0] % 12
								if (period === "AM") {  // No I18N	
									hourValue = modValue === 0 ? 0 : values[0];
								}
								if (period === "PM") { // No I18N	
									hourValue = modValue === 0 ? 12 : values[0] + 12;
								}
								minuteValue = values[1], secondValue = values[2]
							}
						} else {
							if (values[0] >= 0 && values[0] <= 23 && values[1] >= 0 && values[1] <= 59 && values[2] >= 0 && values[1] <= 59) {
								hourValue = values[0], minuteValue = values[1], secondValue = values[2];
							} else {
								invalidTime = true;
							}
						}
					} else {
						invalidTime = true;
					}
					if (!invalidTime) {
						date = new Date();
						hourValue !== undefined && date.setHours(hourValue);
						minuteValue !== undefined && date.setMinutes(minuteValue);
						secondValue !== undefined ? date.setSeconds(secondValue) : date.setSeconds(0);
					} else {
						noMatchFound = true;
					}
				} else if (matches.length) {
					var dateElements = date.split(matches[0]), month, year;
					if (dateElements[0].length === 4) {
						year = parseInt(dateElements[0]);
						month = parseInt(dateElements[1]);
					} else if (dateElements[1].length === 4) {
						month = parseInt(dateElements[0]);
						year = parseInt(dateElements[1]);
					}
					if (month !== undefined && year !== undefined) {
						date = new Date();
						date.setFullYear(year);
						date.setDate(1);
						date.setMonth(month);

					} else {
						noMatchFound = true;
					}
				} else {
					noMatchFound = true;
				}
				if (noMatchFound) {
					throw new Error(this.invalidInput);
				}
				return date;
			}
		},
		_getDate: function (year, month, date, hours, mins, seconds) {
			return new Date(year, month, date, hours, mins, seconds);
		},
		_appendZerosToValue: function (number, chars, last) {
			var zeros = ["", "0", "00", "000", "0000"];  // No I18N 
			number = number.toString();
			chars = chars || 2;
			last = chars - number.length;
			if (last) {
				return zeros[chars].substring(0, last) + number;
			}
			return number;
		},
		_replaceMatchedText: function (date, labels = [], match) {
			if (date) {
				var minutes;
				var result;
				var sign;
				switch (match) {
					case "d":   // No I18N
						result = date.getDate();
						break;
					case "dd":  // No I18N
						var date = date.getDate();
						result = (date < 10 ? "0" : "") + date;  // No I18N
						break;
					case "ddd":  // No I18N
						result = (labels.daysAbbreviated || this.daysAbbreviated)[date.getDay()];
						break;
					case "dddd":  // No I18N
						result = (labels.days || this.days)[date.getDay()];
						break;
					case "M":  // No I18N
						result = date.getMonth() + 1;
						break;
					case "MM":  // No I18N
						var month = date.getMonth() + 1;
						result = (month < 10 ? "0" : "") + month;  // No I18N
						break;
					case "MMM":   // No I18N
						result = (labels.monthsAbbreviated || this.monthsAbbreviated)[date.getMonth()];
						break;
					case "MMMM":   // No I18N
						result = (labels.months || this.months)[date.getMonth()];
						break;
					case "yy":  // No I18N
						result = this._appendZerosToValue(date.getFullYear() % 100);
						break;
					case "yyyy":   // No I18N
						result = this._appendZerosToValue(date.getFullYear(), 4);
						break;
					case "h":  // No I18N
						result = date.getHours() % 12 || 12;
						break;
					case "hh":  // No I18N
						var hours = (date.getHours() % 12 || 12);
						result = (hours < 10 ? "0" : "") + hours;  // No I18N
						break;
					case "H":  // No I18N
						result = date.getHours();
						break;
					case "HH":  // No I18N
						var hours = date.getHours();
						result = (hours < 10 ? "0" : "") + hours;  // No I18N
						break;
					case "m":  // No I18N
						result = date.getMinutes();
						break;
					case "mm":  // No I18N
						var minutes = date.getMinutes();
						result = (minutes < 10 ? "0" : "") + minutes;  // No I18N
						break;
					case "s":  // No I18N
						result = date.getSeconds();
						break;
					case "ss":  // No I18N
						var seconds = date.getSeconds();
						result = (seconds < 10 ? "0" : "") + seconds;  // No I18N
						break;
					case "tt":  // No I18N
						result = date.getHours() < 12 ? "AM" : "PM";  // No I18N
						break;
					case "z":  // No I18N
					case "zz":
					case "zzz":
						result = date.toString().split(" ")[5];
						break;
				}
				return result !== undefined ? result : match.slice(1, match.length - 1);
			}
		},
		formatDate: function (date, format, labels) {
			var dateFormatRegExp = /dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|HH|H|hh|h|mm|m|fff|ff|f|tt|ss|s|zzz|zz|z|"[^"]*"|'[^']*'/g; // No I18N
			var base = this;
			if (date && date instanceof Date) {
				return format.replace(dateFormatRegExp, this._replaceMatchedText.bind(this, date, labels));
			}
			return date;
		},
		parsePattern: function (pattern) {
			pattern = pattern.replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, "");
			var acceptedVal = /d(?:d{1,3})?|M(?:M{1,3})?|yy(?:yy)?|h(?:h)?|H(?:H)?|m(?:m)?|s(?:s)|t{2}|z(?:z{1,3})?/g;
			var dateSeperator = pattern.replace(acceptedVal, '\0').split('\0'),
				dateParts = pattern.match(acceptedVal);
			if (!dateSeperator || !dateSeperator.length || !dateParts || !dateParts.length) {
				return false;
			}
			return { dateSeperator: dateSeperator, dateParts: dateParts };
		},
		parseDate: function (date, pattern) {
			var val, parsedDate = {}, pattern, formattedDate, filtered, matchFound = false;
			if (!date) {
				return undefined;
			}
			if (date instanceof Date) {
				if(typeof pattern === "string" && pattern.indexOf('s') < 0){// No I18N
					date.setSeconds(0, 0);
				}
				return { date: date, isValid: true };
			}
			if (typeof date !== "string" || typeof date === "string" && !date.length) {  // No I18N
				return undefined;
			}
			var filterDate = function (date) {
				var month = date.slice(0, dateParts[i].length), part = dateParts[i].slice(0, month.length);
				return month.toLowerCase() === part.toLowerCase();
			}
			var date1 = date, specialCharacters;
			date = date1;
			if (typeof pattern === "string") {
				var matches = pattern.match(/(["'])(?:(?=(\\?))\2.)*?\1/g);
				if (matches) {
					specialCharacters = matches.map(function (val) { return val.replace(/'/g, "") });
				}
				pattern = this.parsePattern(pattern);	// No I18N
			}
			var part, dateParts = date.match(/[^ -/:-@\u5e74\u6708\u65e5[-`{-~\t\n\r]+/g) || [];
			if (specialCharacters) {
				dateParts = dateParts.filter(function (part) {
					return specialCharacters.indexOf(part) === -1;
				});
			}
			var pParts = pattern.dateParts.slice(), days;
			date = new Date();
			if (dateParts.length === pParts.length) {
				for (var i = 0; i < pParts.length; i++) {
					val = parseInt(dateParts[i], 10),
						part = pParts[i];
					if (isNaN(val)) {
						if (part === "MMM" || part === "MMMM") {	// No I18N
							switch (part) {
								case "MMM": 	// No I18N
								case "MMMM": 	// No I18N
									filtered = this.monthsAbbreviated.filter(filterDate);
									val = this.monthsAbbreviated.indexOf(filtered[0]) + 1;
									break;
							}
							parsedDate[part] = val;
						} else if (part === "dddd" || part === "ddd") { // No I18N
							val = dateParts[pParts.indexOf("d") > -1 ? pParts.indexOf("d") : pParts.indexOf("dd") > -1];
							parsedDate[part] = val;
						} else if (part === "tt" && (dateParts[i] === "AM" || dateParts[i] === "PM")) { // No I18N
							var key = pParts.indexOf("hh") === -1 ? "h" : "hh"; // No I18N
							var value = dateParts[pParts.indexOf(key)],
								hourValue = parseInt(value),
								modValue = hourValue % 12;
							var startingTime = dateParts[i] === "PM" ? 12 : 0;	// No I18N
							parsedDate[key] = modValue === 0 ? startingTime : hourValue + startingTime;
							parsedDate[part] = value;
						}
					} else {
						if (part === "yyyy" || part === "yy") {  // No I18N	
							if (val > 9999) {
								dateParts[i] = "9999";  // No I18N	
							}
						}
						if (!((part.indexOf("d") > -1 && val > 31) || (part.indexOf("M") > -1 && val > 12) || (part.indexOf("y") > -1 && part.length !== dateParts[i].length))) {  // No I18N	
							parsedDate[part] = val;
						} else {
							break;
						}
					}
				}
			}
			if (Object.keys(parsedDate).length && dateParts.length === Object.keys(parsedDate).length) {
				date = this._getFormattedDate(parsedDate, date);
				if (pattern.dateParts.indexOf("s") === -1 && pattern.dateParts.indexOf("ss") === -1) {  // No I18N	
					date.setSeconds(0, 0);
				}
				date = { date: date, isValid: true };
			} else {
				date = { date: date, isValid: false };
			}
			return date;
		},
		getDateFromOffset: function (dateOffset, date, datePattern, dateParts) {
			if (!date) {
				return;
			}
			var offsetValue;
			if (dateOffset.indexOf("TODAY") === 0) {  // No I18N
				offsetValue = dateOffset.substring(5);
			} else if (dateOffset.indexOf("FROM_VALUE") === 0) {  // No I18N
				offsetValue = dateOffset.substring(10);
			} else {
				return { date: undefined, isValid: false };
			}
			var pattern = /([+-][0-9]+)(DAYS|MONTHS|YEARS|WEEKS)/g, matches = pattern.exec(offsetValue),
				day = date.getDate(), month = date.getMonth(), year = date.getFullYear(), hour = date.getHours(), minutes = date.getMinutes(), seconds = date.getSeconds();
			if (!matches) {
				try {
					var value = { date: this._getDateByIntelligence(dateOffset, datePattern, dateParts), isValid: true };
					return value;
				} catch (exception) {
					var value = { date: undefined, isValid: false };
					return value;
				}
			}
			while (matches) {
				switch (matches[2] || "DAYS") {	// No I18N
					case "DAYS":  // No I18N
						day += parseInt(matches[1], 10);
						break;
					case "WEEKS":
						day += (parseInt(matches[1], 10) * 7);
						break;
					case "MONTHS":  // No I18N
						month += parseInt(matches[1], 10);
						day = Math.min(day, new Date(year, month + 1, 0).getDate());
						break;
					case "YEARS": // No I18N
						year += parseInt(matches[1], 10);
						day = Math.min(day, new Date(year, month + 1, 0).getDate());
						break;
					case "HOURS":  // No I18N
						hour += parseInt(matches[1], 10);
						break;
					case "MINUTES":  // No I18N
						minutes += parseInt(matches[1], 10);
						break;
					case "SECONDS": // No I18N
						seconds += parseInt(matches[1], 10);
						break;
				}
				matches = pattern.exec(offsetValue);
			}
			date = this._getDate(year, month, day, hour, minutes, seconds);
			var returnObj = { date: date, isValid: true };
			return returnObj;
		},
		convertOffsetToValue: function (offset) {
			var pattern = /([+-]{1}([0-9])+$)/g, match = pattern.exec(offset);
			if (!match) {
				return 0;
			}
			return parseInt(match[0]);
		},
		getUTCDate: function () {
			return new Date(Date.UTC.apply(Date, arguments));
		},
		areDatesEqual: function (first, second) {
			if (first && second) {
				return (first.getFullYear() === second.getFullYear() && first.getMonth() === second.getMonth() &&
					first.getDate() === second.getDate());
			}

		},
		areTimesEqual: function (first, second) {
			if (first && second) {
				return (first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes() && first.getSeconds() === second.getSeconds());
			}
		},
		isTimeGreater: function(first, second) {
			first.setFullYear(second.getFullYear());
			first.setMonth(second.getMonth());
			first.setDate(second.getDate());
			return +first > +second;
		},
		isGreater: function (first, second) {
			if (first && second) {
				if (first.getTime() < second.getTime()) {
					return false;
				}
				return true;
			}
		},
	}
}(ZComponents));
(function(ZC, $){
		/* mx - mouse x, my - mouse y */
		class ZDraggable extends ZC.CoreComponent {
			get name(){
				return "zdraggable";
			}
		    get props() {
		        return {
		            cursor:'move',  // No I18N
		            handle: null,
		            ignoreAsHandle: 'input,textarea,button,select,option', // No I18N
		            axis: 'both', // No I18N
		            region: false,
		            showGhostOnDrag: false,
		            cursorOffset: {
		                top: 0,
		                left: 0
		            },
		            // classNameOnDrag can contain cursor, opacity and zIndex like props
		            classNameOnDrag: '', // No I18N
		            disabled: false,
		            dragStartDelay: 0,
		            autoScrollRegion: true,
		            cancelOnEscKey: true, // No I18N
		            scrollSpeed: 5,
		            scrollSensitivity: 20
		            /* future enhancements -> snap: false, snapToElement: null, snapToElementMode: 'outer', snapToGrid: null, */
		        }
		    }
		    get EVENTS() {
		        return [ 'start', 'drag', 'end', 'cancel' ]; // No I18N
		    }
		    _create(ele, opts) {
		        ele.addClass('zh-draggable'); // No I18N
		        this._handle = opts.handle ? ele.find(opts.handle) : ele;
		        this._handle.addClass('zdraggable ' + (opts.disabled ? 'is-disabled' : '')); // No I18N
		        this._bindEvents();
		        this._prevCursor = this._handle.css('cursor'); // No I18N
		        this._setCursor();
		        if (opts.disabled) {
		            this._disable();
		        }
		    }
		    _setCursor(prev) {
		        this._handle.css('cursor', prev ? this._prevCursor : this._opts.cursor); // No I18N
		    }
		    _bindEvents() {
		        this._addEvents({
		            mouseDown: 'mousedown', // No I18N
		            docMouseUp: 'mouseup contextmenu' // No I18N
		        }, this._handle);
		    }
		    _mouseDownHandler(event) {
		        let opts = this._opts;
		        if (!$(event.target).closest(opts.ignoreAsHandle).length && !opts.disabled) {
		            let x = event.pageX,
		                y = event.pageY;
		            this._delay = window.setTimeout(() => {
		                if (x === event.pageX && y === event.pageY) {
		                    this._md = true; // md - mousedown
		                    this._mx = event.pageX;
		                    this._my = event.pageY;
		                    this._scrollPar = this._getScrollPar(this.element);
		                    this._scrollOff = this._scrollPar[0] === document ? undefined : this._scrollPar.offset();
		                    this._prevPos = this.element[opts.region === 'parent' ? 'position' : 'offset'](); // No I18N
		                    this._addEvents({
		                        drag: 'mousemove', // No I18N
		                        docKeydown: 'keydown', // No I18N
		                        docMouseUp: 'mouseup contextmenu'// No I18N
		                    }, ZC.$document);
		                }
		                clearTimeout(this._delay);
		                this._delay = undefined;
		            }, opts.dragStartDelay);
		            $('body').addClass('zh-userselectnone');
		        }
		    }
		    _dragHandler(event) {
		        let ele = this._dragEle || this.element,
		            opts = this._opts;
		        if (this._md && !opts.disabled) {
		            // dragstart will be dispatched while started dragging the object.
		            if (!this._stDispatched) {
		                if (opts.showGhostOnDrag && !this._dragEle) {
		                    let orgEle = ele,
		                        parent = orgEle[0].parentNode;
		                    this._dragEle = ele = $(ele[0].cloneNode(true));
		                    parent.appendChild(ele[0]);
		                    ele.css('position', 'absolute'); // No I18N
		                    let pos = orgEle[opts.region === 'parent' ? 'position' : 'offset'](); // No I18N
		                    ele.css({
		                        top: pos.top,
		                        left: pos.left
		                    });
		                }
		                ele.addClass(opts.classNameOnDrag); // previously h-drag class was added.
		                this._dispatchEvent('start', event); // No I18N
		                this._stDispatched = true;
		            }
		            let scrollPar = this._scrollPar[0],
		                eveX = event.pageX,
		                eveY = event.pageY,
		                eHeight = ele.outerHeight(),
		                eWidth = ele.outerWidth();
		            if (opts.autoScrollRegion && this._opts.region !== 'viewport') { // No I18N
		                let doc = ZC.$document;
		                if (scrollPar !== doc[0] && scrollPar.tagName !== 'HTML') { // No I18N
		                    this._checkScroll('Top', eveY, eHeight, ele); // No I18N
		                    this._checkScroll('Left', eveX, eWidth, ele); // No I18N
		                } else {
		                    let win = ZC.$window,
		                        distance = opts.scrollSensitivity,
		                        speed = this._prevX ? Math.max(Math.abs(this._prevY - eveY), Math.abs(this._prevX - eveX)) : opts.scrollSpeed,
		                        docTop = doc.scrollTop(),
		                        docLeft = doc.scrollLeft(),
		                        yVal = (eveY - docTop < distance) ? docTop - speed : ((win.height() - (eveY - docTop) < distance) ? docTop + speed : undefined),
		                        xVal = (eveX - docLeft < distance) ? docLeft - speed : ((win.width() - (eveX - docLeft) < distance) ? docLeft + speed : undefined);
		                    if (yVal !== undefined) {
		                        doc.scrollTop(yVal);
		                    }
		                    if (xVal !== undefined) {
		                        doc.scrollLeft(xVal);
		                    }
		                    this._prevX = eveX;
		                    this._prevY = eveY;
		                }
		            }
		            let objectOffset = ele.offset(),
		                region;
		            if (opts.region) {
		                if (typeof opts.region === 'string') { // No I18N
		                    if (opts.region === 'viewport') { // No I18N
		                        region = [ 0, 0, $(window).width(), $(window).height() ];
		                    } else if (opts.region === 'page') { // No I18N
		                        region = ZC.$document;
		                    } else if (opts.region === 'parent') { // No I18N
		                        let isBody = ele.parent().is('body'); // No I18N
		                        region = isBody ? ZC.$document : ele.parent(); // No I18N
		                        if (!isBody) {
		                            objectOffset = ele.position();
		                        }
		                    }
		                } else if (typeof opts.region === 'object') { // No I18N
		                    region = opts.region;
		                    objectOffset = ele.position();
		                } else {
		                    region = opts.region;
		                }
		            }
		            let isUp = !((eveY - this._my) >= 0),
		                isRight = (eveX - this._mx) >= 0,
		                top = objectOffset.top + (scrollPar.scrollTop || 0) + eveY + opts.cursorOffset.top - this._my,
		                left = objectOffset.left + (scrollPar.scrollLeft || 0) + eveX + opts.cursorOffset.left - this._mx;
		            top = top < 0 ? 0 : top; // needed otherwise element moves out of view port
		            left = left < 0 ? 0 : left;
		            let winWidth, winHeight;
		            if (region && region instanceof Array) {
		                top = top < region[1] ? region[1] : top;
		                left = left < region[0] ? region[0] : left;
		                winWidth = region[2];
		                winHeight = region[3];
		            } else {
		                winWidth = region && region[0].scrollWidth || ZC.$document.width();
		                winHeight = region && region[0].scrollHeight || ZC.$document.height();
		            }
		            if (top + eHeight > winHeight) {
		                top = winHeight - eHeight; // No I18N
		            }
		            if (left + eWidth > winWidth) {
		                left = winWidth - eWidth; // No I18N
		            }
		            let obj = {};
		            if (opts.axis !== 'y' && eveX >= 0) { // No I18N
		                obj.left = left
		            }
		            if (opts.axis !== 'x' && eveY >= 0) { // No I18N
		                obj.top = top;
		            }
		            ele[opts.region === 'parent' ? 'css' : 'offset'](obj); // No I18N
		            // resetting the right and bottom values after setting the top and left values as the draggable element might have right and bottom set on them previously.
		            ele.css({
		                right: '', // No I18N
		                bottom: '' // No I18N
		            });
		            this._dispatchEvent('drag', event, { // No I18N
		                isUp: isUp,
		                isRight: isRight
		            });
		            this._mx = eveX + opts.cursorOffset.left;
		            this._my = eveY + opts.cursorOffset.top;
		            event.preventDefault(); // preventing the default behavior to avoid text selection while dragging.
		        }
		    }
		    _checkScroll(prop, eveVal, eSize, dragEle) {
		        let scrollPar = this._scrollPar[0],
		            offVal = this._scrollOff[prop.toLowerCase()],
		            currVal = scrollPar['scroll' + prop], // No I18N
		            size = (prop === 'Top' ? 'Height' : 'Width'), // No I18N
		            scSize = scrollPar['scroll' + size], // No I18N
		            scOffVal = scrollPar['offset' + size], // No I18N
		            calcVal,
		            distance = this._opts.scrollSensitivity,
		            scSpeed = this._opts.scrollSpeed,
		            forward = false;
		        if ((offVal + scOffVal - eveVal) < distance) {
		            calcVal = currVal + scSpeed;
		            forward = true;
		        } else if (eveVal - offVal < distance) {
		            calcVal = currVal - scSpeed;
		        }
		        let compSize = eSize + (calcVal === undefined ? 0 : calcVal);
		        if (calcVal !== undefined && calcVal >= 0 && (forward ? compSize <= scSize : compSize >= 0)) {
		            this._updateProp(prop, calcVal, eSize, scSize, dragEle, forward, scSpeed);
		        }
		    }
		    _updateProp(prop, value, elemSize, threshold, dragEle, forward, scSpeed) {
		        this._scrollPar[0]['scroll' + prop] = value;
		        let curr = dragEle[0]['offset' + prop],
		            mod = forward ? curr + scSpeed : curr - scSpeed;
		        if (forward ? mod + elemSize <= threshold : mod + elemSize >= 0) {
		            dragEle.css({
		                [prop.toLowerCase()]: mod
		            });
		        }
		    }
		    _getScrollPar(element, includeHidden) {
		        let position = element.css('position'),	// No I18N
		            isParBound = this._opts.region === 'parent', // No I18N
		            excludeStaticParent = isParBound !== 'parent' && position === 'absolute', // No I18N
		            overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
		            scrollPar = element.parents().filter(function() {
		                let parent = $(this);
		                if ((excludeStaticParent && parent.css('position') === 'static') || (isParBound && parent[0] !== element[0].parentNode)) {	// No I18N
		                    return false;
		                }
		                return overflowRegex.test(parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x'));	// No I18N
		            }).eq(0);
		        return position === 'fixed' || !scrollPar.length ? $(element[ 0 ].ownerDocument || document) : scrollPar;	// No I18N
		    }
		    _docMouseUpHandler(event) {
		        if (this._md && !this._opts.disabled) {
		            this._resetValues(event);
		        }
		        clearTimeout(this._delay);
		        this._delay = undefined;
		    }
		    _docKeydownHandler(event) { /* Binded the events to document since activeElement will be body only on mousemove */
		        if (this._md && this._opts.cancelOnEscKey && event.keyCode === ZC.keyCode.ESCAPE) {
		            this._revertPos();
		            this._dispatchEvent('cancel', event); // No I18N
		        }
		    }
		    _resetValues(eve, reverted) {
		        this._md = this._stDispatched = false;
		        let opts = this._opts;
		        opts.classNameOnDrag && (this._dragEle || this.element).removeClass(opts.classNameOnDrag);
		        if (eve) { // because event has to triggered while dragging alone.
		            this._dispatchEvent('end', eve); // No I18N
		        }
		        opts.showGhostOnDrag && this._removeGhost(reverted);
		        $('body').removeClass('zh-userselectnone');
		        this._removeEvents('mousemove mouseup contextmenu keydown', ZC.$document); // No I18N
		    }
		    _removeGhost(reverted) {
		        if (this._dragEle) {
		            if (!reverted) {
		                let hasPar = this._opts.region === 'parent', // No I18N
		                    offset = this._dragEle[ hasPar ? 'position' : 'offset'](); // No I18N
		                this.element[hasPar ? 'css' : 'offset']({ // No I18N
		                    top: offset.top,
		                    left: offset.left
		                });
		            }
		            this._dragEle[0].parentNode.removeChild(this._dragEle[0]);
		            this._dragEle = undefined;
		        }
		    }
		    _revertPos() { // revert the position to started state.
		        this.element.css({
		            left: this._prevPos.left,
		            top: this._prevPos.top
		        });
		        this._resetValues(undefined, true);
		    }
		    _dispatchEvent(type, event, obj = {}) {
		        let ele = this.element;
		        obj.offset = ele.offset();
		        obj.position = ele.position();
		        super._dispatchEvent(type, event, obj);
		    }
		    destroy() {
		        let name = this.name;
		        this._md = this._stDispatched = this._mx = this._my = undefined;
		        this._handle.off('.' + name).removeClass('zdraggable'); // No I18N
		        this.element.removeClass('zh-draggable'); // No I18N
		        // ZC.$document.off('.' + name); // No I18N - event should not be removed since all draggables will have single document listener
		        this.element.removeData('zdraggable'); // No I18N
		        this._setCursor(true);
		    }
		    _disable(value) {
		        super._disable(value, this._handle);
		        this._handle[value ? 'removeClass' : 'addClass']('zdraggable'); // No I18N
		        this.element[value ? 'removeClass' : 'addClass']('zh-draggable'); // No I18N
		        this._setCursor(value);
		    }
		    _setAttribute(optionName, value) {
		        if (optionName === 'handle') { // No I18N
		            this._handle.off('.' + this.name).removeClass('zdraggable'); // No I18N
		            this._setCursor(true);
		            this._resetValues();
		            this._handle = value ? this.element.find(value) : this.element;
		            this._handle.addClass('zdraggable'); // No I18N
		            this._setCursor();
		            this._bindEvents();
		        }
		        this._opts[optionName] = value;
		    }
		}
	ZC.registerComponent('ZDraggable', ZDraggable); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
		// ms - mouse started
		class ZSortable extends ZC.CoreComponent {
			get name(){
				return "zsortable";
			}
		    get attrs() {
		        return {
		            items: '> *',	// No I18N
		            handle: undefined, // No I18N
		            ignoreAsHandle: 'input,textarea,button,select,option',	// No I18N
		            axis: 'both',	// No I18N
		            region: undefined, // No I18N
		            disabled: false,	// No I18N
		            classNameOnSort: '', // No I18N
		            cancelOnEscKey: true,
		            connectWith: undefined, // No I18N
		            autoScrollRegion: true,
		            placeholderClassName: '', // No I18N
		            sortStartDelay: 0,
		            cursorOffset: {
		                left: 0,
		                top: 0
		            },
		            restrictExternalItem: false, // No I18N
		            // showGhostOnDrag - yet to be done
		            // dropOnEmpty - future enhancement
		            scrollSensitivity: 20,	// No I18N
		            scrollSpeed: 20,	// No I18N
		            prependToEmpty: false // No I18N
		        }
		    }
		    get EVENTS() {
		        return [ 'start', 'drag', 'change', 'beforeend', 'end', 'cancel' ]; // No I18N
		    }
		    _create() {
		        this._init();
		        this._construct();
		        this._bindEvents();
		    }
		    _init() {
		        this._doc = ZC.$document[0];
		    }
		    _construct() {
		        let ele = this.element;
		        this.savedData = {};
		        ele.addClass('zsortable'); // No I18N
		        this._manipulateHandles();
		        this._offsetPos = ele.offset();
		        this._inited = true;
		    }
		    _manipulateHandles() {
		        this._refreshItems();
		        this._setHandleClassName();
		        this._refreshPositions();
		    }
		    _handleMouseDown(orgEvent) {
		        let opts = this._opts,
		            cname = this.name,
		            delay = opts.sortStartDelay;
		        if (delay) {
		            $(this._doc).on('mousemove.delay.' + cname, (eve) => {
		                if (eve.pageX !== orgEvent.pageX && eve.pageY !== orgEvent.pageY) {
		                    clearTimeout(this._delay);
		                    $(this._doc).off('mousemove.delay.' + cname);
		                }
		            });
		        }
		        this._delay = window.setTimeout(() => {
		            let target = $(orgEvent.target);
		            this._dispatchEvent('start', target, orgEvent); // No I18N
		            this._isMouseMoved = false;
		            (this._ms && this._handleMouseUp(orgEvent));
		            this._mdEvent = orgEvent;
		            let isLeftBtn = (orgEvent.which === 1),
		                ignoredEle = typeof opts.ignoreAsHandle === 'string' && target[0].nodeName ? (target.closest(opts.ignoreAsHandle).length) : false, // No I18N
		                isInvalidEle = opts.handle ? target.closest(opts.handle).length : true;
		            if (!isLeftBtn || ignoredEle || !isInvalidEle || !this._captureMouseAction(orgEvent)) {
		                return true;
		            }
		            if (target.data(cname + '.prevClickEve') === true) { 	// No I18N
		                target.removeData(cname + '.prevClickEve'); 	// No I18N
		            }
		            $(this._doc).on('mousemove.' + cname, (orgEvent) => {	// No I18N
		                this._handleMouseMove(orgEvent);
		            }).on('mouseup.' + cname, (orgEvent) => {	// No I18N
		                this._handleMouseUp(orgEvent);
		            });
		            orgEvent.preventDefault();
		            return true;
		        }, delay);
		    }
		    _handleMouseMove(orgEvent) {
		        this._dispatchEvent('drag', orgEvent.target, orgEvent); // No I18N
		        if (this._isMouseMoved) {
		            if (ZC.Browser.isIE && (!document.documentMode || document.documentMode < 9) && !orgEvent.button) {
		                return this._handleMouseUp(orgEvent);
		            }
		        }
		        if (orgEvent.which || orgEvent.button) {
		            this._isMouseMoved = true;
		        }
		        if (this._ms) {
		            this._onMouseDrag(orgEvent);
		            return orgEvent.preventDefault();
		        }
		        if (this._opts.cancelOnEscKey) {
		            ZC.$document.on('keydown.' + this.name, this._keydownHandler.bind(this, orgEvent)); // No I18N
		        }
		        this._ms = (this._handleMouseMoveStart(this._mdEvent, orgEvent) !== false);
		        this[this._ms ? '_onMouseDrag' : '_handleMouseUp'](orgEvent); // No I18N
		        return !this._ms;
		    }
		    _keydownHandler(mouseMoveEvent, orgEvent) {
		        if (orgEvent.keyCode === ZC.keyCode.ESCAPE) {
		            this._handleMouseUp(this._mdEvent, true);
		            this._dispatchEvent('cancel', orgEvent.target, orgEvent); // No I18N
		        }
		        ZC.$document.off('keydown.' + this.name); // No I18N
		    }
		    _dispatchEvent(customEvent, ui, orgEvent) {
		        return super._dispatchEvent(customEvent, orgEvent, {
		            value: ui,
		            draggedElement: this._draggedEle
		        });
		    }
		    _handleMouseMoveStart(orgEvent) {
		        this.currentContainer = this; // revisit
		        this._refreshPositions();
		        this._draggedEle = this._createDraggableElement(); // revisit
		        this._saveDraggedEleSize();
		        this._saveMargins();
		        this._scrollParent = this._getScrollParent(this._draggedEle);
		        this._scrollEleOffset = this._scrollParent[0] === document ? {
		            left: 0,
		            top: 0
		        } : this._scrollParent.offset();
		        this._offsetPos = this._selItem.offset();
		        this._offsetPos = {
		            top: this._offsetPos.top - this._margins.top,
		            left: this._offsetPos.left - this._margins.left
		        }
		        this._draggedEle.css('position', 'absolute');	// No I18N
		        this._cssPos = this._draggedEle.css('position');	// No I18N
		        let base = this,
		            px = orgEvent.pageX,
		            py = orgEvent.pageY;
		        $.extend(this._offsetPos, {
		            click: {
		                left: px - base._offsetPos.left,
		                top: py - base._offsetPos.top
		            },
		            parent: base._getParentOffset(),
		            relative: base._getRelativeOffset()
		        })
		        this._elementPosition = this._fixPosition(orgEvent);
		        this._eventPageX = px;
		        this._eventPageY = py;
		        this._formerDomElements = {
		            prev: this._selItem.prev()[0],
		            parent: this._selItem.parent()[0]
		        };
		        this._createPlaceHolder();
		        if (this._opts.region) {
		            this._setContainment();
		        }
		        this._draggedEle.addClass(this._opts.classNameOnSort + ' zsortable__helper'); // No I18N
		        this._onMouseDrag(orgEvent);
		        return true;
		    }
		    _setContainment() {
		        let opts = this._opts,
		            region = opts.region;
		        if (region === 'parent') { // No I18N
		            region = this._draggedEle[0].parentNode;
		        }
		        let isDoc = region === 'page'; // No I18N
		        if (isDoc || region === 'viewport') { // No I18N
		            let ele = $(isDoc ? document : window);
		            this._containment = [
		                0 - this._offsetPos.relative.left - this._offsetPos.parent.left,
		                0 - this._offsetPos.relative.top - this._offsetPos.parent.top,
		                ele.width() - this._draggedEleSize.width - this._margins.left,
		                (ele.height() || document.body.parentNode.scrollHeight) - this._draggedEleSize.height - this._margins.top
		            ]
		        } else if (region !== 'parent') { // No I18N
		            let container = $(region)[0],
		                contIns = $(container),
		                containerOff = $(region).offset(),
		                isOverFlowHidden = ($(container).css('overflow') !== 'hidden'), // No I18N
		                borderLeftWidth = parseInt(contIns.css('borderLeftWidth')), // No I18N
		                borderTopWidth = parseInt(contIns.css('borderTopWidth')); // No I18N
		            this._containment = [ containerOff.left + borderLeftWidth + parseInt(contIns.css('paddingLeft')) - this._margins.left, // No I18N
		                containerOff.top + borderTopWidth + parseInt(contIns.css('paddingTop')) - this._margins.top, // No I18N
		                containerOff.left + (isOverFlowHidden ? Math.max(container.scrollWidth, container.offsetWidth) : container.offsetWidth) - borderLeftWidth - parseInt(contIns.css('paddingRight')) - this._draggedEleSize.width - this._margins.left, // No I18N
		                containerOff.top + (isOverFlowHidden ? Math.max(container.scrollHeight, container.offsetHeight) : container.offsetHeight) - borderTopWidth - parseInt(contIns.css('paddingBottom')) - this._draggedEleSize.height - this._margins.top // No I18N
		            ];
		        }
		    }
		    _onMouseDrag(orgEvent) {
		        let item, intersection, itemElement,
		            opts = this._opts;
		        this._position = this._fixPosition(orgEvent);
		        this._changeToAbsolute = this._changePosition('absolute');	// No I18N
		        if (!this._lastAbsolutePos) {
		            this._lastAbsolutePos = this._changeToAbsolute;
		        }
		        // handling the overflow: scroll container
		        let hasContainer = this._opts.region,
		            offset = this._scrollEleOffset,
		            scrollParent = this._scrollParent,
		            leftBound = !hasContainer || (orgEvent.pageX >= this._containment[0] && orgEvent.pageX <= this._containment[2]),
		            topBound = !hasContainer || (orgEvent.pageY >= this._containment[1] && orgEvent.pageY <= (this._containment[3] + this._draggedEleSize.height)),
		            scSpeed = opts.scrollSpeed;
		        if (opts.autoScrollRegion && opts.region !== 'viewport' && (leftBound || topBound)) { // No I18N
		            let calcLeft, calcTop,
		                forward = false;
		            if (scrollParent[0] !== document && scrollParent[0].tagName !== 'HTML') { // No I18N
		                if (topBound) {
		                    if ((offset.top + scrollParent[0].offsetHeight - orgEvent.pageY) < opts.scrollSensitivity) {
		                        forward = true;
		                        calcTop = scrollParent[0].scrollTop + scSpeed + this._selItem.height();
		                    } else if (orgEvent.pageY - offset.top < opts.scrollSensitivity) {
		                        calcTop = scrollParent[0].scrollTop - scSpeed;
		                    }
		                    // new code
		                    // else if (this._moveUp && orgEvent.pageY - scrollParent[0].scrollTop - selHgt < opts.scrollSensitivity) {
		                    //     calcTop = scrollParent[0].scrollTop - scSpeed - selHgt;
		                    // }
		                    if (calcTop !== undefined && (!hasContainer || (forward && (scrollParent.offset().top - this._selItem.offset().top + calcTop) <= scrollParent[0].scrollHeight - scrollParent[0].offsetHeight) || (!forward && this._containment[1] !== undefined && calcTop >= (this._containment[1] - scrollParent.offset().top)))) {
		                        this._fullScroll = false;
		                        scrollParent[0].scrollTop = calcTop;
		                        this._refreshPositions(true); // Since scroll happens, items positions has to be refreshed.
		                        this._offsetPos.top = this._selItem.offset().top;
		                        this._offsetPos.left = this._selItem.offset().left;
		                    } else if (!this._fullScroll && calcTop !== undefined && ((forward && !(this._selItem.offset().top + calcTop) <= scrollParent[0].scrollHeight && scrollParent[0].scrollTop !== scrollParent[0].scrollHeight - scrollParent[0].offsetHeight) || (!forward && calcTop >= this._containment[1] && scrollParent[0].scrollTop !== 0))) {
		                        scrollParent[0].scrollTop = forward ? scrollParent[0].scrollHeight - scrollParent[0].offsetHeight : 0;
		                        this._fullScroll = true;
		                    }
		                }
		                if (leftBound) {
		                    if ((offset.left + scrollParent[0].offsetWidth - orgEvent.pageX) < opts.scrollSensitivity) {
		                        forward = true;
		                        calcLeft = scrollParent[0].scrollLeft + scSpeed;
		                    } else if (orgEvent.pageX - offset.left < opts.scrollSensitivity) {
		                        calcLeft = scrollParent[0].scrollLeft - scSpeed;
		                    }
		                    if (calcLeft !== undefined && (!hasContainer || (this._changeToAbsolute.left + calcLeft) < this._containment[1])) {
		                        scrollParent[0].scrollLeft = calcLeft;
		                    }
		                }
		            } else {
		                let doc = $(document),
		                    speed = this._prevX ? Math.max(Math.abs(this._prevY - orgEvent.pageY), Math.abs(this._prevX - orgEvent.pageX)) : opts.scrollSpeed;
		                if (orgEvent.pageY - doc.scrollTop() < opts.scrollSensitivity) {
		                    doc.scrollTop(doc.scrollTop() - speed);
		                } else if ($(window).height() - (orgEvent.pageY - doc.scrollTop()) < opts.scrollSensitivity) {
		                    doc.scrollTop(doc.scrollTop() + speed);
		                }
		                if (orgEvent.pageX - doc.scrollLeft() < opts.scrollSensitivity) {
		                    doc.scrollLeft(doc.scrollLeft() - speed);
		                } else if ($(window).width() - (orgEvent.pageX - doc.scrollLeft()) < opts.scrollSensitivity) {
		                    doc.scrollLeft(doc.scrollLeft() + speed);
		                }
		                this._prevX = orgEvent.pageX;
		                this._prevY = orgEvent.pageY;
		            }
		        }
		        this._changeToAbsolute = this._changePosition('absolute');	// No I18N
		        if (leftBound && (opts.axis === 'both' || opts.axis !== 'y')) {	// No I18N
		            this._draggedEle[0].style.left = this._position.left - opts.cursorOffset.left + 'px';	// No I18N
		        }
		        if (topBound && (opts.axis === 'both' || opts.axis !== 'x')) {	// No I18N
		            this._draggedEle[0].style.top = this._position.top - opts.cursorOffset.top + 'px';	// No I18N
		        }
		        for (let i = this.items.length - 1; i >= 0; i--) {
		            item = this.items[i];
		            itemElement = item.item[0];
		            intersection = this._intersectsWithPointer(item);
		            if (!intersection) {
		                continue;
		            }
		            if (itemElement !== this._selItem[0] && this._placeHolder[intersection === 1 ? 'next' : 'prev']()[0] !== itemElement && !this._placeHolder[0].contains(itemElement)) {	// No I18N
		                this._direction = intersection === 1 ? 'down' : 'up';	// No I18N
		                if (this._intersectsWithSides(item) && item.item[0].nodeName !== 'INPUT') {	// No I18N
		                    this._reArrangeItems(orgEvent, item);
		                }
		                break;
		            }
		        }
		        this._lastAbsolutePos = this._changeToAbsolute;
		        this._checkContainerIntersection(orgEvent);
		        return false;
		    }
		    _checkContainerIntersection() {
		        let innerCont, innerIndex,
		            cont = this.containers,
		            len = cont.length;
		        for (let i = len - 1; i >= 0; i--) {
		            if (cont[i].element[0].contains(this._selItem[0])) { // current container contains the element
		                continue;
		            }
		            if (this._intersectsWith(this.containers[i].savedData)) {
		                innerCont = cont[i];
		                innerIndex = i;
		            }
		        }
		        if (!innerCont) {
		            return;
		        }
		        if (innerCont.element[0] !== this.element[0]) { // moved outside the main containers
		            let newContainer = cont[innerIndex],
		                curr,
		                appDist = 10000,
		                closestItem = null,
		                containerProp = this._changeToAbsolute[newContainer.floating ? 'left' : 'top']; // No I18N
		            for (let j = this.items.length - 1; j >= 0; j--) {
		                if (!newContainer.element[0].contains(this.items[j].item[0])) { // new container doesn't contains the element
		                    continue;
		                }
		                curr = newContainer.floating ? this.items[j].item.offset().left : this.items[j].item.offset().top;
		                if (Math.abs(curr - containerProp) < appDist) {
		                    appDist = Math.abs(curr - containerProp);
		                    closestItem = this.items[j];
		                    this.direction = (curr - containerProp > 0) ? 'down' : 'up'; // No I18N
		                }
		            }
		            this.currentContainer = newContainer;
		            this._reArrangeItems(event, closestItem, !closestItem && newContainer.element, true);
		        }
		    }
		    _reArrangeItems(orgEvent, item, appendTo, hardRefresh) {
		        let pholder = this._placeHolder[0];
		        if (appendTo) {
		            let parent = appendTo[0];
		            if (this._opts.prependToEmpty) {
		                parent.insertBefore(pholder, parent.firstChild);
		            } else {
		                parent.appendChild(pholder);
		            }
		        } else {
		            let actualItem = item.item[0],
		                position = this._direction === 'down' ? actualItem : actualItem.nextSibling; // No I18N
		            actualItem.parentNode.insertBefore(pholder, position);
		        }
		        this._counter = this._counter ? ++this._counter : 1;
		        setTimeout(() => {
		            this._refreshPositions(!hardRefresh);
		        }, 0);
		    }
		    _intersectsWithSides(item) {
		        let absEle = this._changeToAbsolute,
		            isOverBottomHalf = this._isOverAxis(absEle.top + this._offsetPos.click.top, item.top + (item.height / 2), item.height),
		            isOverRightHalf = this._isOverAxis(absEle.left + this._offsetPos.click.left, item.left + (item.width / 2), item.width),
		            vDir = this._getDragVerticalDirection(),
		            hDir = this._getDragHorizontalDirection(),
		            intersectsRegion = false;
		        if (!hDir && !vDir) {
		            return false;
		        }
		        let value,
		            region = this._containment;
		        if (this.floating && hDir) {
		            if (region) {
		                intersectsRegion = ((absEle.left <= region[0]) || (absEle.left >= region[2]));
		            }
		            value = intersectsRegion || ((hDir === 'right' && isOverRightHalf) || (hDir === 'left' && !isOverRightHalf)); // No I18N
		        } else {
		            if (region) {
		                intersectsRegion = ((absEle.top <= region[1]) || (absEle.top >= region[3]));
		            }
		            value = intersectsRegion || (vDir && ((vDir === 'down' && isOverBottomHalf) || (vDir === 'up' && !isOverBottomHalf))); // No I18N
		        }
		        return value;
		    }
		    _intersectsWithPointer(item) {
		        let isOnEleHeight = (this._opts.axis === 'x') || this._isOverAxis(this._changeToAbsolute.top + this._offsetPos.click.top, item.top, item.height, 'x'),	// No I18N
		            isOnEleWidth = (this._opts.axis === 'y') || this._isOverAxis(this._changeToAbsolute.left + this._offsetPos.click.left, item.left, item.width, 'y'),	// No I18N
		            isOverElement = isOnEleHeight && isOnEleWidth,
		            vDir = this._getDragVerticalDirection(),
		            hDir = this._getDragHorizontalDirection();
		        if (!isOverElement) {
		            return false;
		        }
		        let val = this.floating ?
		            (((hDir && hDir === 'right') || vDir === 'down') ? 2 : 1)	// No I18N
		            : (vDir && (vDir === 'down' ? 2 : 1));	// No I18N
		        return val;
		    }
		    _intersectsWith(item) {
		        let phSize = {
		                width: this._placeHolder.outerWidth(),
		                height: this._placeHolder.outerHeight()
		            },
		            x1 = this._changeToAbsolute.left,
		            x2 = x1 + phSize.width,
		            y1 = this._changeToAbsolute.top,
		            y2 = y1 + phSize.height,
		            iLeft = item.left,
		            iRight = iLeft + item.width,
		            iTop = item.top,
		            iBottom = iTop + item.height,
		            clickY = this._offsetPos.click.top,
		            clickX = this._offsetPos.click.left,
		            isOverElement = (y1 + clickY) > iTop && (y1 + clickY) < iBottom && (x1 + clickX) > iLeft && (x1 + clickX) < iRight;
		        if (phSize[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height']) {
		            return isOverElement;
		        }
		        return (iLeft < x1 + (phSize.width / 2) // Right Half
							&& x2 - (phSize.width / 2) < iRight // Left Half
							&& iTop < y1 + (phSize.height / 2) // Bottom Half
							&& y2 - (phSize.height / 2) < iBottom); // Top Half
		    }
		    _isOverAxis(x, reference, size, axis) {
		        let isXaxis = axis === 'x', // No I18N
		            value = isXaxis ? Math.ceil(this._selItem.outerHeight()) : 0; // No I18N
		        // return ((x + value) > reference) && (x < (reference + size));
		        if(isXaxis && value !== size){ // item height and selItem height differs - accordion like cases.
		            return (x + value > reference) && (x < (reference + size));
		        }
		        return (x >= reference) && (x < (reference + size));
		        // return (x > reference) && (x < (reference + size)); // newly added fix
		    }
		    _getDragVerticalDirection() {
		        let delta = this._changeToAbsolute.top - this._lastAbsolutePos.top;
		        return delta !== 0 && (delta > 0 ? 'down' : 'up');	// No I18N
		    }
		    _getDragHorizontalDirection() {
		        let delta = this._changeToAbsolute.left - this._lastAbsolutePos.left;
		        return delta !== 0 && (delta > 0 ? 'right' : 'left');	// No I18N
		    }
		    _changePosition(pos) {
		        let mod = pos === 'absolute' ? 1 : -1, // No I18N
		            scroll = this._cssPos === 'absolute' && !(this._scrollParent[0] !== this._doc && this._scrollParent[0].contains(this._offsetParent[0])) ? this._offsetParent : this._scrollParent,
		            isScrollRootNode;	// No I18N
		        if (scroll[0].tagName.toLowerCase() === 'html' || scroll[0].tagName.toLowerCase() === 'body') {	// No I18N
		            isScrollRootNode = true;
		        }
		        let position = {
		            top: (this._position.top + this._offsetPos.relative.top * mod + this._offsetPos.parent.top * mod - ((this._cssPos === 'fixed' ? -this._scrollParent.scrollTop() : (isScrollRootNode ? 0 : scroll.scrollTop())) * mod)),	// No I18N
		            left: (this._position.left + this._offsetPos.relative.left * mod + this._offsetPos.parent.left * mod - ((this._cssPos === 'fixed' ? -this._scrollParent.scrollLeft() : (isScrollRootNode ? 0 : scroll.scrollLeft())) * mod))	// No I18N
		        };
		        return position;
		    }
		    _createPlaceHolder() {
		        let selectedNodeName = this._selItem[0].nodeName.toLowerCase();
		        this._placeHolder = $('<' + selectedNodeName + '>', this._doc).addClass(this._selItem[0].className + ' zsortable__placeholder');	// No I18N
		        // this._placeHolder.css('visibility', 'hidden');	// No I18N
		        this._placeHolder.addClass(this._opts.placeholderClassName);
		        this._selItem.after(this._placeHolder);
		        this._placeHolder.width(this._selItem.innerWidth() - parseInt(this._selItem.css('paddingLeft') || 0, 10) - parseInt(this._selItem.css('paddingRight') || 0, 10)); 	// No I18N
		        this._placeHolder.height(this._selItem.innerHeight() - parseInt(this._selItem.css('paddingTop') || 0, 10) - parseInt(this._selItem.css('paddingBottom') || 0, 10)); // No I18N
		    }
		    _fixPosition(orgEvent) {
		        let pageX = orgEvent.pageX,
		            pageY = orgEvent.pageY,
		            scroll = this._cssPos === 'absolute' && !(this._scrollParent[0] !== this._doc && this._scrollParent[0].contains(this._offsetParent[0])) ? this._offsetParent : this._scrollParent, 	// No I18N
		            isScrollRootNode;
		        if (this._containment) {
		            if (orgEvent.pageX - this._offsetPos.click.left < this._containment[0]) {
		                pageX = this._containment[0] + this._offsetPos.click.left;
		            }
		            if (orgEvent.pageY - this._offsetPos.click.top < this._containment[1]) {
		                pageY = this._containment[1] + this._offsetPos.click.top;
		            }
		            if (orgEvent.pageX - this._offsetPos.click.left > this._containment[2]) {
		                pageX = this._containment[2] + this._offsetPos.click.left;
		            }
		            if (orgEvent.pageY - this._offsetPos.click.top > this._containment[3]) {
		                pageY = this._containment[3] + this._offsetPos.click.top;
		            }
		        }
		        if (scroll[0].tagName.toLowerCase() === 'html' || scroll[0].tagName.toLowerCase() === 'body') {	// No I18N
		            isScrollRootNode = true;
		        }
		        return {
		            top: pageY - this._offsetPos.click.top - this._offsetPos.relative.top - Math.abs(this._offsetPos.parent.top) + (this._cssPos === 'fixed' ? -this._scrollParent.scrollTop() : (isScrollRootNode ? 0 : scroll.scrollTop())),	// No I18N
		            left: pageX - this._offsetPos.click.left - this._offsetPos.relative.left - this._offsetPos.parent.left + (this._cssPos === 'fixed' ? -this._scrollParent.scrollLeft() : (isScrollRootNode ? 0 : scroll.scrollLeft()))	// No I18N
		        }
		    }
		    _getScrollParent(element, includeHidden) {
		        let position = element.css('position'),	// No I18N
		            excludeStaticParent = position === 'absolute', // No I18N
		            overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
		            scrollParent = element.parents().filter(function(i, ele) {
		                let parent = $(ele);
		                if (excludeStaticParent && parent.css('position') === 'static') {	// No I18N
		                    return false;
		                }
		                return overflowRegex.test(parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x'));	// No I18N
		            }).eq(0);
		        return position === 'fixed' || !scrollParent.length ? $(element[ 0 ].ownerDocument || document) : scrollParent;	// No I18N
		    }
		    _getParentOffset() {
		        this._offsetParent = $(this._draggedEle[0].offsetParent);
		        let po = this._offsetParent[0] === document ? {
		            left: 0,
		            top: 0
		        } : this._offsetParent.offset();
		        if (this._cssPos === 'absolute' && this._scrollParent[0] !== this._doc && this._scrollParent[0].contains(this._offsetParent[0])) {	// No I18N
		            po.left += this._scrollParent.scrollLeft();
		            po.top += this._scrollParent.scrollTop();
		        }
		        if (this._offsetParent[0] === this._doc.body || (this._offsetParent[0].tagName && this._offsetParent[0].tagName.toLowerCase() === 'html' && ZC.Browser.isIE)) {	// No I18N
		            po = {
		                top: 0,
		                left: 0
		            };
		        }
		        return {
		            top: po.top + (parseInt(this._offsetParent.css('borderTopWidth'), 10) || 0),	// No I18N
		            left: po.left + (parseInt(this._offsetParent.css('borderLeftWidth'), 10) || 0)	// No I18N
		        };
		    }
		    _getRelativeOffset() {
		        if (this._cssPos === 'relative') {	// No I18N
		            let p = this._selItem.position();
		            return {
		                top: p.top - (parseInt(this._draggedEle.css('top'), 10) || 0) + this._scrollParent.scrollTop(),	// No I18N
		                left: p.left - (parseInt(this._draggedEle.css('left'), 10) || 0) + this._scrollParent.scrollLeft()	// No I18N
		            };
		        }
		        return {
		            top: 0,
		            left: 0
		        };
		    }
		    _saveMargins() {
		        this._margins = {
		            left: (parseInt(this._selItem.css('marginLeft'), 10) || 0),	// No I18N
		            top: (parseInt(this._selItem.css('marginTop'), 10) || 0)	// No I18N
		        }
		    }
		    _createDraggableElement() {
		        let draggableItem = this._selItem,
		            selItem = this._selItem;
		        this._savedCSS = {
		            width: selItem[0].style.width,
		            height: selItem[0].style.height,
		            position: selItem.css('position'), 	// No I18N
		            top: selItem.css('top'), 	// No I18N
		            left: selItem.css('left') 	// No I18N
		        };
		        // IE horizontal scroll bar on vertical movement issue fix.
		        draggableItem.width(selItem.width() - (ZC.Browser.isIE ? (parseInt(selItem.css('borderLeftWidth')) + parseInt(selItem.css('borderRightWidth'))) : 0)).height(selItem.height()); // No I18N
		        return draggableItem;
		    }
		    _saveDraggedEleSize() {
		        this._draggedEleSize = {
		            width: this._draggedEle.outerWidth(),
		            height: this._draggedEle.outerHeight()
		        };
		    }
		    _captureMouseAction(orgEvent) {
		        let _selItem = null,
		            base = this;
		        this._isPrev = false;
		        if (this.reverting) {	// revisit
		            return false;
		        }
		        if (this._opts.disabled) {
		            return false;
		        }
		        this._refreshItems();
		        let pars = $(orgEvent.target).parents().toArray();
		        pars.forEach(function(ele) {
		            if ($.data(ele, base.name + '-item') === base) {	// No I18N
		                _selItem = $(ele);
		                return false;
		            }
		        })
		        if ($.data(orgEvent.target, this.name + '-item') === base) {	// No I18N
		            _selItem = $(orgEvent.target);
		        }
		        if (!_selItem) {
		            return false;
		        }
		        this._selItem = _selItem;
		        let prevEle = this._selItem.prev();
		        if (prevEle.length) {
		            this._adjacentElement = prevEle;
		            this._isPrev = true;
		        } else {
		            this._adjacentElement = this._selItem.next()
		        }
		        return true;
		    }
		    _handleMouseUp(orgEvent, escKeyPressed) {
		        let cname = this.name;
		        clearTimeout(this._delay);
		        $(this._doc).off('mousemove.' + cname).off('mouseup.' + cname);	// No I18N
		        if (this._ms) {
		            this._ms = false;
		            this._prevX = this._prevY = undefined;
		            if (orgEvent.target === this._mdEvent.target) {
		                $.data(orgEvent.target, cname + '.prevClickEve', true);	// No I18N
		            }
		            this._dropDraggedElement(orgEvent, escKeyPressed);
		        }
		        return false;
		    }
		    _dropDraggedElement(orgEvent, escKeyPressed) {
		        if (!orgEvent) {
		            return;
		        }
		        if (!this._dispatchEvent('beforeend', orgEvent.target, orgEvent)) {
		            escKeyPressed = true;
		        }
		        this._placeElement(orgEvent, escKeyPressed);
		    }
		    _placeElement(orgEvent, escKeyPressed) {
		        let i,
		            sItem = this._selItem;
		        this.reverting = false;
		        if (escKeyPressed) {
		            sItem['insert' + (this._isPrev ? 'After' : 'Before')](this._adjacentElement); // No I18N
		        } else if (!this._noFinalSort && sItem.parent().length) {
		            this._placeHolder.before(sItem);
		        }
		        this._noFinalSort = null;
		        if (this._draggedEle[0] === sItem[0]) {
		            for (i in this._savedCSS) {
		                if (this._savedCSS[i] === 'auto' || this._savedCSS[i] === 'static') {	// No I18N
		                    this._savedCSS[i] = '';	// No I18N
		                }
		            }
		            sItem.css(this._savedCSS).removeClass('zsortable__helper');	// No I18N
		        } else {
		            sItem.show();
		        }
		        this._draggedEle.removeClass(this._opts.classNameOnSort);
		        this.dragging = false; // revisit
		        this._placeHolder[0].parentNode.removeChild(this._placeHolder[0]);
		        this.fromOutside = false;
		        this._dispatchEvent('end', orgEvent.target, orgEvent); // No I18N
		        this._dispatchEvent('change', orgEvent.target, orgEvent); // No I18N
		    }
		    _bindEvents() {
		        let cname = this.name;
		        this.element.on('mousedown.' + cname, (orgEvent) => { 	// No I18N
		            this._handleMouseDown(orgEvent);
		            // orgEvent.stopImmediatePropagation(); // To avoid nested sortables to trigger events for parent sortable elements.
		        }).on('click.' + cname, (orgEvent) => {	// No I18N
		            if ($.data(orgEvent.target, cname + '.prevClickEve') === true) {	// No I18N
		                $.removeData(orgEvent.target, cname + '.prevClickEve');	// No I18N
		                orgEvent.stopImmediatePropagation();
		                return false;
		            }
		        }).on('mouseup.' + cname, (orgEvent) => {	// No I18N
		            // element mouseup too added since before binding the document mouseup itself, mouseup happened
		            this._handleMouseUp(orgEvent);
		        });
		    }
		    _refreshItems() {
		        this.items = [];
		        this.containers = [ this ];
		        let targetData, item, query,
		            opts = this._opts,
		            queries = [ [ $(opts.items, this.element), this ] ];
		        if (opts.connectWith && this._inited && !opts.restrictExternalItem) {
		            let cWith = $(opts.connectWith),
		                cinst;
		            for (let k = 0; k < cWith.length; k++) {
		                cinst = $(cWith[k]).data('zsortable'); // No I18N
		                if (cinst && cinst.element[0] !== this.element[0]) {
		                    queries.push([ $(cinst._opts.items, cinst.element), cinst ]);
		                    this.containers.push(cinst);
		                }
		            }
		        }
		        for (let i = queries.length - 1; i >= 0; i--) {
		            targetData = queries[i][1];
		            query = queries[i][0];
		            for (let j = 0; j < query.length; j++) {
		                item = $(query[j]);
		                item.data(this.name + '-item', targetData);	// No I18N
		                this.items.push({
		                    item: item,
		                    width: 0,
		                    height: 0,
		                    left: 0,
		                    top: 0
		                });
		            }
		        }
		    }
		    _setHandleClassName() {
		        let cls = 'zsortable__handle'; // No I18N
		        this.element.find('.' + cls).removeClass(cls);	// No I18N
		        let ignoredEle = this._opts.ignoreAsHandle.split(','), // No I18N
		            items = this.items,
		            index, item;
		        for (let i = 0; i < items.length; i++) {
		            item = items[i].item;
		            index = ignoredEle.indexOf(item[0].nodeName.toLowerCase());
		            if (index === -1) {
		                item.addClass(cls);
		            }
		        }
		    }
		    _refreshPositions(fast) {
		        let items = this.items;
		        this.floating = items.length ? (this._opts.axis === 'x' || this._isFloating(items[0].item)) : false;	// No I18N
		        let item, itemSize, offsetPos;
		        for (let i = items.length - 1; i >= 0; i--) {
		            item = items[i];
		            itemSize = item.item;
		            if (!fast) {
		                item.width = itemSize.outerWidth();
		                item.height = itemSize.outerHeight();
		            }
		            offsetPos = itemSize.offset();
		            item.left = offsetPos.left;
		            item.top = offsetPos.top;
		        }
		        let cont = this.containers;
		        for (let i = cont.length - 1; i >= 0; i--) {
		            offsetPos = cont[i].element.offset();
		            cont[i].savedData.left = offsetPos.left;
		            cont[i].savedData.top = offsetPos.top;
		            cont[i].savedData.width = cont[i].element.outerWidth();
		            cont[i].savedData.height = cont[i].element.outerHeight();
		        }
		        return this;
		    }
		    _isFloating(item) {
		        let floatVal = item.css('float').toLowerCase(), // No I18N
		            displayVal = item.css('display').toLowerCase();// No I18N
		        return (floatVal === 'left' || floatVal === 'right' || displayVal === 'table-cell' || displayVal === 'inline');	// No I18N
		    }
		    _unbindEvents(fromDes) {
		        let name = this.name;
		        this.element.off('mousedown.' + name).off('click.' + name);	// No I18N
		        $(this._doc).off('mousemove.' + name).off('mouseup.' + name);	// No I18N
		        if (fromDes) {
		            this.element.removeData(name);
		        }
		    }
		    destroy() {
		        this._unbindEvents(true);
		    }
		    disable() {
		        this._unbindEvents();
		    }
		    enable() {
		        this._bindEvents();
		    }
		    getItems() {
		        return this.items;
		    }
		    refresh() {
		        this._manipulateHandles();
		        return this;
		    }
		    _disable() { // overriding to avoid this._data errors from general method.
		    }
		    _setAttribute(optName, val) {
		        // Special handling not needed for handle, disabled, region, classNameOnSort, cancelOnEscKey, autoScrollRegion, placeholderClassName, sortStartDelay, cursorOffset and axis
		        this._opts[optName] = val;
		        if (optName === 'items') { // No I18N
		            this._manipulateHandles();
		        } else if (optName === 'ignoreAsHandle') { // No I18N
		            this._setHandleClassName();
		        } else if (optName === 'connectWith' || optName === 'restrictExternalItem') { // No I18N
		            this._refreshItems();
		        }
		    }
		}
	ZC.registerComponent('ZSortable', ZSortable); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
		/* eslint-disable no-mixed-spaces-and-tabs */
		// md - mouse down
		class ZResizable extends ZC.CoreComponent {
			get name(){
				return "zresizable";
			}
		    get props() {
		    	return {
		    		disabled: false, // No I18N
		            minHeight: 10, // No I18N
		            minWidth: 10, // No I18N
		            maxWidth: false, // No I18N
		            maxHeight: false, // No I18N
		            boundary: 'viewport', // No I18N
		            directions: 's,e,se', // No I18N
		            relatedElements: null, // No I18N
		            handleClasses: {},
		            delay: 0,
		            cueIcons: {},
		            // cues & handles allowed values are all, none, individual direction value and array of directions
		            cues: 'se', // No I18N
		            handles: 'none', // No I18N
		            // displayCues allowed values are always, onelementmouseover, oncontextmouseover
		            displayCues: 'always', // No I18N
		            // displayHandles allowed values are onelementmouseover, oncontextmouseover, onelementactive
		            displayHandles: 'oncontextmouseover', // No I18N
		            preserveAspectRatio: false
		            // yet to implement: showGhost
		    	}
		    }
		    get dirMap() {
		        return {
		            se: 'southEast', // No I18N
		            ne: 'northEast', // No I18N
		            sw: 'southWest', // No I18N
		            nw: 'northWest', // No I18N
		            s: 'south', // No I18N
		            n: 'north', // No I18N
		            e: 'east', // No I18N
		            w: 'west'// No I18N
		        }
		    }
		    get EVENTS() {
		        return [ 'start', 'end', 'resize' ]; // No I18N
		    }
		    _create(ele, opts) {
		        let isDis = opts.disabled;
		        ele.addClass('zresizable' + (isDis ? ' is-disabled' : '')); // No I18N
		        this._createVisuals();
		        if (!isDis) {
		            this._bindEvents();
		        }
		        if (opts.preserveAspectRatio) {
		            this._ratio = ele.width() / ele.height();
		        }
		    }
		    _createVisuals() { /* Adding the resizable handlers based on the handle option */
		        let opts = this._opts,
		            handles = opts.directions,
		            isStrType = typeof handles === 'string', // No I18N
		            axiswithIcons = [ 'se', 'sw', 'ne', 'nw' ]; // No I18N
		        if (opts.rtl && isStrType) {
		            handles = handles.replace(/e/g, 'east').replace(/w/g, 'e').replace(/east/g, 'w'); // No I18N
		        }
		        if (isStrType) {
		            handles = handles === 'all' ? [ 's', 'e', 'n', 'w', 'se', 'sw', 'ne', 'nw' ] : handles.split(','); // No I18N
		        }
		        let htmlStr = '',	// No I18N
		            styleStr = 'style=display:none;', // No I18N
		            showHandle = false,
		            showCue = false,
		            handlesArr = typeof opts.handles === 'object' ? opts.handles : undefined, // No I18N
		            cueArr = typeof opts.cues === 'object' ? opts.cues : undefined, // No I18N
		            isIconsEmpty = ZC.isEmpty(opts.cueIcons),
		            cueSVG, cueSprite, hName, cueIcons,
		            iconCls = 'zresizable__icon zresizable__cue'; // No I18N
		        for (let i = 0; i < handles.length; i++) {
		            let handle = handles[i].trim();
		            hName = this.dirMap[handle];
		            showHandle = opts.handles === 'all' || opts.handles === handle || (handlesArr && handlesArr.indexOf(handle) > -1); // No I18N
		            showCue = opts.cues === 'all' || opts.cues === handle || (cueArr && cueArr.indexOf(handle) > -1); // No I18N
		            htmlStr += '<div hdir=' + handle + " class='zresizable__handle zresizable__" + handle + ' ' + (opts.handleClasses[hName] || '') + "'>";	// No I18N
		            htmlStr += '<div class="zresizable__sub__handle ' + (showHandle ? 'h-visibleitem' : '') + '" ' + (showHandle ? '' : styleStr) + ' ></div>';
		            // if (isIconsEmpty && axiswithIcons.indexOf(handle) >= 0) { // if cue icons are not provided, default cue icons will be shown.
		            if (isIconsEmpty) { // if cue icons are not provided, default cue icons will be shown.
		                // htmlStr += '<i class="' + iconCls + ' ' + (showCue ? 'h-visibleitem' : '') + '" ' + (showCue ? '' : styleStr) + '  ><svg class="zresizable__svg" viewBox="0 0 12 12" width="100%" height="100%"><line x1="11" y1="1" x2="1" y2="11"></line><line x1="11" y1="5" x2="5" y2="11"></line><line x1="11" y1="9" x2="9" y2="11"></line></svg></i>'; // No I18N
		                htmlStr += '<i class="' + iconCls + ' ' + (showCue ? 'h-visibleitem' : '') + '" ' + (showCue ? '' : styleStr) + '  ></i>'; // No I18N
		            } else {
		                cueSprite = opts.cueIcons[hName + 'iconClassName']; // No I18N
		                cueSVG = opts.cueIcons[hName + 'SVGIconId']; // No I18N
		                if (cueSVG || cueSprite) {
		                    cueIcons = ZC._getIconInfo(cueSprite, cueSVG);
		                    iconCls += ' ' + cueIcons.iconClassName;// No I18N
		                    htmlStr += '<i class="' + iconCls + ' ' + (showCue ? 'h-visibleitem' : '') + '"  ' + (showCue ? '' : styleStr) + '>'; // No I18N
		                    if (cueIcons.SVGIconId) {
		                        htmlStr += '<svg class=' + cueIcons.SVGIconClassName + '><use xlink:href="' + cueIcons.SVGIconId + '" ></use></svg>'; // No I18N
		                    }
		                    htmlStr += '</i>'; // No I18N
		                } else {
		                    // htmlStr += '<i class="' + iconCls + ' ' + (showCue ? 'h-visibleitem' : '') + '" ' + (showCue ? '' : styleStr) + '  ><svg class="zresizable__svg" viewBox="0 0 12 12" width="100%" height="100%"><line x1="11" y1="1" x2="1" y2="11"></line><line x1="11" y1="5" x2="5" y2="11"></line><line x1="11" y1="9" x2="9" y2="11"></line></svg></i>'; // No I18N
		                    htmlStr += '<i class="' + iconCls + ' ' + (showCue ? 'h-visibleitem' : '') + '" ' + (showCue ? '' : styleStr) + '  ></i>'; // No I18N
		                }
		            }
		            htmlStr += '</i></div>';	// No I18N
		        }
		        this.element.append(htmlStr);
		    }
		    _bindEvents() { /* Binding the events to the element and document */
		        let handles = this.element.find('.zresizable__handle'); // No I18N
		        this._addEvents({
		            handleMD: 'mousedown', // No I18N
		            handleMU: 'mouseup' // No I18N
		        }, handles);
		        this._bindHandleCueEvents(true);
		        this._bindHandleCueEvents();
		    }
		    _handleMDHandler(event) {
		        let cname = this.name,
		            opts = this._opts,
		            delay = opts.delay,
		            ele = this.element;
		        if (delay) {
		            ZC.$document.on('mousemove.delay.' + cname, (eve) => {
		                if (eve.pageX !== event.pageX && eve.pageY !== event.pageY) {
		                    clearTimeout(this._delay);
		                    ZC.$document.off('mousemove.delay.' + cname); // No I18N
		                }
		            });
		        }
		        this._delay = window.setTimeout(() => {
		            event.preventDefault();
		            this._md = true;
		            let width = parseInt(ele.outerWidth(true)),
		                height = parseInt(ele.outerHeight(true));
		            this.size = {
		                width: width,
		                height: height
		            };
		            this.orgSize = {
		                width: width,
		                height: height
		            }
		            if (opts.boundary) {
		                this._saveContainerData();
		            }
		            let off = ele.offset(),
		                currTop = parseInt(off.top) || 0,
		                currLeft = parseInt(off.left) || 0;
		            this.offset = off;
		            this.orgPos = {
		                left: currLeft,
		                top: currTop
		            };
		            this.position = {
		                left: currLeft,
		                top: currTop
		            };
		            this.currTop = currTop;
		            this.currLeft = currLeft;
		            this._bindDocEvents(currTop, currLeft);
		            this.orgMousePos = {
		                left: event.pageX,
		                top: event.pageY
		            };
		            this.sizeDiff = {
		                width: ele.outerWidth(true) - ele.width(),
		                height: ele.outerHeight(true) - ele.height()
		            };
		            if (opts.relatedElements) {
		                this._cacheProperties(opts.relatedElements);
		            }
		            this._target = $(event.target).closest('.zresizable__handle'); // No I18N
		            this._resizeDirection = $(this._target).attr('class').replace('zresizable__handle zresizable__', ''); // No I18N
		            this._dispatchEvent('start', event);	// No I18N
		        }, delay);
		    }
		    _handleMUHandler(event) {
		        let cname = this.name;
		        clearTimeout(this._delay);
		        if (this._md) {
		            this._dispatchEvent('end', event);	// No I18N
		            ZC.$document.off('mousemove.' + cname + ' mouseup.' + cname); // No I18N
		            $('body').css('cursor', 'default').removeClass('zh-userselectnone');
		            this._md = false;
		        }
		    }
		    _bindHandleCueEvents(isHandle) {
		        let eSuff = (isHandle ? '.handle.' : '.cue.') + this.name, // No I18N
		            ele = this.element,
		            handles = ele.find('.zresizable__handle'), // No I18N
		            sel = (isHandle ? '.zresizable__sub__handle' : '.zresizable__cue') + '.h-visibleitem', // No I18N
		            nestedEles = ele.find('.zresizable__handle ' + sel), // No I18N
		            dis = this._opts['display' + (isHandle ? 'Handles' : 'Cues')], // No I18N
		            _showHide = (event, hide, context) => {
		                if (context) {
		                    let target = $(event.target).closest('.zresizable__handle'); // No I18N
		                    target.find(sel)[hide ? 'hide' : 'show'](); // No I18N
		                } else {
		                    nestedEles[hide ? 'hide' : 'show'](); // No I18N
		                }
		            },
		            showFunc = (event, context) => {
		                _showHide(event, false, context);
		            },
		            hideFunc = (event, context) => {
		                _showHide(event, true, context);
		            };
		        nestedEles.hide();
		        if (dis === 'onelementmouseover') { // No I18N
		            ele.on('mouseenter' + eSuff, showFunc).on('mouseleave' + eSuff, hideFunc); // No I18N
		        } else if (dis === 'onelementactive') { // No I18N
		            ele.on('focus' + eSuff, showFunc).on('blur' + eSuff, hideFunc); // No I18N
		        } else if (dis === 'oncontextmouseover') { // No I18N
		            handles.on('mouseenter' + eSuff, function(event) { // No I18N
		                showFunc(event, true);
		            }).on('mouseleave' + eSuff, function(event) {
		                hideFunc(event, true);
		            });
		        } else if (dis === 'always') { // No I18N
		            nestedEles.show();
		        }
		    }
		    _unbindHandleCueEvents(isHandle) {
		        let ele = this.element,
		            handles = ele.find('.zresizable__handle'), // No I18N
		            eSuff = (isHandle ? '.handle.' : '.cue.') + this.name; // No I18N
		        ele.off(eSuff);
		        handles.off(eSuff);
		    }
		    _bindDocEvents() {
		        this._addEvents({
		            docMM: 'mousemove', // No I18N
		            handleMU: 'mouseup' // No I18N
		        }, ZC.$document);
		    }
		    _docMMHandler(event) {
		        if (this._md) {
		            let ele = this.element;
		            // resetting the right and bottom values after setting the top and left values as the draggable element might have right and bottom set on them previously.
		            if (ele[0].style.right || ele[0].style.bottom) {
		                ele.css({
		                    right: '',
		                    bottom: ''
		                });
		                ele.css({
		                    top: this.currTop,
		                    left: this.currLeft
		                });
		            }
		            let dx = (event.pageX - this.orgMousePos.left) || 0,
		                dy = (event.pageY - this.orgMousePos.top) || 0,
		                a = $(this._target).attr('hdir'), // No I18N Retrieving the axis variable - n,s,e,w,ne,nw,se,sw
		                data = this._computePosition(a, dx, dy);
		                // reversing the direction related logic goes here.
		            // if (data.width <= 0 && !this._opts.minWidth && a === 'se' || a === 'e') { // No I18N
		            // ele.find('.zresizable__e').trigger('mouseup');
		            // ele.find('.zresizable__n').trigger('mousedown');
		            // return;
		            // }
		            data = this._checkLimit(data, a);
		            if (this._opts.boundary) {
		                data = this._checkContainerLimit(data);
		            }
		            if (this._opts.relatedElements) {
		                this._resizeOthers(); // Simultaneously resize the other elements if relatedElements is given.
		            }
		            if (a === 'n' || a === 'ne' || a === 'nw' || a === 'w' || a === 'sw') { // No I18N
		                ele.offset({
		                    top: this.position.top,
		                    left: this.position.left
		                });
		            }
		            ele.outerWidth(this.size.width);
		            ele.outerHeight(this.size.height);
		            $('body').css('cursor', a + '-resize').addClass('zh-userselectnone'); // No I18N
		            this._updateCache(data);
		            this._dispatchEvent('resize', event);	// No I18N
		        }
		    }
		    _dispatchEvent(eventName, event) {
		        super._dispatchEvent(eventName, event, {
		            originalPosition: this.orgPos,
		            originalSize: this.orgSize,
				 	resizedDirection: this._resizeDirection
		        });
		    }
		    _cacheProperties(sel) { /* Storing the relatedElements element's current size and position */
		        let eles = $(sel),
		            ele;
		        for (let i = 0; i < eles.length; i++) {
		            ele = $(eles[i]);
		            ele.data('resizable-related', {	// No I18N
		                width: parseInt(ele.outerWidth(true)),
		                height: parseInt(ele.outerHeight(true)),
		                left: parseInt(ele.css('left'), 10), // No I18N
		                top: parseInt(ele.css('top'), 10) // No I18N
		            });
		        }
		    }
		    _resizeOthers() { /* Resizing the relatedElements elements whenever the original element is being resized */
		        let diff = {
		            height: (this.size.height - this.orgSize.height) || 0,
		            width: (this.size.width - this.orgSize.width) || 0,
		            top: (this.position.top - this.orgPos.top) || 0,
		            left: (this.position.left - this.orgPos.left) || 0
		        };
		        let relatedEles = $(this._opts.relatedElements),
		            len = relatedEles.length,
		            ele, data, style, css, j, jLen, prop, sum;
		        for (let i = 0; i < len; i++) {
		            ele = $(relatedEles[i]);
		            data = ele.data('resizable-related'); // No I18N
		            style = {};
		            css = ele.closest(this.element).length ? [ 'width', 'height' ] : [ 'width', 'height', 'top', 'left' ]; // No I18N
		            jLen = css.length;
		            for (j = 0; j < jLen; j++) {
		                prop = css[j];
		                sum = (data[prop] || 0) + (diff[prop] || 0);
		                if (sum && sum >= 0) {
		                    if (prop === 'width' || prop === 'height') { // No I18N
		                        ele['outer' + prop[0].toUpperCase() + prop.substr(1)](sum); // No I18N
		                    } else {
		                        style[prop] = sum;
		                    }
		                }
		            }
		            ele.css(style);
		        }
		    }
		    _updateCache(data) { /* Updating the modified size and position in order to reflect those properties in the next resize */
		        if (data.left) {
		            this.position.left = data.left;
		        }
		        if (data.top) {
		            this.position.top = data.top;
		        }
		        if (data.height) {
		            this.size.height = data.height;
		        }
		        if (data.width) {
		            this.size.width = data.width;
		        }
		    }
		    _computePosition(a, dx, dy) { /* Computing the new size and position based on the mouse movement */
		        let os = this.orgSize,
		            op = this.orgPos,
		            size = {};
		        switch (a) {
		            case 'n' : // No I18N
		                size.top = op.top + dy; // North ( Top + Height)
		                size.height = os.height - dy;
		                break;
		            case 's' : // No I18N
		                size.height = os.height + dy; // South  ( Height )
		                break;
		            case 'e' : // No I18N
		                size.width = os.width + dx; // East ( Width )
		                break;
		            case 'w' : // No I18N
		                size.left = op.left + dx; // West ( Left + Width )
		                size.width = os.width - dx;
		                break;
		            case 'se': // South East  ( Height + Width )	// No I18N
		            case 'sw': // South West  ( Left + Width + Height )	// No I18N
		            case 'ne': // North East ( Top + Width + Height )	// No I18N
		            case 'nw': // North West ( Top + Left + Width + Height)	// No I18N
		                size = $.extend(this._computePosition(a[0], dx, dy), this._computePosition(a[1], dx, dy)); // No I18N
		                break;
		        }
		        if (this._opts.preserveAspectRatio) {
		            if (size.width) {
		                size.height = size.width / this._ratio;
		            } else if (size.height) {
		                size.width = size.height * this._ratio;
		            }
		        }
		        return size;
		    }
		    _hasScroll(ele, pos) {
		        if ($(ele).css('overflow') === 'hidden') { // No I18N
		            return false;
		        }
		        return ele[ 'scroll' + (pos ? 'Left' : 'Top')] > 0; // No I18N
		    }
		    _saveContainerData() { /* Storing the current size and position of the containing element if boundary option is provided */
		        let boundary = this._opts.boundary,
		            containerElement = boundary === 'parent' ? this.element.parent().get(0) : boundary, // No I18N
		            contOff = {},
		            isDoc = containerElement === 'page'; // No I18N
		        if (isDoc || containerElement === 'viewport') { // No I18N
		            contOff = {
		                left: 0,
		                top: 0
		            };
		            let ele = ZC[isDoc ? '$document' : '$window'], // No I18N
		                sLeft = window.pageXOffset,
		                sTop = window.pageYOffset;
		            this.parentData = {
		                scrollTop: sTop,
		                scrollLeft: sLeft,
		                top: sTop,
		                left: sLeft,
		                element: ele,
		                width: ele.width() - sLeft,
		                height: ele.height() + (isDoc ? sTop : 0)
		            };
		        } else {
		            let element = $(containerElement),
		                p = [],
		                arr = [ 'Top', 'Right', 'Left', 'Bottom' ], // No I18N
		                arrLen = arr.length,
		                name;
		            for (let i = 0; i < arrLen; i++) {
		                name = arr[i];
		                p[i] = parseInt(element.css('padding' + name)) || 0; // No I18N
		            }
		            contOff = element.offset();
		            let hgt = element.innerHeight() - p[3],
		                wid = element.innerWidth() - p[1];
		            let contSize = {
		                height: this._hasScroll(element) ? element[0].scrollHeight : hgt,
		                width: this._hasScroll(element, 'left') ? element[0].scrollWidth : wid
		            };
		            this.parentData = {
		                element: containerElement,
		                scrollTop: element.scrollTop(),
		                scrollLeft: element.scrollLeft(),
		                left: contOff.left,
		                top: contOff.top,
		                width: contSize.width,
		                height: contSize.height
		            };
		        }
		    }
		    _checkContainerLimit(data) { /* Ensuring that new size and position doesn't exceed the container size and position */
		        let parData = this.parentData,
		            pos = this.position,
		            sTop = parData.scrollTop;
		        if (pos.top + data.height - sTop >= parData.top + parData.height) {
		            // let totalHeight = pos.top + data.height - sTop,
		            //     diff = totalHeight - parData.top - parData.height + (this._target ? parseInt($(this._target).height()) / 2 : 0);
		            // data.height = data.height - diff;
		            data.height = parData.top + parData.height - sTop - pos.top;
		        }
		        let sLeft = parData.scrollLeft;
		        if (pos.left + data.width - sLeft >= parData.left + parData.width) {
		            // let totalWidth = pos.left + data.width - sLeft,
		            //     diff = totalWidth - parData.left - parData.width + (this._target ? parseInt($(this._target).width()) / 2 : 0);
		            // data.width = data.width - diff;
		            data.width = parData.left + parData.width - sLeft - pos.left;
		        }
		        if (data.top && data.top < parData.top) {
		            data.top = parData.top;
		            data.height = this.size.height;
		        }
		        if (data.left && data.left < parData.left) {
		            data.left = parData.left;
		            data.width = this.size.width;
		        }
		        return data;
		    }
		    _checkLimit(data, axis) { /* Checking the new size and position against minimum width,minimum height,maximum width and maximum height */
		        let opts = this._opts,
		            minW = opts.minWidth,
		            maxW = opts.maxWidth,
		            minH = opts.minHeight,
		            maxH = opts.maxHeight,
		            hasLessWid = data.width && minW && (data.width < minW),
		            hasLessHei = data.height && minH && (data.height < minH),
		            hasMoreWid = data.width && maxW && (data.width > maxW),
		            hasMoreHei = data.height && maxH && (data.height > maxH);
		        if (hasLessWid) {
		            data.width = minW;
		        }
		        if (hasLessHei) {
		            data.height = minH;
		        }
		        if (hasMoreWid) {
		            data.width = maxW;
		        }
		        if (hasMoreHei) {
		            data.height = maxH;
		        }
		        let diffWid = this.orgPos.left + this.orgSize.width,
		            diffHei = this.position.top + this.size.height,
		            changeWid = /sw|nw|w/.test(axis),
		            changeHei = /nw|ne|n/.test(axis);
		        if (hasLessWid && changeWid) {
		            data.left = diffWid - minW;
		        }
		        if (hasMoreWid && changeWid) {
		            data.left = diffWid - maxW;
		        }
		        if (hasLessHei && changeHei) {
		            data.top = diffHei - minH;
		        }
		        if (hasMoreHei && changeHei) {
		            data.top = diffHei - maxH;
		        }
		        let noWidHgt = !data.width && !data.height;
		        if (noWidHgt && !data.left && data.top) {
		            data.top = undefined;
		        } else if (noWidHgt && !data.top && data.left) {
		            data.left = undefined;
		        }
		        return data;
		    }
		    destroy() { /* Destroys the resizable component functionality */
		        this.element.removeClass('zresizable').removeData('zresizable'); // No I18N
		        this.element.find('.zresizable__handle').remove(); // No I18N
		        this._unbindEvents(true);
		    }
		    _showHideEle(dir = this._opts.directions, hide, isCue) {
		        let handle = typeof dir === 'string' ? dir.split(',') : dir, // No I18N
		            len = handle.length,
		            ele;
		        for (let i = 0; i < len; i++) {
		            ele = this.element.find('.zresizable__' + handle[i]).find('.zresizable__' + (isCue ? 'cue' : 'sub__handle'));
		            ele[hide ? 'removeClass' : 'addClass']('h-visibleitem')[hide ? 'hide' : 'show'](); // No I18N
		        }
		    }
		    showHandles(dir) { // string or array type supported
		        this._showHideEle(dir);
		    }
		    hideHandles(dir) {
		        this._showHideEle(dir, true);
		    }
		    showCues(dir) {
		        this._showHideEle(dir, false, true);
		    }
		    hideCues(dir) {
		        this._showHideEle(dir, true, true);
		    }
		    _setAttribute(optName, value) { /* Changing the options of the resizable component */
		        let opts = this._opts,
		            ele = this.element;
		        opts[optName] = value;
		        if (optName === 'directions' || optName === 'cues' || optName === 'handles' || optName === 'rtl' || optName === 'cueIcons') { // No I18N
		            ele.find('.zresizable__handle').remove(); // No I18N
		            this._createVisuals();
		            if (!opts.disabled) {
		                this._bindEvents();
		            }
		        } else if (optName === 'displayCues' || optName === 'displayHandles') { // No I18N
		            let isHandle = optName.indexOf('Cue') < 0; // No I18N
		            this._unbindHandleCueEvents(isHandle);
		            this._bindHandleCueEvents(isHandle);
		        } else if (optName === 'preserveAspectRatio') { // No I18N
		            this._ratio = value ? (ele.width() / ele.height()) : undefined;
		        }
		    }
		    _unbindEvents(fromDes) {
		        let cname = this.name,
		            handles = this.element.find('.zresizable__handle');
		        handles.off('.' + cname); // No I18N
		        this.element.off('.' + cname); // No I18N
		        ZC.$document.off('.' + cname); // No I18N
		        if (fromDes) {
		            handles.remove();
		        }
		    }
		    _disable(value) {
		        this.element[value ? 'addClass' : 'removeClass']('is-disabled'); // No I18N
		        this[(value ? '_un' : '_') + 'bindEvents'](); // No I18N
		    }
		}
	ZC.registerComponent('ZResizable', ZResizable); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
	class ZTooltip  extends ZC.CoreComponent{
			get name(){
				return "ztooltip";
			}
	    get attrs() {
	        return {
	            isMessageHTMLEncoded: false,
	            selector: undefined,
	            displayType: 'box', // No I18N
	            position: 'at-cursor', // No I18N
	            hideOnTargetClick: true,
	            margin: undefined,
	            showDelay: 500,
	            hideDelay: 300,
	            maxDisplayTime: 5000,
	            reshowDelay: undefined,
	            showShortcutKey: true,
	            animation: {
	                show: {
	                    name: 'fade' // No I18N
	                },
	                hide: {
	                    name: 'fade' // No I18N
	                }
	            },
	            className: undefined,
	            innerHTML: undefined,
	            pauseOnMouseOver: false,
	            positionAlterable: undefined,
	            parseTitleForOptions: false,
	            /* New */
	            forElement: ''// api for ellipsis element // No I18N
	        }
	    }
	    get EVENTS() {
	        return [
	            'beforeshow', // No I18N
	            'show', // No I18N
	            'beforehide', // No I18N
	            'hide' // No I18N
	        ]
	    }
	    _create() {
	        let _namespace = '.' + this.name; // No I18N
	        this._eventSuffix = _namespace + '-temp'; // No I18N
	        this.element
	            .on('mouseenter' + _namespace + ' mousemove' + _namespace, this._targetEnter.bind(this)) // No I18N
	            .on('mouseleave' + _namespace, () => { // No I18N
	                ZC._inTooltipArea = false;
	            });
	        this._scrollHandlerBinded = this._scrollHandler.bind(this);
	    }
	    _scrollHandler(orgEvent) {
	        this._hide(undefined, orgEvent);
	    }
	    _handleEvents(listen) {
	        let _namespace = this._eventSuffix;
	        ZC.$document.off(_namespace);
	        window.removeEventListener('scroll', this._scrollHandlerBinded, true); // No I18N
	        if (listen) {
	            ZC.$document.on('keydown' + _namespace + ' mousedown' + _namespace, (orgEvent) => { // No I18N
	                this._hide(undefined, orgEvent);
	            });
	            window.addEventListener('scroll', this._scrollHandlerBinded, true); // No I18N
	        }
	    }
	    _targetEnter(origEvent, customTarget, opt) {
	        let target,
	            disabledSelector = 'button[disabled], input[disabled], textarea[disabled], fieldset[disabled], select[disabled], keygen[disabled] , output[disabled], option[disabled]'; // No I18N
	        this.custom = false;
	        // Disabled form elements are omitted becos some browsers doesnt trigger events for disabled elements.
	        if (this.target && (this.target.is(':hidden') || this.target.is(disabledSelector))) { // No I18N
	            this._hide(undefined, origEvent);
	            return;
	        }
	        if (origEvent) {
	            if (!origEvent.originalEvent) {
	                return;
	            }
	            this.pageX = origEvent.pageX;
	            this.pageY = origEvent.pageY;
	            target = $(origEvent.target).closest('[title],[data-title-content-id]'); // No I18N
	            if (this.target && this.target.is(':hover') && !this.target.find(target).length) { // No I18N
	                if (!this._refreshed && (this._lastTip || this._hiddenOnTimeOut)) {
	                    return;
	                }
	                target = this.target;
	            } else if (!target.length || ((!target.attr('title') && !this._opts.forElement && !target.attr('data-title-for-element')) || target.attr('data-title-content-id') || (this._opts.selector && !target.is(this._opts.selector)))) {
	                /*
	                1. If not a DOM Element
	                2. If there is no content in title/content-id attribute
	                3. If it does'nt match the given selector,
	                tooltip is not shown.
	            */
	                return;
	            }
	            if (ZC._inTooltipArea) {
	                if (this.element.find(ZC._inTooltipArea.element[0]).length) {
	                    return;
	                }
	                ZC._inTooltipArea._hide(true);
	            }
	            ZC._inTooltipArea = this;
	        } else if (customTarget) {
	            this.custom = true;
	            target = $(customTarget);
	        } else {
	            return;
	        }
	        this._hiddenOnTimeOut = false;
	        // clear previous title.
	        this.target && this._clearTitle(true, this.target);
	        this.target = target;
	        // Saving the options of the target so retrival will be easy
	        this.targetOpt = this._getOptions(target, opt);
	        // @deprecated
	        if (this.custom) {
	            this.targetOpt.showDelay = 0;
	        }
	        this._clearTitle();
	        this.target
	            .off(this._eventSuffix)
	            .on('mouseleave' + this._eventSuffix, (origEvent) => {// No I18N
	                this._hiddenOnTimeOut = false;
	                this._hide(undefined, origEvent);
	            });
	        this._lastEvent = origEvent;
	        this._show(origEvent);
	    }
	    _hide(immediate, origEvent) {
	        if (this.target) {
	            if (this._trigger('beforehide', origEvent)) { // No I18N
	                let clearTitle = !this.target.is(':hover'); // No I18N
	                clearTitle && this._clearTitle(true);
	                this._clearShowTimer();
	                this._clearHideTimer();
	                if (this.container) {
	                    this._removeTip(immediate, clearTitle); // No I18N
	                }
	                this._handleEvents();
	            }
	        }
	    }
	    _show(origEvent) {
	        let targetOpt = this.targetOpt;
	        let target = this.target;
	        if (targetOpt.showDelay && targetOpt.reshowDelay === undefined) {
	            this.targetOpt.reshowDelay = targetOpt.showDelay / 5;
	        }
	        if (this.targetOpt.hideOnTargetClick) {
	            target.on('mousedown' + this._eventSuffix, (origEvent) => { // No I18N
	                if (this._trigger('beforehide', origEvent)) { // No I18N
	                    this._clearShowTimer();
	                    this._removeTip(true);
	                }
	            });
	        }
	        this._showTooltip(origEvent);
	    }
	    _clearShowTimer() {
	        clearTimeout(this.showTimer)
	    }
	    _clearHideTimer() {
	        clearTimeout(this.hideTimer);
	    }
	    _setTimer(target, opt) {
	        let maxDisplayTime = opt.maxDisplayTime;
	        maxDisplayTime = typeof maxDisplayTime === 'number' ? Number(maxDisplayTime) : 0; // No I18N
	        if (maxDisplayTime) {
	            this._clearHideTimer();
	            this.hideTimer = setTimeout(() => {
	                if (this._trigger('beforehide', undefined, {// No I18N
	                    exceededMaxDisplayTime: true
	                })) {
	                    this._hiddenOnTimeOut = true;
	                    this._removeTip(true);
	                }
	            }, maxDisplayTime);
	        }
	    }
	    _getTitleForEllipsisEle(options) {
	        let ellipsisEle = this.target;
	        if (options.forElement !== 'self') { // No I18N
	            ellipsisEle = ellipsisEle.find(options.forElement);
	        }
	        if (!ellipsisEle.length || ellipsisEle[0].clientWidth >= ellipsisEle[0].scrollWidth) {
	            return;
	        }
	        return options.title || ellipsisEle.text();
	    }
	    _showHandler(origEvent, animation) {
	        if (this._trigger('beforeshow', origEvent)) { // No I18N
	            let options = this.targetOpt;
	            if (!this.target.is(':visible')) { // No I18N
	                return;
	            }
	            if (options.forElement) {
	                let title = this._getTitleForEllipsisEle(options);
	                if (!title) {
	                    return;
	                }
	                options.title = title;
	            }
	            this._clearHideTimer();
	            /* validating the position */
	            if (!/^(auto|top|bottom|right|left|top-left|top-right|bottom-left|bottom-right|at-cursor|follow-cursor)$/.test(options.position)) {
	                options.position = this._DEFAULTS.position;
	            }
	            /* set displayType = "box" for at-cursor/follow-cursor */
	            if (this._isAtCursorPos()) {
	                if ((this.pageX === undefined || this.pageY === undefined) && !options.offset) {
	                    options.position = 'top'; // No I18N
	                } else {
	                    options.displayType = 'box'; // No I18N
	                }
	            }
	            this._includeContent();
	            this._createTooltip();
	            this._setTimer(this.target, options);
	            if (options.position === 'follow-cursor') { // No I18N
	                this.target.on('mousemove' + this._eventSuffix, (origEvent) => { // No I18N
	                    this._positionElement(origEvent);
	                    /* When the tooltip is on move, its hidetimer is reset */
	                    this._setTimer(this.target, options);
	                });
	            }
	            this._positionElement(origEvent);
	            this._handleEvents(true);
	            this._animate(this.container, animation, 'show', () => { // No I18N
	                this._trigger('show', origEvent); // No I18N
	            });
	        }
	    }
	    _showTooltip(origEvent) {
	        let options = this.targetOpt;
	        let delay = options.showDelay;
	        let animation = options.animation;
	        if (this.container) {
	            if (this.target.is(this._lastTip)) {
	                animation = delay = undefined;
	            } else {
	                delay = options.reshowDelay;
	                this._trigger('hide', origEvent, this._lastTip); // No I18N
	            }
	        }
	        /* When the tooltip is about to be displayed, current target is set as last target */
	        this._lastTip = this.target;
	        this._clearShowTimer();
	        if (delay) {
	            this.showTimer = setTimeout(this._showHandler.bind(this, origEvent, animation), delay);
	        } else {
	            this._showHandler(origEvent, animation);
	        }
	    }
	    _animate(element, animation, action, animationCallback) {
	        let callback = () => {
	            element.css('display', action === 'hide' ? 'none' : ''); // No I18N
	            animationCallback && animationCallback();
	        }
	        if (animation && ZC.animationHandler && !$.isEmptyObject(animation)) {
	            let animationObject = {
	                element: element,
	                action: action,
	                callback: callback,
	                ctype: this.name,
	                animation: animation
	            }
	            ZC.animationHandler(animationObject);
	        } else {
	            callback();
	        }
	    }
	    _includeContent() {
	        let targetOptions = this.targetOpt;
	        if (typeof targetOptions === 'object') { // No I18N
	            let content = targetOptions.title = targetOptions.title || targetOptions.content || ''; // No I18N
	            if (typeof targetOptions.innerHTML === 'string') { // No I18N
	                content = this._populateTemplate(targetOptions.innerHTML, targetOptions);
	            } else if (typeof targetOptions.contentId === 'string') { // No I18N
	                content = document.getElementById(targetOptions.contentId).innerHTML;
	            } else {
	                content = this._encodeContent(content);
	            }
	            if (targetOptions.showShortcutKey && ZC.ShortCut) {
	                content = this._appendShortCut(targetOptions, content);
	            }
	            this._setContent(targetOptions, content);
	        }
	    }
	    _setContent(options, content) {
	        this._opts.content = content;
	    }
	    _encodeContent(htmlContent) {
	        return this.targetOpt.isMessageHTMLEncoded ? htmlContent : ZC.encodeHTML(htmlContent);
	    }
	    _populateTemplate(template, data) {
	        if (typeof template === 'string') { // No I18N
	            return template.replace(/(#?#[^# ]+#?#)/g, (match) => {
	                let content = data[match.replace(/#/g, '')]; // No I18N
	                return this._isNotNull(content) ? this._encodeContent(content) : match; // No I18N
	            });
	        } else if (typeof template === 'function') { // No I18N
	            return template(data);
	        }
	    }
	    _isAtCursorPos() {
	        return /^(at-cursor|follow-cursor)$/.test(this.targetOpt.position);
	    }
	    _positionElement(origEvent) {
	        let positionObject = this._getPosition(origEvent);
	        let direction = positionObject.direction.split('-')[0]; // No I18N
	        this.container.removeClass('class').addClass('ztooltip ztooltip--' + direction); // No I18N
	        let margin = this.targetOpt.margin;
	        if (this._isAtCursorPos() || (margin && typeof margin === 'object')) { // No I18N
	            this._updateMargin(margin, positionObject, direction);
	        }
	        this.container.css(positionObject.elementPosition);
	        if (this._callout) {
	            this._callout.css(positionObject.arrowPosition);
	        }
	    }
	    _getPosition(origEvent) {
	        let opt = this.targetOpt;
	        let eventTarget = this.target,
	            position = opt.position,
	            positionAlterable = opt.positionAlterable;
	        this.container.css({
	            left: 'auto', // No I18N
	            right: 'auto' // No I18N
	        });
	        /* Get the current position of mouse pointer */
	        let offset = opt.offset;
	        if (this._isAtCursorPos() || offset) {
	            if (offset) {
	                this.pageX = parseInt(offset.left);
	                this.pageY = parseInt(offset.top);
	            } else {
	                position = 'bottom-left'; // No I18N
	            }
	            eventTarget = origEvent || {
	                preventDefault: function() {}
	            };
	            eventTarget.pageX = this.pageX;
	            eventTarget.pageY = this.pageY;
	            positionAlterable = 'flipallfit'; // No I18N
	        } else if (opt.position === 'auto') { // No I18N
	            position = 'bottom'; // No I18N
	            positionAlterable = 'flipallfit'; // No I18N
	        } else if (positionAlterable === undefined) {
	            positionAlterable = false;
	        }
	        return ZC.Position.get(eventTarget, this.container, {
	            rtl: opt.rtl,
	            direction: position,
	            eventObj: origEvent,
	            bufferSpace: this._callout ? 10 : 0,
	            positionAlterable: positionAlterable,
	            arrowCallback: (element, direction) => {
	                $(element).attr('class', 'ztooltip__pointer zh-' + direction); // No I18N
	            },
	            arrow: opt.displayType === 'callout' ? { // No I18N
	                element: this._callout,
	                direction: true,
	                minSpace: 8
	            } : undefined
	        });
	    }
	    _removeTipHandler(immediate) {
	        if (this.container) {
	            if (!immediate && this.targetOpt.pauseOnMouseOver && this.container.is(':hover')) { // No I18N
	                return;
	            }
	            this._lastTip = null;
	            this._animate(this.container, this.targetOpt.animation, 'hide', () => { // No I18N
	                this._callout = null;
	                this._trigger('hide'); // No I18N
	            });
	        }
	    }
	    _removeTip(immediate, clearTitle) {
	        this._lastEvent = false;
	        this._clearHideTimer();
	        if (this.container) {
	            /* This has been incuded becos, for all tip targets, its title is reset on targetleave
	            but incase of tip shown using show method, there wont be any targetleave method to clear its title.
	              This cannot be done for all case becos removeing tip on target click, its title should not be cleared.
	            */
	            this.custom && clearTitle && this._clearTitle(true, this.target);
	            if (immediate || !this.targetOpt.hideDelay) {
	                this._removeTipHandler(immediate);
	            } else {
	                this.hideTimer = setTimeout(this._removeTipHandler.bind(this), this.targetOpt.hideDelay);
	            }
	        }
	    }
	    _getOptions(target, opt) {
	        let titledata = target.attr('title'); // No I18N
	        let localOpts = {
	            title: titledata
	        };
	        if (this._opts.parseTitleForOptions && titledata && isNaN(titledata) && titledata.indexOf('{') !== -1) { // No I18N
	            try {
	                localOpts = JSON.parse(titledata);
	            } catch (e) {
	            }
	        } else {
	            $.extend(localOpts, this._getTargetAttrs(target));
	        }
	        return $.extend(true, {}, this._opts, localOpts, opt || {});
	    }
	    _createTooltip() {
	        let targetOpt = this.targetOpt;
	        this._opts.callout = targetOpt.displayType === 'callout'; // No I18N
	        this._callout = false;
	        let element = this._render(!!this.container);
	        if (element) {
	            // If tooltip is present already, it is not recreated.
	            if (this.container) {
	                this.container
	                    .stop(true, true)
	                    .hide();
	            } else {
	                this.container = $(element)
	                    .on('mouseleave' + this._eventSuffix, () => { // No I18N
	                        if (!this.target) {
	                            this._removeTipHandler();
	                        }
	                    });
	            }
	        }
	        this.container
	            .css('pointer-events', targetOpt.pauseOnMouseOver ? 'auto' : '') // No I18N
	            .attr('class', 'ztooltip ' + (targetOpt.className || '') + (targetOpt.rtl ? ' h-rtl' : '')); // No I18N
	        if (this._opts.callout) {
	            this._callout = this.container.find('.ztooltip__pointer'); // No I18N
	        }
	    }
	    _render(skipParent) {
	        let renderParam = {
	            skipParent: skipParent
	        }
	        return ZC._render(this._opts, this.name, null, this.container && this.container[0], $('body')[0], renderParam); // No I18N
	    }
	    _isUploadFileBtn(target) {
	        return target.tagName === 'INPUT' && target.type === 'file'; // No I18N
	    }
	    _clearTitle(reset, target) {
	        target = target || this.target;
	        if (target && target.length) {
	            if (reset) {
	                target.off(this._eventSuffix);
	                let parents = target.data('zdependentElements') || []; // No I18N
	                for (let i = 0; i < parents.length; i++) {
	                    let tar = $(parents[i]);
	                    let titleAttr = tar.attr('title'); // No I18N
	                    if (titleAttr === undefined || (!titleAttr && this._isUploadFileBtn(tar[0]))) { // No I18N
	                        tar.attr('title', tar.data('ztitle')); // No I18N
	                    }
	                    tar.removeData('ztitle'); // No I18N
	                }
	                target.removeData('zdependentElements'); // No I18N
	                let contentId = target.data('ztitleId'); // No I18N
	                if (contentId) {
	                    target
	                        .attr('data-title-content-id', contentId) // No I18N
	                        .removeData('ztitleId'); // No I18N
	                }
	                this.target = undefined;
	            } else {
	                /* Fix to remove title attributes of parent elements having title attribute */
	                let parents = target.parents('[title]').toArray(); // No I18N
	                parents.push(target);
	                for (let i = 0; i < parents.length; i++) {
	                    let tar = $(parents[i]);
	                    tar.data('ztitle', tar.attr('title')); // No I18N
	                    tar.removeAttr('title'); // No I18N
	                    if (this._isUploadFileBtn(tar[0])) { // No I18N
	                        tar[0].title = ''; // No I18N
	                    }
	                }
	                target.data('zdependentElements', parents); // No I18N
	                let contentId = target.attr('data-title-content-id'); // No I18N
	                if (contentId) {
	                    target
	                        .data('ztitleId', contentId) // No I18N
	                        .removeAttr('data-title-content-id'); // No I18N
	                }
	            }
	        }
	    }
	    _trigger(customEvent, origEvent, target) {
	        return this._dispatchEvent(customEvent, origEvent, {
	            target: target || this.target,
	            tooltip: customEvent === 'show' ? this.container : undefined // No I18N
	        });
	    }
	    _destroy() {
	        this.element.off('.' + this.name); // No I18N
	        this._hide(true);
	    }
	    refresh() {
	        if (this._lastEvent) { // No I18N
	            this._refreshed = true;
	            this._targetEnter(this._lastEvent); // No I18N
	            this._refreshed = false;
	        }
	    }
	    setAttribute(optionName, value) {
	        if (typeof value === 'object') { // No I18N
	            if (this._opts[optionName]) {
	                $.extend(this._opts[optionName], value);
	                return;
	            }
	        }
	        this._opts[optionName] = value;
	    }
		_getTargetAttrs  (target) {
		    let tooltipdata = {};
		    let attributes = target[0].attributes;
		    let keys = Object.keys(attributes);
		    keys.forEach((key) => {
		        let attrData = attributes[key];
		        // Sometimes attrData is null in IE.
		        if (attrData) {
		            let name = attrData.nodeName;
		            let value = attrData.value;
		            if (name.match(/^data-title-/)) {
		                name = name
		                    .replace(/^data-title-/, '') // No I18N
		                    .replace(/-([a-z])/g, (g) => g[1].toUpperCase()) // replacing the hyphenated names to camelCase
		                    .replace(/(html)/gi, 'HTML'); // No I18N
		                tooltipdata[name] = value === 'true' || value === 'false' ? value === 'true' : value.indexOf('{') === -1 ? value : ZC._getObject(value); // No I18N
		            }
		        }
		    });
		    return tooltipdata;
		}
		show  (target, options) {
		    target = $(target || this.element);
		    if (target.length) {
		        options = options || {};
		        options.showDelay = 0;
		        this._targetEnter(undefined, target, options);
		    }
		    return target;
		}
		hide  (immediate) {
		    this._hide(immediate);
		}
		_updateMargin  (margin, positionObject, direction) {
		    let marginTop = margin && parseInt(margin.top);
		    let marginLeft = margin && parseInt(margin.left);
		    let factor = this.targetOpt.rtl ? -1 : 1;
		    let elementPosition = positionObject.elementPosition;
		    if (isNaN(marginTop)) {
		        marginTop = 0;
		    }
		    if (isNaN(marginLeft)) {
		        marginLeft = 0;
		    }
		    if (this._isAtCursorPos()) {
		        let maxCorrection = positionObject.availableHeight - this.container.outerHeight();
		        elementPosition.left += marginLeft * factor;
		        // @constant 18
		        /* There must be some distance between cursor and the tooltip by default */
		        if (!marginTop) {
		            marginTop = /* direction === 'top' ? 2 : */ Math.min(16, maxCorrection);
		        }
		    }
		    if (direction === 'top') { // No I18N
		        elementPosition.top -= marginTop;
		    } else if (direction === 'bottom') { // No I18N
		        elementPosition.top += marginTop;
		    } else if (direction === 'right') { // No I18N
		        elementPosition.left += marginLeft * factor;
		    } else if (direction === 'left') { // No I18N
		        elementPosition.left -= marginLeft * factor;
		    }
		}
		_appendShortCut  (targetOptions, content) {
		    let target = this.target;
		    target = target.is('label.zbutton') ? target.prev('input') : target; // No I18N
		    let data = ZC._getOpts(target);
		    let key = ZC.ShortCut.getInfo(data.actionName, target, false);
		    if (key) {
		        if (targetOptions.shortcutKeyCustomHTML) {
		            key = targetOptions.shortcutKeyCustomHTML.replace(/(#key#)/gi, key);
		        } else {
		            key = ' (' + key + ')'; // No I18N
		        }
		        content += key;
		    }
		    return content;
		}
	}
	ZC.registerComponent('ZTooltip', ZTooltip); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.ztooltip.Templates; 
template.WCContainer = (data) => ZT.html `<div class="ztooltip" style='display:none;'>${data.children && template.WCChildren(data)}</div>` 
template.WCChildren = (data) => ZT.html `<div class="ztooltip__content">${ZT.customHTML(data.content)}</div> ${data.callout && ZT.html `<div class="ztooltip__pointer"></div>`}`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.ztooltip.Templates; 
template.container = (data) => ZT.html `<div class="ztooltip" style='display:none;'>${data.children && template.children(data)}</div>` 
template.children = (data) => ZT.html `<div class="ztooltip__content">${ZT.customHTML(data.content)}</div> ${data.callout && ZT.html `<div class="ztooltip__pointer"></div>`}`; }(ZComponents)); 
(function(ZC, $){
	window.ZAlertBanner = ZC.AlertBanner = {
	    show: function(options) {
	        if (typeof options === 'string') { // No I18N
	            options = {
	                message: options
	            }
	        }
	        options.createdByShowMethod = true;
	        // ZC.createAlertBanner(options);
	        let alertbanner = ZC.createAlertBanner(options);
	        if (options.isCE) {
	            alertbanner[0].show();
	        } else {
	            ZC.alertbanner(alertbanner).show();
	        }
	        let id = $(alertbanner).attr('id'),
	            eleID = id ? id + '-banner' : ZC.getID('zalertbanner', alertbanner); // No I18N
	        $(alertbanner).attr('id', eleID); // No I18N
	        return eleID;
	    },
	    hide: function(alertbanner, immediate) {
	        $(alertbanner).toArray().forEach((alertbanner) => {
	            if (alertbanner.tagName === 'Z-ALERTBANNER') { // No I18N
	                alertbanner[0].hide(immediate);
	            } else {
	                ZC.alertbanner(alertbanner).hide(immediate);
	            }
	        });
	    }
	}
	class ZAlertBanner  extends ZC.CoreComponent{
			get name(){
				return "zalertbanner";
			}
	    get attrs() {
	        return {
	            type: 'info', // (info|success|error|warning) // No I18N
	            icon: null,
	            iconClass: null,
	            SVGIconId: null,
	            errorIconClass: null,
	            errorSVGIconId: null,
	            successIconClass: null,
	            successSVGIconId: null,
	            warningIconClass: null,
	            warningSVGIconId: null,
	            infoIconClass: null,
	            infoSVGIconId: null,
	            message: null,
	            isMessageHTMLEncoded: false,
	            position: 'top', // No I18N
	            align: 'center', // No I18N
	            hideDelay: null,
	            closeButton: false,
	            closeSVGIconId: null,
	            closeIconClass: null,
	            display: 'fixed', // No I18N
	            target: 'body', // No I18N
	            displayAfter: null,
	            displayBefore: null,
	            displayInside: null,
	            hideOnClick: false,
	            left: null,
	            right: null,
	            bottom: null,
	            top: null,
	            width: null,
	            pauseOnMouseOver: false
	        }
	    }
	    get props() {
	        return {
	            margin: null,
	            errorIconClassName: null,
	            successIconClassName: null,
	            warningIconClassName: null,
	            infoIconClassName: null,
	            closeIconClassName: null,
	            iconClassName: null,
	            animation: {},
	            labels: {
	                close: 'Close' // No I18N
	            }
	        }
	    }
	    get EVENTS() {
	        return [
	            'show', // No I18N
	            'hide', // No I18N
	            'beforeshow', // No I18N
	            'beforehide' // No I18N
	        ]
	    }
	    _init() {
	        clearTimeout(this._autoHideTimer);
	        let IEVerison = ZC.Browser.getIEVersion(),
	            childNodes = this.element[0].childNodes;
	        if (this.isCE && !this._opts.message && childNodes.length) {
	            this._data.messageDOM = [ ...childNodes ];
	        }
	        this._data.isIE = IEVerison !== -1 && IEVerison < 10;
	        this._validate();
	    }
	    _validate(oldValue) {
	        let options = this._opts,
	            _data = this._data,
	            margin = options.margin || {},
	            methodName = '_getIcon', // No I18N
	            type = options.type,
	            delay = options.hideDelay,
	            closeButton = options.closeButton;
	        options.hideOnClick = closeButton ? false : options.hideOnClick;
	        options.hideDelay = this._hideDelay = parseInt(/(undefined|null)/.test(delay) ? closeButton ? 0 : 5000 : delay);
	        let pixel = options.display === 'inline' ? 0 : 10;
	        if (typeof margin === 'number' || typeof margin === 'string') { // No I18N
	            pixel = parseInt(margin);
	            pixel = Number.isNaN(margin) ? 0 : margin;
	            margin = {};
	        }
	        [ 'left', 'right', 'top', 'bottom' ].forEach((dir) => { // No I18N
	            if (/(undefined|null)/.test(margin[dir])) {
	                margin[dir] = pixel;
	            }
	        });
	        options.margin = margin;
	        _data.closeButton = false;
	        if (closeButton) {
	            _data.closeButton = ZC._getIconInfo((options.closeIconClass || options.closeIconClassName), options.closeSVGIconId, 'zc__svg--close zalertbanner__svg', 'zalertbanner__icon'); // No I18N
	            _data.closeText = this._getI18NText('close'); // No I18N
	        }
	        _data.icon = options.icon;
	        _data.type = type;
	        _data.IconClassName = _data.IconClass = _data.SVGIconId = _data.SVGIconClassName = null; // No I18N
	        if (options.icon) {
	            if (type === 'custom') {
	                methodName = '_customIcon'; // No I18N
	            }
	            let iconInfo = this[methodName](options, type);
	            ZC._getIconInfo(iconInfo.iconClass, iconInfo.SVGIconId, ('zc__svg--' + type + ' zalertbanner__svg'), ' zalertbanner__icon', _data); // No I18N
	        }
	        let message = options.message;
	        if (message) {
	            message = options.isMessageHTMLEncoded ? message : ZC.encodeHTML(message);
	            _data.messageDOM = '';
	        }
	        if (!message && _data.messageDOM) {
	            message = null;
	        }
	        _data.message = message;
	    }
	    _postRender() {
	        this.container.attr('role', 'status').hide(); // No I18N
	        if (this._opts.createdByShowMethod) {
	            this._handleOpen();
	        }
	    }
	    _postEachRender() {
	        let options = this._opts,
	            eventName = 'click.' + this.name; // No I18N
	        options.closeButton && this.container.find('.zalertbanner__close').off(eventName).on(eventName, (origEvent) => this.hide(false, origEvent)); // No I18N
	        this._data.className = 'zalertbanner ' + (options.type === 'custom' ? '' : 'zalertbanner--' + options.type) + ' ' + (options.className || options.zclassName || '') + ' ' + (options.rtl ? 'zh-rtl' : ''); // No I18N
	    }
	    _setStyles() {
	        /* FIXING WIDTH FOR INLINE BANNER, FIX FOR ANIMATION[] */
	        let styleObj = this.container[0].style;
	        let width = this._opts.width;
	        if (width !== 'none') {
	            this.container.css({
	                width: '', // No I18N
	                display: '' // No I18N
	            });
	            if (width) {
	                styleObj.width = width;
	            } else if (this._opts.display === 'inline') { // No I18N
	                styleObj.width = this.container.outerWidth() + 1 + 'px'; // No I18N
	            }
	        }
	        if (this._opts.display !== 'inline') {
	            styleObj.position = (this._target || this.container.parent()).is('body') ? 'fixed' : 'absolute'; // No I18N
	        }
	    }
	    _bindEvents() {
	        let options = this._opts;
	        let eventName = 'click.' + this.name; // No I18N
	        options.hideOnClick && this.container.off(eventName).on(eventName, this.hide.bind(this));
	        options.pauseOnMouseOver && options.hideDelay && this._pauseOnHover();
	    }
	    _setHideTimer() {
	        let delay = this._opts.hideDelay;
	        if (delay) {
	            clearTimeout(this._autoHideTimer);
	            this._startTimer = new Date().getTime();
	            this._autoHideTimer = setTimeout(this.hide.bind(this), delay);
	        }
	    }
	    _showHandler() {
	        // if(!this._autoHideTimer){
	        this._trigger('show'); // No I18N
	        this._setHideTimer();
	        // }
	    }
	    _closeHandler(origEvent) {
	        this._trigger('hide', origEvent); // No I18N
	    }
	    _trigger(customEvent, origEvent) {
	        return this._dispatchEvent(customEvent, origEvent);
	    }
	    show() {
	        if (this._trigger('beforeshow')) { // No I18N
	            clearTimeout(this._autoHideTimer);
	            this._setStyles();
	            this._position();
	            this.container.hide();
	            this._showHide();
	        }
	    }
	    _showHide(closeImmediate, isClose, origEvent) {
	        let animate = closeImmediate ? undefined : this._opts.animation,
	            animateCallBack = () => {
	                this._display(isClose, this.container);
	                if (isClose) {
	                    this._closeHandler(origEvent);
	                } else {
	                    this._showHandler();
	                }
	            };
	        if (typeof animate === 'object' && !ZC.isEmpty(animate) && ZC.animationHandler) { // No I18N
	            this._animate(this.container, animate, (isClose ? 'hide' : 'show'), animateCallBack); // No I18N
	        } else {
	            animateCallBack();
	        }
	    }
	    hide(closeImmediate, origEvent) {
	        if (this._trigger('beforehide')) { // No I18N
	            clearTimeout(this._autoHideTimer);
	            this._showHide(closeImmediate, true);
	        }
	    }
	    _destroy() {
	        this.container.empty();
	        clearTimeout(this._autoHideTimer);
	        clearTimeout(this._startTimer);
	        this._animate = this._target = this._opts = undefined;
	    }
		_animate  (element, animation, action, callback) {
		    ZC.animationHandler({
		        element: element,
		        action: action === 'none' ? 'hide' : 'show', // No I18N
		        callback: callback,
		        ctype: this.name,
		        animation: animation
		    });
		}
		_customIcon  (options) {
		    return {
		        iconClass: (options.iconClass || options.iconClassName),
		        SVGIconId: options.SVGIconId
		    }
		}
		_getIcon  (options, iconType) {
		    return {
		        iconClass: (options[iconType + 'IconClass'] || options[iconType + 'IconClassName']), // No I18N
		        SVGIconId: options[iconType + 'SVGIconId']  // No I18N
		    }    
		}
		_inlinePosition  (align, marginRight) {
		    let options = this._opts,
		        margin = options.margin,
		        position = options.position,
		        cssPos = {};
		    if (margin.top) {
		        cssPos['margin-top'] = margin.top; // No I18N
		    }
		    if (margin.bottom) {
		        cssPos['margin-bottom'] = margin.bottom; // No I18N
		    }
		    return cssPos;
		}
		_getTarget  (options) {
		    let target = options.displayAfter || options.displayBefore, action;
		    if (target) {
		        action = options.displayAfter ? "insertAfter" : "insertBefore"; // No I18N
		    }
		    return {
		        target: (target || options.displayInside),
		        action: action
		    }
		}
		_pauseOnHover   () {
			let _namespace = '.' + this.name; // No I18N
		    this.container
		        .on("mouseenter"+_namespace, this._pauseTimer.bind(this))
		        .on("mouseleave"+_namespace, this._setHideTimer.bind(this));
		}
		_pauseTimer   () {
		    if (this._startTimer) {
		        clearTimeout(this._autoHideTimer);
		        this._hideDelay -= new Date().getTime() - this._startTimer;
		        this._startTimer = undefined;
		    }
		}
		_position   () {
		    let options = this._opts,
		        positions = {
		            left: '', // No I18N
		            right: '', // No I18N
		            top: '', // No I18N
		            bottom: '' // No I18N
		        };
		    this.container.css(positions);
		    let position = this._getPosition();
		    for (let prop in positions) {
		        options[prop] && (position[prop] = options[prop]);
		    }
		    this.container.css(position);
		}
		_getDimension  (height) {
		    let value = this.container[height ? 'outerHeight' : 'outerWidth'](); // No I18N
		    this.container.css({
		        left: 'auto', // No I18N
		        top: 'auto' // No I18N
		    });
		    return value;
		}
		_getPosition  () {
		    let options = this._opts,
		        margin = options.margin,
		        align = this._getRTLBasedDir(options.align),
		        cssPos = {},
		        marginRight = parseInt(margin[this._getRTLBasedDir(align)]);
		    cssPos = this["_"+ options.display +"Position"](align, marginRight);
		    /* Alignment is common for inline and fixed */
		    if (align === "left") { //No I18N
		        cssPos.left = marginRight;
		    }
		    else if (align === "right") { //No I18N
		        if (options.display !== "fixed") { //No I18N
		            cssPos.left = `calc(100% - ${this._getDimension() + marginRight}px)`;
		        } else {
		            cssPos.right = marginRight;
		        }
		    } else {
		        cssPos.left = `calc(50% - ${this._getDimension() / 2}px)`;
		    }
		    return cssPos;
		}
		_fixedPosition  (align, marginRight) {
		    let options = this._opts,
		        margin = options.margin,
		        position = options.position,
		        cssPos = {};
		    if ((/^(top|bottom)$/).test(position)) {
		        cssPos[position] = parseInt(margin[position]);
		    } else {
		        /* Middle positioning */
		        cssPos.top = 'calc(50% - ' + this._getDimension(true) / 2 + 'px)'; // No I18N
		    }
		    this.container.attr('data-position', position + '-' + align); // No I18N
		    return cssPos;
		}
		_setAttribute   (optionName, value) {
		    // if (!this._opts.createdByShowMethod) {
		    let container = this.container, isBannerVisible = container.is(':visible'), options = this._opts, reset = true, oldValue = options[optionName]; // No I18N
		    if (/(target)$/.test(optionName)) {
		        if (optionName === 'target') {
		            $(this._target).removeData('previous-bannerId');
		        }
		        this._target = undefined;
		        options[optionName] = value;
		        reset = false;
		        // this._init();
		    } else if (/(icon|closeButton|type|closeIconClassName|closeSVGIconId|IconClassName|SVGIconId|message|isMessageHTMLEncoded)$/.test(optionName)){
		        options[optionName] = value;
		        this._validate(oldValue);
		    } else if (/(display)/.test(optionName)) {
		        options[optionName] = value;
		        reset = false;
		        container.css('position', ''); // No I18N
		        if (isBannerVisible) {
		            this._setStyles();
		            this._position();
		        }
		    } else if (/(margin|left|right|top|bottom)/.test(optionName)) {
		        options[optionName] = value;
		        reset = false;
		        this._validate();
		        if (isBannerVisible) {
		            this._position();
		        }
		    } else if (/(hideDelay|hideOnClick|pauseOnMouseOver)/.test(optionName) && oldValue !== value) {
		        options[optionName] = value;
		        reset = false;
		        this._validate();
		        container.off("."+this.name);   // No I18N
		        this._bindEvents();
		    } else if (/(className|zclassName)/.test(optionName)) {
		        this._updateClass(value, oldValue);
		        options[optionName] = value;
		    } else if (optionName === 'animation') {
		        if (typeof options.animation === 'object' && value === 'object') {
		            $.extend(true, options.animation, value);
		        } else {
		            options[optionName] = value;
		        }
		    } else {
		        options[optionName] = value;
		    }
		    if (optionName === 'message') { // No I18N
		        this._position();
		    }
		    reset && (this._domChanged = true);
		    // }
		}
		_handleOpen   () {
		    let options = this._opts, info = {},
		        showInline = (options.display === 'inline');    // No I18N
		    if (showInline) {
		        info = this._getTarget(options);
		    }
		    let action = info.action || "appendTo",// No I18N
		        target = $(info.target || options.target);
		    this.container[(action)](target);
		    this._target = target;
		    // Previous Banner is removed.
		    let previousID = target.data('previous-bannerId'); // No I18N
		    if (previousID) {
		        let animation = options.animation,
		            banner = $('#' + previousID); // No I18N
		        banner.finish ? banner.finish() : banner.stop(true, true);
		        if (banner.is(':visible') && banner.length) { // No I18N
		            if (banner.is('z-alertbanner')) { // No I18N
		                banner[0].hide(true);
		            } else {
		                ZC.alertbanner(banner).hide(true);
		            }
		            if (showInline && animation && animation.show) {
		                animation.show = false;
		            }
		        }
		    }
		    target.data('previous-bannerId', this.container[0].id); // No I18N
		}
		_closeHandler   (origEvent) {
		    let container = this.container, target = this._target,base = this;
		    if (this._opts && this._opts.createdByShowMethod) {
		        if (target.data('previous-bannerId') === container.attr('id')) { // No I18N
		            target.removeData('previous-bannerId'); // No I18N
		        }
		        this._trigger('hide', origEvent); // No I18N
		        container && container.remove();
		        base._destroy();
		        base.element.remove();
		    }else{
		        this._trigger('hide', origEvent); // No I18N
		    }
		}
	}
	ZC.registerComponent('ZAlertBanner', ZAlertBanner); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zalertbanner.Templates; 
let utilities = ZC.Templates.Utilities; 
template.WCContainer = (data)=> ZT.html`<div class="zalertbanner ${data.className}">${data.children && template.WCChildren(data)}</div>`; 
template.WCChildren = (data)=> ZT.html` ${data.isIE && ZT.html`<div class="zalertbanner__table"></div>`} ${data.icon && utilities.WCIcon(data)} ${data.isIE && template.WCCloseButton(data)} ${data.type && ZT.html`<span class="zalertbanner__text">${data.messageDOM} ${ZT.customHTML(data.message)}</span>`} ${!data.isIE && template.WCCloseButton(data)} `; 
template.WCCloseButton = (data)=> ZT.html` ${data.closeButton && ZT.html`<div class="zalertbanner__action" title=${data.closeText}><button type="button" class="zalertbanner__close">${utilities.WCIcon(data.closeButton)}</button></div>`}`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zalertbanner.Templates; 
let utilities = ZC.Templates.Utilities; 
template.container = (data)=> ZT.html`<div class="zalertbanner ${data.className}">${data.children && template.children(data)}</div>`; 
template.children = (data)=> ZT.html` ${data.isIE && ZT.html`<div class="zalertbanner__table"></div>`} ${data.icon && utilities.icon(data)} ${data.isIE && template.closeButton(data)} ${data.type && ZT.html`<span class="zalertbanner__text">${data.messageDOM} ${ZT.customHTML(data.message)}</span>`} ${!data.isIE && template.closeButton(data)} `; 
template.closeButton = (data)=> ZT.html` ${data.closeButton && ZT.html`<div class="zalertbanner__action" title=${data.closeText}><button type="button" class="zalertbanner__close">${utilities.icon(data.closeButton)}</button></div>`}`; }(ZComponents)); 
(function(ZC, $){
	class ZAlertDialog  extends ZC.CoreComponent{
			get name(){
				return "zalertdialog";
			}
	    static get DEFAULTS() {
	        return {
	            rtl: false, // No I18N
	            type: 'custom', // No I18N
	            buttonsAlignment: 'right', // No I18N
	            isHTMLEncoded: false, // No I18N
	            isTitleHTMLEncoded: false, // No I18N
	            isMessageHTMLEncoded: false, // No I18N
	            className: '', // No I18N
	            closeButton: false,
	            icon: undefined, // No I18N
	            draggable: true, // No I18N
	            labels: { // No I18N
	                cancel: 'Cancel', // No I18N
	                no: 'No', // No I18N
	                ok: 'OK', // No I18N
	                yes: 'Yes', // No I18N
	                close: 'Close', // No I18N
	                help: 'Help', // No I18N
	                suppressionMessage: 'Do not show this message again.' // No I18N
	            },
	            // suppressAlert option will be considered only if an alert dialog is already suppressed.
	            suppressAlert: true, // No I18N
	            overlayClassName: '', // No I18N
	            closeIcon: undefined, // No I18N
	            helpIcon: undefined, // No I18N
	            helpIconClassName: '', // No I18N
	            OKButtonLabel: undefined, // No I18N
	            cancelButtonLabel: undefined, // No I18N
	            yesButtonLabel: undefined, // No I18N
	            noButtonLabel: undefined, // No I18N
	            closeButtonLabel: undefined, // No I18N
	            helpButtonLabel: undefined, // No I18N
	            suppressionDecisionBoxLabel: undefined, // No I18N
	            excludeFocus: '.zbutton--action' // No I18N
	        }
	    }
	    static open(opts) {
	        this._opts = $.extend(true, {}, this.DEFAULTS, opts);
	        let baseObj = this;
	        this.close({}, {}, function() {
	            baseObj._init(opts);
	        }); // closing the previously opened alert dialog before opening a new one.
	    }
	    static _getID() {
	        let opts = this._opts;
	        return 'zalert-' + (opts.name || (opts.customAttributes && opts.customAttributes.id) || '') + '-suppressed'; // No I18N
	    }
	    static _init(options) {
	        let opts = this._opts,
	            sId = this._getID(),
	            cookieVals = document.cookie.split(';'), // No I18N
	            cfound = cookieVals.filter(function(item) {
	                if (item.trim().indexOf(sId + '=true') === 0) { // No I18N
	                    return item;
	                }
	            });
	        if (cfound.length) {
	            opts.suppressed && opts.suppressed();
	            return;
	        }
	        this._construct();
	        this._bindEvents();
	        this._positionDialog();
	        this._createOverlay();
	        if (this._opts.animation && this._opts.animation.open) {
	            this._openAnimate();
	        } else {
	            this._display();
	            this._handleOpen();
	        }
	        ZC.$window.off('resize.zalertdialog').on('resize.zalertdialog', (event) => { // No I18N
	            // compute the top and left for the centered aligned alert dialog or golden mean positioned alert dialog whenever window resize occurs.
	            let position = this._opts.position;
	            if (this.container && this.container.is(':visible') && (position && !position.length || position === 'center') && event.originalEvent.type === 'resize') { // No I18N
	                this._positionDialog();
	            }
	        });
	    }
	    /* Constructs the dialog by creating titlebar,content div and button panel */
	    static _construct() {
	        let _opts = this._opts;
	        this._data = _opts;
	        this._data.className = `${_opts.className} ${_opts.rtl ? 'zh-rtl' : ''}`; // No I18N
	        let showTitleBar = _opts.title || _opts.closeButton;
	        if (showTitleBar) {
	            this._updateTitleInfo();
	        } else {
	            this._data.titleBar = false;
	        }
	        let isHTMLEncoded = _opts.isHTMLEncoded || _opts.isMessageHTMLEncoded;
	        if (_opts.primaryMessage && _opts.primaryMessage.trim() !== '') { // No I18N
	            this._data.primaryMessage = isHTMLEncoded ? _opts.primaryMessage : ZC.encodeHTML(_opts.primaryMessage);
	        }
	        if (_opts.secondaryMessage && _opts.secondaryMessage.trim() !== '') { // No I18N
	            this._data.secondaryMessage = isHTMLEncoded ? _opts.secondaryMessage : ZC.encodeHTML(_opts.secondaryMessage);
	        }
	        if (_opts.suppressionDecisionBox) {
	            this._data.suppressionDecisionBoxLabel = _opts.suppressionDecisionBoxLabel || this._getString('suppressionMessage'); // No I18N
	        }
	        this._setIcon();
	        this._createFooter();
	        this.container = $(ZC._render(this._data, 'zalertdialog', null, null, document.body, {})); // No I18N
	        this.container.addClass(this._data.className);
	        if (_opts.customAttributes) {
	            this.container.attr(_opts.customAttributes);
	        }
	        let btns = this.container.find('.zbutton');
	        btns.not('.zbutton--help').on('click.zalertdialog', this._clickHandler.bind(this)); // No I18N
	        let fpanelBtns = btns.not('.zbutton--action'), // No I18N
	            len = fpanelBtns.length;
	        for (let i = 0; i < len; i++) {
	            ZC._handleFocus($(fpanelBtns[i]), 'zalertdialog'); // No I18N
	        }
	        if (_opts.suppressionDecisionBox) {
	            this._handleSuppression();
	        }
	        showTitleBar && this._handleTitleBar();
	    }
	    static _clickHandler(event) {
	        let targetBtn = $(event.target).closest('.zbutton'), // No I18N
	            btns = this._data.buttons,
	            len = btns.length,
	            id = targetBtn.attr('id'), // No I18N
	            btnOpts;
	        for (let i = 0; i < len; i++) {
	            if (btns[i].id && btns[i].id === id) {
	                btnOpts = btns[i];
	            }
	        }
	        let args = {
	            button: targetBtn,
	            properties: btnOpts,
	            buttonOptions: btnOpts
	        }; // btnOpts will be empty for close button.
	        if(id === "zalertbutton--close"){   // No I18N
	            args.buttonType = "CLOSE";  // No I18N
	            args.closeButton = true;
	        }
	        if (btnOpts && btnOpts.action && typeof btnOpts.action !== 'string') { // No I18N
	            btnOpts.action(event, args);
	        } else {
	            this.close(event, args);
	        }
	        event.stopPropagation(); // event is preventing to avoid alert dialog event triggering.
	        event.preventDefault();
	    }
	    static _createFooter() {
	        let buttons = this._getButtons(),
	            buttonObj = {},
	            text, action;
	        for (let property in buttons) {
	            if (buttons.hasOwnProperty(property)) {
	                buttonObj = buttons[property];
	                text = buttonObj.text;
	                buttonObj.id = buttonObj.id || (this._getID() + ZC.getID());
	                buttonObj.templateRender = true;
	                buttonObj.role = buttonObj.type = 'button'; // No I18N
	                buttonObj.contentType = text === '' || text === undefined || text === null ? 'icon' : 'text'; // No I18N
	                // buttonObj.isCE = this._data.isCE;
	                buttonObj.tabIndex = buttonObj.tabIndex || 0;
	                action = buttonObj.action;
	                buttonObj.className = 'zbutton zbutton--' + (buttonObj.appearance || 'normal') + (action && typeof action === 'string' && action === 'CANCEL' ? ' zh--clickonescape' : ''); // No I18N
	            }
	        }
	        this._data.buttons = buttons;
	        let commandBar = this._opts.commandBar || {};
	        commandBar.componentName = this.name;
	        // Below statement is added since zalertdialog__footer class is not available and alert dialog uses zdialog__footer.
	        let btnAlign = this._opts.buttonsAlignment;
	        commandBar.className = `zdialog__footer ${btnAlign === 'right' ? '' : this._getAlignCls(btnAlign)}`
	        this._data.commandBar = commandBar;
	        if (this._opts.helpButton) {
	            this._setHelpButton();
	        }
	    }
	    static _getString(label) {
	        return ZC.getI18NText('zalertdialog', label, this._opts.labels, []); // No I18N
	    }
	    /* Returns the buttons object corresponding to the type of the dialog */
	    static _getButtons() {
	        let _opts = this._opts;
	        let buttons = {
	            CANCEL: {
	                actionType: 'CANCEL', // No I18N
	                id: 'zc-zdialog-cancel', // No I18N
	                text: _opts.cancelButtonLabel || this._getString('cancel'), // No I18N
	                action: 'CANCEL', // No I18N
	                name: 'cancel', // No I18N
	                isCancel: true
	            },
	            OK: {
	                actionType: 'OK', // No I18N
	                id: 'zc-zdialog-ok', // No I18N
	                text: _opts.OKButtonLabel || this._getString('ok'), // No I18N
	                appearance: 'primary', // No I18N
	                name: 'ok' // No I18N
	            },
	            NO: {
	                actionType: 'NO', // No I18N
	                id: 'zc-zdialog-no', // No I18N
	                text: _opts.noButtonLabel || this._getString('no'), // No I18N
	                action: 'CANCEL', // No I18N
	                isCancel: true,
	                name: 'no' // No I18N
	            },
	            YES: {
	                actionType: 'YES', // No I18N
	                id: 'zc-zdialog-yes', // No I18N
	                text: _opts.yesButtonLabel || this._getString('yes'), // No I18N
	                appearance: 'primary', // No I18N
	                name: 'yes' // No I18N
	            }
	        };
	        let buttonsOrder = _opts.buttonsOrder || (ZC.OS.isWindows() ? 'windows' : 'mac'); // No I18N
	        // if the platform is windows, use windows style order for action buttons.
	        buttons = {
	            OK: buttons.OK,
	            CANCEL: buttons.CANCEL,
	            YES: buttons.YES,
	            NO: buttons.NO
	        };
	        if (buttonsOrder === 'mac') {
	            buttons = {
	                CANCEL: buttons.CANCEL,
	                OK: buttons.OK,
	                NO: buttons.NO,
	                YES: buttons.YES
	            };
	        }
	        let btns = _opts.buttons;
	        if (!btns) {
	            return _opts.type === 'custom' || _opts.type === 'confirm' ? [ buttons.CANCEL, buttons.OK ] : [ buttons.OK ];
	        } else if (typeof btns === 'object') { // No I18N
	            // for (let i = 0; i < btns.length; i++) {
	            //     _opts.buttons[i].templateRender = true;
	            // }
	            return _opts.buttons;
	        } else if (typeof btns === 'string') { // No I18N
	            let newArray = [],
	                i = 0,
	                splitArr = btns.split('-');
	            for (let key in buttons) {
	                if (splitArr.indexOf(key.toLowerCase()) !== -1) {
	                    newArray[i] = buttons[key];
	                    i++;
	                }
	            }
	            // $.each(buttons, (key) => {
	            // if (splitArr.indexOf(key.toLowerCase()) !== -1) {
	            //     newArray[i] = buttons[key];
	            //     i++;
	            // }
	            // });
	            // for(let i = 0; i < splitArr.length; i++){
	            //     newArray[i] = buttons[splitArr[i].toUpperCase()];
	            // }
	            return newArray;
	        }
	    }
	    static _display(hide) {
	        let isGTIE11 = ZC.Browser.isIE ? ZC.Browser.getIEVersion() >= 11 : true;
	        return this.container.css('display', hide ? 'none' : isGTIE11 ? 'flex' : 'block'); // No I18N
	    }
	    static _handleOpen() {
	        let _opts = this._opts;
	        _opts.open && _opts.open({
	            dialog: this.container,
	            element: this.container,
	            options: _opts
	        });
	        if (_opts.closeTimeout !== undefined && _opts.closeTimeout !== '') { // No I18N
	            window.setTimeout(() => {
	                this.close({}, {});
	            }, parseInt(_opts.closeTimeout));
	        }
	        this.container.attr('aria-expanded', true); // No I18N
	        ZC.FocusHandler && ZC.FocusHandler.init(this.container, _opts.excludeFocus);
	        this._focusActionButton();
	    }
	    static _focusActionButton() {
	        let buttonSelector = this._opts.defaultActionButton;
	        if (buttonSelector && buttonSelector.indexOf('#') !== 0) { // No I18N
	            // retrieve based on the button text.
	            buttonSelector = `button[data-text='${buttonSelector.toLowerCase()}']`; // No I18N
	        } else {
	            buttonSelector = '.zbutton--primary'; // No I18N
	        }
	        let buttonTobeFocused = this.container.find(buttonSelector);
	        if (!buttonTobeFocused.length) {
	            buttonTobeFocused = this.container.find('button:last'); // No I18N
	        }
	        buttonTobeFocused.focus();
	    }
	    /* Creates an overlay to achieve the "modal" behavior */
	    static _createOverlay() {
	        // Here tabindex is set in order to make the div element receive keydown events.
	        this._overlay = $("<div class='zdialog--overlay " + this._opts.overlayClassName + "' ></div>").attr('tabindex', 1);
	        this._hideBodyScroll(true);
	        ZC.zIndex += 2; // setting the maximum zIndex of the dialog.
	        // Overlay element is placed before the dialog element in order to have the elements in correct order.For Ex: If same z-index value is set for both dialog and overlay, overlay has to precede the dialog element.
	        document.body.insertBefore(this._overlay[0], this.container[0]);
	        this._overlay.css('z-index', ZC.zIndex - 1); // No I18N
	        this.container.css('z-index', ZC.zIndex); // No I18N
	        let eventSuffix = '.' + this.name; // No I18N
	        this._overlay.on(`keydown.${eventSuffix}`, (event) => {
	            event.stopPropagation(); // preventing the default behavior since shortcut keys behaviors are executed.
	            event.preventDefault();
	        }).on(`mousedown.${eventSuffix}`, function(event) {
	            // mousedown event propagation is prevented inorder to avoid document mousedown(mainly close handler) handlers being executed (which might close the opened menu/popover).
	            event.stopPropagation();
	        });
	    }
	    static _hideBodyScroll(hide) {
	        $('body')[hide ? 'addClass' : 'removeClass']('zh-overflowhidden'); // No I18N
	    }
	    static close(event, data, callback) {
	        let containerElement = this.container;
	        if (containerElement && containerElement.is(':visible')) { // No I18N
	            containerElement.finish ? containerElement.finish() : containerElement.stop(true, true);
	            data = data || {
	                actionType: 'CLOSE', // No I18N
	                isCancel: true
	            };
	            data.element = containerElement;
	            data.options = this._opts;
	            data.isSuppressed = this._opts.suppressionDecisionBox && $('#zalert__suppression--box').prop('checked'); // No I18N
	            if (this._opts.beforeclose) {
	                if (this._opts.beforeclose(event, data) !== false) {
	                    this._handleClose(event, data, callback);
	                }
	            } else {
	                this._handleClose(event, data, callback);
	            }
	        } else {
	            callback && callback.apply(this);
	        }
	    }
	    static _handleClose(event, data, callback) {
	        if (this._opts.animation) {
	            this._closeAnimate(event, data, callback);
	        } else {
	            this._display(true);
	            this._close(event, data, callback);
	        }
	    }
	    static _close(event, data, callback) {
	        this.container.remove();
	        this._overlay && this._overlay.remove();
	        if (!$('body').find('.zdialog--overlay').length) {
	            this._hideBodyScroll(false);
	        }
	        ZC.zIndex = ZC.zIndex - 2; // one for overlay and other for alert dialog.
	        /* setTimeout is used because event triggered before dialog and overlay are removed from the document. */
	        // window.setTimeout(function(){
	        event = event || {};
	        $.extend(true, data, {
	            options: this._opts,
	            button: $(event.target),
	            event: event,
	            element: this.container
	        });
	        this._opts.close && this._opts.close(event, data);
	        this._overlay = this.container = undefined;
	        callback && callback.apply(this);
	    }
	    /* Bind the events to the dialogs */
	    static _bindEvents() {
	        let eventSuffix = `.${this.name}`,
	            _opts = this._opts;
	        // After taking focus outside of the dialog via mouse and if we click the dialog once again, dialog buttons should get focus. (Reference : predefined alert dialogs)
	        this.container.on(`keydown${eventSuffix}`, (event) => {
	            if (event.keyCode === ZC.keyCode.ESCAPE) {
	                // Pressing Escape should trigger the click event on button which has CANCEL action set on it otherwise don't close the dialog - referred from native system alerts.
	                let cancelBtn = this.container.find('.zh--clickonescape:first');
	                if (cancelBtn.length) { // setting focus is removed since we have separate focus for keyboard and mouse.
	                    window.setTimeout(() => cancelBtn.trigger('click'), 150); // No I18N
	                    // timer is used since click triggers immediately before focus effect applies to the button.
	                } else if (_opts.closeButton) {
	                    this.container.find('.zdialog__actiongroup #zalertbutton--close').trigger('click'); // No I18N
	                } else {
	                    this.close(event, {
	                        ESCAPE_PRESSED: true
	                    });
	                }
	            } else if (event.keyCode === ZC.keyCode.ENTER) {
	                let buttonElement = this.container.find(_opts.defaultActionButton || '.zbutton--primary'), // No I18N
	                    includedList = '.zbutton:not(.zbutton--menu), input:not(.ztokenfield):not(.zsuggestfield-element):not([type=checkbox]), div.zdialog__header'; // No I18N
	                if ($(event.target).closest(includedList).length && buttonElement.length && !$(event.target).closest('.zdialog__footer').length) {
	                    buttonElement.trigger('click'); // No I18N
	                }
	            }
	            // if (event.keyCode === ZC.keyCode.TAB) {
	            //     event.preventDefault(); // preventing default in all scenarios prevents the editing of text inside the textboxes present in the alert dialog.
	            // }
	        }).on(`click${eventSuffix}`, function(event) {
	            // Click event propagation is prevented inorder to avoid document click handlers being executed (which might close the opened menu/popover).
	            event.stopPropagation();
	        });
	        this.container.find('.zdialog__header').length && this.container.find('.zdialog__header').on(`mouseup${eventSuffix}`, () => this._focusActionButton()); // No I18N
	        let helpButtonAction = (_opts.helpButton || {}).action;
	        if(helpButtonAction){
	            $('#zalert--helpbutton').on('click', () => helpButtonAction()); // No I18N
	        }
	    }
		static _closeAnimate  (event, data, callback) {
		    let animation = this._opts.animation.close,
		        animationClass = animation.className,
		        effect = animation.name,
		        duration = animation.duration ? animation.duration : 0;
		    if (animationClass) {
		        this.container.addClass(animationClass).on(ZC._animationEnd, () => {
		            this.container.removeClass(animationClass); // removing the animation class.
		            this._display(true);
		            this._close(event, data, callback);
		        });
		    } else if (typeof effect === 'object') { // No I18N
		        // custom animation properties
		        this.container.animate(effect, duration, () => this._close(event, data, callback));
		    } else { // predefined effects like slide and fade & custom css class.
		        this.container[effect](duration, () => this._close(event, data, callback));
		    }
		}
		static _openAnimate  () {
		    let animation = this._opts.animation.open,
		        animationClass = animation.className,
		        effect = animation.name,
		        duration = animation.duration ? animation.duration : 0;
		    if (animationClass) { // css class name
		        this._display().addClass(animationClass).on(ZC._animationEnd, () => {
		            this.container.removeClass(animationClass); // removing the animation class.
		            this._handleOpen();
		        });
		    } else if (typeof effect === 'object') { // No I18N
		        // custom animation properties
		        // this._overlay && this._overlay.show().animate(effect,duration,completeFunction);
		        this._display().animate(effect, duration, this._handleOpen);
		    } else { // predefined effects like slide and fade.
		        // this._overlay && this._overlay[this._opts.EFFECTS[effect].open](duration,completeFunction);
		        this.container[effect](duration, this._handleOpen.bind(this));
		    }
		}
		static get _ALIGNMENTS (){
			return	 {
		    left: 'zdialogfooter--invert', // No I18N
		    right: '', // No I18N
		    center: 'zh-center' // No I18N
		}
		 }
  static _getAlignCls  (btnAlign) {
		    return this._ALIGNMENTS[btnAlign];
		}
		static _closeButton  () {
		    let _opts = this._opts;
		    this._data.closeButton = ZC.ZButton.getBtnProps({
		        id: 'zalertbutton--close', // No I18N
		        title: _opts.closeButtonLabel || this._getString('close'), // No I18N
		        className: 'zbutton--action', // No I18N
		        iconClassName: _opts.closeIconClassName,
		        templateRender: true,
		        SVGIconId: _opts.closeSVGIconId,
		        customAttributes: {
		            tabindex: -1
		        },
		        defaultSVGIconId: 'zc__svg--close zbutton__svg' // No I18N
		    });
		}
		    /* Sets the position of the dialog to the given position or golden mean position  */
		static _draggable  () {
		    ZC.draggable(this.container, {
		        ignore: '.zdialog__actiongroup', // No I18N
		        handle: '.zdialog__header', // No I18N
		        cursor: 'default',	// No I18N
		        container: 'window' // No I18N
		    });
		}
		static _setHelpButton  () {
		    let _opts = this._opts;
		    this._data.helpButton = ZC.ZButton.getBtnProps({
		        id: 'zalert--helpbutton', // No I18N
		        className: 'zbutton--help', // No I18N
		        title: _opts.helpButtonLabel || this._getString('help'), // No I18N
		        iconClassName: 'zdialog__icon ' + _opts.helpIconClassName, // No I18N
		        templateRender: true,
		        SVGIconId: _opts.helpSVGIconId || (_opts.helpIconClassName ? '' : 'zc__svg--help zdialog__svg grayscale'), // No I18N
		        customAttributes: _opts.helpButton.customAttributes || {},
		        action: _opts.helpButton.action
		    });
		}
		static _setIcon  () {
		    let _opts = this._opts,
		        type = _opts.type,
		        iconClassName, SVGIconId, iconInfo,
		        icon = true,
		        defaultID = (type === 'custom') ? 'zdialog__svg' : `zc__svg--${type} zdialog__svg ${type}color`; // No I18N
		    if (_opts.iconClassName || _opts.SVGIconId) {
		        iconClassName = _opts.iconClassName;
		        SVGIconId = _opts.SVGIconId;
		    } else if (type !== 'custom') { // No I18N
		        iconClassName = _opts[`${type}IconClassName`]; // No I18N
		        SVGIconId = _opts[`${type}SVGIconId`]; // No I18N
		    } else {
		        icon = false;
		    }
		    if (icon) {
		        iconInfo = ZC._getIconInfo(iconClassName, SVGIconId, defaultID, 'zdialog__icon'); // No I18N
		        this._data.iconClassName = iconInfo.iconClassName;
		        this._data.SVGIconClassName = iconInfo.SVGIconClassName || _opts.SVGIconClassName;
		        this._data.SVGIconId = iconInfo.SVGIconId;
		    }
		    this._data.alertIcon = icon;
		}
		    /* Sets the position of the dialog to the given position or golden mean position  */
		static _positionDialog  () {
		    let wrapper = this.container,
		        _opts = this._opts,
		        position = _opts.position;
		    _opts.width && wrapper.outerWidth(_opts.width);
		    _opts.height && wrapper.outerHeight(_opts.height);
		    let elemWidth = wrapper.outerWidth(true) + parseInt(wrapper.css('border-left-width')) + parseInt(wrapper.css('border-right-width')), // No I18N
		        elemHeight = wrapper.outerHeight(true) + parseInt(wrapper.css('border-bottom-width')) + parseInt(wrapper.css('border-top-width')), // No I18N
		        positionObject = this._getGoldenMeanPosition(wrapper); // default position will be golden-mean position.
		    if (typeof position === 'object' && (position.left || position.top)) {
		        positionObject = $.extend({}, positionObject, position);
		        positionObject.left = parseInt(positionObject.left) + window.pageXOffset;
		        positionObject.top = parseInt(positionObject.top) + window.pageYOffset;
		    } else if (position === 'center') { // No I18N
		        positionObject.top = ZC.windowObject.height / 2 - elemHeight / 2 + window.pageYOffset; // Adding the scrollY and scrollX values
		        positionObject.left = ZC.windowObject.width / 2 - elemWidth / 2 + window.pageXOffset;
		    }
		    wrapper.css(positionObject);
		}
		static _getGoldenMeanPosition  (dialog) {
		    let phi = 1.618, // used to find the golden mean position (a+b/a = a/b)
		        // windowHeight = ZC.windowObject.height,
		        // windowWidth = ZC.windowObject.width,
		        windowHeight = document.documentElement.clientHeight, // document object is taken into account instead of window object inorder to position the alert dialog in correct position.
		        windowWidth = document.documentElement.clientWidth,
		        halfWindow = windowHeight / 2,
		        smallerPortion = halfWindow - halfWindow / phi,
		        topPosition = smallerPortion - parseFloat(dialog.height() / 2), // scroll height is added.
		        leftPosition = windowWidth / 2 - parseFloat(dialog.width() / 2); // scroll width is added.
		        /*
		            Above Calculation: Golden-Mean by taking half window height.
		                TopValue: 137
		            golden-mean by taking full window height into account
		                smallerPortion = windowHeight - (windowHeight/phi),
		                Top Value: 277
		        */
		    /*
		            1/3 of window height calculation
		                smallerPortion = windowHeight/3,
		                Top Value: 244
		        */
		    if (topPosition < 0) {
		        topPosition = 0;
		    }
		    if (leftPosition < 0) {
		        leftPosition = 0;
		    }
		    return {
		        top: topPosition + window.pageYOffset,
		        left: leftPosition + window.pageXOffset
		    };
		}
		static _handleSuppression  () {
		    let opts = this._opts;
		    this.container.find('#zalert__suppression--box').on('change', () => { // No I18N
		        if (opts.suppressAlert) {
		            let checkedState = $('#zalert__suppression--box').prop('checked'), // No I18N
		                sId = this._getID();
		            document.cookie = sId + '=' + checkedState; // No I18N
		        }
		    });
		}
		static _updateTitleInfo  () {
		    let _opts = this._opts;
		    this._data.title = (_opts.isHTMLEncoded || _opts.isTitleHTMLEncoded) ? _opts.title : ZC.encodeHTML(_opts.title);
		    this._data.titleBar = true;
		    if (_opts.closeButton) {
		        this._closeButton();
		    }
		}
		static _handleTitleBar  () {
		    let baseObj = this;
		    this.container.find('#zalertbutton--close').on('click', (event) => { // No I18N
		        baseObj.close(event, {
		            button: $(event.target),
		            buttonType: 'CLOSE', // No I18N
		            closeButton: true
		        });
		    });
		    if (this._opts.draggable && ZC.draggable) {
		        this._draggable();
		    }
		}
	}
	ZC.AlertDialog = window.ZAlertDialog = ZAlertDialog; 
	ZC.zalertdialog = {Templates: {}};
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let button = ZC.zbutton.Templates.WCContainer, template = ZC.zalertdialog.Templates, utilities = ZC.Templates.Utilities; 
template.WCContainer = (data) => ZT.html `<z-alertdialog class="zdialog zdialog--alert" tabindex="-1" role="alertdialog" aria-modal="true" aria-expanded="true">${data.children && template.WCChildren(data)}</z-alertdialog>`; 
template.WCChildren = (data) => ZT.html ` ${data.titleBar && ZT.html `<div class="zdialog__header zdraggable"> ${data.title && ZT.html `<span class="zdialog__title">${ZT.customHTML(data.title)}</span>`} ${data.closeButton && ZT.html `<div class="zdialog__actiongroup">${button(data.closeButton)}</div>`} </div>`} <div class="zdialog__content"> ${data.alertIcon && ZT.html `<div class="zdialog__alerticon">${utilities.WCIcon(data)}</div>`} <div class="zdialog__description"> ${data.primaryMessage && ZT.html `<div class="zdialog__primarytext">${ZT.customHTML(data.primaryMessage)}</div>`} ${data.secondaryMessage && ZT.html `<div class="zdialog__secondarytext">${ZT.customHTML(data.secondaryMessage)}</div>`} ${data.suppressionDecisionBoxLabel && ZT.html `<div class="zdialog__suppression"> <div class="zcheckbox"><input id="zalert__suppression--box" type="checkbox" class="zcheckbox__helper"><label for="zalert__suppression--box" class="zcheckbox__label">${data.suppressionDecisionBoxLabel}</label></div> </div>`} </div> </div> ${data.commandBar && ZT.html `<div class="zalertdialog__commandbar zalertdialog__footer ${data.commandBar.className}"> ${data.helpButton && button(data.helpButton)} ${data.buttons.map((value) => button(value))} </div>`}` }(ZComponents)); 
 (function(ZC){ 
let button = ZC.zbutton.Templates.container, template = ZC.zalertdialog.Templates, utilities = ZC.Templates.Utilities; 
template.container = (data) => ZT.html `<div class="zdialog zdialog--alert" tabindex="-1" role="alertdialog" aria-modal="true" aria-expanded="true">${data.children && template.children(data)}</div>`; 
template.children = (data) => ZT.html ` ${data.titleBar && ZT.html `<div class="zdialog__header zdraggable"> ${data.title && ZT.html `<span class="zdialog__title">${ZT.customHTML(data.title)}</span>`} ${data.closeButton && ZT.html `<div class="zdialog__actiongroup">${button(data.closeButton)}</div>`} </div>`} <div class="zdialog__content"> ${data.alertIcon && ZT.html `<div class="zdialog__alerticon">${utilities.icon(data)}</div>`} <div class="zdialog__description"> ${data.primaryMessage && ZT.html `<div class="zdialog__primarytext">${ZT.customHTML(data.primaryMessage)}</div>`} ${data.secondaryMessage && ZT.html `<div class="zdialog__secondarytext">${ZT.customHTML(data.secondaryMessage)}</div>`} ${data.suppressionDecisionBoxLabel && ZT.html `<div class="zdialog__suppression"> <div class="zcheckbox"><input id="zalert__suppression--box" type="checkbox" class="zcheckbox__helper"><label for="zalert__suppression--box" class="zcheckbox__label">${data.suppressionDecisionBoxLabel}</label></div> </div>`} </div> </div> ${data.commandBar && ZT.html `<div class="zalertdialog__commandbar zalertdialog__footer ${data.commandBar.className}"> ${data.helpButton && button(data.helpButton)} ${data.buttons.map((value) => button(value))} </div>`}` }(ZComponents)); 
(function(ZC, $){
		ZC.createMenu = function(menuId, menuItems, options = {}) { // Menu created via JSON
		    if (menuId && typeof menuId === 'object') { // No I18N
		        menuItems = menuId.items;
		        options = menuId;
		        menuId = menuId.id;
		    }
		    // If menu is already initialized for the element, return here.
		    let menuEle = $('#' + menuId); // No I18N
		    if (menuEle.data('zmenu')) {
		        return menuEle;
		    }
		    options.id = menuId;
		    options.usingJSON = true;
		    if (menuItems.body || menuItems.header || menuItems.footer) {
		        $.extend(true, options, menuItems); // ##revisit - try to remove $.extend
		        options.items = menuItems.body;
		        delete options.body;
		    } else {
		        options.items = menuItems;
		    }
		    options.allowReplace = true;
		    return ZC.createElement(options, 'menu'); // assigning the ID and customAttributes is handled in createElement method itself.
		}
	class ZMenu  extends ZC.CoreComponent{
			get name(){
				return "zmenu";
			}
	    get attrs() {
	        return {
	            // allowReplace is introduced to completely replace the child elements present inside the element given by the user with the new elements created by the templates.
	            allowReplace: true, // No I18N
	            constructMenu: true, // No I18N
	            appendTo: null, // No I18N
	            arrowIconClass: null, // No I18N
	            arrowSVGIconId: null, // No I18N
	            checkedCheckboxItemIconClass: null, // No I18N
	            checkedCheckboxItemSVGIconId: null, // No I18N
	            checkedRadioItemIconClass: null, // No I18N
	            checkedRadioItemSVGIconId: null, // No I18N
	            columns: 3, // No I18N
	            headerContentType: undefined,
	            footerContentType: undefined,
	            contentType: 'text', // No I18N
	            direction: 'auto', // No I18N
	            displayType: 'box', // No I18N
	            forElement: null, // No I18N
	            menuClass: '', // No I18N
	            zclassName: '', // No I18N
	            height: null, // No I18N
	            usingJSON: false,
	            isCustomHTMLEncoded: true, // No I18N
	            isLabelHTMLEncoded: false, // No I18N
	            offset: null, // No I18N
	            pointer: false, // No I18N
	            renderInPlace: false, // No I18N
	            scroll: 'slider', // No I18N
	            scrollDownArrowIconClass: null, // No I18N
	            scrollDownArrowSVGIconId: null, // No I18N
	            scrollUpArrowIconClass: null, // No I18N
	            scrollUpArrowSVGIconId: null, // No I18N
	            type: 'list', // No I18N
	            toggle: true, // No I18N
	            width: null, // No I18N
	            EFFECTS: { // No I18N
	                slide: { // No I18N
	                    open: 'slideDown', // No I18N
	                    close: 'slideUp' // No I18N
	                },
	                fade: { // No I18N
	                    open: 'fadeIn', // No I18N
	                    close: 'fadeOut' // No I18N
	                }
	            },
	            minWidth: 200, // No I18N
	            handleAccessKeyNavigation: true, // No I18N
	            itemTagName: 'li', // No I18N
	            groupTagName: 'ul', // No I18N
	            viewport: null, // No I18N
	            menuItems: null, // No I18N
	            submenuHideDelay: 300
	        };
	    }
	    get props() {
	        return {
	            items: null,
	            header: null,
	            footer: null,
	            body: null,
	            arrowIconClassName: null, // No I18N
	            checkedCheckboxItemIconClassName: null, // No I18N
	            checkedRadioItemIconClassName: null, // No I18N
	            scrollDownArrowIconClassName: null, // No I18N
	            scrollUpArrowIconClassName: null, // No I18N
	            animation: {} // No I18N
	        };
	    }
	    get parts() {
	        return [ 'header', 'body', 'footer' ]; // No I18N
	    }
	    get _DIRECTIONS() {
	        return {
	            menu: 'bottom-left', // No I18N
	            submenu: 'right-bottom', // No I18N
	            pointer: 'bottom' // No I18N
	        };
	    }
	    get EVENTS() {
	        return [ 'beforeshow', 'beforehide', 'show', 'hide', 'beforesubmenushow', 'submenushow', 'beforesubmenuhide', 'submenuhide', 'itemhover', 'itemclick', 'beforefocus', 'keydown', 'submenuitemclick', 'beforesubmenufocus' ]; // No I18N
	    }
	    static get _CONTENT_TYPES() {
	        return {
	            text: '', // No I18N
	            icon: 'zmenu--icononly', // No I18N
	            'icon-text': 'zmenu--iconwithtext' // No I18N
	        };
	    }
	    static get _ITEM_TYPES() {
	        return {
	            'default': 'zmenu__item', // No I18N
	            separator: 'zmenu__separator', // No I18N
	            splitmenu: 'zmenu__item zmenu--split', // No I18N
	            itemgroup: 'zmenu__title', // No I18N
	            custom: 'zmenu__item zmenu__custom' // No I18N
	        };
	    }
	    static get ARIA_ROLES() {
	        return {
	            'default': 'menuitem', // No I18N
	            splitmenu: 'menuitem', // No I18N
	            custom: 'menuitem', // No I18N
	            radio: 'menuitemradio', // No I18N
	            checkbox: 'menuitemcheckbox', // No I18N
	            itemgroup: 'group', // No I18N
	            separator: 'separator' // No I18N
	        };
	    }
	    get SELECTORS() {
	        let isCE = this.isCE;
	        return {
	            container: isCE ? 'z-menu' : 'div', // No I18N
	            menu: isCE ? 'z-menubody' : 'ul:not([data-header]):not([data-footer])', // No I18N
	            body: isCE ? 'z-menubody' : 'ul:not([data-header]):not([data-footer])', // No I18N
	            header: isCE ? 'z-menuheader' : 'ul[data-header=true]', // No I18N
	            footer: isCE ? 'z-menufooter' : 'ul[data-footer=true]', // No I18N
	            // footer: isCE ? 'z-menufooter' : 'ul:last:not(.zmenu__body):not([data-body])', // No I18N
	            group: isCE ? 'z-menuitemheading' : 'li[data-item-type=itemgroup]', // No I18N
	            item: isCE ? 'z-menuitem' : 'li', // No I18N
	            separator: isCE ? 'z-menuseparator' : 'li[data-item-type=separator]', // No I18N
	            visibleItems: '.zmenu__item:not(.is-disabled):visible' // No I18N
	        };
	    }
	    _getItemDetails(itemObj, opts, item, attrChange) {
	        let dItemType = itemObj.itemType || 'default', // No I18N
	            itemType = itemObj.itemType = opts.isCE && item ? item.tagName === 'Z-MENUSEPARATOR' ? 'separator' : item.tagName === 'Z-MENUITEMHEADING' ? 'itemgroup' : dItemType : dItemType, // No I18N
	            contentType = itemObj.contentType || opts.contentType || 'text', // No I18N
	            hoverCls = 'on-hover', // No I18N
	            hasShortcut = false,
	            isElement = false,
	            itemCls = ZMenu._ITEM_TYPES[itemType === 'radio' || itemType === 'checkbox' ? 'default' : itemType], // No I18N
	            // regexp = new RegExp(itemCls + '|' + hoverCls, 'g'); // No I18N
	            regexp = new RegExp((attrChange ? itemCls : itemCls + '|' + hoverCls) + '|is-disabled|zh-dnone|zmenu--submenu', 'g'); // No I18N
	        itemObj.className = (itemObj.className ? itemObj.className.replace(regexp, '') + ' ' : '') + itemCls; // No I18N
	        // Since for separator type, we don't have to fetch other details.
	        if (!opts.allowReplace && item) {
	            itemObj.element = item;
	        }
	        if (itemType === 'separator') { // No I18N
	            itemObj.isSeparator = true;
	            // contentType is set to avoid rendering icons inside separator item.
	            itemObj.contentType = 'text'; // No I18N
	            if (item) {
	                item = $(item);
	            }
	        } else {
	            if (!attrChange && itemObj.label && !opts.isLabelHTMLEncoded) {
	                itemObj.label = ZC.encodeHTML(itemObj.label);
	            }
	            if (!attrChange && !itemObj.label && item) { // custom check added to support itemgroup with custom HTML
	                let label = $(item)[itemObj.custom ? 'html' : 'text'](); // No I18N
	                if (!itemObj.custom && !opts.isLabelHTMLEncoded && (label.indexOf('<') > -1 || label.indexOf('>') > -1)) { // No I18N
	                    label = ZC.encodeHTML(label); // encoding here since label might contain special characters
	                }
	                itemObj.label = label;
	            }
	            if (itemType === 'itemgroup') { // No I18N
	                // contentType is changed here since itemgroup header element will contain text alone irrespective of the declared content type for menu.
	                contentType = 'text'; // No I18N
	            } else {
	                if (itemType === 'custom' || itemObj.custom) { // No I18N
	                    this._getCustItemInfo(itemObj, item);
	                } else {
	                    let action = itemObj.action,
	                        hasShortcut;
	                    if (typeof action === 'string' && action.indexOf('URL:') !== -1) { // No I18N
	                        itemObj.target = itemObj.target || '_blank'; // No I18N
	                        itemObj.className += ' zmenu--withlink'; // No I18N
	                        itemObj.url = action.replace('URL:', ''); // No I18N
	                        if (itemObj.target === '_blank') { // No I18N
	                            itemObj.rel = 'noopener noreferrer'; // No I18N
	                        }
	                    }
	                    if (itemObj.ellipsis) {
	                        itemObj.label = itemObj.label + '...'; // No I18N
	                    }
	                    hasShortcut = ZC.ShortCut && item ? ZC.ShortCut.getInfo(action, item, true) : itemObj.shortcutKey; // need revisit
	                    itemObj.shortcutKey = hasShortcut && (typeof hasShortcut === 'string' ? hasShortcut : hasShortcut[0]); // No I18N
	                    this._data.hasShortcut = !!hasShortcut;
	                }
	                if (itemObj.menuItems) { // contains submenu
	                    let submenuId = itemObj.id + 'submenu'; // No I18N
	                    itemObj.menuId = submenuId;
	                    ZC.createMenu(submenuId, itemObj.menuItems, {
	                        type: itemObj.type,
	                        isCE: opts.isCE,
	                        contentType: itemObj.contentType,
	                        appendTo: itemObj.appendTo,
	                        [opts.isCE ? 'zclassName' : 'className']: itemObj.submenuClassName // No I18N
	                    });
	                }
	            }
	            itemObj.hasSubmenu = itemObj.menuId || (itemType === 'splitmenu' || itemType === 'submenu'); // No I18N
	            if (itemObj.hasSubmenu) {
	                itemObj.className += itemType !== 'splitmenu' && !itemObj.splitmenu ? ' zmenu--submenu' : ''; // No I18N
	                itemObj.arrowIcon = ZC._getIconInfo(opts.arrowIconClassName || opts.arrowIconClass, opts.arrowSVGIconId, 'zc__svg--arrow zmenu__arrow zh-arrowicon', 'zmenu__icon zh-alignright'); // No I18N
	                if (itemObj.customType) {
	                    itemObj.iconAsSuffix = true;
	                }
	                this._hasSMenu = true;
	            }
	            let dIconCls = `${opts.type === 'grid' ? 'zmenu__image' : 'zmenu__icon'}`; // No I18N
	            // replacing to avoid duplicate class name additions while updating via setMenuItemsAttribute
	            itemObj.iconClassName = (itemObj.iconClassName || '').replace(new RegExp(itemObj.iconClass + '|' + dIconCls, 'g'), ''); // No I18N
	            if (itemObj.SVGIconId) {
	                itemObj.SVGIconId += ' zmenu__svg'; // No I18N
	            }
	            itemObj = ZC._getIconInfo(itemObj.iconClass || itemObj.iconClassName, itemObj.SVGIconId, undefined, dIconCls, itemObj);
	            itemObj.contentType = contentType; // No I18N
	            if (itemType === 'radio' || itemType === 'checkbox') { // No I18N
	                itemObj = this._getIconDetails(itemObj, opts, itemObj.checked);
	            }
	            if (opts.isCE && itemType === 'itemgroup') { // No I18N
	                itemObj.isHeading = true;
	            }
	        }
	        if (item) {
	            item = $(item);
	            let stateAttrs = [ 'disabled', 'checked', 'hidden', 'name' ], // No I18N
	                aName;
	            for (let k = 0; k < 4; k++) {
	                aName = stateAttrs[k];
	                itemObj[aName] = itemObj[aName] || item.attr(aName);
	            }
	            if (opts.allowReplace) {
	                let attrs = item[0].attributes,
	                    cAttrs = {};
	                for (let a = 0; a < attrs.length; a++) {
	                    if (attrs[a].name === 'class') { // No I18N
	                        itemObj.className = attrs[a].value + ' ' + itemObj.className; // No I18N
	                        // class should be merged with existing class
	                    } else {
	                        cAttrs[attrs[a].name] = attrs[a].value;
	                    }
	                }
	                itemObj.attrs = cAttrs;
	            } else {
	                isElement = true;
	            }
	        } else if (itemObj.customAttributes) {
	            // itemObj.attrs = Object.create(itemObj.customAttributes); Object.keys returns null if we assign like this
	            itemObj.attrs = { // to avoid memory reference prblm
	                ...itemObj.customAttributes
	            };
	        }
	        if (itemType !== 'separator' && (itemType === 'radio' || itemType === 'checkbox')) { // No I18N
	            itemObj = this._getIconDetails(itemObj, opts, itemObj.checked);
	        }
	        if (!itemObj.isSeparator && !itemObj.isHeading) {
	            itemObj.isDefault = true;
	        }
	        let cls = itemObj.className; // replace is needed if disabled option is updated for a menu item using setMenuItemsAttribute.
	        cls = itemObj.disabled ? cls + ' is-disabled' : (cls.indexOf('is-disabled') >= 0 ? cls.replace(/is-disabled/g, '') : cls); // No I18N
	        cls = itemObj.hidden ? cls + ' zh-dnone' : (cls.indexOf('zh-dnone') >= 0 ? cls.replace(/zh-dnone/g, '') : cls); // No I18N
	        itemObj.className = cls;
	        itemObj.uniqueKey = itemObj.uniqueKey || (itemObj.id || 'mitem') + Math.round(Math.random() * 100000000); // No I18N
	        itemObj.id = (item && item.attr('id')) || itemObj.id || (itemObj.attrs && itemObj.attrs.id) || itemObj.uniqueKey; // ID is assigned mandatory for performance improvement reasons like querying using the ID.
	        itemObj.role = ZMenu.ARIA_ROLES[itemType];
	        if (itemObj.element) { // all attrs like class,role, id, uniquekey has to be set
	            itemObj.defaultClass = itemObj.defaultClass === undefined ? itemObj.element.className : itemObj.defaultClass;
	            itemObj.attrs = $.extend(true, {}, itemObj.attrs, { // itemObj.attrs might be undefined. So, using assignment statements
	                id: itemObj.id,
	                'class': itemObj.defaultClass + ' ' + itemObj.className, // No I18N
	                role: itemObj.role,
	                'data-unique-key': itemObj.uniqueKey // No I18N
	            });
	        }
	        if (hasShortcut) {
	            this._data.shortcutItems.push(itemObj.id);
	        }
	        if ((itemObj.attrs && !ZC.isEmpty(itemObj.attrs)) || itemObj.checked) {
	            this._itemsHavingAttrs.push(itemObj.id);
	        }
	        itemObj.layoutName = this._getLayout(`${itemObj.customType ? 'custom' : (itemObj.url ? 'anchor' : 'default')}Layout`); // No I18N
	        itemObj.className = itemObj.className.trim();
	        if (isElement) {
	            itemObj.element.itemData = itemObj;
	        }
	        if (opts.addItemCallback) {
	            opts.addItemCallback(item, itemObj, opts);
	        }
	        return itemObj;
	    }
	    _init(ele, opts) {
	        // getData is changed to .itemData to improve performance.
	        let data = this._data;
	        if (!opts.headerContentType) {
	            opts.headerContentType = opts.contentType;
	            this._sameheaderct = true;
	        }
	        if (!opts.footerContentType) {
	            opts.footerContentType = opts.contentType;
	            this._samefooterct = true;
	        }
	        this._itemsHavingAttrs = [];
	        this._labelList = [];
	        this._namespace = '.zmenu'; // No I18N
	        this._data.shortcutItems = [];
	        // ##revisit - create via json
	        // $.extend(true, data, opts); // _opts.data will be passed from createMenu method.
	        data.callout = opts.displayType === 'callout'; // No I18N
	        this._skipParent = data.alwaysSetAttrs = true; // always container template execution should be prevented.
	        data.attrs = data.attrs || {};
	        data.attrs.role = 'menu'; // No I18N
	        data.attrs.tabindex = ele[0].getAttribute('tabindex') || 0; // No I18N
	        data.items = [];
	        let sel = this._SELECTORS;
	        this._isContainer = ele[0].tagName.toLowerCase() === sel.container && (this.isCE ? !ele.children(sel.item).length : true); // first element child
	        this._lastOverlayedMenu = ele;
	        if (opts.constructMenu) {
	            this[this._isContainer ? '_storeAllPortionItems' : '_storeMenuItemDetails'](); // No I18N
	            data.simple = !this._isContainer;
	        }
	        if (!this._isContainer) { // slider type scroll will be shown for container type menus alone
	            opts.scroll = 'default'; // No I18N
	        }
	        if (this.isCE && opts.allowReplace) {
	            this._addedByComponent = true;
	        }
	        this._useParent = !opts.usingJSON;
	        this._NAV_OPTS = {
	            ...this.NAV_OPTS,
	            ctype: this.name,
	            headerClassName: 'zmenu__header', // No I18N
	            footerClassName: 'zmenu__footer', // No I18N
	            items: this._SELECTORS.visibleItems,
	            keydown: this._keydownHandler.bind(this),
	            arrowkeydown: this._arrowKeydownHandler.bind(this),
	            focusmove: this._focusMoveHandler.bind(this),
	            beforeblur: this._beforeBlurHandler.bind(this)
	        }
	    }
	    _storeMenuItemDetails(section, ele = this.element) {
	        let sel = this._SELECTORS,
	            data = this._data,
	            elePassed = ele[0] !== this.element[0],
	            itemsArr = [],
	            opts = this._opts,
	            secName = section ? section + 'Items' : 'items', // No I18N
	            items = opts[section] || opts[secName] || ele[0].querySelectorAll(`${sel.item}, ${sel.separator}, ${sel.group}`), // No I18N
	            len = items.length,
	            iData = {};
	        for (let i = 0; i < len; i++) {
	            if (!opts.usingJSON) {
	                iData = ZC._getOpts(items[i]);
	            }
	            iData.contentType = (elePassed && ZC._getOpts(ele).contentType) || opts[section + 'ContentType'] || undefined; // No I18N
	            itemsArr.push(this._getItemDetails(opts.usingJSON ? items[i] : iData, opts, !opts.usingJSON && items[i])); // collecting the items related data to store in this._data.items
	        }
	        if (itemsArr.length) {
	            data[secName] = itemsArr; // No I18N
	        }
	    }
	    _postRender(ele) { // below code will be executed for first render alone
	        let opts = this._opts,
	            data = this._data;
	        data.className += ` ${ele ? ele[0].className : ''} zmenu ${opts.contentType ? ZMenu._CONTENT_TYPES[opts.contentType] : ''} ${this._isContainer === false && opts.type === 'grid' ? 'zmenu--thumbnail' : ''} ${opts.menuClass || ''}`; // No I18N
	        if (!opts.allowReplace) {
	            data.rendered = true;
	            data.isInitial = true; // will be revisited
	            this['_setCustomAttrsForItem' + (this._isContainer ? 's' : '')](data, true); // No I18N
	        }
	        if (opts.renderInPlace) {
	            this._resetLabels(ele);
	        }
	        if (this.isCE && opts.allowReplace) {
	            this._addedByComponent = false;
	        }
	        ele.attr('aria-hidden', true); // No I18N
	    }
	    _postEachRender() {
	        let data = this._data;
	        if ((data.rendered && !data.isInitial && this._itemsHavingAttrs.length) || (this._opts.allowReplace && (!data.rendered || this._itemsHavingAttrs.length))) { // element attrs has to be added like this for nested elements
	            this['_setCustomAttrsForItem' + (this._isContainer ? 's' : '')](data, false); // No I18N
	        }
	        // Why have we assigned it everytime and this statement will return true instead of the pointer element - Revisit
	        this._pointerElement = data.callout && this.element.find('.zmenu__pointer'); // No I18N
	        this._addedByComponent = false;
	    }
	    _setCustomAttrsForItem(itemsObj, isInitial, customPortion) { // serves dual purpose - setting custom attributes for menu items and fetching only the newly added items using the passed data.
	        if (this.isCE) {
	            this._addedByComponent = true;
	        }
	        let menuItems = [],
	            portionData = itemsObj[customPortion || 'items'],
	            j, attrs, menuItem, itemData; // No I18N
	        if (portionData && portionData.length) {
	            for (j = 0; j < portionData.length; j++) {
	                itemData = portionData[j];
	                attrs = itemData.attrs;
	                menuItem = $('#' + itemData.id)[0];
	                if (!this._opts.allowReplace) { // run template for each and every LI elements separately
	                    // this._data.isInitial = true;
	                    menuItem = itemData.element || menuItem;
	                    this._render(itemData, itemData.layoutName, menuItem, true);
	                    // this._data.isInitial = false;
	                    if (itemData.className) {
	                        $(itemData.element).attr('class', itemData.className); // No I18N
	                    }
	                    // attrs && delete attrs.class; // updating the class attribute behaves erroneous if not deleted here.
	                }
	                menuItem = $('#' + itemData.id);
	                if (!menuItem.length) {
	                    continue;
	                }
	                if (this._itemsHavingAttrs.indexOf(itemData.id) !== -1) {
	                    if (attrs) {
	                        // https://git.csez.zohocorpin.com/zoho_components/zoho-components/-/commit/4a18e8d7e617de8b08fa901614bbacc447ec78ec
	                        attrs.class && menuItem.attr('class', attrs.class); // No I18N
	                        delete attrs.class;
	                        menuItem.attr(attrs);
	                    }
	                    // Initially item prop should be set.
	                    menuItem.prop('checked', itemData.checked); // No I18N
	                }
	                menuItems.push(menuItem);
	            }
	        }
	        if (this.isCE) {
	            this._addedByComponent = false;
	        }
	        return menuItems; // return values are used in addMenuItems method.
	    }
	    _bindEvents() {
	        // if (!this._opts.allowReplace) {
	        this._data.isInitial = false;
	        // }
	        let ele = this.element,
	            cname = this._namespace,
	            itemSel = '.zmenu__item'; // No I18N
	        this._addEvents({
	            mouseup: 'mouseup' // No I18N
	        });
	        // cannot use _addEvents for the mouseenter event. Also, mouseover event cannot be used. So, using on method.
	        ele.on('mouseenter' + cname, itemSel, (event, actualEvent) => this._mouseenterHandler(event, actualEvent))
	            .on('mouseleave' + cname, itemSel, (event) => this._mouseleaveHandler(event));
	    }
	    get NAV_OPTS() {
	        return {
	            wrapAround: true,
	            handleHover: false
	        }
	    }
	    _focusMoveHandler(event) {
	        let item = this._lastOverlayedMenuItem;
	        if (item && item.length) {
	            this._lastOverlayedMenuItem.trigger('mouseleave'); // No I18N
	        }
	        event.target = event.detail.item;
	        event.type = event.originalEvent && event.originalEvent.type;
	        this._mouseenterHandler(event);
	        if (this._opts.scroll === 'slider' && this._data.scroller) { // No I18N
	            let menu = this.element,
	                item = this._lastOverlayedMenuItem,
	                itemTop = item.offset().top + item.outerHeight(),
	                scrDown = this.element.find('.zmenu--scrollerdown'), // No I18N
	                scrUp = this.element.find('.zmenu--scrollerup'), // No I18N
	                bodyEle = menu.find('.zmenu__body'),
	                hideVal;
	            if (scrDown.is(':visible')) { // No I18N
	                hideVal = itemTop > scrDown.position().top;
	                hideVal = hideVal ? bodyEle.scrollTop() + Math.abs(scrDown.position().top - itemTop) : undefined;
	            } else if (scrUp.is(':visible')) { // No I18N
	                hideVal = item.offset().top < 0;
	                hideVal = hideVal ? item.offset().top : undefined;
	            }
	            if (hideVal !== undefined) {
	                bodyEle.scrollTop(hideVal);
	            }
	            this._showScrollEle(bodyEle);
	        }
	    }
	    _beforeBlurHandler(event) {
	        let item = this._lastOverlayedMenuItem || this.element.find('.on-hover'), // No I18N
	            relTarget = event.relatedTarget;
	        if (relTarget && item && item.length && ((item[0].itemData.hasSubmenu && this._isMenuOfMenuItemShown(item)) || $(relTarget)[0].contains(item[0]))) {
	            return false;
	        }
	        return true;
	    }
	    // Revisit - Why do we bind event everytime on open
	    _bindRuntimeEvents() { // keydown should be binded only to the main menu element and not for submenus. So having a separate method to call during menu show.
	        let menu = this._lastOverlayedMenu || this.element;
	        ZC.keyboardnavigation(menu, {
	            ...this._NAV_OPTS,
	            direction: this._isGridMenu(menu) ? 'both' : 'vertical' // No I18N
	        });
	    }
	    _mouseenterHandler(event, actualEvent) {
	        // Revisit - shorten second function name
	        this[this._hasSMenu ? '_checkSubmenuEnter' : '_handleMouseEnterOnMenuItems'](event, !event.originalEvent, actualEvent); // No I18N
	    }
	    _handleMouseEnterOnMenuItems(event, scrollToView = !event.originalEvent, actualEvent) {
	        let menuItem = $(event.target).closest('.zmenu__item'), // No I18N
	            data = this._getData(menuItem),
	            mBodyCls = '.zmenu__body', // No I18N
	            menu = menuItem.closest('.zmenu'), // No I18N
	            bodyEle = menu.find(mBodyCls).length && menu.find(mBodyCls),
	            hideSubmenu = this._hideOpenedSubmenu.bind(this),
	            hoverCls = 'on-hover'; // No I18N
	        bodyEle && bodyEle.stop();
	        if (data.disabled || data.itemType === 'itemgroup') { // No I18N
	            hideSubmenu(menu); // if submenuitem is hovered previously, it's submenu should be closed. [ Behavior is referred in MAC XCode]
	            let item = this._lastOverlayedMenuItem;
	            item && this._updateHoverState(item, false);
	            return;
	        }
	        let storeHoverItem = this._setLastOverlayedMenuItem.bind(this);
	        // Revisit - Shorten name
	        if (data.hasSubmenu && menuItem.hasClass(hoverCls) && this._isMenuOfMenuItemShown(menuItem)) { // No I18N
	            storeHoverItem(menuItem);
	            return;
	        }
	        let mainMenu = menu.data('parent'); // No I18N
	        if (mainMenu) {
	            mainMenu = mainMenu.closest('.zmenu'); // No I18N
	            clearTimeout(ZC._getOpts(mainMenu).mouseOverTimeout);
	        }
	        if (actualEvent) { // inorder to find whether the mouseenter is triggered on key events or not in selectbox component.
	            event = actualEvent;
	        }
	        if (this._triggerEvent('itemhover', event, this._lastOverlayedMenu, menuItem, data)) { // No I18N
	            if (scrollToView !== false) {
	                this._scrollToView(menuItem, bodyEle || menu); // No I18N
	            }
	            hideSubmenu(menu);
	            storeHoverItem(menuItem);
	            this._updateHoverState(menuItem, true, data);
	            if (data.hasSubmenu) { // No I18N
	                let submenu = data.submenu || $('#' + data.menuId);
	                ZC.keyboardnavigation(menu).setAttribute('activeEleOnRight', submenu); // No I18N
	                ZC.keyboardnavigation(submenu, {
	                    // ...this._NAV_OPTS,
	                    ...ZC.menu(submenu)._NAV_OPTS,
	                    direction: this._isGridMenu(submenu) ? 'both' : 'vertical' // No I18N
	                });
	                ZC.keyboardnavigation(submenu).setAttribute('activeEleOnLeft', menu); // No I18N
	                this._handleMouseEnterOnSubmenuItem(menuItem, event, data); // No I18N
	            }
	        }
	    }
	    _setLastOverlayedMenuItem(menuItem) {
	        let hoveredItem = this._lastOverlayedMenuItem,
	            hasMItem = menuItem && menuItem.length;
	        if (hoveredItem && hasMItem && hoveredItem[0] === menuItem[0]) {
	            return;
	        }
	        let lastMenu = this._lastOverlayedMenu,
	            par;
	        if (hoveredItem && hasMItem && !lastMenu[0].contains(menuItem[0]).length) { // Split menu case
	            let iData = this._getData(menuItem),
	                submenu = iData.submenu;
	            if (!submenu || submenu[0] !== lastMenu[0]) {
	                par = lastMenu.data('parent'); // No I18N
	                if (par && par.parent().has(menuItem[0]).length) {
	                    menuItem.trigger('mouseleave'); // No I18N
	                }
	            }
	        }
	        if (hoveredItem) {
	            hoveredItem.trigger('mouseleave', menuItem); // No I18N
	        }
	        this._lastOverlayedMenuItem = menuItem;
	        if (hasMItem) {
	            // Revisit - Avoid using closest. Use parent based on conditions
	            let __menu = menuItem.closest('.zmenu'), // No I18N
	                currentMenu = this.element,
	                par,
	                currData = currentMenu.data('parent'); // No I18N
	            this.setLastOverlayedMenu(__menu);
	            while (currData) { // No I18N
	                par = currentMenu.data('parent'); // No I18N
	                currentMenu = par.closest('.zmenu'); // No I18N
	                currData = currentMenu.data('parent'); // No I18N
	            }
	            ZC.menu(currentMenu)._lastOverlayedMenuItem = menuItem; // No I18N
	        }
	    }
	    _hideOpenedSubmenu(menu) {
	        this._hasSMenu && this._hideAllSubmenus && this._hideAllSubmenus(menu);
	    }
	    _hideParentMenu(menu, event) {
	        menu = this._findMain(menu);
	        if (menu[0] === this.element[0]) {
	            // Revisit - SHorten function name
	            this._hideOpenedSubmenu(menu, true, event);
	        } else {
	            ZC.menu(menu).hide(undefined, event);
	        }
	    }
	    _scrollToView(item, menu) {
	        let iTop = item.offset().top - menu.offset().top,
	            prevTop = menu[0].scrollTop,
	            topValue,
	            sBar = ZC.menu(menu.closest('.zmenu')).getData().scroller, // No I18N
	            bar = iTop >= 0 ? 'downEle' : 'upEle'; // No I18N
	        if (sBar && sBar[bar].is(':visible')) { // considering the scrollbar presence while navigating
	            let sBarHeight = sBar[bar].outerHeight(true);
	            iTop += (bar === 'upEle' ? -sBarHeight : sBarHeight); // No I18N
	        }
	        // iTop < 0 means scrolling backward
	        topValue = iTop < 0 ? (prevTop + iTop) : Math.max(prevTop, iTop + prevTop + item.outerHeight(true) - menu.outerHeight());
	        menu.scrollTop(topValue); // animation is removed because in fast repeat keyboards animation produces incorrect results.
	        if (sBar && prevTop !== topValue) {
	            this._showScrollEle(menu); // showing and hiding the scrollbars similar to MAC OS menubar's menu.
	        }
	    }
	    _mouseleaveHandler(event) {
	        this[this._hasSMenu ? '_checkSubmenuLeave' : '_handleMouseLeaveOnMenuItems'](event); // No I18N
	    }
	    _handleMouseLeaveOnMenuItems(event) {
	        let menuItem = $(event.target).closest('.zmenu__item'), // No I18N
	            // data = menuItem[0].itemData;
	            data = this._getData(menuItem);
	        if (data.hasSubmenu && !this._handleMouseLeaveOnSubmenuItem(menuItem, event)) {
	            return;
	        }
	        let lastOver = this._lastOverlayedMenuItem;
	        // fix for the combination of mouse and key alternative usages
	        if (!menuItem.hasClass('on-hover') && lastOver && lastOver[0] !== menuItem[0]) { // No I18N
	            menuItem = lastOver;
	            data = this._getData(menuItem);
	        }
	        this._updateHoverState(menuItem, false, data);
	        this._lastOverlayedMenuItem = undefined;
	    }
	    _mouseupHandler(event) {
	        if (event.which === 3 && !$(event.target).closest('.zmenu--withlink').length) { // No I18N
	            // context menu event bubbles up mouseup event for menu items if enough space is not present for the contextual menu. Issue faced in sheet & code team.
	            return;
	        }
	        let menuItem = $(event.target).closest('.zmenu__item'); // No I18N
	        if (!menuItem.length) {
	            return;
	        }
	        // let data = menuItem[0].itemData,
	        let data = this._getData(menuItem),
	            iType = data.itemType;
	        if (data.disabled || iType === 'itemgroup' || iType === 'separator') { // No I18N
	            return;
	        }
	        let triggerFunc = this._triggerEvent.bind(this),
	            menu = menuItem.closest('.zmenu');// No I18N
	        if (!triggerFunc('before' + (menu.data('parent') ? 'submenu' : '') + 'itemclick', event, menu, menuItem, data)) { // No I18N
	            return;
	        }
	        let click = data.action;
	        if (click) {
	            let args = [ menuItem, event, {
	                menuitem: menuItem,
	                options: data
	            } ];
	            if (typeof click === 'string' && click.indexOf('URL:') === -1) { // No I18N
	                ZC._triggerFunction(click, args[0], args.splice(1)); // function names given as strings will be handled here
	            } else if (typeof click === 'function') { // No I18N
	                click.call(args[0], args[1], args[2]);
	            }
	        }
	        if (iType === 'radio' || iType === 'checkbox') { // No I18N
	            if (triggerFunc('beforeitemchecked', event, undefined, menuItem, data)) {
	                this._checkMenuItem(menuItem, iType === 'checkbox' ? !data.checked : true, data); // No I18N
	            }
	        }
	        if (triggerFunc((menu.data('parent') ? 'submenu' : '') + 'itemclick', event, menu, menuItem, data)) { // No I18N
	            (!data.hasSubmenu || data.itemType === 'splitmenu') && this.hide(undefined, event); // No I18N
	        }
	    }
	    _enterKeyHandler(event) {
	        event.target = $(this._lastOverlayedMenuItem); // target is modified since actual target will be menu element.
	        let target = this._lastOverlayedMenuItem;
	        if (target && target.data('menuId') && !target.hasClass('zmenu--split')) { // No I18N
	            event.keyCode = ZC.keyCode.RIGHT;
	            this.handleKeyCode(event);
	        } else {
	            this._mouseupHandler(event);
	        }
	    }
	    _escKeyHandler(event) {
	        if (this._lastOverlayedMenu.data('parent')) { // No I18N
	            this._hideLastShownMenu();
	            this._lastOverlayedMenu && this._lastOverlayedMenu[0].focus();
	        } else {
	            this.hide();
	        }
	        event.stopPropagation();
	        event.preventDefault();
	    }
	    _onLtRtKey(event, key) { // secondary direction key handler. For Ex: right and left key handling
	        return this._openCloseSubmenu(key, event);
	    }
	    handleKeyCode(event, fromKeydown) { // This method is made public to use in other dependency components like menubutton, selectbox & etc.
	        this._lastOverlayedMenu = this._lastOverlayedMenu || this.element;
	        !fromKeydown && ZC.keyboardnavigation(this._lastOverlayedMenu).moveFocus(event); // No I18N
	        let code = event.keyCode,
	            prevHover = this._lastOverlayedMenuItem;
	        if (this._labelList.length && this._opts.handleAccessKeyNavigation) {
	            this._callMenuitemSearch(String.fromCharCode(code), +(new Date()));
	        }
	        // Keydown event triggering is added inorder to implement MAC menu bar like behavior.
	        let hoveredItem = this._lastOverlayedMenu.find('.on-hover'),
	            containsSubmenu = false;
	        if (hoveredItem.length && (!prevHover || (prevHover && prevHover[0] !== hoveredItem[0]))) {
	            // let submenu = hoveredItem[0].itemData.submenu; // No I18N
	            let submenu = this._getData(hoveredItem).submenu; // No I18N
	            containsSubmenu = submenu && submenu.length;
	            if (!containsSubmenu && prevHover) {
	                containsSubmenu = this._lastOverlayedMenu.data('parent') && this._lastOverlayedMenu.data('forElement')[0] === prevHover[0];
	            }
	        }
	        event && event.type === 'keydown' && !containsSubmenu && this._triggerEvent('KEYDOWN', event, this.element); // No I18N
	    }
	    _keydownHandler(event) {
	        let detail = event.detail;
	        if (detail.isEnterKey || detail.isSpaceKey) {
	            this._enterKeyHandler(event);
	        } else if (detail.isEscapeKey) {
	            this._escKeyHandler(event);
	        }
	    }
	    _arrowKeydownHandler(event) {
	        let detail = event.detail,
	            item = this._lastOverlayedMenuItem,
	            isRtl = this._opts.rtl,
	            openCond = (isRtl ? detail.isLeftKey : detail.isRightKey) && (item && (item.hasClass('zmenu--submenu') || item.hasClass('zmenu--split'))), // No I18N
	            closeCond = detail['is' + (isRtl ? 'Right' : 'Left') + 'Key']; // No I18N
	        if (openCond || closeCond) {
	            this._onLtRtKey(event, detail.key);
	        }
	    }
	    _isNonModifier(event) {
	        return (!event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey);
	    }
	    getData() { // having this as public method to fetch the data of submenu in main menu
	        return this._data;
	    }
	    _getData(item, remove) { // No I18N
	        if (!item.length) {
	            return {};
	        }
	        let uKey = item.attr('data-unique-key'), // No I18N
	            itemParent = item.parent(),
	            // itemParent length is added since removeMenuItem might be called after removing the element from the DOM - web component case.
	            sectionName = !itemParent.length || itemParent.hasClass('zmenu__body') || itemParent.hasClass('zmenu') ? 'items' : (itemParent.hasClass('zmenu__footer') ? 'footerItems' : 'headerItems'), // No I18N
	            // closest zmenu will not be present for custom element removal case.
	            cMenu = itemParent.closest('.zmenu'), // No I18N
	            pMenu = cMenu.length ? cMenu : this.element,
	            items = ZC.menu(pMenu).getData()[sectionName], // Submenu Items Datas might also be needed.
	            len = items.length;
	        for (let j = 0; j <= len - 1; j++) {
	            if (items[j].uniqueKey === uKey) {
	                if (remove) {
	                    delete items[j];
	                    items.splice(j, 1);
	                    len = len - 1;
	                } else {
	                    return items[j];
	                }
	            }
	        }
	    }
	    _removeData(item) {
	        this._getData(item, true);
	    }
	    _fixMenuUI(menu, options, isSubMenu) {
	        if (!menu.is(':visible')) {
	            return;
	        }
	        ZC.Helpers.fixHeight(menu);
	    }
	    _resetLabels(menu) { // used for access key navigation
	        this._opts.handleAccessKeyNavigation && this._refreshLabelArray(menu);
	    }
	    setLastOverlayedMenu(menu, isExternal) {
	        this._lastOverlayedMenu = menu;
	        if (!isExternal && menu[0] !== this.element[0]) {
	            this._setLastOverlayedSubMenu(menu);
	        }
	    }
	    _findMain(menu = this.element) {
	        return (menu.data('parent') ? this._findParentMenu(menu) : menu).closest('.zmenu'); // No I18N
	    }
	    show(options, menu) { // submenu will be passed as the second argument
	        options = options ? Object.create(options) : {};
	        let opts = this._opts,
	            originalEvent = options.event || {},
	            appendedTo = $(options.appendTo || opts.appendTo),
	            forElement = $(options.forElement || opts.forElement),
	            isSubMenu = options.isSubMenu = !!menu,
	            dirMap = this._DIRECTIONS,
	            dirPassed = options.direction,
	            dir = opts.direction,
	            isContextMenu = opts.isRightClick || (dirPassed || dir) === 'at-cursor', // No I18N
	            defaultDir = isContextMenu ? opts.displayType === 'callout' ? dirMap.pointer : dirMap.menu : (dirPassed || dir); // No I18N
	        menu = menu || this.element; // If menu is undefined, then it means it is the base menu.
	        // forElement is set before itself to make it available in beforeshow events.
	        menu.data('forElement', forElement); // No I18N
	        let canOpen = this._triggerEvent(isSubMenu ? 'beforesubmenushow' : 'beforeshow', originalEvent, menu, undefined, { // No I18N
	            currentTarget: isContextMenu ? originalEvent.target : forElement
	        });
	        if (canOpen === false) {
	            return options;
	        }
	        // getAttributes is taking longer time. Since it is not needed for main menu included this check.
	        let menuOpts = isSubMenu ? ZC.menu(menu).getAttributes() : this._opts,
	            isGrid = this._isGridMenu(menu),
	            offsetValue = options.offset || (isSubMenu ? menuOpts.offset : opts.offset) || undefined;
	        if (!isSubMenu) {
	            this._bindRuntimeEvents();
	        }
	        this.setLastOverlayedMenu(menu);
	        if ((opts.pointer || opts.displayType === 'callout') && !isSubMenu) { // No I18N
	            options = this._getCalloutDetails(options);
	        }
	        options.direction = dirPassed ? (dirPassed === 'auto' ? defaultDir : dirPassed) : isSubMenu ? dirMap.submenu : dir === 'auto' ? defaultDir : dir; // No I18N
	        /* if direction is at-cursor, we should not place the menu to the left or right of the target */
	        options.positionAlterable = (dir === 'at-cursor' || isContextMenu) && !isSubMenu ? 'fit' : (options.positionAlterable || opts.positionAlterable || (isSubMenu ? 'flipfit' : dir === 'auto' || dir === 'at-cursor')); // No I18N
	        let dataProps = ZC.Helpers.open(menu, $.extend(true, {}, {
	            forElement: forElement,
	            isSubList: isSubMenu,
	            isGrid: isGrid,
	            renderInPlace: opts.renderInPlace,
	            position: opts.position,
	            width: menuOpts.width,
	            height: menuOpts.height,
	            offset: offsetValue,
	            contentType: menuOpts.contentType,
	            appendTo: appendedTo,
	            within: options.within,
	            viewport: opts.viewport,
	            event: options.event,
	            animation: menuOpts.animation,
	            isContextual: isContextMenu,
	            direction: options.direction,
	            positionAlterable: options.positionAlterable,
	            rtl: menuOpts.rtl,
	            columns: menuOpts.columns,
	            alterBorderRadius: true,
	            isRightClick: opts.isRightClick,
	            hideMethodName: '_hide', // No I18N
	            hideEventName: 'hide', // No I18N
	            cname: 'zmenu', // No I18N
	            arrowElement: this._pointerElement,
	            arrowCallback: options.arrowCallback,
	            scroll: opts.scroll,
	            isCE: menuOpts.isCE,
	            // getAllMenuItems is used for setting grid menu width.
	            getAllMenuItems: (actualEle, excludeFI, excludeSI, isOnlyVisible) => this._getAllMenuItems(actualEle, excludeFI, excludeSI, isOnlyVisible),
	            onShow: () => {
	                this._handleMenuOpen(menu, isSubMenu, options);
	            },
	            onShowWithAnimation: () => {
	                this._openWithAnimation(menu, options);
	            },
	            onToggle: () => {
	                this.hide(menu, opts);
	            },
	            displayScrollers: (isGreater) => {
	                let mName = (isGreater ? '_' : '_un') + 'initSliders'; // No I18N
	                (isGreater || this[mName]) && this[mName](menu, undefined, true);
	            },
	            beforeFocus: () => this._triggerEvent(isSubMenu ? 'beforesubmenufocus' : 'beforefocus', {}) // No I18N
	        }, options));
	        if (!dataProps) {
	            return options;
	        }
	        menu.data('positionOpts', Object.create(options)); // No I18N
	        options.position = dataProps.pos;
	        return options;
	    }
	    _handleMenuOpen(menu, isSubMenu, options) {
	        this._resetLabels(menu);
	        menu.attr('aria-hidden', false); // No I18N
	        this._triggerEvent((isSubMenu ? 'submenu' : '') + 'show', options.event, menu, undefined, {}); // No I18N
	    }
	    selectHoveredMenuItem() {
	        let item = this._lastOverlayedMenuItem;
	        item && $(item).trigger('mouseup'); // Trigger method is used since event object is not present. Event object is mandatory in this case to use event.preventDefault and event.stopPropagation methods.
	        // Hiding the menu is not needed here because menu hide can be prevented using itemclick event.
	        return item;
	    }
	    hoverMenuItem(item) {
	        item = $(item);
	        if (!item.length) {
	            item = this._lastOverlayedMenuItem;
	            item && this._updateHoverState(item, false);
	            this._lastOverlayedMenuItem = undefined;
	            return;
	        }
	        this._mouseenterHandler({
	            target: item[0]
	        });
	    }
	    _updateHoverState(item, setHover, data = this._getData(item)) { // hoverClass addition and removal should be updated in data object too
	        let hoverCls = 'on-hover'; // No I18N
	        item[(setHover ? 'add' : 'remove') + 'Class'](hoverCls); // No I18N
	        if (!setHover) {
	            item.removeClass('has-focus'); // No I18N
	        }
	        data.className = setHover ? data.className + ' ' + hoverCls : data.className.replace(/on-hover/g, ''); // No I18N
	    }
	    _isGridMenu(menuOrMenuItem = this.element, isMenuItem) {
	        let menu = isMenuItem ? menuOrMenuItem.closest('.zmenu') : menuOrMenuItem; // No I18N
	        if (menu.length) {
	            let thumbCls = 'zmenu--thumbnail'; // No I18N
	            return this.getMenuType(menu) === 'grid' || menu.hasClass(thumbCls) || menu.find('.' + thumbCls).length; // No I18N
	        }
	    }
	    getMenuType(menu) {
	        return menu && menu.data('isExternalSubmenu') ? ZC.menu(menu).getMenuType() : this._opts.type; // No I18N
	    }
	    getMenuItemAt(index, menu = this.element, returnAsObj) {
	        let item = menu.find(`.zmenu__item:eq(${index})`);
	        return returnAsObj ? this._getData(item) : item;
	    }
	    _setFocus() {
	        clearTimeout(this._focusTimer);
	        if (this._triggerEvent('beforefocus', {})) { // No I18N
	            this._focusTimer = setTimeout(() => this.element.focus(), 100);
	        }
	    }
	    callRender() {
	        this._render();
	    }
	    _hide(orgEvent) { // added to make it compatible with close handler recent change
	        this.hide(undefined, orgEvent);
	    }
	    hide(menu = this.element, event) {
	        let ele = this.element,
	            opts = this._opts,
	            menuPar = menu.data('parent'), // No I18N
	            isSubMenu = !!((menu[0] !== ele[0]) || (menuPar && menuPar.is('.zmenu__item')) && !event); // No I18N
	        ZC.Helpers.close(menu, {
	            renderInPlace: opts.renderInPlace,
	            animation: opts.animation,
	            beforeHide: () => {
	                let res = this._triggerEvent((isSubMenu ? 'beforesubmenu' : 'before') + 'hide', event, menu); // No I18N
	                if (res !== false) {
	                    if (!isSubMenu) {
	                        this._hideParentMenu(menu, event && event.originalEvent ? event.originalEvent : event);
	                    }
	                    let hoverCls = 'on-hover', // No I18N
	                        items = $(`${this._SELECTORS.item}.${hoverCls}`, menu),
	                        item;
	                    for (let i = 0; i < items.length; i++) {
	                        item = $(items[i]);
	                        if (item.is('.zmenu--split')) { // No I18N
	                            item.find('.zmenu__icon.zh-alignright').removeClass(hoverCls);
	                        }
	                        this._updateHoverState(item, false);
	                        item.removeClass('has-focus'); // No I18N
	                    }
	                    if (menu[0] === ele[0]) {
	                        this._lastOverlayedMenuItem = undefined;
	                    } else {
	                        let menuParent = menuPar.parent();
	                        if (menuParent.is('.zmenu__body, .zmenu__header, .zmenu__footer')) { // No I18N
	                            menuParent = menuParent.parent();
	                        }
	                        this.setLastOverlayedMenu(menuParent);
	                        // this.setLastOverlayedMenu(menuPar.parent()); // No I18N
	                    }
	                    this._isToBeDelayed = false;
	                }
	                return res;
	            },
	            onHide: () => {
	                // closing the main menu whenever hide method for submenu is called from close handler should be prevented. So, event & parent check is included - fix for annotator.
	                this._handleMenuClose(menu, isSubMenu, event);
	            },
	            onHideWithAnimation: () => {
	                this._closeWithAnimation(menu, isSubMenu, event);
	            }
	        });
	    }
	    _handleMenuClose(menu, isSubMenu, event) {
	        !isSubMenu && this._isContainer && this._opts.scroll === 'slider' && this._uninitSliders && this._uninitSliders(menu); // No I18N
	        // If h-scroll_y class presents, retrieving width returns value with scrollbar width. So, removing the classes here.
	        let scrollCls = 'zh-scroll_y'; // No I18N
	        menu.removeClass(scrollCls).find('.' + scrollCls).removeClass(scrollCls); // No I18N
	        menu.find('.has-focus, .on-hover').removeClass('has-focus on-hover'); // No I18N
	        this._resetLabels(menu);
	        menu.attr('aria-hidden', true); // No I18N
	        this._triggerEvent((isSubMenu ? 'submenu' : '') + 'hide', event, menu); // No I18N
	    }
	    _triggerEvent(type, event = {}, menu = this.element, item, dataObj) {
	        item = item || $(event.target).closest('.zmenu__item');
	        let hasItem = item.length,
	            isBase = menu[0] === this.element[0],
	            data = {
	                originalEvent: event,
	                forElement: menu.data('forElement'), // No I18N
	                // Need to remove target option
	                target: menu.data('forElement'), // No I18N
	                // offset is re-calculating style
	                offset: this._offset || menu.offset(),
	                menu,
	                isBaseMenu: isBase,
	                menuitem: item,
	                data: hasItem ? dataObj : undefined,
	                itemValue: hasItem && dataObj && dataObj.itemValue // No I18N
	            };
	        if (dataObj) {
	            data = $.extend(true, {}, dataObj, data);
	        }
	        if (type.indexOf('submenu') !== -1 && type !== 'beforesubmenufocus') { // No I18N
	            return this._triggerEventToSubmenu(type, event, data, menu);
	        }
	        return this._dispatchEvent(type, event, data, menu);
	    }
	    triggerEvent() { // used by submenu to trigger event to main menu
	        return this._dispatchEvent(...arguments);
	    }
	    _getLayout(layoutName) {
	        return this.isCE ? ('WC' + layoutName.replace(/./, ($0) => $0.toUpperCase())) : layoutName; // No I18N
	    }
		_refreshLabelArray  (menu) {
		    this._labelList = [];
		    this._prevSKey = this._prevKTime = this._prevSIndex = ''; // S denotes search key, K - keydown
		    let itemSel = '.zmenu__item:not(.zmenu__title):not(.is-disabled):not(.zmenu__separator):visible', // No I18N
		        menuItems = menu.find(itemSel),
		        len = menuItems.length,
		        item;
		    for (let i = 0; i < len; i++) {
		        item = menuItems[i];
		        this._labelList.push({
		            text: item.getAttribute('data-label') || $(item).find('.zmenu__text').text() || '', // No I18N
		            itemId: item.id
		        });
		    }
		    // Removed this code as this._getData takes lot of time to execute
		    // let menuItems = menu.find(this._SELECTORS.visibleItems),
		    //     iData;
		    // for (let i = 0; i < menuItems.length; i++) {
		    //     iData = this._getData($(menuItems[i]));
		    //     this._labelList[i] = {
		    //         text: iData.label || '', // No I18N
		    //         itemId: iData.id
		    //     };
		    // }
		}
		_callMenuitemSearch  (key, currentTime) {
		    let sameKey = false;
		    if (this._prevKTime && currentTime - this._prevKTime > 700) { // No I18N
		        sameKey = this._prevSKey === key;
		        this._prevSKey = key;
		    } else {
		        this._prevSKey = this._prevSKey + key;
		    }
		    this._prevKTime = currentTime;
		    this._menuitemSearch(sameKey);
		}
		_menuitemSearch  (sameKey) {
		    let arr = this._labelList,
		        len = arr.length,
		        regExp = new RegExp('^' + this._prevSKey.replace(/[|()[{.+*?$\\]/g, '\\$0'), 'i'), // No I18N
		        fromIndex = sameKey && this._prevSIndex < len ? this._prevSIndex + 1 : 0;
		    fromIndex = fromIndex > 0 && fromIndex < len ? fromIndex : 0;
		    for (let x = fromIndex; x < len; x++) {
		        if (regExp.test(arr[x].text)) {
		            let checkNextMatch = -1;
		            for (let y = x + 1; y < len; y++) {
		                if (regExp.test(arr[y].text)) {
		                    checkNextMatch = x;
		                    break;
		                }
		            }
		            this._prevSIndex = checkNextMatch;
		            this._handleMouseEnterOnMenuItems({ // converting target to jquery obj is done in the method itself.
		                target: '#' + arr[x].itemId // No I18N
		            }, true);
		            return;
		        }
		    }
		}
		addMenuItems  (menuItemArray, itemCallback, skipHeightFix) { // menuItem details are given as json object.
		    // skipHeightFix - added for selectbox component since addMenuItems will be called during scroll.
		    return this._fetchAndRender(menuItemArray, itemCallback, true, skipHeightFix);
		}
		replaceMenuItems  (menuItemArray, replaceCallback, skipHeightFix) {
		    let data = this._data;
		    this._removeCustomAttrs(menuItemArray);
		    data.headerItems = data.footerItems = data.items = [];
		    let lastOverlayed = this._lastOverlayedMenuItem;
		    if (lastOverlayed && lastOverlayed.length) {
		        lastOverlayed.removeClass('on-hover'); // No I18N
		    }
		    this._lastOverlayedMenuItem = null;
		    this._itemsHavingAttrs = [];
		    return this._fetchAndRender(menuItemArray, replaceCallback, undefined, skipHeightFix);
		}
		_fetchAndRender  (menuItemArray, callback, concat, skipHeightFix) { // concat denotes whether concating the data is needed or not
		    let itemsObj = this._fetchItemDetails(menuItemArray, concat);
		    return this._invokeRender(callback, itemsObj, undefined, undefined, skipHeightFix); // rendered items will be returned from here.
		}
		_removeCustomAttrs  (itemsObj) {
		    let portions = this.parts,
		        pName, data, newData;
		    for (let k = 0; k < 3; k++) {
		        pName = portions[k];
		        data = this._data[k === 1 ? 'items' : pName + 'Items']; // No I18N
		        newData = itemsObj[pName];
		        if (newData && data && data.length) {
		            this._removeCustomAttrsOf(data, newData);
		        }
		    }
		}
		_removeCustomAttrsOf  (items, itemsObj) {
		    if (!items || !items.length) {
		        return;
		    }
		    let iData, attrs;
		    for (let i = 0; i < items.length && i < itemsObj.length; i++) {
		        iData = items[i];
		        if (this._itemsHavingAttrs.indexOf(iData.id) !== -1) {
		            attrs = iData.customAttributes;
		            if (attrs) { // checkbox items will also be present in the array to update their checked prop.
		                Object.keys(attrs).forEach((key) => { attrs[key] = null });
		                itemsObj[i].customAttributes = $.extend(true, {}, attrs, itemsObj[i].customAttributes);
		            }
		        }
		    }
		    this._itemsHavingAttrs = [];
		}
		_invokeRender  (callback, itemsObj, viaAddMenuItem, viaRemoveMenuItems, skipHeightFix) {
		    let ele = this.element,
		        isCE = this.isCE;
		    if (isCE) {
		        this._addedByComponent = true;
		    }
		    this._isContainer && this._updateSectionCls(this._opts.type === 'grid', this._data); // No I18N
		    if (this._opts.allowReplace || viaRemoveMenuItems) {
		        this._render();
		    } else { // we have to iterate over all items in each section.
		        let parts = this.parts,
		            pName, section, secEle; // No I18N
		        for (let i = 0; i < 3; i++) {
		            pName = i === 1 ? 'items' : parts[i] + 'Items'; // No I18N
		            if (this._data[pName]) {
		                section = this._data[pName];
		                secEle = this.element.find('.zmenu__' + parts[i]);
		                secEle = !secEle.length && i === 1 ? this.element : secEle;
		                if (secEle.length) {
		                    this._render(section, 'items', this.element.find('.zmenu__' + parts[i])[0]);
		                } else {
		                    this._render();
		                }
		            }
		        }
		    }
		    if (isCE) {
		        this._addedByComponent = false;
		    }
		    let menuItems = [];
		    if (itemsObj) {
		        menuItems = viaAddMenuItem ? $('#' + itemsObj.id) : this[this._isContainer ? '_setCustomAttrsForItems' : '_setCustomAttrsForItem'](itemsObj); // No I18N
		    }
		    if (callback) {
		        callback(menuItems, itemsObj); // need to decide the arguments.
		    }
		    if (!skipHeightFix) {
		        this._fixMenuUI(ele, ele.data('positionOpts')); // No I18N
		    }
		    this._resetLabels(ele);
		    return menuItems;
		}
		_fetchItemDetails  (menuItemArray, concatNeeded) { // menuItemArr can be Array of Objects/ a single object containing header, footer and body keys
		    let itemsObj = {
		            items: [],
		            headerItems: [],
		            footerItems: []
		        },
		        data = this._data,
		        menuItemArr = menuItemArray instanceof $ ? menuItemArray : Object.create(menuItemArray),
		        itemData,
		        len = menuItemArr.length,
		        i,
		        opts = this._opts,
		        secName;
		    if (menuItemArr instanceof Array) {
		        for (i = 0; i < len; i++) {
		            itemData = this._getItemDetails(menuItemArr[i], opts);
		            secName = itemData.isHeader ? 'headerItems' : (itemData.isFooter ? 'footerItems' : 'items'); // No I18N
		            itemsObj[secName].push(itemData);
		            if (concatNeeded) {
		                data[secName].push(itemData);
		            }
		        }
		    } else {
		        let parts = this.parts,
		            portionData, j, sectionName;
		        for (i = 0; i < 3; i++) {
		            portionData = menuItemArr[parts[i]];
		            if (portionData) {
		                sectionName = i === 1 ? 'items' : parts[i] + 'Items'; // No I18N
		                for (j = 0; j < portionData.length; j++) {
		                    itemData = this._getItemDetails(portionData[j], opts);
		                    itemsObj[sectionName].push(itemData); // No I18N
		                }
		                if (concatNeeded) {
		                    data[sectionName] = (data[sectionName] || []).concat(itemsObj[sectionName]);
		                }
		            }
		        }
		    }
		    if (!concatNeeded) { // invoked from replaceMenuItems
		        data.headerItems = itemsObj.headerItems;
		        data.footerItems = itemsObj.footerItems;
		        data.items = itemsObj.items;
		    }
		    return itemsObj;
		}
		addCustomMenuItem  (item, callback) {
		    if (!item[0]._constructed && item.attr('_constructed') !== 'true') { // No I18N
		        this.addMenuItem(item, callback);
		    }
		}
		removeMenuItems  (menuItems) { // menuItems can be an array of id's or selector containing elements.
		    if (menuItems) {
		        for (let i = 0; i < menuItems.length; i++) {
		            this.removeMenuItem(menuItems[i], true);
		        }
		    } else {
		        let data = this._data;
		        // If the assignment is present as single stmt, then memory reference pblm occurs.
		        data.headerItems = [];
		        data.footerItems = [];
		        data.items = []; // all sections are made empty
		        data.headerElement = data.bodyElement = data.footerElement = this._lastOverlayedMenuItem = null;
		    }
		    this._invokeRender(undefined, undefined, undefined, true);
		}
		removeMenuItem  (menuItem, isInternal) {
		    let ele = this.element;
		    menuItem = $(menuItem, ele);
		    if (!menuItem.length || !this._data.rendered || !menuItem.attr('role')) { // temporary fix for custom elements case. ##revisit
		        return;
		    }
		    let name = menuItem.attr('name'); // No I18N
		    this._removeData(menuItem); // remove the data present in _data for this menuitem.
		    // Removing the group label if no element of that particular group is visible
		    let groupTitle = name ? $('#' + name + '.zmenu__title') : undefined; // No I18N
		    if (groupTitle && groupTitle.length) {
		        let items = ele.find('.zmenu__item[name=' + name + ']:not(.zmenu__title):not([data-unique-key="' + menuItem.attr('data-unique-key') + '"])'); // No I18N
		        if (!items.length) {
		            this._removeData(groupTitle); // removing the group title data in _data.
		        }
		    }
		    if (!isInternal) {
		        this._invokeRender(); // invoke render will handle the height fixing
		    }
		}
		addMenuItem  (menuItemObj, itemCallback) {
		    if (this._addedByComponent) {
		        return;
		    }
		    let menuItem = menuItemObj instanceof $ || menuItemObj.nodeType === 1 ? $(menuItemObj) : undefined;
		    if (typeof menuItemObj === 'object') { // No I18N
		        menuItemObj = Object.create(menuItem ? ZC._getOpts(menuItem) : menuItemObj);
		    }
		    let attrName,
		        cAttrs = menuItemObj.customAttributes || {};
		    for (let i in this._propNames) {
		        attrName = this._propNames[i];
		        if (menuItemObj[attrName]) {
		            cAttrs[attrName] = menuItemObj[attrName];
		        }
		    }
		    if (menuItemObj.isHeader) {
		        menuItemObj.contentType = this._opts.headerContentType;
		    }
		    if (menuItemObj.isFooter) {
		        menuItemObj.contentType = this._opts.footerContentType;
		    }
		    menuItemObj = this._getItemDetails(menuItemObj, this._opts, menuItem && menuItem[0]);
		    let data = this._data,
		        index = menuItemObj.index;
		    if (this._isNotNull(index)) {
		        data.items.splice(index, 0, menuItemObj);
		    } else {
		        data[menuItemObj.isHeader ? 'headerItems' : (menuItemObj.isFooter ? 'footerItems' : 'items')].push(menuItemObj); // No I18N
		    }
		    /* Need to address
		        ZC._getOpts(menuItem).action = menuItemObj.action;  // action might be a JS function
		    */
		    let submenuItems = menuItemObj.menuItems;
		    if (submenuItems && submenuItems === 'object') { // No I18N revisit needed
		        itemCallback = undefined;
		    }
		    if (menuItem) { // removing the custom element added. ##revisit
		        menuItem[0].parentNode.removeChild(menuItem[0]);
		    }
		    return this._invokeRender(itemCallback, menuItemObj, true);
		}
		_closeWithAnimation  (menu, isSubmenu, event) {
		    let animation = this._opts.animation;
		    if (isSubmenu) {
		        animation = menu.data('zmenu')._opts.animation; // No I18N
		    }
		    if (animation.close) {
		        animation = animation.close || animation.hide;
		        let animationClass = animation.className,
		            effect = animation.name,
		            duration = animation.duration ? animation.duration : 0,
		            completeCallback = () => {
		                this._handleMenuClose(menu, isSubmenu, event); // hiding the menu on animation complete
		                ZC.Helpers.removeScrollClass(menu); // scroll related classes has to be removed after animation is completed otherwise scrollTop reset will be visible in the UI.
		            };
		        if (animationClass) {
		            menu.addClass(animationClass).on(ZC._animationEnd, () => {
		                menu.removeClass(animationClass);
		                this._display(true, menu);
		                completeCallback && completeCallback();
		                completeCallback = undefined;
		                menu.off(ZC._animationEnd);
		            });
		        } else if (typeof effect === 'object') { // No I18N
		            // custom animation properties
		            menu.animate(effect, duration, completeCallback);
		        } else if (this._opts.EFFECTS[effect]) { // predefined effects like slide and fade.
		            if (!duration) {
		                duration = 400;
		            }
		            menu[this._opts.EFFECTS[effect].close](duration, completeCallback);
		        }
		        if (isSubmenu) {
		            menu.data('parent').closest('.zmenu').data('waitingTime', duration); // No I18N
		        }
		    } else if (menu.data('waitingTime') > 0) {
		        window.setTimeout(() => {
		            this._display(true, menu);
		            this._handleMenuClose(menu, isSubmenu, event);
		            menu.data('waitingTime', 0); // No I18N
		        }, menu.data('waitingTime')); // No I18N
		    } else {
		        this._display(true, menu);
		        this._handleMenuClose(menu, isSubmenu, event);
		    }
		}
		_openWithAnimation  (menu, options) {
		    let animation = this._opts.animation,
		        isSub = options.isSubMenu;
		    if (isSub) {
		        animation = menu.data('zmenu')._opts.animation; // No I18N
		    }
		    if (animation.open) {
		        animation = animation ? (animation.open || animation.show) : (options.animation.open || options.animation.show);
		        let animationClass = animation.className,
		            effect = animation.name,
		            duration = animation.duration ? animation.duration : 0,
		            completeCallback = () => {
		                this._handleMenuOpen(menu, isSub, options);
		            };
		        if (animationClass) {
		            this._pointerElement && this._pointerElement.show().addClass(animationClass);
		            this._display(undefined, menu);
		            menu.addClass(animationClass).on(ZC._animationEnd, () => {
		                menu.removeClass(animationClass); // removing the animation class.
		                completeCallback && completeCallback();
		                completeCallback = undefined;
		                menu.off(ZC._animationEnd);
		            });
		        } else if (typeof effect === 'object') { // No I18N
		        // custom animation properties
		            this._pointerElement && this._pointerElement.show().animate(effect, duration, completeCallback);
		            this._display(undefined, menu);
		            menu.animate(effect, duration, completeCallback);
		        } else if (this._opts.EFFECTS[effect]) { // predefined effects like slide and fade.
		            if (!duration) {
		                duration = 400;
		            }
		            this._pointerElement && this._pointerElement[this._opts.EFFECTS[effect].open](duration, completeCallback);
		            menu[this._opts.EFFECTS[effect].open](duration, completeCallback);
		        }
		    } else if (isSub) {
		        this._display(undefined, menu);
		        this._pointerElement && this._pointerElement.show();
		        this._handleMenuOpen(menu, isSub, options);
		    }
		}
		_getCalloutDetails  (options) {
		    this._changeCalloutData(true);
		    options.arrowCallback = (element, direction) => {
		        this._arrowDirection = direction;
		        element.removeClass('zh-top zh-bottom zh-right zh-left').addClass(`zh-${direction}`); // No I18N
		    };
		    return options;
		}
		_changeCalloutData  (createCallout) { // pointer element
		    if (createCallout && this._pointerElement && this._pointerElement.length) {
		        return this._pointerElement.removeClass('zh-top zh-bottom zh-left zh-right'); // No I18N
		    }
		    this._data.callout = !!createCallout;
		    this._render();
		}
		_getCustItemInfo  (itemObj, item) { // itemObj passed by reference only
		    let content,
		        htmlContent = itemObj.innerHTML || itemObj.zinnerHTML;
		    if (htmlContent) {
		        let replaceArray = htmlContent.replaceArray;
		        content = htmlContent.content || htmlContent;
		        if (replaceArray) {
		            for (let i = 0; i < replaceArray.length; i++) {
		                content = content.replace('{' + i + '}', ZC.encodeHTML(replaceArray[i])); // No I18N
		            }
		        }
		    }
		    content = item ? item.innerHTML : content;
		    itemObj.innerHTML = this._opts.isCustomHTMLEncoded ? content : ZC.encodeHTML(content);
		    itemObj.customType = true;
		    // delete itemObj.label; // commenting since label is used for access key navigation
		}
		_destroy  (menu = this.element) {
		    clearTimeout(this._focusTimer);
		    menu.removeData('positionOpts forElement parent isRightClick direction actualDirection arrowDirection arrowPosition availableHeight availableWidth elementPosition oldDirection pos zshowhide zscrEle'); // No I18N
		    ZC.keyboardnavigation(menu).destroy();
		    menu.off('.' + this.name); // No I18N
		    if (!this.isCE) {
		        let opts = this._opts;
		        menu.removeClass('zh-scroll_y'); // No I18N
		        if (opts.usingJSON) {
		            let submenuItems = menu[0].querySelectorAll('.zmenu--submenu,.zmenu--split'), // No I18N
		                submenu;
		                // Since custom item can have submenu, using li[submenuitem=true] to retrieve the menuitems having submenu will not work.
		            for (let i = 0; i < submenuItems.length; i++) {
		                submenu = $(submenuItems[i]).data('submenu');
		                if (submenu && submenu.data('usingJSON')) { // No I18N
		                    this._removeAllSubmenus(submenu);
		                }
		            } // JSON menu contents will be removed since this._useParent will be false.
		        } else {
		            let data = this._data;
		            data.callout = false;
		            data.headerClassName = data.bodyClassName = data.footerClassName = '';
		            this._pointerElement = undefined;
		            let parts = [ 'headerItems', 'items', 'footerItems' ], // No I18N
		                portion,
		                cls = new RegExp('zmenu__item|zmenu__title|zmenu__custom|zmenu__separator|is-disabled|is-fixed|is-selected', 'g');
		            for (let i = 0; i < 3; i++) {
		                portion = parts[i];
		                if (data[portion]) {
		                    this._changeDataForDes(data[portion], cls);
		                }
		            }
		            this._render();
		        }
		    }
		}
		_changeDataForDes  (portion, cls) {
		    let data;
		    for (let i = 0; i < portion.length; i++) {
		        data = portion[i];
		        data.iconClassName = data.iconClass = data.SVGIconId = data.role = data.itemType = data.shortcutKey = data.description = data.hasSubmenu = data.menuId = data.checked = data.iconAsSuffix = data.iconAsPrefix = undefined;
		        data.className = data.className.replace(cls, ''); // No I18N
		        data.layoutName = this._getLayout('destroyLayout'); // No I18N
		    }
		}
		disableMenuItems  (items) {
		    this._toggleDisState(items, true);
		}
		enableMenuItems  (items) {
		    this._toggleDisState(items, false);
		}
		_toggleDisState  (items, disable) {
		    let sel = this._SELECTORS;
		    if (!items) {
		        if (disable) { // making visible items to disable.
		            items = this.element.find(sel.item).filter(function() { // No I18N
		                return $(this).css('display') !== 'none'; // No I18N
		            });
		        } else {
		            items = this.element.find('.is-disabled'); // No I18N
		        }
		    }
		    this.setMenuItemsAttribute(items, 'disabled', disable); // No I18N
		}
		_getAllMenuItems  (menu, excludeFloatingItems, excludeSubMenuItems, isOnlyVisible, excludeseparator) {
		    if (!menu || !menu.length) {
		        menu = this.element;
		    }
		    return menu.find(`.zmenu__item:not(.zmenu__title${excludeseparator ? ',.zmenu__separator' : ''}${excludeFloatingItems ? ',.zmenu--thumbnail' : ''}${excludeSubMenuItems ? ',li ul[mtype=submenu] li' : ''})${isOnlyVisible ? ':visible' : ''}`); // No I18N
		}
		// ZMenu.propertyName = { key: value }; This notation should be used to define a static getter function.
		_getIconDetails  (itemObj, opts, checked, isGrid) { // static member function belongs to ZMenu class.
		    let iType = itemObj.itemType,
		        defaultIconClass = isGrid ? 'zmenu__image' : 'zmenu__icon', // No I18N
		        name = iType[0].toUpperCase() + iType.slice(1),
		        iconClass = opts[`checked${name}ItemIconClass`] || opts[`checked${name}ItemIconClassName`] || '', // No I18N
		        SVGIconId = opts[`checked${name}ItemSVGIconId`],
		        defaultSVGId = `#zc__svg--${iType === 'radio' ? 'round' : 'tick'}`; // No I18N
		        // Revisit - itemObj.iconClassName.trim() can be stored and reused
		    if (isGrid || itemObj.iconClass || (itemObj.iconClassName && itemObj.iconClassName.trim() !== defaultIconClass && itemObj.iconClassName.trim() !== (defaultIconClass + ' ' + iconClass).trim()) || (itemObj.SVGIconId && itemObj.SVGIconId !== defaultSVGId && itemObj.SVGIconId.slice(1) !== SVGIconId)) { // icon is present
		        let className = itemObj.className.replace(/is-selected/g, " "); // No I18N
		        if (checked) {
		            className += ' is-selected'; // No I18N
		        }
		        itemObj.className = className;
		    } else if (checked) {
		        itemObj.iconClassName = defaultIconClass + ' ' + iconClass; // No I18N
		        itemObj.SVGIconId = !iconClass && (opts[`checked${name}ItemSVGIconId`] || defaultSVGId); // No I18N
		        if (itemObj.SVGIconId && itemObj.SVGIconId.indexOf('#') === -1) { // No I18N
		            itemObj.SVGIconId = '#' + itemObj.SVGIconId; // No I18N
		        }
		        itemObj.SVGIconClassName = iType === 'radio' ? 'zmenu__radio' : 'zmenu__tick'; // No I18N
		    } else {
		        // Removed itemObj.iconClassName existence check since it is not necessary in this scenario
		        if (itemObj.iconClassName === defaultIconClass + ' ' + iconClass) { // No I18N
		            itemObj.iconClassName = defaultIconClass;
		        }
		        if (itemObj.SVGIconId && (itemObj.SVGIconId === defaultSVGId || itemObj.SVGIconId.slice(1) === SVGIconId)) {
		            itemObj.SVGIconId = undefined;
		        }
		    }
		    itemObj.iconAsPrefix = itemObj.customType; // custom layout but checkbox/radio type.
		    return itemObj;
		}
		_checkMenuItem  (menuItem, checked, data) {
		    data = this._getData(menuItem);
		    this[data.itemType === 'radio' ? '_handleRadioItem' : '_addCheckedStateIcon'](menuItem, checked, data);// No I18N
		}
		_addCheckedStateIcon  (menuItem, checked, data, doNotRender) {
		    let isGrid = this._isGridMenu(menuItem, true),
		        iconEle = menuItem.find('i:first'); // No I18N
		    if (iconEle.length) {
		        let itemData = this._getData(menuItem);
		        // updating item details present in this._data
		        itemData = this._getIconDetails(itemData, ZC.menu(this._lastOverlayedMenu)._opts, checked, isGrid);
		        let attrs = itemData.attrs || {};
		        attrs.checked = attrs['aria-checked'] = itemData.checked = checked; // No I18N
		        itemData.attrs = attrs;
		        this._itemsHavingAttrs.push(itemData.id);
		        // !doNotRender && this._render();
		        // ##revisit Try to use this._render();
		        !doNotRender && ZC.menu(menuItem.closest('.zmenu')).callRender(); // No I18N
		    }
		    menuItem.prop('checked', checked); // No I18N
		}
		_handleRadioItem  (menuItem, checked, data, doNotRender) {
		    if (checked) {
		        let name = $(menuItem).attr('name'), // No I18N
		            sel = this._SELECTORS,
		            menu = menuItem.closest(sel.menu);
		        menu = menu.length ? menu : menuItem.closest(sel.container);
		        let radios = menu.find(`${sel.item}[role=menuitemradio][name=${name}]`);
		        for (let i = 0, radio; i < radios.length; i++) {
		            radio = $(radios[i]);
		            // Try using javascript properties
		            if (radio.prop('checked') || radio.attr('checked')) { // No I18N
		                this._addCheckedStateIcon(radio, false, this._getData(radio), doNotRender);
		            }
		        }
		    }
		    this._addCheckedStateIcon(menuItem, checked, data, doNotRender);
		}
		_changeCheckedIcons  () { // used by setAttribute method.
		    let opts = this._opts,
		        items = this.element.find('[role="menuitemradio"],[role="menuitemcheckbox"]'),
		        itemData;
		    for (let j = 0; j < items.length; j++) {
		        itemData = this._getData($(items[j]));
		        itemData.iconClass = itemData.iconClassName = itemData.SVGIconId = ''; // No I18N
		        itemData = this._getIconDetails(itemData, opts, itemData.checked);
		    }
		}
		_clearRadioCheckboxData  (iData) { // if default icon details are present, it should be removed
		    let iType = iData.itemType,
		        name = iType[0].toUpperCase() + iType.slice(1),
		        opts = this._opts,
		        iconClass = opts[`checked${name}ItemIconClass`] || opts[`checked${name}ItemIconClassName`] || '', // No I18N
		        SVGIconId = opts[`checked${name}ItemSVGIconId`],
		        defaultSVGId = `#zc__svg--${iType === 'radio' ? 'round' : 'tick'}`; // No I18N
		    if (iData.iconClassName === iconClass || iData.SVGIconId === defaultSVGId || iData.SVGIconId && iData.SVGIconId.indexOf(SVGIconId) >= 0) {
		        iData.SVGIconId = iData.iconClassName = null;
		    }
		}
		_initSliders  (menu) {
		    let mData = ZC.menu(menu).getData(),
		        actualMenu = menu.find('.zmenu__body').length ? menu.find('.zmenu__body') : menu;
		    if (!mData.scroller) {
		        this._getScrollInfo(mData);
		        this._getScrollInfo(mData, true); // create bottom slider.
		        this._render();
		        this._bindSliderEvents(actualMenu, mData);
		    }
		    this._positionSliders(actualMenu, mData);
		}
		_positionSliders  (actualMenu, data) {
		    let container = actualMenu.closest('.zmenu'), // No I18N
		        scrollerInfo = data.scroller,
		        topScroller = scrollerInfo.upEle,
		        bottomScroller = scrollerInfo.downEle,
		        topLeft, bottomLeft, topTop, bottomTop,
		        offset = actualMenu.position();
		    if (container.length) {
		        let container = actualMenu.parent();
		        bottomTop = offset.top + actualMenu.height() - bottomScroller.outerHeight(true); // No I18N
		        if (!data.footerItems.length) {
		            bottomTop += parseInt(container.css('padding-bottom')); // No I18N
		        }
		        topLeft = bottomLeft = '0px'; // No I18N
		        topTop = offset.top - (data.headerItems.length ? 0 : parseInt(container.css('padding-top'))); // No I18N
		    } else {
		        topTop = offset.top + 1;
		        topLeft = bottomLeft = offset.left + 1;
		        bottomTop = offset.top + (actualMenu.outerHeight() - bottomScroller.outerHeight(true) - 1);
		    }
		    bottomScroller.show();
		    topScroller.css({
		        left: topLeft,
		        top: topTop
		    });
		    bottomScroller.css({
		        left: bottomLeft,
		        top: bottomTop
		    });
		}
		_bindSliderEvents  (actualMenu, data) {
		    let container = actualMenu.closest('.zmenu'), // No I18N
		        topScroller = container.find('.zmenu--scrollerup'), // No I18N
		        bottomScroller = container.find('.zmenu--scrollerdown'); // No I18N
		    data.scroller.upEle = topScroller;
		    data.scroller.downEle = bottomScroller;
		    let eSuf = this._namespace;
		    // binding events to scroller elements
		    topScroller.add(bottomScroller).off('mouseenter mouseleave').on('mouseenter', (e) => { // No I18N
		        this._startScroll(actualMenu, $(e.target).closest('.zmenu--scroller').hasClass('zmenu--scrollerup'));
		    }).on('mouseleave', () => {
		        this._stopScroll(actualMenu);
		    }).hide();
		    let cEve = 'click' + eSuf; // No I18N
		    topScroller.add(bottomScroller).off(cEve).on(cEve, () => {
		        let isTop = $(this).hasClass('.zmenu--scrollerup'),
		            top = Math.round(actualMenu.scrollTop()); // rounding the value since windows machine contains floating point numbers
		        this._stopScroll(actualMenu);
		        actualMenu.scrollTop(top + (isTop ? -1 : 1));
		        this._startScroll(actualMenu, isTop);
		        return false;
		    });
		    let mEve = 'mousewheel' + eSuf;// No I18N
		    // Binding mousewheel event for the menu to scroll the menu using mouse eventhough scrollers are present.
		    actualMenu.off(mEve).on(mEve, (event) => {
		        actualMenu.stop();
		        actualMenu.scrollTop(Math.round(actualMenu.scrollTop()) + (event.originalEvent.wheelDelta > 0 ? -6 : 6));
		        this._showScrollEle(actualMenu);
		        event.stopPropagation();
		        event.preventDefault();
		    });
		}
		_getScrollInfo  (data, isTop) {
		    let direction = isTop ? 'up' : 'down'; // No I18N
		    if (!data[direction]) {
		        data.scroller = data.scroller || {};
		        data.scroller[direction] = {
		            className: 'zmenu--scroller zmenu--scroller' + direction // No I18N
		        };
		        this._changeScrollerIcons(direction[0].toUpperCase() + direction.slice(1));
		    }
		}
		_showScrollEle  (menu) {
		    let scrollElement = this._data.scroller,
		        scrollTop = Math.round(menu.scrollTop());
		    scrollElement.upEle[scrollTop === 0 ? 'hide' : 'show'](); // No I18N
		    scrollElement.downEle[menu[0].scrollHeight - scrollTop <= menu.outerHeight() ? 'hide' : 'show'](); // No I18N
		}
		_startScroll  (menu, isTop) {
		    let stop = isTop ? 0 : menu[0].scrollHeight - menu.innerHeight(),
		        distance = Math.round(menu.scrollTop()) - stop,
		        duration = Math.abs(distance * 1000 / 50); // 1000 ms for 50px
		    menu.animate({
		        scrollTop: stop
		    }, {
		        duration: duration, // No I18N
		        easing: 'linear', // No I18N
		        complete: () => {
		            this._showScrollEle(menu);
		        }
		    });
		}
		_stopScroll  (menu) {
		    menu.stop();
		    this._showScrollEle(menu);
		}
		_uninitSliders  (menu, isFromDestroy, isFromShow) {
		    let actData = ZC.menu(menu).getData(),
		        data = actData.scroller || {};
		    menu = menu.find('.zmenu__body').length ? menu.find('.zmenu__body') : menu;
		    if (Object.keys(data).length && isFromShow) {
		        this._positionSliders(menu, actData);
		    }
		    data.upEle && data.upEle[isFromDestroy ? 'remove' : 'hide'](); // No I18N
		    data.downEle && data.downEle[isFromDestroy ? 'remove' : 'hide'](); // No I18N
		    if (isFromDestroy) {
		        data = null;
		    }
		    // mousewheel need not be unbinded here since everytime we don't generate sliders now.
		    // menu.off('mousewheel'); // No I18N
		}
		_changeScrollerIcons  (position) {
		    let place = position.toLowerCase(),
		        opts = this._opts,
		        iconCls = opts['scroll' + position + 'ArrowIconClass'] || opts['scroll' + position + 'ArrowIconClassName'] || ''; // No I18N
		    this._data.scroller[place].icon = {
		        iconClassName: 'zmenu__icon ' + iconCls, // No I18N
		        SVGIconId: '#' + (opts['scroll' + position + 'ArrowSVGIconId'] || !iconCls && 'zc__svg--' + place + 'scroller'), // No I18N
		        SVGIconClassName: 'zmenu__' + place + 'scroller' // No I18N
		    }
		}
		_setAttribute  (optionName, value) {
		    this._addedByComponent = this.isCE;
		    let ele = this.element,
		        data = this._data,
		        isVisible = ele.is(':visible'), // No I18N
		        opts = this._opts,
		        renderNeeded = false; // No I18N
		    if (optionName === 'headerContentType') { // No I18N
		        this._sameheaderct = false;
		    } else if (optionName === 'footerContentType') { // No I18N
		        this._samefooterct = false;
		    } else if (optionName === 'height' || optionName === 'width') {
		        let parsedValue = parseInt(value);
		        opts[optionName] = parsedValue;
		        ele.data(optionName, parsedValue); // No I18N
		        // Revisit - Check whether it is necessary
		        if (isVisible) {
		            if (optionName === 'height') { // No I18N
		                ZC.Helpers.fixHeight(ele, {
		                    height: parsedValue
		                });
		            } else {
		                ele.width(parsedValue);
		            }
		        }
		    } else if (optionName === 'pointer' || optionName === 'displayType') { // No I18N
		        // render handled in the below method itself
		        this._changeCalloutData(value && value !== 'box'); // No I18N
		    } else if (optionName === 'renderInPlace' && !value) { // No I18N
		        ele.removeClass('zmenu--inline'); // No I18N
		    } else if (optionName === 'handleAccessKeyNavigation') { // No I18N
		        // Keypress events
		        // this['_' + (value ? '' : 'un') + 'bindRuntimeEvents'](); // No I18N
		        ZC.keyboardnavigation(ele).setAttribute('characterKeyFocus', value); // No I18N
		    } else if (optionName === 'contentType') { // No I18N
		        let cTypes = ZMenu._CONTENT_TYPES;
		        this._updateClass(cTypes[value], cTypes[opts.contentType]);
		        let oldVal = opts.contentType;
		        opts.contentType = value;
		        if (this._sameheaderct) {
		            opts.headerContentType = value;
		        }
		        if (this._samefooterct) {
		            opts.footerContentType = value;
		        }
		        this._changeOpt('contentType', value, oldVal); // No I18N
		    } else if (optionName === 'type') { // No I18N
		        opts.type = value;
		        let isGrid = value === 'grid'; // No I18N
		        if (this._isContainer) {
		            this._updateSectionCls(isGrid, data);
		        } else {
		            this._updateClass(isGrid ? 'zmenu--thumbnail' : '', isGrid ? '' : 'zmenu--thumbnail'); // No I18N
		        }
		        if (opts.contentType !== 'text') { // No I18N
		            this._changeOpt('type', isGrid); // No I18N
		        }
		    } else if (optionName === 'header' || optionName === 'footer' || optionName === 'body' || optionName === 'items') { // No I18N
		        this.addMenuItems(optionName === 'items' ? value : { // No I18N
		            [optionName]: value
		        });
		    }
		    opts[optionName] = value;
		    if (optionName === 'columns' && isVisible) { // No I18N
		        ZC.Helpers.fixGridWidth(ele, {
		            columns: value
		        });
		    } else if ([ 'scrollDownArrowIconClass', 'scrollDownArrowIconClassName', 'scrollDownArrowSVGIconId', 'scrollUpArrowIconClass', 'scrollUpArrowIconClassName', 'scrollUpArrowSVGIconId' ].indexOf(optionName) !== -1 && data.scroller) { // No I18N
		        this._changeScrollerIcons(optionName.indexOf('Down') === -1 ? 'Up' : 'Down'); // No I18N
		    } else if (optionName === 'arrowIconClassName' || optionName === 'arrowIconClass' || optionName === 'arrowSVGIconId') { // No I18N
		        this._changeArrowIcon();
		    } else if (optionName === 'checkedCheckboxItemSVGIconId' || optionName === 'checkedCheckboxItemIconClassName' || optionName === 'checkedCheckboxItemIconClass' || optionName === 'checkedRadioItemSVGIconId' || optionName === 'checkedRadioItemIconClassName' || optionName === 'checkedRadioItemIconClass') { // No I18N
		        this._changeCheckedIcons(optionName, value);
		    }
		    // For the above set of conditional icon change related conditional statements, rendering is needed.
		    if (optionName.indexOf('Icon') !== -1 || optionName === 'contentType' || optionName === 'type') { // No I18N
		        renderNeeded = true;
		    }
		    if (!this._domChanged) {
		        this._domChanged = renderNeeded;
		    }
		    this._addedByComponent = false;
		}
		_changeOpt  (optionName, value, oldVal) {
		    let parts = [ 'headerItems', 'items', 'footerItems' ], // No I18N
		        section; // No I18N
		    for (let i = 0; i < 3; i++) {
		        section = this._data[parts[i]];
		        if (section && section.length) {
		            if (optionName === 'contentType') {
		                if (i === 1 || this._opts[(i === 0 ? 'header' : 'footer') + 'ContentType'] === value) { // No I18N
		                    this._changeItemData(section, value, optionName, oldVal);
		                }
		            } else {
		                this._changeItemData(section, value, optionName, oldVal);
		            }
		        }
		    }
		}
		_changeItemData  (section, value, optName, oldVal) {
		    let listIcon = 'zmenu__icon', // No I18N
		        gridIcon = 'zmenu__image', // No I18N
		        newValue = value ? gridIcon : listIcon;
		    section.forEach((iData) => {
		        if (optName === 'contentType') { // No I18N
		            iData.contentType = iData.itemType === 'itemgroup' ? 'text' : (oldVal === iData.contentType ? value : iData.contentType); // No I18N
		        } else if (this._opts.contentType !== 'text') { // No I18N
		            iData.iconClassName = iData.iconClassName ? iData.iconClassName.replace(value ? listIcon : gridIcon, newValue) : newValue;
		        }
		    });
		}
		setMenuItemsAttribute  (menuItems, optionName, value, skipRender) { // ## optionName can support array of options to avoid multiple renders.
		    this._addedByComponent = true;
		    let unparsedProps = [ 'itemValue', 'action', 'disabled', 'checked', 'hidden', 'className', 'menuId', 'description', 'label', 'SVGIconId', 'iconClassName' ], // No I18N
		        itemData,
		        opts = this._opts;
		    for (let i = 0, menuItem; i < menuItems.length; i++) {
		        menuItem = $(menuItems[i], this.element);
		        if (menuItem.length) {
		            itemData = this._getData(menuItem); // returns data found in this._data
		            // Revisit - itemData[optionName] is assigned at multiple places, assign once by doing the necessary processing
		            if (itemData.itemType === 'itemgroup' && optionName !== 'itemgroup') { // No I18N
		                let groupItems = $(`[name=${menuItem.attr('name')}]:not(.zmenu__title)`, this.element); // No I18N
		                groupItems.length && this.setMenuItemsAttribute(groupItems, optionName, value);
		            }
		            if (unparsedProps.indexOf(optionName) !== -1) {
		                if (optionName === 'checked' && itemData.checked && value === '') { // No I18N
		                    // Fix for Web Component case attributeChangedCallback triggers if checked attribute is set on the z-menuitem element.
		                    value = 'checked'; // No I18N
		                }
		                if(optionName === 'label' && !opts.isLabelHTMLEncoded){ // No I18N
		                    value = ZC.encodeHTML(value);
		                }
		                itemData[optionName] = value;
		            }
		            if (optionName === 'customAttributes') { // No I18N
		                // custom attributes added for select box requirement.
		                itemData.attrs = $.extend(true, {}, itemData.attrs || {}, value);
		            } else if ((optionName === 'innerHTML' || optionName === 'zinnerHTML') && (itemData.itemType === 'custom' || itemData.custom)) { // No I18N
		                itemData.innerHTML = opts.isCustomHTMLEncoded ? value : ZC.encodeHTML(value); // should be used only in custom menu item;
		            } else if (optionName === 'shortcutKey') { // No I18N
		                value = ZC.ShortCut ? ZC.ShortCut.getInfo(itemData.action, menuItem, true) : value;
		                itemData[optionName] = value;
		            } else if (optionName === 'itemType') { // No I18N
		                let iType = itemData.itemType;
		                itemData.className = itemData.className.replace(ZMenu._ITEM_TYPES[iType === 'radio' || iType === 'checkbox' ? 'default' : iType], ''); // No I18N;
		                if (iType === 'radio' || iType === 'checkbox') { // No I18N
		                    this._clearRadioCheckboxData(itemData);
		                }
		                itemData[optionName] = value;
		            } else if (optionName === 'checked') { // No I18N
		                // Other radio item's data has to be updated as well as prop set on that item should be updated.
		                this._handleRadioItem(menuItem, itemData.checked, itemData, true);
		            } else if (optionName === 'menuId' && itemData.submenu) {
		                itemData.submenu = null;
		            }
		            itemData = this._getItemDetails(itemData, opts, undefined, true);
		            // skipRender added for performance reasons.
		            if ((optionName !== 'itemValue' || optionName !== 'action') && !skipRender) { // No I18N
		                this._addedByComponent = this.isCE;
		                this._render();
		            }
		        }
		    }
		    this._addedByComponent = false;
		}
		hideMenuItems  (items) {
		    this._toggleMenuItems(items, true);
		}
		showMenuItems  (items) {
		    this._toggleMenuItems(items, false);
		}
		_toggleMenuItems  (items, hide) {
		    let sel = this._SELECTORS;
		    if (!items) {
		        if (hide) {
		            items = this.element.find(sel.item + ', ' + sel.separator).filter(function() { // No I18N
		                return $(this).css('display') !== 'none'; // No I18N
		            });
		        } else {
		            items = this.element.find(sel.item + ':not(' + sel.item + '[data-hidden=true])'); // No I18N
		        }
		    }
		    this.setMenuItemsAttribute(items, 'hidden', hide); // No I18N
		}
		_mouseEnterOnSplit  (menuItem, event, data) {
		    clearTimeout(this._splitDelay);
		    this._splitDelay = window.setTimeout(() => { // Hover delay for split menu item
		        this._hoverSplit(menuItem, true);
		        event.type !== 'keydown' && this._showSubmenu(menuItem, event, data); // No I18N
		    }, 150);
		}
		_mouseLeaveOnSplit  (menuItem) {
		    this._hoverSplit(menuItem);
		}
		_hoverSplit  (menuItem, enter) {
		    menuItem.find('.zmenu__icon.zh-alignright')[enter ? 'addClass' : 'removeClass']('on-hover'); // No I18N
		    clearTimeout(this._splitDelay);
		}
		_changeArrowIcon  () { // used by setAttribute method
		    let opts = this._opts,
		        items = this.element.find('.zmenu--submenu,.zmenu--split');
		    for (let j = 0; j < items.length; j++) {
		        this._getData($(items[j])).arrowIcon = ZC._getIconInfo(opts.arrowIconClassName || opts.arrowIconClass, opts.arrowSVGIconId, 'zc__svg--arrow zmenu__arrow zh-arrowicon', 'zmenu__icon zh-alignright'); // No I18N
		    }
		}
		_hideAllSubmenus  (menu) {
		    let items = menu.find(this._SELECTORS.item);
		    for (let i = 0; i < items.length; i++) {
		        let item = $(items[i]),
		            itemData = this._getData(item),
		            subMenu = itemData.submenu;
		        if (subMenu && subMenu.is(':visible')) { // No I18N
		            this._hideAllSubmenus(subMenu); // hiding all the submenus of submenu.
		            item.trigger('mouseleave'); // No I18N
		        }
		    }
		    this._isToBeDelayed = false;
		}
		_findParentMenu  (menu) {
		    let par = menu.data('parent'), // No I18N
		        _menu;
		    while (par) {
		        _menu = par.closest('.zmenu'); // No I18N
		        if (_menu.is(':visible')) { // No I18N
		            menu = _menu;
		            par = menu.data('parent'); // No I18N
		        } else {
		            par = false;
		        }
		    }
		    return menu;
		}
		_setLastOverlayedSubMenu  (menu) {
		    ZC.menu(this._findMain()).setLastOverlayedMenu(menu, true);
		}
		_getSubmenu  (menuItem, data = this._getData(menuItem)) {
		    if (data.submenu) {
		        return data.submenu;
		    }
		    let menuId = data.menuId,
		        submenu = menuId ? $(`#${menuId}`) : menuItem.children(`${this._SELECTORS.container}:not(.zmenu__iconcontainer):first`);
		    if (!submenu.length) {
		        return;
		    }
		    let submenuData = ZC._getOpts(submenu);
		    if (!menuId) { // have to append the nested submenu to the appendTo container/body.
		        $(submenuData.appendTo ? submenuData.appendTo : 'body')[0].appendChild(submenu[0]); // No I18N
		    }
		    submenuData.rtl = this._opts.rtl;
		    if (!submenu.data('zmenu')) { // No I18N
		        ZC.menu(submenu);// initializing the submenu
		    }
		    data.submenu = submenu;
		    submenu.data({
		        isExternalSubmenu: true,
		        parent: menuItem
		    });
		    return submenu;
		}
		_openCloseSubmenu  (key, event) {
		    let smenuOpen = false,
		        isRtl = this._opts.rtl;
		    if (isRtl ? key === 'left' : key === 'right') { // No I18N
		        // open the submenu if submenu is available for currently hovered menu item.
		        let item = this._lastOverlayedMenu.find('.on-hover'),
		            submenu = this._getSubmenu(item);
		        if (!submenu || !submenu.length) {
		            return;
		        }
		        this.show({
		            forElement: this._lastOverlayedMenuItem,
		            event: event
		        }, submenu);
		        this._lastOverlayedMenuItem = undefined;
		        submenu.find(`${this._SELECTORS.visibleItems}:first`).trigger('mouseenter'); // No I18N
		        this._lastOverlayedMenu = submenu;
		        smenuOpen = true;
		    } else if (!this._isMenuMainMenu(this._lastOverlayedMenu)) { // close the submenu associated with the hovered menu item.
		        // Pressing left from submenu will hide the submenu.
		        this._hideLastShownMenu();
		    }
		    let retVal = this._triggerEvent(smenuOpen ? 'beforesubmenufocus' : 'beforefocus', {}, smenuOpen ? undefined : this._lastOverlayedMenu); // No I18N
		    if (retVal !== false) {
		        this._lastOverlayedMenu && this._lastOverlayedMenu[0].focus();
		    }
		}
		_handleMouseEnterOnSubmenuItem  (menuItem, event, data) {
		    clearTimeout(this._menuTimeout);
		    if (data.itemType === 'splitmenu') { // No I18N
		        this._mouseEnterOnSplit(menuItem, event, data);
		    } else if (event.type !== 'keydown') { // No I18N
		        this._showSubmenu(menuItem, event, data);
		    }
		}
		_handleMouseLeaveOnSubmenuItem  (menuItem, event) {
		    let isDirect = !!event.originalEvent;
		    if (isDirect) {
		        if (!menuItem.parent().has(event.relatedTarget).length) {
		            if (menuItem.data('submenu') && this._isMenuOfMenuItemShown(menuItem)) {
		                return false;
		            }
		            this._setLastOverlayedMenuItem(undefined);
		        }
		        return false;
		    }
		    let data = this._getData(menuItem),
		        submenu = data.submenu;
		    if (this._isMenuOfMenuItemShown(menuItem) && (!event || $(event.relatedTarget).closest('.zmenu')[0] === submenu[0])) { // No I18N
		        return false;
		    }
		    if (data.itemType === 'splitmenu') { // No I18N
		        this._mouseLeaveOnSplit(menuItem);
		    }
		    clearTimeout(this._menuTimeout);
		    if ($(submenu).data('parent') && $(submenu).data('parent')[0] === menuItem[0]) { // No I18N
		        // submenu's parent item is checked since submenu can be used as main menu for some other item.
		        this.hide(submenu); // hiding the sub menu.
		        let retVal = this._triggerEvent('beforefocus', {}); // No I18N
		        if (retVal !== false) {
		            this.element[0].focus();
		        }
		        this.element.off('mousemove' + this._namespace); // No I18N
		    }
		    return true;
		}
		_isMenuOfMenuItemShown  (menuItem) {
		    let data = this._getData(menuItem);
		    return data.submenu && data.submenu.is(':visible'); // No I18N
		}
		_isElementInMenu  (element, menu = this.element) {
		    return menu[0].contains($(element)[0]);
		}
		_removeAllSubmenus  (menu) {
		    let submenuItems = menu.find('.zmenu--submenu,.zmenu--split'), // No I18N
		        submenu;
		    for (let i = 0; i < submenuItems.length; i++) {
		        submenu = this._getData($(submenuItems[i]), undefined, menu);
		        if (submenu && submenu.data('usingJSON')) { // No I18N
		            this._removeAllSubmenus(submenu);
		        }
		    }
		    ZC.menu(menu).destroy();
		    menu.remove();
		}
		_showSubmenu  (menuItem, event, data, showImmediately) { // data contains menuItem's data.
		    let isDirectEvent = event ? event.type !== 'keydown' && !!event.originalEvent : false, // No I18N
		        submenu = data.submenu || this._getSubmenu(menuItem, data); // building the submenu here because menu created using createMenu method will not have its submenu created previously.
		    if (submenu && isDirectEvent) { // No I18N
		        this._hideAllSubmenus(menuItem.closest('.zmenu')); // No I18N
		        let f = () => {
		            if (menuItem.is(':visible')) { // No I18N
		                let options = {
		                    forElement: menuItem,
		                    direction: submenu.data('zmenu')._opts.submenuDirection ? submenu.data('zmenu')._opts.submenuDirection : this._DIRECTIONS.submenu // No I18N
		                };
		                options = this.show(options, submenu);
		                this._clearMouseHoverTimeout();
		                this._mousex = event.clientX;
		                this._prevmousex = event.pageX;
		                this._bindMousemoveEvent(submenu, (options.position && options.position.direction) || options.direction); // options.position.direction is the actual opening direction.
		                let retVal = this._triggerEvent('beforesubmenufocus', {}); // No I18N
		                if (retVal !== false && submenu) {
		                    submenu[0].focus();
		                }
		            }
		        };
		        this._menuTimeout = setTimeout(f, showImmediately ? 0 : 100);
		    }
		}
		_bindMousemoveEvent  (subMenu, direction) {
		    let offset = subMenu.offset(),
		        parentOffset = subMenu.data('parent').closest('.zmenu').offset(), // No I18N
		        moveRight = direction.indexOf('left') !== 0;
		    this.element.on('mousemove' + this._namespace, (event) => { // No I18N
		        // equal values are considered since safari browser produces erroneous results by executing stmts differently.
		        this._isToBeDelayed = this._prevmousex && (moveRight ? this._prevmousex <= event.pageX : this._prevmousex >= event.pageX) && (moveRight ? event.pageX <= offset.left : event.pageX >= parentOffset.left);
		        this._prevmousex = event.pageX;
		    });
		}
		_isMenuMainMenu  (menu) {
		    let forEle = menu.data('forElement'); // No I18N
		    if (forEle && (forEle.hasClass('zmenu--submenu') || forEle.hasClass('zmenu--split'))) { // No I18N
		        return false;
		    }
		    return $(menu)[0] === this.element[0];
		}
		_hideLastShownMenu  () {
		    let nextItem = this._lastOverlayedMenu.data('parent'); // No I18N
		    this._lastOverlayedMenuItem = nextItem;
		    this.hide(this._lastOverlayedMenu);
		    let prevMenu = nextItem.closest('.zmenu'); // No I18N
		    this.setLastOverlayedMenu(prevMenu);
		    let ins = ZC.menu(prevMenu);
		    ins._lastOverlayedMenuItem = nextItem;
		    ins._lastOverlayedMenu = prevMenu;
		}
		_clearMouseHoverTimeout  () {
		    let eleOptions = ZC._getOpts(this.element);
		    clearTimeout(eleOptions.mouseOverTimeout);
		    clearTimeout(eleOptions.mouseOutTimeout);
		    if (this.element.data('parent') !== undefined) { // No I18N
		        let parData = ZC._getOpts(this.element.data('parent').closest('.zmenu')); // No I18N
		        clearTimeout(parData.mouseOverTimeout);
		        clearTimeout(parData.mouseOutTimeout);
		    }
		}
		_checkSubmenuEnter  (event) {
		    let isdirect = !!event.originalEvent,
		        mouseOverFunc = function() {
		            this._handleMouseEnterOnMenuItems(event, !event.originalEvent);
		        };
		    this._clearMouseHoverTimeout();
		    if (isdirect) {
		        // if(!(relatedItem.length && relatedItem.data("submenu") && $(event.target).closest(".zmenu")[0] !== $(relatedItem.data("submenu"))[0] && this._isToBeDelayed)){
		        let forElement = $(this.element.data('forElement')); // No I18N
		        if (forElement.is('.zmenu__item')) { // No I18N
		            forElement.closest('.zmenu').data('zmenu')._isToBeDelayed = false; // No I18N
		        }
		        if (this._isToBeDelayed) {
		            ZC._getOpts(this.element).mouseOverTimeout = setTimeout(mouseOverFunc.bind(this), this._opts.submenuHideDelay);
		        } else {
		            mouseOverFunc.bind(this)();
		            clearTimeout(this._mouseoutTimer);
		        }
		    } else {
		        mouseOverFunc.bind(this)();
		        clearTimeout(this._mouseoutTimer);
		    }
		}
		_checkSubmenuLeave  (event) {
		    let isdirect = !!event.originalEvent,
		        menuItem = $(event.target).closest('.zmenu__item'),
		        mouseOutFunc = function() {
		            if (isdirect && this._isToBeDelayed) {
		                this._mouseoutTimer = setTimeout(mouseOutFunc.bind(this), 20);
		            } else {
		                this._handleMouseLeaveOnMenuItems(event);
		            }
		            clearTimeout(this._mouseoutTimer);
		        };
		    if (!isdirect || (!menuItem.data('submenu') && !ZC._getOpts(this.element).mouseOverTimeout)) {
		        mouseOutFunc.bind(this)();
		    } else {
		        ZC._getOpts(this.element).mouseOutTimeout = setTimeout(mouseOutFunc.bind(this), 10);
		    }
		}
		_triggerEventToSubmenu  (type, event, data, menu) {
		    // if external submenu has menu events binded on it
		    ZC.menu(menu).triggerEvent(type.replace('submenu', ''), event, data); // No I18N
		    // temporary fix to find the parent element for custom tag notation.
		    let parentMenu = menu.data('parent').closest('.zmenu'); // No I18N
		    // parentMenu is passed as argument since it is currently needed in custom element case.
		    return ZC.menu(parentMenu).triggerEvent(type, event, data, parentMenu);
		}
		_storeAllPortionItems  () {
		    let sel = this._SELECTORS,
		        parts = [ 'header', 'menu', 'footer' ], // No I18N
		        pName, ele,
		        data = this._data,
		        opts = this._opts,
		        isBody;
		    data.headerItems = [];
		    data.footerItems = [];
		    for (let i = 0; i < 3; i++) {
		        pName = parts[i];
		        ele = this.element.find(sel[pName]);
		        isBody = i === 1;
		        if (isBody || ele.length || opts[pName]) {
		            pName = isBody ? 'body' : pName; // No I18N
		            this._storeMenuItemDetails(isBody ? '' : pName, ele.length ? ele : undefined); // No I18N
		        }
		    }
		    this._updateSectionCls(opts.type === 'grid', data, true);
		}
		_setCustomAttrsForItems  (itemsObj, isInitial) {
		    let menuItems = [],
		        parts = [ 'headerItems', 'items', 'footerItems' ]; // No I18N
		    for (let i = 0; i < 3; i++) {
		        menuItems = menuItems.concat(this._setCustomAttrsForItem(itemsObj, isInitial, parts[i]));
		    }
		    return menuItems; // return values are used in addMenuItems method.
		}
		_updateSectionCls  (isGrid, data, isInit) { // used by setAttribute method.
		    let parts = this.parts,
		        pName,
		        ele,
		        partType,
		        opts = this._opts || {},
		        isPartIsGrid = null,
		        sel = this._SELECTORS,
		        pCls;
		    for (let i = 0; i < 3; i++) {
		        pName = parts[i];
		        ele = this.element.find(isInit ? sel[pName] : '.zmenu__' + pName); // No I18N
		        partType = (ele.length && ZC._getOpts(ele).type) || opts[pName + 'Type'] || opts.type; // No I18N
		        pCls = 'zmenu__' + pName + ((!partType || partType !== 'list') && isGrid ? ' zmenu--thumbnail' : ''); // No I18N
		        if (isInit && !opts.allowReplace && ele && ele[0] !== this.element[0]) {
		            data[pName + 'Element'] = ele[0]; // No I18N
		            ele.addClass(pCls);
		        }
		        data[pName + 'ClassName'] = pCls; // No I18N
		    }
		}
	}
	ZC.registerComponent('ZMenu', ZMenu); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zmenu.Templates, utilities = ZC.Templates.Utilities; 
template.WCContainer = (data) => ZT.html `<z-menu class="${data.className}" ?id=${data.id}>${data.children && template.WCChildren(data)}</z-menu>`; 
template.WCChildren = (data) => ZT.html ` ${data.simple ? ZT.html `${data.items && data.items.map((item) => template.WCItem(item))}` : template.WCAdvancedChildren(data)} `; 
template.WCItem = (data) => ZT.html `${data.element || ZT.html ` ${data.isDefault ? template.WCDefaultItem(data) : (data.isSeparator ? template.WCSeparator(data) : data.isHeading ? template.WCHeading(data) : '')} `}`; 
template.WCDefaultItem = (data) => ZT.html `<z-menuitem ?id=${data.id} ?data-item-type=${data.itemType} class="${data.className}" role="${data.role}" ?name=${data.name} ?data-menu-id="${data.menuId}" data-unique-key="${data.uniqueKey}" ?data-label='${data.label}' ?checked="${data.checked}" .itemData="${data}"> ${template[data.layoutName](data)} </z-menuitem>`; 
template.WCHeading = (data) => ZT.html `<z-menuitemheading ?id=${data.id} ?data-item-type=${data.itemType} class="${data.className}" role="${data.role}" ?name=${data.name} data-unique-key="${data.uniqueKey}" .itemData="${data}"> ${data.label && ZT.html `<span class="zmenu__text" >${ZT.customHTML(data.label)}</span>`} </z-menuitemheading>`; 
template.WCSeparator = (data) => ZT.html `<z-menuseparator ?id=${data.id} ?data-item-type=${data.itemType} class="${data.className}" role="${data.role}" data-unique-key="${data.uniqueKey}" .itemData="${data}"></z-menuseparator>`; 
template.WCAnchorLayout = (data) => ZT.html `<a class="zmenu__link" href=${data.url} target=${data.target} rel='${data.rel}' >${template.WCDefaultLayout(data)}</a>`; 
template.WCDestroyLayout = (data) => ZT.html `${data.label}`; 
template.WCDefaultLayout = (data) => ZT.html `${ZT.customHTML('')} ${data.contentType !== 'text' && ZT.html `<div class="zmenu__iconcontainer" >${data.iconText || utilities.WCIcon(data)}</div>`} ${data.contentType !== 'icon' && !data.customType && ZT.html ` ${data.label && ZT.html `<span class="zmenu__text" >${ZT.customHTML(data.label || '')}</span>`} ${data.shortcutKey && ZT.html `<span class="zmenu__shortcut" >${data.shortcutKey}</span>`} ${data.description ? ZT.html `<span class="zmenu__description" >${data.description}</span>` : ''} `} ${data.hasSubmenu && utilities.WCIcon(data.arrowIcon)} `; 
template.WCCallout = () => ZT.html `<div class="zmenu__pointer" ></div>`; 
template.WCCustomLayout = (data) => ZT.html `${data.iconAsPrefix && template.WCDefaultLayout(data)} ${ZT.customHTML(data.innerHTML || '')} ${data.iconAsSuffix && template.WCDefaultLayout(data)} `; 
template.WCScroller = (data) => ZT.html `<div class='${data.className}'>${utilities.WCIcon(data.icon)}</div>`; 
template.WCContainer = (data) => ZT.html `<z-menu class="${data.className}" ?id=${data.id}>${data.children && template.WCChildren(data)}</z-menu>`; 
template.WCAdvancedChildren = (data) => ZT.html `${data.callout && ZT.html `${template.WCCallout(data)}`} ${data.headerItems.length && ZT.html `${data.headerElement || ZT.html `<z-menuheader class='${data.headerClassName}' data-header=true > ${template.WCItems(data.headerItems)} </z-menuheader>`}`} ${data.items && ZT.html `${data.bodyElement || ZT.html `<z-menubody class='${data.bodyClassName}' data-body=true > ${template.WCItems(data.items)} </z-menubody>`}`} ${data.footerItems.length && ZT.html `${data.footerElement || ZT.html `<z-menufooter class='${data.footerClassName}' data-footer=true > ${template.WCItems(data.footerItems)} </z-menufooter>`}`} ${data.scroller && ZT.html `${template.WCScroller(data.scroller.up)} ${template.WCScroller(data.scroller.down)}`} `; 
template.WCItems = (data) => ZT.html `${data.map((item) => template.WCItem(item))}`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zmenu.Templates, utilities = ZC.Templates.Utilities; 
template.container = (data) => ZT.html `<ul class="${data.className}" ?id=${data.id}>${data.children && template.children(data)}</ul>`; 
template.children = (data) => ZT.html ` ${data.simple ? ZT.html `${data.items && data.items.map((item) => template.item(item))}` : template.advancedChildren(data)} `; 
template.item = (data) => ZT.html `${data.element || ZT.html ` ${data.isDefault ? template.defaultItem(data) : (data.isSeparator ? template.separator(data) : data.isHeading ? template.heading(data) : '')} `}`; 
template.defaultItem = (data) => ZT.html `<li ?id=${data.id} ?data-item-type=${data.itemType} class="${data.className}" role="${data.role}" ?name=${data.name} ?data-menu-id="${data.menuId}" data-unique-key="${data.uniqueKey}" ?data-label='${data.label}' ?checked="${data.checked}" .itemData="${data}"> ${template[data.layoutName](data)} </li>`; 
template.heading = (data) => ZT.html `<li ?id=${data.id} ?data-item-type=${data.itemType} class="${data.className}" role="${data.role}" ?name=${data.name} data-unique-key="${data.uniqueKey}" .itemData="${data}"> ${data.label && ZT.html `<span class="zmenu__text" >${ZT.customHTML(data.label)}</span>`} </li>`; 
template.separator = (data) => ZT.html `<li ?id=${data.id} ?data-item-type=${data.itemType} class="${data.className}" role="${data.role}" data-unique-key="${data.uniqueKey}" .itemData="${data}"></li>`; 
template.anchorLayout = (data) => ZT.html `<a class="zmenu__link" href=${data.url} target=${data.target} rel='${data.rel}' >${template.defaultLayout(data)}</a>`; 
template.destroyLayout = (data) => ZT.html `${data.label}`; 
template.defaultLayout = (data) => ZT.html `${ZT.customHTML('')} ${data.contentType !== 'text' && ZT.html `<div class="zmenu__iconcontainer" >${data.iconText || utilities.icon(data)}</div>`} ${data.contentType !== 'icon' && !data.customType && ZT.html ` ${data.label && ZT.html `<span class="zmenu__text" >${ZT.customHTML(data.label || '')}</span>`} ${data.shortcutKey && ZT.html `<span class="zmenu__shortcut" >${data.shortcutKey}</span>`} ${data.description ? ZT.html `<span class="zmenu__description" >${data.description}</span>` : ''} `} ${data.hasSubmenu && utilities.icon(data.arrowIcon)} `; 
template.callout = () => ZT.html `<div class="zmenu__pointer" ></div>`; 
template.customLayout = (data) => ZT.html `${data.iconAsPrefix && template.defaultLayout(data)} ${ZT.customHTML(data.innerHTML || '')} ${data.iconAsSuffix && template.defaultLayout(data)} `; 
template.scroller = (data) => ZT.html `<div class='${data.className}'>${utilities.icon(data.icon)}</div>`; 
template.container = (data) => ZT.html `<div class="${data.className}" ?id=${data.id}>${data.children && template.children(data)}</div>`; 
template.advancedChildren = (data) => ZT.html `${data.callout && ZT.html `${template.callout(data)}`} ${data.headerItems.length && ZT.html `${data.headerElement || ZT.html `<ul class='${data.headerClassName}' data-header=true > ${template.items(data.headerItems)} </ul>`}`} ${data.items && ZT.html `${data.bodyElement || ZT.html `<ul class='${data.bodyClassName}' data-body=true > ${template.items(data.items)} </ul>`}`} ${data.footerItems.length && ZT.html `${data.footerElement || ZT.html `<ul class='${data.footerClassName}' data-footer=true > ${template.items(data.footerItems)} </ul>`}`} ${data.scroller && ZT.html `${template.scroller(data.scroller.up)} ${template.scroller(data.scroller.down)}`} `; 
template.items = (data) => ZT.html `${data.map((item) => template.item(item))}`; }(ZComponents)); 
(function(ZC, $){
	class ZList extends ZC.CoreComponent {
			get name(){
				return "zlist";
			}
	    get attrs() {
	        return {
	            id: null,
	            direction: 'auto', // No I18N
	            positionAlterable: true,
	            forElement: null,
	            contentType: 'text', // No I18N
	            appendTo: null,
	            height: null,
	            width: null,
	            messages: {},
	            checkedIcon: null,
	            checkedIconClassName: null,
	            checkedSVGIconId: null,
	            showSearchField: false,
	            isGrouped: false,
	            lazyLoading: true,
	            virtualization: false,
	            maxPage: 3,
	            viewPerPage: null,
	            sort: false,
	            sortBy: null,
	            sortOrder: null,
	            customSorter: null,
	            filterByCSSSelector: false,
	            serverSearch: false,
	            cacheData: true,
	            selectHoveredOnTabPress: false,
	            preventDefaultOnTabPress: false,
	            customSearch: null,
	            showAllItemsOnDOWNKeyPress: false,
	            search: {
	                by: 'label', // No I18N
	                searchIncrementsInCache: false,
	                highlightKeyword: false,
	                showNoResultsMessage: false,
	                moreResultsAction: false
	            },
	            dataMapping: {
	                label: 'label', // No I18N
	                value: 'value', // No I18N
	                informativeText: 'informativeText', // No I18N
	                iconClassName: 'iconClassName', // No I18N
	                textIcon: null, // No I18N
	                SVGIconId: 'SVGIconId', // No I18N
	                options: 'options' // No I18N
	            },
	            inputField: null,
	            inputFieldSettings: {
	                updateOnSelect: true,
	                autoFill: true,
	                handleEvents: true,
	                filterBasedOnCurPos: false,
	                suggestOnFocus: true
	            },
	            callbacks: {}
	        }
	    }
	    // Revisit - Remove it
	    get CLASSES() {
	        return {
	            suggestfield: 'zsuggestfield', // No I18N
	            unselectable: 'zsuggestfield__nonselectable', // No I18N
	            iconhint: 'zsuggestfield--withiconandhint', // No I18N
	            icon: 'zsuggestfield--withicon', // No I18N
	            loadingmenu: 'zsuggestfield--loading', // No I18N
	            withhint: 'zmenu--withhint', // No I18N
	            icononly: 'zmenu--icononly', // No I18N
	            icontext: 'zmenu--iconwithtext', // No I18N
	            title: 'zmenu__title', // No I18N
	            loader: 'zmenu--loading', // No I18N
	            text: 'zmenu__text', // No I18N
	            hint: 'zmenu__description', // No I18N
	            menuicon: 'zmenu__icon', // No I18N
	            menuitem: 'zmenu__item', // No I18N
	            menubody: 'zmenu__body' // No I18N
	        }
	    }
	    get isIE9() {
	        return ZC.Browser.getIEVersion() === 9;
	    }
	    _create() {
	        this._namespace = '.' + this.name;
	        this.isCE = false;
	        this._init();
	        this._initDS();
	    }
	    // Method to initiate all the options
	    _init() {
	        let options = this._opts;
	        this._groupsIncluded = [];
	        this.params = {};
	        this._dataMapping = options.dataMapping;
	        this._isGrouped = !!this._dataMapping.groupLabel;
	        this._showSearchField = options.showSearchField;
	        this._isCheckBoxType = options.checkedIcon || options.itemType === 'checkbox'; // No I18N
	        this.inputField = this._maxHt = this._opened = undefined;
	        if (!this._showSearchField && options.inputField) {
	            this.inputField = $(options.inputField);
	            this._bindInputFieldEvents();
	        }
	        this._searchable = options.showSearchField || options.inputField;
	        if (options.forElement) {
	            options.forElement = $(options.forElement);
	        }
	        this._setContentProps(options.contentType);
	    }
	    _setContentProps(contentType) {
	        if (!/^(image-text|image-text-desc|text-desc|text|custom|image)$/.test(contentType) || (contentType === 'image' && this._dataMapping.image)) { // No I18N
	            contentType = 'text'; // No I18N
	        }
	        // Validating the list content type
	        this._isCustom = contentType.indexOf('custom') > -1; // No I18N
	        this._hasImage = this._hasIcon = this._hasContentTag = false;
	        if (!this._isCustom) {
	            this._hasText = contentType.indexOf('text') > -1; // No I18N
	            this._hasDesc = this._hasContentTag = contentType.indexOf('desc') > -1; // No I18N
	            if (contentType.indexOf('image') > -1) { // No I18N
	                this._hasContentTag = this._hasText;
	                this._hasIcon = !(this._hasImage = this._dataMapping.image);
	            }
	        }
	    }
	    _setNoResults(inSufficientQuery) {
	        if (inSufficientQuery) {
	            this._inSufficentQuery = true;
	        } else {
	            this._noResults = true;
	            if (this._opts.search.showNoResultsMessage) {
	                return this._addNoResults();
	            }
	        }
	        if (this._opts.showSearchField) {
	            this._hideAllItems();
	        } else {
	            this._hideSuggestions();
	            return false;
	        }
	    }
	    // Menu creation
	    _createMenu(menuJSON) {
	        if (!this._menu) {
	            $('#' + this._opts.id).remove(); // No I18N
	            this._menu = $(ZC.createMenu(this._opts.id, menuJSON || [], this._getMenuSettings()));
	            this._menuBody = $(this._menu[0].querySelector('.' + this.CLASSES.menubody)); // No I18N
	            this._menuInstance = ZC.menu(this._menu);
	            if (this._showSearchField) {
	                this._storeSearchBox();
	            }
	            this._bindMenuEvents();
	            this._trigger('menucreation', undefined, {// No I18N
	                menu: this._menu,
	                instance: this._menuInstance
	            });
	        }
	    }
	    _getMenuSettings() {
	        // Revisit
	        let customAttributes = this._opts.customAttributes || {};
	        customAttributes.role = 'listbox'; // No I18N
	        let menuSettings = {
	            allowReplace: true,
	            scroll: 'default', // No I18N
	            className: this._getClass(),
	            contentType: this._isCheckBoxType ? 'icon-text' : (this._hasIcon ? (this._hasText ? 'icon-text' : 'text') : 'text'), // No I18N
	            // beforeshow: this._onBeforeShow.bind(this),
	            customAttributes,
	            templateData: {
	                searchBox: null,
	                loader: null
	            },
	            handleAccessKeyNavigation: this._searchable ? false : this._opts.handleAccessKeyNavigation,
	            templateFunc: 'listChildren' // No I18N
	        };
	        // Direct options
	        [ 'forElement', // No I18N
	            'isCE', // No I18N
	            'rtl', // No I18N
	            'positionAlterable', // No I18N
	            'direction', // No I18N
	            'appendTo', // No I18N
	            'viewport', // No I18N
	            'animation', // No I18N
	            'height', // No I18N
	            'width' ].forEach((key) => menuSettings[key] = this._opts[key]);
	        // Events
	        [ 'BeforeFocus', // No I18N
	            'ItemClick', // No I18N
	            'ItemHover', // No I18N
	            'Show', // No I18N
	            'BeforeHide', // No I18N
	            'Hide', // No I18N
	            'ItemChecked', // No I18N
	            'BeforeItemChecked' ]// No I18N
	            .forEach((event) => {
	                let Levent = event.toLowerCase();
	                menuSettings[Levent] = this['_on' + event].bind(this, Levent)// No I18N
	            });
	        if (this._loading) {
	            this._includeLoaderData(menuSettings.templateData);
	        }
	        if (this._showSearchField) {
	            this._addSearchBox(menuSettings);
	        }
	        return menuSettings;
	    }
	    _onItemChecked() {
	        this._trigger(...arguments);
	    }
	    _onBeforeItemChecked() {
	        this._trigger(...arguments);
	    }
	    _onBeforeFocus(eventName, orgEvent) {
	        if (this.inputField) {
	            return orgEvent.preventDefault();
	        }
	        this._trigger(...arguments);
	    }
	    _hideEle(element) {
	        element.addClass('zh-dnone'); // No I18N
	    }
	    _showEle(element) {
	        element.removeClass('zh-dnone'); // No I18N
	    }
	    // Method to create datasource instance
	    _initDS() {
	        let options = this._opts;
	        this._menuLoaded = this._ajaxSource = this._highlighted = this._moreResultsData = false;
	        this._headerJSON = [];
	        this._footerJSON = [];
	        this._groupHeads = [];
	        let headerItems = options.headerItems;
	        let footerItems = options.footerItems;
	        if ((headerItems && headerItems.length) || (footerItems && footerItems.length)) {
	            this._setHeaderFooterItems(headerItems, footerItems);
	        }
	        let dataSource = options.dataSource;
	        let data = options.data;
	        this._dsInit = false;
	        if (dataSource && dataSource.URL || (data && data.length)) {
	            this._dsInit = true;
	            this.params = {};
	            let dataSourceSettings = {
	                callbacks: {}
	            };
	            if (dataSource && dataSource.URL) {
	                this._ajaxSource = true;
	                this._bindAjaxEvents(dataSourceSettings.callbacks);
	            } else if (options.dataStructure === 'nested') { // No I18N
	                this._isGrouped = true;
	                data = this._flattenData(data);
	                this._dataMapping.groupLabel = 'groupLabel'; // No I18N
	            }
	            dataSourceSettings.dataSource = dataSource;
	            dataSourceSettings.data = data;
	            this._virtualization = false;
	            if (options.filterByCSSSelector && !this._ajaxSource) {
	                this._lazyLoadData = false;
	                this._styleBasedFilter = true;
	                this._filterFn = this._filterListViaStyles;
	            } else {
	                this._lazyLoadData = options.lazyLoading;
	                if (options.virtualization) {
	                    this._virtualization = this._lazyLoadData = true;
	                }
	                this._styleBasedFilter = false;
	                this._filterFn = this._filterByAddRemoval;
	            }
	            dataSourceSettings.filter = options.search;
	            [ 'sort', // No I18N
	                'sortBy', // No I18N
	                'sortOrder', // No I18N
	                'customSorter', // No I18N
	                'serverSearch', // No I18N
	                'customSorter', // No I18N
	                'dataMapping', // No I18N
	                'isResponseFiltered', // No I18N
	                'cacheData', // No I18N
	                'customSearch' ] // No I18N
	                .forEach((key) => {
	                    dataSourceSettings[key] = options[key];
	                });
	            let viewPerPage = options.viewPerPage;
	            dataSourceSettings.maxResults = this._lazyLoadData ? (this._isNotNull(viewPerPage) ? viewPerPage : 10) : 0;
	            dataSourceSettings.searchIncrementsInCache = options.search.searchIncrementsInCache;
	            this.DSInstance = new ZC.ZDatasourceHandler(null, dataSourceSettings);
	        }
	    }
	    // Menu Object created from the datasource record using data mapping.
	    getMenuData(data, groupID, itemgroup) {
	        /* style & title would be passed in custom atributes */
	        let mData = {};
	        mData.id = this._getItemId(data);
	        mData.name = groupID;
	        mData.itemType = itemgroup ? 'itemgroup' : 'custom'; // No I18N
	        mData.selectable = !itemgroup;
	        mData.originalData = data;
	        mData.custom = true;
	        if (typeof data === 'object') { // No I18N
	            [ 'className', 'hidden', 'disabled', 'customAttributes', 'isHeader', 'isFooter' ].forEach((key) => { // No I18N
	                mData[key] = data[key];
	            });
	            if (data.separator) {
	                mData.itemType = 'separator'; // No I18N
	                mData.selectable = false;
	            }
	            let dataMapping = this._dataMapping;
	            if (data.isHeader || data.isFooter) {
	                if (!data.separator) {
	                    mData.innerHTML = data.innerHTML || this._mapJSONToData(data, dataMapping.label, true);
	                    mData.clickable = true;
	                }
	                mData.selectable = false;
	            } else if (!data.separator) {
	                let addToMenuData = (key, dataKeyLabel) => {
	                    mData[key] = dataKeyLabel && this._mapJSONToData(data, dataKeyLabel, true);
	                }
	                [ 'label', 'image', 'iconClassName', 'SVGIconId', 'textIcon' ].forEach((key) => { // No I18N
	                    addToMenuData(key, dataMapping[key]);
	                });
	                addToMenuData('description', dataMapping.informativeText);// No I18N
	            }
	        } else {
	            mData.label = this._encodeContent(data);
	            data = {
	                label: data
	            };
	        }
	        if (itemgroup) {
	            mData.label = this._highlight(mData.label, this._dataMapping.groupLabel);
	        }
	        if (mData.selectable) {
	            if (this._isCheckBoxType) {
	                mData.itemType = 'checkbox'; // No I18N
	                mData.custom = true;
	            }
	            mData.innerHTML = this._getMenuItemTemplate(mData, data);
	            mData.iconClassName = mData.SVGIconId = mData.description = ''; // No I18N
	            let attrs = mData.customAttributes = mData.customAttributes || {};
	            attrs['data-label'] = mData.label; // No I18N
	            if (data.value) {
	                attrs['data-value'] = data.value; // No I18N
	            }
	            if (this._styleBasedFilter && this._searchable) {
	                this._getAttrForCSSFilter(data, attrs);
	            }
	        }
	        mData.normalisedData = data;
	        return mData;
	    }
	    // Filter results using css style tag
	    _openList(orgEvent, applyFilterStyle) {
	        // Menu is populated only once
	        if (this._menuLoaded) {
	            this._callMenuShow(orgEvent);
	        } else {
	            // this._groupsIncluded = [];
	            this._noResults = false;
	            let query = this.params.query;
	            this.params.query = ''; // No I18N
	            this._loadDataSource((dataSource) => {
	                let eventData = {
	                    results: dataSource,
	                    params: this.params
	                };
	                this.params.query = query;
	                this._trigger('beforelistupdate', orgEvent, eventData); // No I18N
	                eventData.addedMenuItems = this._replaceMenuItems(this._getMenuJSON(dataSource));
	                applyFilterStyle && this._applyFilterStyles();
	                this._afterFilter(orgEvent, eventData);
	                this._menuLoaded = true;
	            });
	        }
	    }
	    // This is called only on new page creation
	    _afterFilter(orgEvent, eventData, lazyLoaded) {
	        let options = this._opts;
	        let addedMenuItems = eventData && eventData.addedMenuItems;
	        if (!lazyLoaded) {
	            if (this._styleBasedFilter ? this.getFirstItem() : (addedMenuItems && addedMenuItems.length)) {
	                if (this._styleBasedFilter) {
	                    options.search.showNoResultsMessage && this._removeNoResults();
	                    options.search.moreResultsAction && this._showMoreResults();
	                }
	            } else if (this._trigger('noresults', orgEvent, { // No I18N
	                query: this.params.query
	            })) {
	                if (this._setNoResults() === false) {
	                    return;
	                }
	            }
	            this._callMenuShow(orgEvent);
	        }
	        if (options.search.highlightKeyword) {
	            this._highlightInList(eventData);
	        }
	        if (!this._noResults && this._lazyLoadData) {
	            if (this._hasImage || (this._hasIcon && this._isCheckBoxType)) {
	                let totalImgWidth = this._totalImgWidth;
	                if (this._freshRequest) {
	                    let firstItem = this.getFirstItem();
	                    totalImgWidth = 0;
	                    firstItem = $(firstItem);
	                    let avatar = firstItem.find('.zsuggestfield__avatar'); // No I18N
	                    let icons = firstItem.find('.zmenu__iconcontainer'); // No I18N
	                    if (avatar.length) {
	                        totalImgWidth = avatar.outerWidth(true);
	                    }
	                    if (icons.length) {
	                        if (icons.length === 1) {
	                            totalImgWidth += icons.outerWidth(true);
	                        } else {
	                            icons.toArray().forEach((icon) => totalImgWidth += $(icon).outerWidth(true));
	                        }
	                    }
	                    this._totalImgWidth = totalImgWidth;
	                }
	                if (!this._freshRequest && totalImgWidth) {
	                    addedMenuItems.forEach((item) => $(item).find('.zmenu__content').css('width', `calc(100% - ${String(totalImgWidth)}px)`)); // No I18N
	                }
	            }
	            // Setting the width of items alters the scrollTop and hence scrollTop is set after all the operations.
	            if (lazyLoaded) {
	                this._afterLazyLoad();
	            }
	        }
	        this._trigger('listupdate', orgEvent, eventData); // No I18N
	    }
	    // Method to get the display messages
	    _getMsg(key) {
	        let options = this._opts;
	        let instance = this.componentInstance;
	        return instance ? instance._getI18NText(key) : options.messages[key];
	    }
	    // Menu class need to be provided since the items are generated and given as custom content to the menu.
	    _getClass() {
	        let classToBeAdded = this._opts.className || ''; // No I18
	        let classes = this.CLASSES;
	        let addClass = (newClass) => {
	            classToBeAdded += ' ' + newClass; // No I18N
	        };
	        if (!this._isCustom) {
	            if (this._hasIcon) {
	                if (this._hasText) {
	                    addClass((this._hasDesc ? classes.iconhint : classes.icon));
	                } else {
	                    addClass(classes.icononly);
	                }
	            } else if (this._hasImage) {
	                addClass(classes.suggestfield);
	                if (this._hasDesc) {
	                    addClass(classes.withhint);
	                }
	            } else if (this._isCheckBoxType) {
	                addClass(classes.icontext);
	            }
	        }
	        if (this._loading) {
	            addClass(classes.loadingmenu);
	        }
	        return classToBeAdded;
	    }
	    // To generate custom content for a menu item
	    _getMenuItemTemplate(mData, originalData) {
	        let iconDOMStr = '', // No I18N
	            textDOMStr = '', // No I18N
	            descDOMStr = ''; // No I18N
	        let classes = this.CLASSES;
	        if (this._isCustom) {
	            return this._getCustomContent(mData.originalData, originalData.zinnerHTML || originalData.innerHTML || this._opts.template, true);
	        }
	        if (this._hasIcon || this._hasImage) {
	            iconDOMStr = this._getIconHTML(mData);
	        }
	        if (this._hasText) {
	            textDOMStr = '<span class="' + classes.text + '">' + this._highlight(mData.label, this._dataMapping.label) + '</span>'; // No I18N
	        }
	        if (this._hasDesc) {
	            descDOMStr = '<span class="' + classes.hint + '">' + (this._highlight(mData.description, this._dataMapping.informativeText) || '') + '</span>'; // No I18N
	        }
	        return iconDOMStr + (this._hasContentTag ? '<div class="zmenu__content">' + (textDOMStr + descDOMStr) + '</div>' : textDOMStr); // No I18N
	    }
	    _highlight(content, key) {
	        if (content) {
	            if (this.params.query && this._opts.search.highlightKeyword) {
	                content = this._highlightValidKey(content, key);
	            }
	        }
	        return content;
	    }
	    // Method to get the first visible menu item
	    getFirstItem(selector) {
	        selector = `.${this.CLASSES.menuitem}:not(#${this._getID('noresults')}):not([item-type=itemgroup]):not([hidden])${selector || ''}`; // No I18N
	        return [ ...this._menuBody[0].children ].find((item) => {
	            let $item = $(item);
	            return $item.is(selector) && (!this._styleBasedFilter || $item.css('display') !== 'none')// No I18N
	        });
	    }
	    getFirstValidItem() {
	        return this.getFirstItem(':not(.is-disabled)'); // No I18N
	    }
	    // Method to handle item hover
	    _onItemHover(eventName, orgEvent, menuEventData) {
	        menuEventData = this._getEventData(orgEvent, menuEventData);
	        if (menuEventData.unhoverable) {
	            orgEvent.preventDefault();
	        } else {
	            let eventData = this._getItemEventData(menuEventData);
	            let originalEvent = orgEvent && orgEvent.detail.originalEvent;
	            if (originalEvent && originalEvent.type === 'keydown') { // No I18N
	                eventData.keyEvent = this._scrolledOnKeyDown = true;
	                if (this._opts.inputFieldSettings.autoFill) {
	                    this._autoFilled = true;
	                    this._setInputValue(menuEventData);
	                }
	            }
	            this._trigger(eventName, orgEvent, eventData); // No I18N
	        }
	    }
	    // // Method to handle before show
	    // _onBeforeShow(orgEvent, eventData) {
	    //     this._trigger('beforeshow', orgEvent, eventData); // No I18N
	    // }
	    // Method to handle show
	    _onShow() {
	        if(this._opened){
	            this._preventMouseUpSelection = false;
	        }else{
	            this._preventMouseUpSelection = true;
	        }
	        let options = this._opts;
	        this._opened = true;
	        let itemToBeHovered;
	        if (!this._noResults) {
	            if (options.search.focusFirstResult) {
	                itemToBeHovered = this.getFirstValidItem();
	            }
	            this._bindMenuBodyEvents();
	            if (this._freshRequest && this._lazyLoadData && (this.params.totalPages > this.params.pageIndex || this.params.moreServerPages)) {
	                this._bindScroll();
	                if (this._virtualization) {
	                    this._calcItemHts();
	                }
	            }
	        }
	        if (options.showSearchField) {
	            this._updateSearchBoxOnMenuShow();
	            this.focusInputField();
	        }
	        this._menu.off('keydown.zmenu keydown.znavigatable') // No I18N
	        this.hoverMenuItem(itemToBeHovered);
	        this._setExpandAttr();
	        this._trigger(...arguments); // No I18N
	    }
	    hoverMenuItem(itemToBeHovered) {
	        if (!this._loading) {
	            this._menuInstance.hoverMenuItem(itemToBeHovered);
	            // It gives incorrect scrolltop as scrolltop needs some time to get updated.
	            // this._lastScrollTop = this._menuBody[0].scrollTop;
	        }
	    }
	    _bindMenuEvents() {
	        this._addEvents({
	            menuKeyDown: 'keydown', // No I18N
	            menuFocus: 'focusin', // No I18N
	            menuMouseMove: 'mousemove' // No I18N
	        }, this._menu);
	    }
	    _menuMouseMoveHandler() {
	        this._preventMouseUpSelection = false;
	    }
	    _bindMenuBodyEvents() {
	        this._addEvents({
	            scroll: 'scroll' // No I18N
	        }, this._menuBody);
	    }
	    _scrollHandler(orgEvent) {
	        if (this._considerScrollForLazyLoad) {
	            this._scrollHandlerToLoadPage(orgEvent);
	        } else {
	            this._lastScrollTop = this._menuBody[0].scrollTop;
	        }
	    }
	    _menuFocusHandler() {
	        this.focusInputField();
	    }
	    focusInputField() {
	        let inputField = this.inputField;
	        if (inputField && this._opts.inputFieldSettings.handleEvents && document.activeElement !== inputField[0]) {
	            inputField[0].focus();
	        }
	    }
	    _handleKeyCode(orgEvent) {
	        return this._menuInstance.handleKeyCode(orgEvent);
	    }
	    _onEnterKeyPress(orgEvent) {
	        if (this._showSearchField && this._noResults) {
	            return;
	        }
	        let hovered = this._getHovered();
	        if (hovered.length) {
	            return this._handleKeyCode(orgEvent);
	        }
	        this.closeDropdownList(orgEvent);
	    }
	    _getHovered() {
	        return this._menu.find('.on-hover'); // No I18N
	    }
	    _onEscKeyPress(orgEvent) {
	        // In Firefox, pressing ESC shows old value bug --> https://bugzilla.mozilla.org/show_bug.cgi?id=524360 and the event is prevented.
	        orgEvent.preventDefault();
	        this._trigger('esckeypress', orgEvent); // No I18N
	        return this._handleKeyCode(orgEvent);
	    }
	    _upDownKeyPress(orgEvent) {
	        if (!this._lazyLoadData || !$(this._menuBody[0][orgEvent.keyCode === ZC.keyCode.UP ? 'firstElementChild' : 'lastElementChild']).hasClass('on-hover')) { // No I18N
	            return this._handleKeyCode(orgEvent);
	        }
	        orgEvent.preventDefault();
	    }
	    _menuKeyDownHandler(orgEvent) {
	        let ZkeyCode = ZC.keyCode;
	        let code = orgEvent.keyCode;
	        if (code === ZkeyCode.ESCAPE) {
	            return this._onEscKeyPress(orgEvent);
	        }
	        if (!this._loader) {
	            switch (code) {
	                case ZkeyCode.DOWN:
	                case ZkeyCode.UP:
	                    return this._upDownKeyPress(orgEvent);
	                case ZkeyCode.PAGE_DOWN:
	                case ZkeyCode.PAGE_UP:
	                    return this._handleKeyCode(orgEvent);
	                case ZkeyCode.ENTER:
	                    return this._onEnterKeyPress(orgEvent);
	                case ZkeyCode.SPACE:
	                    if (!this.inputField) {
	                        this._onEnterKeyPress(orgEvent);
	                    }
	                    break;
	                case ZkeyCode.TAB:
	                    this.closeDropdownList(orgEvent);
	                    orgEvent.preventDefault();
	                    return;
	                default:
	                    return this._handleKeyCode(orgEvent);
	            }
	        }
	    }
	    // Method to handle item click
	    _onItemClick(eventName, orgEvent, menuEventData) {
	        var originalEvent = orgEvent.originalEvent;
	        if(originalEvent && originalEvent.isTrigger !== true){
	            if (originalEvent.originalEvent){
	                originalEvent = originalEvent.originalEvent;
	            }
	            if (originalEvent.type === 'mouseup' && originalEvent.isTrigger !== true && originalEvent.isTrusted !== false) { // No I18N
	                if(this._preventMouseUpSelection){
	                    this._preventMouseUpSelection = false;
	                    if(!originalEvent.isTrigger){
	                        orgEvent.preventDefault();
	                        return;
	                    }
	                }
	            }
	        }
	        menuEventData = this._getEventData(orgEvent, menuEventData);
	        if (menuEventData.noresults) {
	            orgEvent.preventDefault();
	            return
	        }
	        if (menuEventData.selectable || menuEventData.clickable) {
	            this._setInputValue && this._setInputValue(menuEventData);
	        } else if (menuEventData.moreresults) {
	            let moreResultsAction = this._opts.search.moreResultsAction;
	            if (typeof moreResultsAction === 'function') { // No I18N
	                moreResultsAction();
	            }
	            this._trigger('moreactionclick', orgEvent, this._getItemEventData(menuEventData));// No I18N
	        } else {
	            return;
	        }
	        return this._trigger(eventName, orgEvent, this._getItemEventData(menuEventData));
	    }
	    _getItemEventData(menuEventData) {
	        return {
	            data: menuEventData.originalData,
	            listItem: menuEventData.menuitem,
	            listItemData: menuEventData.data
	        }
	    }
	    // Method to get the event detail
	    _getEventData(orgEvent, eventData) {
	        return eventData || (orgEvent && typeof orgEvent.detail === 'object' ? orgEvent.detail : undefined); // No I18N
	    }
	    // Method to handle menu hide
	    _onHide() {
	        this._opened = false;
	        this._cachedData = undefined;
	        if (this._showSearchField) {
	            this.inputField.val(''); // No I18N
	        }
	        this._setExpandAttr();
	        this._removeStyle();
	        this._trigger(...arguments); // No I18N
	    }
	    _setExpandAttr() {
	        if (this._opts.forElement) {
	            this._opts.forElement.attr('aria-expanded', this._opened); // No I18N
	        }
	    }
	    // Method to handle before hide
	    _onBeforeHide() {
	        return this._trigger(...arguments); // No I18N
	    }
	    // Method to hide suggestions
	    _hideSuggestions(orgEvent) {
	        if (this._menu && this._opened) {
	            this._menuInstance.hide(undefined, orgEvent);
	        }
	    }
	    // Method to call callback functions
	    _trigger(customEvent, orgEvent, eventData) {
	        let callback = this._opts.callbacks[customEvent];
	        let response;
	        if (typeof callback === 'function') { // No I18N
	            response = callback(orgEvent, this._getEventData(orgEvent, eventData));
	        }
	        return response === undefined ? !(orgEvent && orgEvent.isDefaultPrevented()) : response;
	    }
	    _getMenuJSON(dataSource) {
	        if (this._isGrouped) {
	            return this._getMenuJSONForGroupedData(dataSource);
	        }
	        return dataSource.map((data) => this.getMenuData(data));
	    }
	    _addMenuItems(menuJSON) {
	        if (this._menu) {
	            return this._menuInstance.addMenuItems(menuJSON, null, !this._freshRequest);
	        }
	        this._createMenu(menuJSON);
	        return [ ...this._menuBody[0].children ];
	    }
	    _replaceMenuItems(menuJSON) {
	        menuJSON = {
	            header: this._headerJSON,
	            body: menuJSON,
	            footer: this._footerJSON
	        }
	        this._opts.search.moreResultsAction && this._setMoreResults();
	        if (this._menu) {
	            return this._menuInstance.replaceMenuItems(menuJSON, null, !this._freshRequest);
	        }
	        this._createMenu(menuJSON);
	        return [ ...this._menuBody[0].children ];
	    }
	    _getID(key) {
	        return 'z' + this._opts.id + '-' + key; // No I18N
	    }
	    _loadDataSource(callback, results = []) {
	        if (this._dsInit) {
	            // Incase of static data, data is fetched only once
	            this.DSInstance
	                .fetch(this.params, (data) => {
	                    this.params = data;
	                    results = results.concat(data.results);
	                    if (data.moreServerPages && this._lazyLoadData && results.length < this._opts.viewPerPage) {
	                        this._getNextPage(callback, undefined, results);
	                    } else {
	                        callback(results);
	                    }
	                });
	        } else {
	            callback([]);
	        }
	    }
	    _mapJSONToData(data, mapper) {
	        return super._mapJSONToData(data, mapper, true);
	    }
	    _getItemId(data) {
	        return super._getItemId(data, this._opts.id);
	    }
	    _callMenuShow(orgEvent) {
	        let options = this._opts;
	        let openOptions = {
	            event: orgEvent,
	            mustBeShown: true,
	            positionAlterable: options.positionAlterable,
	            forElement: options.forElement
	        }
	        let direction = options.direction;
	        let positionAlterable = options.positionAlterable;
	        if (direction === 'auto') { // No I18N
	            direction = 'bottom-left'; // No I18N
	        }
	        if (positionAlterable) {
	            openOptions.direction = direction;
	            openOptions.positionAlterable = positionAlterable;
	            this._alterPositionOptions(openOptions);
	        }
	        if (this._trigger('beforeshow', orgEvent, { // No I18N
	            openOptions
	        })) {
	            this._createMenu();
	            this._menuInstance.show(openOptions);
	        }
	    }
	    _alterPositionOptions(openOptions) {
	        if (!this._opened) {
	            this._maxHt = 0;
	        }
	        openOptions.callbacks = {
	            beforeComputingDir: {
	                dimensionModifier: (targetDim, elementDim, withinDim, options) => {
	                    if (elementDim.height > this._maxHt || !this._maxHt) {
	                        this._maxHt = elementDim.height;
	                    } else {
	                        options.positionAlterable = false;
	                        options.direction = this._menu.data('direction'); // No I18N
	                    }
	                }
	            }
	        }
	    }
	    openDropdownList(orgEvent) {
	        let options = this._opts;
	        if (this._searchable || this._lazyLoadData) {
	            let searchTerm;
	            if (!this._searchable || options.showSearchField || (options.showAllItemsOnDOWNKeyPress && !options.serverSearch)) {
	                searchTerm = ''; // No I18N
	            }
	            this.search(searchTerm, orgEvent, !options.showSearchField); // No I18N
	        } else {
	            this._openList(orgEvent);
	        }
	    }
	    closeDropdownList(orgEvent) {
	        this._hideSuggestions(orgEvent);
	    }
	    _destroyDSIns() {
	        if (this.DSInstance) {
	            this.DSInstance.destroy();
	        }
	    }
	    _removeStyle() {
	        if (this.styletag) {
	            this.styletag.remove();
	            this.styletag = undefined;
	        }
	    }
	    refresh() {
	        let query = this.params && this.params.query;
	        let reopen = this._opened;
	        this._highlightData = undefined;
	        this._detachEvents();
	        this._removeStyle();
	        this._destroyDSIns();
	        this._create();
	        if (this._menu) {
	            this._menuInstance.setAttributes(this._getMenuSettings());
	            if (this._showSearchField) {
	                this._storeSearchBox();
	            }
	            if (reopen) {
	                if (query) {
	                    this.search(query);
	                } else {
	                    this.openDropdownList();
	                }
	                this._setScrollTop();
	            }
	        }
	    }
	    _setScrollTop() {
	        this._menuBody[0].scrollTop = this._lastScrollTop;
	    }
	    _getText(feature) {
	        let innerText = ZC.encodeHTML(this._getMsg(feature)).replace(/#query#/g, '<b class="h-bold">' + this.params.query + '</b>') // No I18N
	        return '<span class=' + this.CLASSES.text + '>' + innerText + '</span>'; // No I18N
	    }
	    _setAttribute(optionName, value) {
	        this._opts[optionName] = value;
	    }
	    setAttributes(optionName, value) {
	        super.setAttributes(optionName, value);
	        this.refresh();
	    }
	    _detachEvents() {
	        if (this.inputField) {
	            this._removeEvents('', this.inputField); // No I18N
	        }
	        if (this._menuBody) {
	            this._removeEvents('', this._menuBody); // No I18N
	        }
	    }
	    clearCache() {
	        this.refresh();
	    }
	    destroy() {
	        clearTimeout(this._searchTimer);
	        this._detachEvents();
	        this._destroyDSIns();
	        this._removeStyle();
	        this.componentInstance = undefined;
	        if (this._menu) {
	            if (!this._opts.isCE) {
	                ZC.menu(this._menu).destroy();
	            }
	            this._menu.remove();
	        }
	    }
	    positionList() {
	        this._callMenuShow();
	        this._setScrollTop();
	    }
		_includeLoader  () {
		    if (this._menuInstance) {
		        this._updateLoaderState(true);
		    } else {
		        this._loading = true;
		        this._createMenu();
		        this._callMenuShow();
		    }
		}
		_removeLoader  () {
		    this._updateLoaderState(false);
		}
		_updateLoaderState  (loader) {
		    if (loader !== this._loading) {
		        let menuInstance = this._menuInstance;
		        this._loading = loader;
		        let templateData = menuInstance.getAttribute('templateData'); // No I18N
		        if (loader) {
		            this._includeLoaderData(templateData);
		        } else {
		            templateData.loader = false;
		        }
		        menuInstance.setAttributes({
		            templateData: templateData,
		            [(this._opts.isCE ? 'z' : '') + 'className']: this._getClass() // No I18N
		        });
		    }
		    loader && !this._opened && this._callMenuShow();
		}
		_includeLoaderData  (templateData) {
		    let options = this._opts;
		    let loaderIconClassName = options.loaderIconClassName;
		    let loaderSVGIconId = options.loaderSVGIconId;
		    if (loaderIconClassName || loaderSVGIconId) {
		        templateData.loader = ZC._getIconInfo(loaderIconClassName, loaderSVGIconId, '#zc__svg--loader zmenu__svg zmenu__loader zeffects--rotate', 'zmenu__icon zh-loading', templateData.loader = {}); // No I18N
		    } else {
		        templateData.loader = templateData.defaultLoader = true;
		    }
		}
		_bindAjaxEvents  (callbacks) {
		    callbacks.requeststart = this._onReqStart.bind(this);
		    callbacks.requestend = this._onReqEnd.bind(this);
		    callbacks.requesterror = this._onReqErr.bind(this);
		}
		// Method to handle before ajax request starts
		_onReqStart  (eventData) {
		    this._includeLoader();
		    this._trigger('requeststart', null, eventData); // No I18N
		}
		// Method to handle when ajax reuwst ends
		_onReqEnd  (eventData) {
		    this._removeLoader();
		    this._trigger('requestend', null, eventData);// No I18N
		}
		// Method to handle when ajax request fails
		_onReqErr  (eventData) {
		    this._removeLoader();
		    this._replaceMenuItems([ {
		        innerHTML: this._getText('serverError'), // No I18N
		        itemType: 'custom', // No I18N
		        className: this.CLASSES.unselectable + ' zmenu__servererror', // No I18N
		        unhoverable: true
		    } ]);
		    this._trigger('requesterror', null, eventData);// No I18N
		    // console.log("ajaxreq error");
		}
		_filterByAddRemoval  (orgEvent) {
		    this._inSufficentQuery = false;
		    // Check with previous and open the previous menu incase query is the same.
		    if (this._menu && this.params.query === this.params.previousQuery && !this._virtualization && this._opts.cacheData) {
		        if (!this._opened) {
		            if (!this._noResults || this._opts.search.showNoResultsMessage) {
		                this._trigger('beforelistupdate'); // No I18N
		                this._callMenuShow();
		                this._setScrollTop();
		                this._trigger('listupdate'); // No I18N
		            }
		        }
		        return;
		    }
		    // Initialisation related to virtualisation
		    this._freshRequest = true;
		    this.params.pageIndex = 1;
		    this._noResults = null;
		    this._lastScrollTop = 0;
		    this._scroll = {};
		    this._groupsIncluded = [];
		    if (this.DSInstance._serverPaging) {
		        this.params.serverPageIndex = 0;
		        this.params.moreServerPages = true;
		    }
		    this._unbindScroll && this._unbindScroll();
		    if (this._virtualization) {
		        this._showVirtualData(orgEvent);
		    } else {
		        this._loadDataSource((filteredData) => this._addDataToMenu(filteredData, orgEvent));
		    }
		}
		_addDataToMenu  (filteredData, orgEvent) {
		    let eventData = {
		        results: filteredData,
		        params: this.params
		    };
		    this._trigger('beforelistupdate', orgEvent, eventData); // No I18N
		    filteredData = eventData.results;
		    if (filteredData.length) {
		        eventData.addedMenuItems = this[this._freshRequest ? '_replaceMenuItems' : '_addMenuItems'](this._getMenuJSON(filteredData)); // No I18N
		    }
		    this._afterFilter(orgEvent, eventData, !this._freshRequest);
		}
		_filterListViaStyles  (orgEvent) {
		    this._noResults = this._inSufficentQuery = false;
		    if (this._menuLoaded) {
		        this._trigger('beforelistupdate', orgEvent); // No I18N
		        this._applyFilterStyles();
		        this._afterFilter(orgEvent);
		    } else {
		        this._openList(orgEvent, true);
		    }
		}
		/* Function to inject styles for filtering */
		_applyFilterStyles  () {
		    let query = this.params.query;
		    if (query.length) {
		        let search = this._opts.search || {};
		        if (!search.caseSensitive) {
		            query = query.toLowerCase();
		        }
		        let operator = search.criteria === 'startswith' ? '^' : '*'; // No I18N
		        let styles = `#${this._opts.id} .${this.CLASSES.menubody} > *:not(.${this.CLASSES.title})${this._getSearchBy(this._opts.search.by).map((by) => `:not([data-${by}${operator}="${this._escapeQuery(query)}"])`).join('')}:not(#${this._getID('noresults')}) {display:none !important;}`; // No I18N
		        this._injectStyle(styles);
		        if (this._isGrouped) {
		            if (!this._opened) {
		                this._menu.show();
		            }
		            let groupIDsToHide = this._groupsIncluded.filter((groupId) => !this.getFirstItem('[name=' + groupId + ']')); // No I18N
		            if (groupIDsToHide.length) {
		                styles += ('#' + groupIDsToHide.join(',#') + '{display:none; !important}'); // No I18N
		            }
		            if (!this._opened) {
		                this._menu.hide();
		            }
		            this._injectStyle(styles);
		        }
		    } else {
		        this._removeStyle();
		    }
		}
		_getAttrForCSSFilter  (data, attrs) {
		    let searchBy = this._getSearchBy(this._opts.search.by);
		    searchBy.forEach((by) => {
		        let value = data[by];
		        if (this._isNotNull(value)) {
		            attrs['data-' + by] = this._opts.search.caseSensitive ? value : value.toLowerCase(); // No I18N
		        }
		    });
		}
		_injectStyle  (styles) {
		    if (!this.styletag) {
		        this.styletag = $('<style id=' + this._getID('style') + '>').appendTo($('head')); // No I18N
		    }
		    this.styletag.text(styles);
		}
		_hideItemsUsingCSS  () {
		    this._injectStyle(`#${this._opts.id} .${this.CLASSES.menubody} .${this.CLASSES.menuitem} {display:none; !important}`); // No I18N
		}
		// Method to convert grouped datas to flat datas
		_flattenData  (dataSource, groupData) {
		    let newDS = [];
		    let subGroupLabel = this._dataMapping.options;
		    dataSource.forEach((data) => {
		        let subOptions = data[subGroupLabel];
		        if (subOptions) {
		            this._groupHeads.push(data);
		            newDS = newDS.concat(this._flattenData(subOptions, data));
		        } else {
		            if (groupData) {
		                data.groupLabel = this._mapJSONToData(groupData, this._dataMapping.groupLabel);
		                data.hidden = data.hidden || groupData.hidden;
		                data.disabled = data.disabled || groupData.disabled;
		            }
		            newDS.push(data);
		        }
		    });
		    return newDS;
		}
		_getMenuJSONForGroupedData  (dataSource) {
		    let menuJSON = [];
		    dataSource.forEach((data) => {
		        let groupLabel = this._mapJSONToData(data, this._dataMapping.groupLabel);
		        let groupID;
		        let groupData = groupLabel = this._isNotNull(groupLabel) ? groupLabel : ''; // No I18N
		        if (this._isGrouped && this._groupHeads.length) {
		            groupData = this._groupHeads.find((data) => groupLabel === this._mapJSONToData(data, this._dataMapping.label)) || ''; // No I18N
		        }
		        groupData = this.getMenuData(groupData, null, true);
		        groupID = groupData.id;
		        if (groupData && this._groupsIncluded.indexOf(groupID) === -1) {
		            menuJSON.push(groupData);
		            this._groupsIncluded.push(groupID);
		        }
		        menuJSON.push(this.getMenuData(data, groupID));
		    });
		    return menuJSON;
		}
		_setHeaderFooterItems  (headerItems, footerItems) {
		    if (headerItems) {
		        this._headerJSON = headerItems.map((data) => this.getMenuData(data));
		    }
		    if (footerItems) {
		        this._footerJSON = footerItems.map((data) => this.getMenuData(data));
		    }
		}
		_getHighlightData  (query) {
		    let search = this._opts.search;
		    if (!this._highlightData) {
		        let searchBy = this._getSearchBy(search.by);
		        let includeText;
		        let includeTitle;
		        let includeDesc;
		        if (this.DSInstance._isJSONSource) {
		            let dataMapping = this._dataMapping;
		            let label = dataMapping.label;
		            let groupLabel = dataMapping.groupLabel;
		            let description = dataMapping.informativeText;
		            includeText = searchBy.indexOf(label) > -1;
		            includeTitle = searchBy.indexOf(groupLabel) > -1;
		            includeDesc = searchBy.indexOf(description) > -1;
		        }
		        this._highlightData = {
		            includeText,
		            includeTitle,
		            includeDesc
		        }
		    }
		    this._highlightData.pattern = this._getMatchingRegex(query, search);
		    return this._highlightData;
		}
		_highlightInList  (eventData) {
		    if (this._styleBasedFilter) {
		        let query = this.params.query;
		        if (!this._noResults && (query || this._highlighted)) {
		            this._highlighted = true;
		            let highlightData = this._getHighlightData(query);
		            let includeText = highlightData.includeText;
		            let includeTitle = highlightData.includeTitle;
		            let includeDesc = highlightData.includeDesc;
		            let addedMenuItems = (eventData && eventData.addedMenuItems) || [ ...this._menuBody[0].children ];
		            let classes = this.CLASSES;
		            let selector = ''; // No I18N
		            if (includeTitle || includeText) {
		                selector = ('.' + classes.text); // No I18N
		            }
		            if (includeDesc) {
		                selector += ((selector ? ',' : '') + '.' + classes.hint); // No I18N
		            }
		            if (selector) {
		                addedMenuItems.forEach((item) => {
		                    if (!this._styleBasedFilter || $(item).css('display') !== 'none') { // No I18N
		                        item = $(item);
		                        if (includeTitle || !item.is('.' + classes.title)) { // No I18N
		                            let elements = item.find(selector);
		                            for (let i = 0; i < elements.length; i++) {
		                                let innerHTML = elements[i].textContent;
		                                elements[i].innerHTML = query ? this._highlightContent(innerHTML, highlightData.pattern) : innerHTML;
		                            }
		                        }
		                    }
		                });
		            }
		        }
		    }
		}
		_highlightValidKey  (content, key) {
		    let search = this._opts.search;
		    let query = this.params.query;
		    let pattern = this._getMatchingRegex(query, search);
		    let searchBy = this._getSearchBy(search.by);
		    if (searchBy.indexOf(key) !== -1) {
		        return this._highlightContent(content, pattern);
		    }
		    return content;
		}
		_highlightContent  (content, pattern) {
		    return content.replace(pattern, "<b class='h-bold'>$1</b>"); // No I18N
		}
		_getIconHTML  (mData) {
		    if (this._hasIcon) {
		        let splits;
		        let SVGIconId = mData.SVGIconId;
		        let iconClassName = mData.iconClassName;
		        if (SVGIconId) {
		            splits = SVGIconId.split(' '); // No I18N
		            splits[0] = splits[0].trim().replace(/^#/, ''); // No I18N
		            iconClassName = undefined;
		        }
		        let iconHTML;
		        if (!iconClassName && !SVGIconId && mData.textIcon) {
		            iconHTML = `<i class="zmenu__icon zmenu__texticon">${mData.textIcon}</i>`;
		        } else {
		            iconHTML = `<i class="zmenu__icon ${iconClassName || ''}">${SVGIconId ? `<svg class="zmenu__svg ${splits[1] || ''}"><use xlink:href="#${splits[0]}"></use></svg>` : ''}</i>`;
		        }
		        return '<div class="zmenu__iconcontainer">' + iconHTML + '</div>'; // No I18N
		    }
		    return '<img src="' + mData.image + '" class="zsuggestfield__avatar">'; // No I18N
		}
		_bindInputFieldEvents  () {
		    if (this.inputField && this.inputField.length) {
		        let inputSettings = this._opts.inputFieldSettings;
		        if (inputSettings.handleEvents) {
		            let events = {
		                inputKeydown: 'keydown', // No I18N
		                paste: 'paste' // No I18N
		            }
		            if (inputSettings.filterBasedOnCurPos || inputSettings.suggestOnFocus) {
		                events.inputMousedown = 'mousedown'; // No I18N
		                events.inputMouseup = 'mouseup'; // No I18N
		                events.inputKeyup = 'keyup'; // No I18N
		            }
		            this._addEvents(events, this.inputField);
		            this.inputField.on((ZC.Browser.isIE ? 'keyup' : 'input') + '.' + this.name, this._inputHandler.bind(this)); // No I18N
		        }
		    }
		}
		_inputKeydownHandler  (orgEvent) {
		    if (ZC.Browser.isIE) {
		        clearTimeout(this._searchTimer);
		    }
		    let options = this._opts;
		    let code = orgEvent.keyCode;
		    let ZkeyCode = ZC.keyCode;
		    this._lastKeyCode = this._lastKeyCode ? undefined : code;
		    if (this._showSearchField) {
		        if (code === ZkeyCode.LEFT || code === ZkeyCode.RIGHT) {
		            orgEvent.stopPropagation();
		        }
		    } else if (this._noResults && code === ZkeyCode.ENTER) {
		        orgEvent.stopPropagation();
		        this._trigger('newvalue', orgEvent); // No I18N
		    } else if (code === ZkeyCode.TAB) {
		        this._opened && options.preventDefaultOnTabPress && orgEvent.preventDefault();
		        if (this._noResults) {
		            this._trigger('newvalue', orgEvent); // No I18N
		        } else if (this._opened) {
		            if (options.selectHoveredOnTabPress) {
		                let hovered = this._getHovered();
		                if (hovered.length) {
		                    this._menuInstance.selectHoveredMenuItem();
		                    return;
		                }
		            }
		            this.closeDropdownList(orgEvent);
		        }
		    } else if ((this._opened || code === ZkeyCode.ESCAPE) && code !== ZkeyCode.LEFT && code !== ZkeyCode.RIGHT) {
		        return this._menuKeyDownHandler(orgEvent);
		    } else if (code === ZkeyCode.DOWN || code === ZkeyCode.UP/* && !this._ajaxSource */) {
		        this.openDropdownList(orgEvent);
		    }
		}
		_inputHandler  (orgEvent) {
		    if (orgEvent.type === 'input' || this._isAlphaNumericKey(orgEvent)) { // No I18N
		        let value = orgEvent.target.value;
		        this._trigger('input', orgEvent); // No I18N
		        /* Value is passed here because the input content might vary when autoComplete is done in combobox */
		        this.searchWithDelay(value, orgEvent, this._opts.search.delay);
		    }
		}
		_inputKeyupHandler  (orgEvent) {
		    let ZkeyCode = ZC.keyCode;
		    let keyCode = orgEvent.keyCode;
		    let inputFieldSettings = this._opts.inputFieldSettings;
		    if (inputFieldSettings.suggestOnFocus && keyCode === ZkeyCode.TAB && keyCode !== this._lastKeyCode) {
		        this.searchWithDelay(undefined, orgEvent, 1);
		    } else if (inputFieldSettings.filterBasedOnCurPos && [ ZkeyCode.LEFT,
		        ZkeyCode.RIGHT,
		        ZkeyCode.HOME,
		        ZkeyCode.END ].indexOf(keyCode) > -1) {
		        this.searchWithDelay(undefined, orgEvent, 1, true);
		    }
		    this._lastKeyCode = undefined;
		}
		_inputMousedownHandler  (orgEvent) {
		    let inputField = this.inputField[0];
		    this._filteredOnMouseDown = false;
		    if (inputField.selectionStart === inputField.selectionEnd) {
		        this._filteredOnMouseDown = true;
		        this._searchBasedOnCurPos(orgEvent);
		    }
		}
		_searchBasedOnCurPos  (orgEvent, delay) {
		    if (!orgEvent.button) {
		        let inputFieldSettings = this._opts.inputFieldSettings;
		        let filterBasedOnCurPos = inputFieldSettings.filterBasedOnCurPos;
		        if (inputFieldSettings.suggestOnFocus || filterBasedOnCurPos) {
		            this.searchWithDelay(undefined, orgEvent, delay || this._opts.search.delay, filterBasedOnCurPos);
		        }
		    }
		}
		_inputMouseupHandler  (orgEvent) {
		    if (!this._filteredOnMouseDown) {
		        this._searchBasedOnCurPos(orgEvent);
		    }
		}
		_pasteHandler  (orgEvent) {
		    clearTimeout(this._searchTimer);
		    this._searchTimer = setTimeout(() => {
		        let value = orgEvent.target.value;
		        this._trigger('input', orgEvent); // No I18N
		        this.search(value, orgEvent);
		    });
		}
		// Method to set the inputfield value if given
		_setInputValue  (menuData) {
		    if (this.inputField && !this._showSearchField && menuData.selectable && this._opts.inputFieldSettings.updateOnSelect) {
		        this.inputField[0].value = this._mapJSONToData(menuData.normalisedData, this._dataMapping.label);
		    }
		}
		/* Function to bind scroll to menu */
		_bindScroll  () {
		    this._addEvents({
		        wheel: 'wheel DOMMouseScroll mousewheel' // No I18N
		    }, this._menuBody);
		    this._considerScrollForLazyLoad = true;
		}
		/* Function to unbind scroll for menu */
		_unbindScroll  () {
		    this._considerScrollForLazyLoad = false;
		}
		_wheelHandler  () {
		    this._scrolledOnKeyDown = false;
		}
		_scrollHandlerToLoadPage  (orgEvent) {
		    /* In the middle of ajax request, when another request is made, previous request is aborted which results in some page not getting loaded. Hence when there is an ongoing request, scrollhandler is not executed */
		    if (!this._loading) {
		        this._freshRequest = false;
		        let scrollTop = this._menuBody[0].scrollTop;
		        let isBackwards = this._lastScrollTop > scrollTop;
		        let menuHt = this._menuBody[0].offsetHeight;
		        let exceeded = !isBackwards && (scrollTop + menuHt + 20) > this._menuBody[0].scrollHeight;
		        this._scroll = {
		            isBackwards,
		            exceeded,
		            menuHt
		        }
		        this._lastScrollTop = scrollTop;
		        if (this._virtualization) {
		            this._showVirtualData(orgEvent);
		        } else if (exceeded) {
		            /*
		                Get Next page and load it to menu
		                If next page is not present. Scroll is unbinded.
		            */
		            this._getNextPage((filteredData) => this._addDataToMenu(filteredData, orgEvent), this._unbindScroll.bind(this));
		        }
		    }
		}
		_getNextPage  (successCallback, failureCallback, results) {
		    let params = this.params;
		    if (params.pageIndex < params.totalPages) {
		        params.pageIndex++;
		    } else if (params.moreServerPages) {
		        params.pageIndex = 1;
		        params.serverPageIndex++;
		        this._groupsIncluded = [];
		    } else {
		        failureCallback && failureCallback();
		        return;
		    }
		    this._loadDataSource(successCallback, results);
		}
		_afterLazyLoad  () {
		    this._setScrollTop();
		}
		_setMoreResults  () {
		    if (this._moreResultsData) {
		        this._footerJSON.pop();
		    }
		    this._moreResultsData = {
		        id: this._getID('moreresults'), // No I18N
		        className: 'zmenu__moreresults', // No I18N
		        itemType: 'custom', // No I18N
		        isFooter: true,
		        moreresults: true,
		        hidden: this._noResults,
		        innerHTML: this._getText('moreAction') // No I18N
		    };
		    if (!this._noResults || this._styleBasedFilter) {
		        this._footerJSON.push(this._moreResultsData);
		    }
		}
		_showMoreResults  (show = true) {
		    let moreResults = this._getMoreResults();
		    if (moreResults.length) {
		        let footer = moreResults.parent();
		        this[show ? '_showEle' : '_hideEle'](footer[0].children.length > 1 ? moreResults : footer); // No I18N
		    }
		}
		_getMoreResults  () {
		    return $('#' + this._getID('moreresults')); // No I18N
		}
		_hideMoreResults  () {
		    this._showMoreResults(false);
		}
		_addNoResults  () {
		    if (this._opts.search.moreResultsAction && this._styleBasedFilter) {
		        this._hideMoreResults();
		    }
		    let addMethodName = '_replaceMenuItems'; // No I18N
		    if (this._styleBasedFilter) {
		        this._removeNoResults();
		        addMethodName = '_addMenuItems'; // No I18N
		    }
		    let classes = this.CLASSES;
		    this[addMethodName]([ {
		        innerHTML: this._getText('noResults'), // No I18N
		        itemType: 'custom', // No I18N
		        id: this._getID('noresults'), // No I18N
		        className: classes.unselectable + ' zmenu__noresults', // No I18N
		        unhoverable: true,
		        noresults: true
		    } ]);
		}
		// Method to remove no results item
		_removeNoResults  () {
		    this._menu && this._menuInstance.removeMenuItem('#' + this._getID('noresults')); // No I18N
		}
		search  (query, orgEvent, showComplete) {
		    this._search(query, orgEvent, null, showComplete);
		}
		searchWithDelay  (query, orgEvent, delay, searchOnCurPos) {
		    clearTimeout(this._searchTimer);
		    if (delay) {
		        this._searchTimer = setTimeout(() => {
		            this._search(query, orgEvent, searchOnCurPos);
		        }, delay);
		    } else {
		        this._search(query, orgEvent, searchOnCurPos);
		    }
		}
		_search  (query, orgEvent, searchOnCurPos, showComplete) {
		    let options = this._opts;
		    let target = orgEvent && orgEvent.target;
		    let inputField = target && target.tagName === 'INPUT' ? target : (this.inputField && this.inputField[0]);
		    if (query === undefined) {
		        query = inputField ? inputField.value : ''; // No I18N
		    }
		    if (query && searchOnCurPos && inputField) {
		        let selectionStart = inputField.selectionStart;
		        let selectionEnd = inputField.selectionEnd;
		        if (selectionStart !== selectionEnd) {
		            selectionStart = query.length - 1;
		        }
		        query = query.substring(0, selectionStart);
		    }
		    this.params.previousQuery = this._inSufficentQuery ? undefined : this.params.query;
		    this.params.query = query;
		    if (this._trigger('beforesearch', orgEvent, {// No I18N
		        params: this.params
		    })) {
		        let minKeywordLength = options.search.minKeywordLength;
		        let inSufficientQuery = minKeywordLength && !showComplete && (query.length < minKeywordLength);
		        if (this._dsInit && query !== undefined && !inSufficientQuery) {
		            this._filterFn(orgEvent);
		        } else if (this._setNoResults(inSufficientQuery) !== false) {
		            if (this._styleBasedFilter && !this._menuLoaded) {
		                this._replaceMenuItems([]);
		            }
		            this._callMenuShow(orgEvent);
		        }
		    } else {
		        this.params.query = this.params.previousQuery;
		        this._hideSuggestions();
		    }
		}
		_addSearchBox  (menuSettings) {
		    let templateData = menuSettings.templateData;
		    templateData.searchBox = {
		        iconClassName: 'zmenu__icon', // No I18N
		        SVGIconId: '#zc__svg--search', // No I18N
		        SVGIconClassName: 'zmenu__svg' // No I18N
		    }
		    templateData.searchBoxId = this._getID('searchbox') // No I18N
		    menuSettings.handleAccessKeyNavigation = false;
		}
		_storeSearchBox  () {
		    this.inputField = $('#' + this._getID('searchbox')); // No I18N
		    this._bindInputFieldEvents();
		}
		_hideAllItems  () {
		    if (this._styleBasedFilter) {
		        this._hideItemsUsingCSS();
		    } else {
		        this._replaceMenuItems([]);
		    }
		}
		// Revisit Aish -- Posibility needs to be checked whether dynamic serachbox positioning could be done in template
		_updateSearchBoxOnMenuShow  () {
		    this.inputField.val(this.params.query);
		    let holderProps = {
		        top: {
		            'class': 'zmenu__footer', // No I18N
		            method: 'append', // No I18N
		            opp: 'bottom' // No I18N
		        },
		        bottom: {
		            'class': 'zmenu__header', // No I18N
		            method: 'prepend', // No I18N
		            opp: 'top' // No I18N
		        }
		    }
		    let direction = this._menu.data('direction').split('-')[0]; // No I18N
		    let props = holderProps[direction];
		    if (props) {
		        let holder = this._menu.children('.' + props.class); // No I18N
		        if (!holder.find('#' + this._getID('searchbox')).length) { // No I18N
		            if (!holder.length) {
		                holder = $("<ul class='" + props.class + "'></ul>")[props.method + 'To'](this._menu); // No I18N
		            }
		            holder[props.method](this.inputField.parent());
		            // Empty Header/Footer is removed
		            props = holderProps[props.opp];
		            let oppHolder = this._menu.children('.' + props.class); // No I18N
		            if (oppHolder.length && !oppHolder[0].childElementCount) {
		                oppHolder.remove();
		            }
		        }
		    }
		}
		_calcItemHts  () {
		    let children = this._menuBody[0].children;
		    if (!this._ht[0]) { // Item Ht stored in 0th pos
		        this._ht[0] = this._getItemHt(children[1]);
		    }
		    if (this._isGrouped && !this._ht[1]) { // Group Ht stored in 1st pos
		        this._ht[1] = this._getItemHt(children[0]);
		    }
		}
		_getItemHt  (element) {
		    return element ? $(element).outerHeight(true) : 0;
		}
		_addDummyJSON  (menuJSON, height) {
		    height && menuJSON.push({
		        unhoverable: true,
		        itemType: 'custom', // No I18N
		        customAttributes: {
		            style: 'height:' + height + 'px', // No I18N
		            'data-zplaceholder': true // No I18N
		        }
		    });
		}
		_cacheData  (menuJSON) {
		    let backedUpdata = this._cachedData;
		    if (menuJSON.length) {
		        let maxResults = this.DSInstance._maxResults;
		        let length = backedUpdata.length;
		        if (length) {
		            let lastPage = backedUpdata[length - 1];
		            let missedCount = maxResults - lastPage.length;
		            if (missedCount) {
		                lastPage.push(...menuJSON.splice(0, missedCount));
		            }
		        }
		        if (menuJSON.length) {
		            backedUpdata.push(menuJSON.splice(0, maxResults));
		            this._cacheData(menuJSON);
		        }
		    }
		}
		_getPagedMenuJSON  (pageIndex) {
		    return this._cachedData[pageIndex - 1];
		}
		_calcHt  (pageIndex) {
		    let height = 0;
		    let pageData = this._getPagedMenuJSON(pageIndex);
		    if (pageData) {
		        pageData.forEach((data) => {
		            height += this._ht[data.itemType === 'itemgroup' ? 1 : 0]; // No I18N
		        });
		    }
		    return height;
		}
		_showVirtualData  (orgEvent) {
		    let eventData = {};
		    let updateVirtualData = this._updateVirtualData.bind(this, orgEvent, eventData);
		    let onDataFetch = (filteredData) => {
		        eventData.results = filteredData;
		        this._trigger('beforelistupdate', orgEvent, eventData); // No I18N
		        filteredData = eventData.results;
		        if (filteredData.length) {
		            this._cacheData(this._getMenuJSON(filteredData));
		            updateVirtualData();
		        } else if (this._freshRequest) {
		            this._afterFilter(orgEvent, eventData);
		        }
		    }
		    if (this._freshRequest) {
		        this._cachedData = [];
		        this._startPage = this._endPage = null;
		        this._ht = [ 0, 0 ];
		        this._loadDataSource(onDataFetch);
		    } else if (this._scroll.exceeded) {
		        this._getNextPage(onDataFetch, updateVirtualData);
		    } else {
		        updateVirtualData();
		    }
		}
		_updateVirtualData  (orgEvent, eventData) {
		    let dummyHtAbove = 0;
		    let dummyHtBelow = 0;
		    let maxPagePerView = this._opts.maxPage;
		    let startPage = 1;
		    let maxPageLen = this._cachedData.length;
		    let endPage = maxPageLen;
		    if (maxPageLen > maxPagePerView) {
		        let elementsHt = 0;
		        let scrollTop = this._lastScrollTop + ((this._scroll.isBackwards ? -1 : 1) * 40);
		        while (startPage < maxPageLen) {
		            elementsHt += this._calcHt(startPage);
		            if (scrollTop < elementsHt) {
		                endPage = startPage;
		                let totalExistingHt = elementsHt;
		                while (endPage < maxPageLen) {
		                    let totalScrollTop = scrollTop + this._scroll.menuHt;
		                    if (totalScrollTop < totalExistingHt) {
		                        break;
		                    }
		                    totalExistingHt += this._calcHt(endPage);
		                    endPage++;
		                }
		                break;
		            }
		            dummyHtAbove = elementsHt;
		            startPage++;
		        }
		    }
		    // if (endPage > maxPagePerView) {
		    //     let elementsHt = 0;
		    //     while (startPage < maxPageLen) {
		    //         elementsHt += this._calcHt(startPage);
		    //         if (this._lastScrollTop < (elementsHt + this._calcHt(startPage + 1))) {
		    //         // if (this._lastScrollTop < elementsHt) {
		    //             endPage = Math.min(startPage + (maxPagePerView - 1), maxPageLen);
		    //             break;
		    //         }
		    //         dummyHtAbove = elementsHt;
		    //         startPage++;
		    //     }
		    // }
		    let endPageCount = this._getPagedMenuJSON(endPage).length;
		    if (startPage < this._startPage || endPage > this._endPage || endPageCount !== this._endPageCount) {
		        this._endPageCount = endPageCount;
		        /* Calculating Dummy Height below */
		        for (let i = endPage + 1; i <= maxPageLen; i++) {
		            dummyHtBelow += this._calcHt(i);
		        }
		        this._startPage = startPage;
		        this._endPage = endPage;
		        let menuJSON = [];
		        /* IMP-- Later we can try to achieve this using transform */
		        this._addDummyJSON(menuJSON, dummyHtAbove);
		        for (let i = startPage; i <= endPage; i++) {
		            menuJSON.push(...this._getPagedMenuJSON(i));
		        }
		        this._addDummyJSON(menuJSON, dummyHtBelow);
		        // IMP - the following method is not working in Firefox
		        // if (this._menuBody){
		        // this._menuBody[0].lastElementChild.style.marginBottom = dummyHtBelow + 'px'; // No I18N
		        // this._menuBody[0].firstElementChild.style.marginTop = dummyHtAbove + 'px'; // No I18N
		        // }
		        eventData = eventData || {};
		        let hoveredItemId;
		        if (this._scrolledOnKeyDown) {
		            hoveredItemId = this._getHovered().attr('id'); // No I18N
		        }
		        eventData.addedMenuItems = this._replaceMenuItems(menuJSON);
		        if (hoveredItemId) {
		            this.hoverMenuItem('#' + hoveredItemId); // No I18N
		        }
		        this._afterFilter(orgEvent, eventData, !this._freshRequest);
		    }
		}
	}
	ZC.registerComponent('ZList', ZList); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zmenu.Templates; 
let utilities = ZC.Templates.Utilities; 
template.WCListChildren = (data) => ZT.html ` ${(data.searchBox || data.headerItems.length) && ZT.html `${data.headerElement || ZT.html `<z-menuheader class='zmenu__header' data-header=true > ${data.searchBox && ZT.html `<div class="zmenu__search"> ${utilities.WCIcon(data.searchBox)} <input id="${data.searchBoxId}" autocomplete="off" type="text" class="zmenu__textbox" autocomplete="off"> </div>`} ${data.headerItems.map((item) => template.WCItem(item))} </z-menuheader>`}`} ${data.items && ZT.html `${data.bodyElement || ZT.html `<z-menubody class='zmenu__body' data-body=true > ${data.items.map((item) => template.WCItem(item))} </z-menubody>`}`} ${data.footerItems.length && ZT.html `${data.footerElement || ZT.html `<z-menufooter class='zmenu__footer' data-footer=true > ${data.footerItems.map((item) => template.WCItem(item))} </z-menufooter>`}`} ${data.loader && ZT.html `${template.WCLoader(data)}`} `; 
template.WCLoader = (data) => ZT.html `<ul data-footer="true" class="zmenu--loading" id="${data.id}-loader"> <li class="zsuggestfield__nonselectable"> ${data.defaultLoader ? ZT.customHTML `<i class="zmenu__icon zh-loading"> <svg class="zmenu__svg zmenu__loader zeffects--rotate"> <circle class="circle__track"></circle> <circle class="circle__load"></circle> </svg> </i>` : ZT.html `${icon(data.loader)}`} </li> </ul>`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zmenu.Templates; 
let utilities = ZC.Templates.Utilities; 
template.listChildren = (data) => ZT.html ` ${(data.searchBox || data.headerItems.length) && ZT.html `${data.headerElement || ZT.html `<ul class='zmenu__header' data-header=true > ${data.searchBox && ZT.html `<div class="zmenu__search"> ${utilities.icon(data.searchBox)} <input id="${data.searchBoxId}" autocomplete="off" type="text" class="zmenu__textbox" autocomplete="off"> </div>`} ${data.headerItems.map((item) => template.item(item))} </ul>`}`} ${data.items && ZT.html `${data.bodyElement || ZT.html `<ul class='zmenu__body' data-body=true > ${data.items.map((item) => template.item(item))} </ul>`}`} ${data.footerItems.length && ZT.html `${data.footerElement || ZT.html `<ul class='zmenu__footer' data-footer=true > ${data.footerItems.map((item) => template.item(item))} </ul>`}`} ${data.loader && ZT.html `${template.loader(data)}`} `; 
template.loader = (data) => ZT.html `<ul data-footer="true" class="zmenu--loading" id="${data.id}-loader"> <li class="zsuggestfield__nonselectable"> ${data.defaultLoader ? ZT.customHTML `<i class="zmenu__icon zh-loading"> <svg class="zmenu__svg zmenu__loader zeffects--rotate"> <circle class="circle__track"></circle> <circle class="circle__load"></circle> </svg> </i>` : ZT.html `${icon(data.loader)}`} </li> </ul>`; }(ZComponents)); 
(function(ZC, $){
	/*  DataSource utility to ease the use of ajax / normal datasource.
	    inputField( optional ) - The dataSource is filtered and "change" event is triggered  based on the input of this element.
	    menu( optional ) - The menu that is to be populated whenever there is "change" in datasource.
	    //ContentTypes =
	        already supported - text, text-desc, image-text, image-text-desc.
	        handling to be changed - for multiple selection, everything needs to be custom.
	*/
	class ZDatasourceHandler extends ZC.CoreComponent {
			get name(){
				return "zdatasourcehandler";
			}
	    get attrs() {
	        return {
	            id: null,
	            data: [],
	            dataSource: null,
	            allowDuplicateValues: true,
	            cacheData: true,
	            searchIncrementsInCache: false,
	            isResponseFiltered: true,
	            maxResults: null,
	            inPlaceSorting: true,
	            matcher: null,
	            dataMapping: {},
	            sort: true,
	            sortBy: null,
	            sortOrder: 'asc', // No I18N
	            customSorter: null,
	            callbacks: {},
	            filters: null,
	            search: {
	                criteria: 'contains' // No I18N
	            },
	            messages: {
	                pageIndexExceed: 'PageIndex exceeds the total pages.' // No I18N
	            }
	        }
	    }
	    _create() {
	        let options = this._opts;
	        this._dataMapping = options.dataMapping;
	        this._maxResults = options.maxResults;
	        let dataSource = options.dataSource;
	        this._promiseObj = undefined;
	        this.params = {};
	        this._cachedData = {};
	        this._filterFn = this._filterStaticSource;
	        this._staticData = true;
	        if (this._isAjaxSource(dataSource)) {
	            this._initAjaxSource(dataSource);
	        }
	    }
	    _setDataSource(dataSource) {
	        this._sorted = false;
	        this._dataSource = dataSource;
	        this._orgData = [ ...dataSource ];
	        if (dataSource.length) {
	            this._isJSONSource = typeof dataSource[0] === 'object'; // No I18N
	            // DataSource is sorted even before filtering. So that it need not be sorted each and every time.
	            if (this._opts.inPlaceSorting) {
	                this._dataSource = this._organizeResults(dataSource);
	            }
	        }
	    }
	    _organizeResults(dataSource) {
	        if (dataSource && dataSource.length) {
	            if (!this._sorted) {
	                this._sorted = true;
	                if (this._opts.sort) {
	                    return this._sortResults(dataSource);
	                } else if (this._isGrouped()) {
	                    return this._organizeGroupedData(dataSource);
	                }
	            }
	        }
	        return dataSource;
	    }
	    _getTotalPages() {
	        return this._maxResults ? Math.ceil(this._totalFilteredData.length / this._maxResults) : this._totalFilteredData.length ? 1 : 0;
	    }
	    _clone(data) {
	        return (JSON.parse(JSON.stringify(data)));
	    }
	    _getFilteredData() {
	        let query = this.params.query;
	        let dataSource = this._dataSource || [];
	        if (dataSource.length) {
	            if (this._isFunc(this._opts.matcher)) {
	                return dataSource.filter((data) => this._opts.matcher(query, data));
	            }
	            return query || this._opts.filters || this._filters ? this._filterData(query, dataSource) : dataSource.filter((data) => !data.hidden);
	        }
	        return dataSource;
	    }
	    _isGrouped() {
	        return this._dataMapping.groupLabel && this._isJSONSource;
	    }
	    _trigger(customEvent, data) {
	        let callback = this._opts.callbacks[customEvent];
	        return !callback || callback(data);
	    }
	    _fetch(queryParam = {}, successCallback, failureCallback) {
	        if (typeof queryParam === 'function') {
	            successCallback = queryParam;
	            failureCallback = successCallback;
	            queryParam = {};
	        }
	        let params = this.params;
	        queryParam.query = queryParam.query ? queryParam.query : ''; // No I18N
	        params.previousQuery = params.query;
	        params.query = queryParam.query;
	        this._serverPageIndex = queryParam.serverPageIndex || 1;
	        this._pageIndex = queryParam.pageIndex;
	        this._filters = queryParam.filters;
	        return new Promise((resolve, reject) => {
	            this._resolvePromise = (response) => {
	                if (this._ajaxSource) {
	                    response.serverPageIndex = params.pages;
	                    response.moreServerPages = this._moreServerPages;
	                }
	                successCallback && successCallback(response);
	                resolve(response);
	            };
	            this._rejectPromise = (exception) => {
	                failureCallback && failureCallback(exception);
	                reject(exception);
	            };
	            this._filterFn();
	        }).catch((e) => {
	            /* Empty catch is included to avoid error being thrown when promise is not used by the user */
	            if (e !== 'abort') { // No I18N
	                throw e;
	            }
	        });
	    }
	    _filterStaticSource() {
	        // If datasource is not set for the first time, It is set.
	        if (!this._dataSource) {
	            this._setDataSource(this._opts.data);
	        }
	        this._totalFilteredData = this._filteredData = this._organizeResults(this._getFilteredData());
	        this._totalPages = this._getTotalPages();
	        this._sendDataToUser();
	    }
	    // Function to resolve the promise passed to the user while fetching the data.
	    _sendDataToUser() {
	        if (this._maxResults) {
	            return this._resolvePageData();
	        }
	        this._resolvePromise({
	            query: this.params.query,
	            results: this._clone(this._filteredData)
	        });
	    }
	    _abortAjaxReq() {
	        if (this._ajaxRequest) {
	            this._ajaxRequest.abort();
	            this._ajaxRequest = undefined;
	        }
	    }
	    fetch() {
	        return this._fetch(...arguments);
	    }
	    destroy() {
	        this._abortAjaxReq();
	    }
	    clearCache() {
	        this.clearCachedQuery();
	        this._dataSource = this._orgData = this._sorted = this._filters = undefined;
	        this._abortAjaxReq();
	    }
	    _getData(data) {
	        let ds = this._dataSource;
	        if (ds.length) {
	            let valueToMatch = this._getUniqueValue(data);
	            for (let i = 0; i < ds.length; i++) {
	                let cData = ds[i];
	                if (valueToMatch === this._getUniqueValue(cData)) {
	                    return cData;
	                }
	            }
	        }
	    }
	    clearCachedQuery() {
	        this._cachedData = {};
	    }
	    setCachedData(data) {
	        this._dataSource = data;
	        this._isJSONSource = typeof data[0] === 'object'; // No I18N
	    }
	    getData(data, successCallback, requestUnloadedData) {
	        if (this._staticData) {
	            if (this._dataSource || !this._ajaxSource || requestUnloadedData) {
	                this._fetch(() => {
	                    let cData = this._getData(data);
	                    successCallback(cData ? {
	                        ...cData
	                    } : null);
	                });
	            }
	        }
	    }
		_initAjaxSource  () {
		    this._ajaxSource = true;
		    this._filterFn = this._filterAjaxSource;
		    if (this._opts.serverSearch) {
		        this._serverSearch = true;
		        // ServerPaging is true only when server searching is true - becos - search cannot be completely performed since the data is not available completely.
		    } else {
		        this._opts.isResponseFiltered = false;
		    }
		    this._serverPaging = this._opts.dataSource.paginated;
		    this._staticData = !(this._serverSearch || this._serverPaging);
		}
		_filterAjaxSource  () {
		    let onSuccess = () => {
		        this._filterCurrentAjaxData();
		        this._sendDataToUser();
		    }
		    let onFailure = (exception) => {
		        this._rejectPromise(exception);
		    }
		    let params = this.params;
		    let isSameQuery = this._dataSource && (params.query === params.previousQuery && params.pages === this._serverPageIndex && this._opts.cacheData);
		    if (isSameQuery) {
		        // Current data is already filtered for the given query
		        this._sendDataToUser();
		        return;
		    }
		    // Check for cached data
		    let cachedData = this._getDataFromCache(params.query);
		    if (cachedData) {
		        this._setDataSource(cachedData);
		    } else if (this._serverSearch || this._serverPaging || !this._dataSource || !this._opts.cacheData) {
		        // Make ajax request if the data is not present in cache
		        return this._initAjaxCall(onSuccess, onFailure);
		    }
		    onSuccess();
		}
		_filterCurrentAjaxData  () {
		    let options = this._opts;
		    let cachedData = this._getDataFromCache(this.params.query);
		    this._filteredData = this._dataSource;
		    if (!cachedData) {
		        if (!options.isResponseFiltered) {
		            this._filteredData = this._getFilteredData(this.params.query);
		        }
		        this._cacheResponse(this._filteredData);
		        this._filteredData = this._organizeResults(this._filteredData);
		    }
		    this._totalFilteredData = this._filteredData;
		    this._totalPages = this._getTotalPages();
		}
		_initAjaxCall  (successCallback, failureCallback) {
		    let dataSource = this._opts.dataSource;
		    if (this._serverPaging) {
		        this.params.pages = this._serverPageIndex;
		    }
		    let params = this._getParams();
		    this._trigger('requeststart', { // No I18N
		        params: params
		    });
		    let onSuccess = (data) => {
		        this._ajaxRequest = undefined;
		        this._onAjaxSucess(data);
		        successCallback && successCallback(data);
		    }
		    let onFail = (jqXHR, exception) => {
		        this._ajaxRequest = undefined;
		        this._onAjaxFail(jqXHR, exception);
		        failureCallback && failureCallback(exception);
		    }
		    let eventData = {
		        params
		    };
		    if (!dataSource.search) {
		        let ajaxSettings = {
		            ...dataSource
		        };
		        ajaxSettings.success = ajaxSettings.error = undefined;
		        let queryParam = ajaxSettings.queryParam;
		        ajaxSettings.sourceURL = this._isFunc(ajaxSettings.URL) ? ajaxSettings.URL(params) : ajaxSettings.URL;
		        ajaxSettings.data = this._isFunc(queryParam) ? queryParam(params) : queryParam;
		        eventData.ajaxSettings = ajaxSettings;
		    }
		    this._trigger('requeststart', eventData); // No I18N
		    this._abortAjaxReq();
		    if (dataSource.search) {
		        this._promiseObj = dataSource.search(eventData.params);
		    } else {
		        this._promiseObj = this._ajaxRequest = ZC.AJAX.transport(eventData.ajaxSettings);
		    }
		    let base = this;
		    (function(promiseObj) {
		        promiseObj.then((data) => {
		            promiseObj === base._promiseObj && onSuccess(data);
		        }, (err, exception) => {
		            promiseObj === base._promiseObj && onFail(err, exception);
		        });
		    }(this._promiseObj));
		}
		_getParams  () {
		    return $.extend({}, this.params);
		}
		_onAjaxSucess  (data) {
		    let options = this._opts;
		    let dsObject = options.dataSource;
		    let response;
		    // success callback given by the user is called.
		    if (dsObject.success) {
		        response = dsObject.success(data, this._getParams());
		        data = response.results || [];
		    } else if (data.results) {
		        response = data;
		        data = response.results || [];
		    }
		    this._moreServerPages = this._serverPaging && response.more;
		    let eventData = {
		        results: data
		    }
		    this._trigger('requestend', eventData); // No I18N
		    this._setDataSource(eventData.results);
		}
		_onAjaxFail  (jqXHR, exception) {
		    if (jqXHR.statusText !== 'abort') { // No I18N
		        let failCallback = this._opts.dataSource.error;
		        if (failCallback) {
		            failCallback(...arguments);
		        }
		        this._trigger('requesterror', { // No I18N
		            params: this._getParams(),
		            jqXHR: jqXHR,
		            exception: exception
		        });
		    }
		}
		_cacheResponse  (response) {
		    // Currently caching is not supported for pagination
		    if (this._serverSearch && this._opts.cacheData && !this._serverPaging) {
		        this._cachedData[this.params.query] = response;
		    }
		}
		_getDataFromCache  (query) {
		    if (query in this._cachedData) {
		        return this._cachedData[query];
		    } else if (query.length > 1 && this._opts.searchIncrementsInCache) {
		        return this._getDataFromCache(query.slice(0, -1));
		    }
		}
		_filterData  (query, dataSource) {
		    let customSearch = this._opts.customSearch;
		    if (this._isFunc(customSearch)) {
		        return customSearch(...arguments);
		    }
		    let matchedSource = []
		    let search = this._opts.search;
		    let regEx = this._getMatchingRegex(query, search);
		    if (this._isJSONSource) {
		        let filterBy = this._getSearchBy(search.by);
		        let addedKeys = [];
		        matchedSource = dataSource.filter((data) => {
		            if (!data.hidden) {
		                let valueKey = this._mapJSONToData(data, this._dataMapping.value);
		                if (this._opts.allowDuplicateValues || addedKeys.indexOf(valueKey) === -1) {
		                    let dynamicFilters = filterBy.map((field) => ({
		                        field,
		                        value: query,
		                        criteria: search.criteria,
		                        caseSensitive: search.caseSensitive
		                    }));
		                    let filters = [ this._filters || this._opts.filters || [] ];
		                    filters.push({
		                        logic: 'or', // No I18N
		                        filters: dynamicFilters
		                    });
		                    let isMatched = this._doesMatchFilters(data, filters);
		                    if (isMatched) {
		                        addedKeys.push(valueKey);
		                        return true;
		                    }
		                }
		            }
		        });
		    } else {
		        matchedSource = dataSource.filter((item) => {
		            regEx.lastIndex = 0;
		            return regEx.test(item);
		        });
		    }
		    return matchedSource;
		}
		_doesMatchFilters  (data, filters = this._opts.filters, logic = 'and') { // No I18N
		    if (filters.logic) {
		        return this._doesMatchFilters(data, filters.filters, filters.logic);
		    }
		    for (let i = 0; i < filters.length; i++) {
		        let filter = filters[i];
		        let isMatched;
		        if (filter.logic) {
		            isMatched = this._doesMatchFilters(data, filter.filters, filter.logic);
		        } else if (Array.isArray(filter)) {
		            isMatched = this._doesMatchFilters(data, filter);
		        } else {
		            let regEx = this._getMatchingRegex(filter.value, {
		                criteria: filter.criteria,
		                caseSensitive: filter.caseSensitive
		            });
		            let value = this._mapJSONToData(data, filter.field);
		            regEx.lastIndex = 0;
		            isMatched = regEx.test(value);
		        }
		        if (isMatched) {
		            if (logic === 'or') { // No I18N
		                return true;
		            }
		        } else if (logic === 'and') { // No I18N
		            return false;
		        }
		    }
		    return logic === 'and'; // No I18N
		}
		_organizeGroupedData  (dataSource) {
		    // To maintain the group order given by the user, even when filtered.
		    let groupedData = this._getGroupedData(dataSource);
		    let newDS = [];
		    for (let key in groupedData) {
		        newDS.push(...groupedData[key]);
		    }
		    return newDS;
		}
		// Function to group records with group label as key
		_getGroupedData  (datasource) {
		    let groupedData = {};
		    datasource.forEach((data) => {
		        let label = this._mapJSONToData(data, this._dataMapping.groupLabel);
		        label = label || ''; // No I18N
		        if (!groupedData[label]) {
		            groupedData[label] = [];
		        }
		        groupedData[label].push(data);
		    });
		    return groupedData;
		}
		_sortGroupedData  (dataSource) {
		    // Only the data within the respective groups are sorted separately. This reduces time complexity and also maintains the group order as given by the user.
		    let groupedData = this._getGroupedData(dataSource);
		    dataSource = [];
		    for (let key in groupedData) {
		        dataSource.push(...groupedData[key].sort(this._sortJSONData.bind(this)));
		    }
		    return dataSource;
		}
		_removeItems  (datasToRemove, indexes, groupsToRemove, removeAll) {
		    if (this._staticData) {
		        this._fetch(() => {
		            let ds = this._dataSource;
		            if (ds.length) {
		                if (datasToRemove) {
		                    if (datasToRemove.length) {
		                        datasToRemove = this._toArr(datasToRemove);
		                        for (let i = 0; i < ds.length; i++) {
		                            let valueToMatch = this._getUniqueValue(ds[i]);
		                            if (datasToRemove.find((dataToRemove) => this._getUniqueValue(dataToRemove) === valueToMatch)) {
		                                ds[i] = null;
		                            }
		                        }
		                        this._reassignData(ds);
		                    }
		                } else if (indexes) {
		                    if (indexes.length) {
		                        indexes = this._toArr(indexes);
		                        for (let i = 0; i < ds.length; i++) {
		                            if (indexes.indexOf(i) !== -1) {
		                                ds[i] = null;
		                            }
		                        }
		                        this._reassignData(ds);
		                    }
		                } else if (groupsToRemove) {
		                    if (groupsToRemove.length) {
		                        groupsToRemove = this._toArr(groupsToRemove);
		                        groupsToRemove.forEach((groupData) => {
		                            for (let i = 0; i < ds.length; i++) {
		                                let cData = ds[i];
		                                if (groupData === this._getProp(cData, 'groupLabel')) { // No I18N
		                                    ds[i] = undefined;
		                                }
		                            }
		                        });
		                        this._reassignData(ds);
		                    }
		                } else if (removeAll) {
		                    ds = [];
		                    this._reassignData(ds);
		                }
		            }
		        });
		    }
		}
		_addItems  (datasToAdd, index, groupLabel) {
		    if (this._staticData) {
		        this._fetch(() => {
		            let ds = this._dataSource;
		            if (ds) {
		                datasToAdd = this._toArr(datasToAdd);
		                if (groupLabel) {
		                    datasToAdd.forEach((newData) => {
		                        newData[this._dataMapping.groupLabel] = groupLabel;
		                    });
		                }
		                if (index === null || isNaN(index) || index < 0 || index >= ds.length) {
		                    ds.push(...datasToAdd);
		                } else {
		                    ds.splice(index, 0, ...datasToAdd);
		                }
		                this._reassignData(ds);
		            }
		        });
		    }
		}
		_setItemAttribute  (data, property, value, isGroup) {
		    if (this._staticData) {
		        this._fetch(() => {
		            let ds = this._dataSource;
		            if (ds && ds.length) {
		                if (isGroup) {
		                    ds.forEach((cData) => {
		                        let targetValue = this._getProp(cData, 'groupLabel'); // No I18N
		                        if (data === targetValue) {
		                            cData[property] = value;
		                        }
		                    })
		                } else {
		                    let matchedData = this._getData(data);
		                    if (matchedData) {
		                        matchedData[property] = value;
		                    }
		                }
		                this._reassignData(ds);
		            }
		        });
		    }
		}
		_reassignData  (data) {
		    data = data.filter((d) => d);
		    this.clearCachedQuery();
		    this._setDataSource(data);
		    this._trigger('update', {// No I18N
		        results: this._clone(data)
		    });
		}
		removeItems  (datas) {
		    this._removeItems(datas);
		}
		removeItemsAt  (indexes) {
		    this._removeItems(null, indexes);
		}
		removeGroups  (groupsToRemove) {
		    this._removeItems(null, null, groupsToRemove);
		}
		removeAllItems  () {
		    this._removeItems(null, null, true);
		}
		addItems  (datas, groupLabel) {
		    this._addItems(datas, null, groupLabel);
		}
		addItemsAt  (datas, index, groupLabel) {
		    this._addItems(datas, index, groupLabel);
		}
		setGroupAttribute  (groupLabel, property, value) {
		    this._setItemAttribute(groupLabel, property, value, true);
		}
		setItemAttribute  (data, property, value) {
		    this._setItemAttribute(data, property, value);
		}
		setAttributes  (props) {
		    let reinit;
		    let sortAPIChange;
		    Object.keys(props).forEach((key) => {
		        switch (key) {
		            case 'data': // No I18N
		            case 'dataSource':// No I18N
		                reinit = true;
		                break;
		            case 'sort':// No I18N
		            case 'sortBy':// No I18N
		            case 'sortOrder':// No I18N
		                sortAPIChange = true;
		                break;
		        }
		    });
		    $.extend(true, this._opts, props);
		    if (reinit) {
		        this.clearCache();
		        this._create();
		    } else {
		        this._maxResults = this._opts.maxResults;
		        this.clearCachedQuery();
		        if (sortAPIChange) {
		            this._sorted = false;
		            if (this._orgData) {
		                this._setDataSource(this._orgData);
		            }
		        }
		    }
		}
		_resolvePageData  () {
		    let pageIndex = this._pageIndex;
		    if (!pageIndex || !this._totalPages || pageIndex <= this._totalPages) {
		        return this._resolvePromise({
		            query: this.params.query,
		            pageIndex: pageIndex,
		            results: this._clone(this._getPageData(pageIndex, this._totalFilteredData)),
		            totalPages: this._totalPages
		        });
		    }
		    this._rejectPromise(this._opts.messages.pageIndexExceed);
		}
		_getPageData  (pageIndex, totalFilteredData) {
		    let maxResults = this._maxResults;
		    if (pageIndex) {
		        let startingIndex = maxResults * (pageIndex - 1);
		        return totalFilteredData.slice(startingIndex, startingIndex + maxResults);
		    }
		    return totalFilteredData;
		}
		_sortResults  (dataSource) {
		    let options = this._opts;
		    // It is copied since we dont work with the original datasource reference.
		    dataSource = dataSource.slice();
		    if (this._isFunc(options.customSorter)) {
		        return options.customSorter(dataSource);
		    }
		    this._offset = options.sortOrder === 'desc' ? -1 : 1; // No I18N
		    if (this._isJSONSource) {
		        let dataMapping = this._dataMapping;
		        this._sortField = (options.sortBy ? String(options.sortBy).split(',') : [ dataMapping.text || dataMapping.label ]); // No I18N
		        let isGrouped = this._isGrouped();
		        if (isGrouped && this._sortField.indexOf(dataMapping.groupLabel) === -1) {
		            dataSource = this._sortGroupedData(dataSource);
		        } else {
		            dataSource.sort(this._sortJSONData.bind(this));
		            if (isGrouped) {
		                dataSource = this._organizeGroupedData(dataSource);
		            }
		        }
		    } else {
		        dataSource.sort(this._sortFn.bind(this));
		    }
		    this._offset = this._sortField = undefined;
		    return dataSource;
		}
		_toLC  (text) {
		    if (typeof text === 'string') { // No I18N
		        return text.toLowerCase();
		    }
		    return text;
		}
		// Sort function for simple data
		_sortFn  (textA, textB) {
		    let returnData;
		    let isTextANull = !this._isNotNull(textA);
		    let isTextBNull = !this._isNotNull(textB);
		    if (isTextANull && isTextBNull) {
		        returnData = 0;
		    } else if (isTextANull) {
		        returnData = -1;
		    } else if (isTextBNull) {
		        returnData = 1;
		    } else if (textA.localeCompare) {
		        returnData = textA.localeCompare(textB);
		    } else {
		        textA = this._toLC(textA);
		        textB = this._toLC(textB);
		        returnData = ((textA > textB) ? 1 : (textA < textB) ? -1 : 0);
		    }
		    return returnData * this._offset;
		}
		// Sort function for JSON data
		_sortJSONData  (dataA, dataB) {
		    // Looping is done to sort by more than one field.
		    for (let i = 0; i < this._sortField.length; i++) {
		        let field = this._sortField[i];
		        let result = this._sortFn(this._mapJSONToData(dataA, field), this._mapJSONToData(dataB, field));
		        if (result) {
		            return result;
		        }
		    }
		}
	}
	ZC.registerComponent('ZDatasourceHandler', ZDatasourceHandler); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
	class ZListBox extends ZC.CoreComponent {
			get name(){
				return "zlistbox";
			}
	    get attrs() {
	        return {
	            contentType: 'text', // No I18N
	            multiple: false,
	            selectionLimit: 0,
	            multiSelectInterfacePattern: 'checkbox', // No I18N
	            hideCheckbox: false,
	            checkboxPosition: 'left', // No I18N
	            checkedIcon: false,
	            checkedIconClassName: null,
	            checkedSVGIconId: null,
	            checkedIconPosition: 'left', // No I18N
	            template: null,
	            groupHeadingTemplate: null,
	            selectorToIgnoreSelection: null,
	            showSearchField: false,
	            searchField: null,
	            loaderIconClassName: undefined,
	            loaderSVGIconId: undefined,
	            lazyLoading: false,
	            virtualization: false,
	            viewPerPage: null,
	            serverSearch: false,
	            customSearch: null,
	            cacheData: true,
	            sort: false,
	            sortBy: null,
	            sortOrder: 'asc', // No I18N
	            customSorter: null,
	            // Extra features
	            reorderable: false,
	            grippyIcon: true,
	            grippyIconClassName: null,
	            grippySVGIconId: null,
	            // States
	            focusItemOnItemMouseover: false,
	            selectOnKeyNavigation: undefined,
	            // Selection Behaviors
	            selectOnEnterKey: true,
	            characterKeyFocus: true,
	            keyNavigation: true,
	            value: null,
	            wrapAround: true,
	            height: null,
	            width: null,
	            allowDragToSelect: true,
	            moreResultsAction: false,
	            disabled: false,
	            // Not Exposed
	            allowDuplicateItems: true,
	            filterByCSSSelector: false,
	            maxPage: 3,
	            isGrouped: false,
	            focusFirstItem: false,
	            selectOnSpaceKey: true,
	            focusSelectedItem: true,
	            allowShiftSelection: true,
	            query: '', // No I18N
	            isTextHTMLEncoded: false
	        }
	    }
	    get props() {
	        return {
	            appendTo: null,
	            headerItems: [],
	            footerItems: [],
	            items: [],
	            dataSource: {},
	            dataMapping: {
	                text: 'text', // No I18N
	                value: 'value', // No I18N
	                informativeText: 'informativeText', // No I18N
	                iconClassName: 'iconClassName', // No I18N
	                textIcon: 'textIcon', // No I18N
	                SVGIconId: 'SVGIconId', // No I18N
	                options: 'options', // No I18N
	                zitemid: 'zitemid' // No I18N
	            },
	            actionButtons: {
	                actions: [],
	                displayType: 'contextual-mouseover', // No I18N
	                position: 'bottom' // No I18N
	            },
	            callbacks: {},
	            searchFieldOptions: {
	                // updateOnSelect: true,
	                // autoComplete: true,
	                placeholder: '', // No I18N
	                iconClassName: undefined,
	                SVGIconId: undefined,
	                clearButton: false,
	                clearButtonIconClassName: undefined,
	                clearButtonSVGIconId: undefined,
	                handleEvents: true,
	                filterBasedOnCurPos: false,
	                preventUPDOWNKeysDefault: true
	            },
	            search: {
	                by: 'text', // No I18N
	                searchIncrementsInCache: false,
	                trimWhitespace: true,
	                highlightKeyword: false,
	                fieldsToHighlight: null,
	                minKeywordLength: 0,
	                focusFirstResult: true,
	                criteria: 'contains' // No I18N
	            },
	            messages: {
	                noResults: 'No results found', // No I18N
	                moreAction: 'See more results', // No I18N
	                serverError: 'Server request failed. Please try again later', // No I18N
	                minKeywordLength: 'Please enter #minKeywordLength# or more characters', // No I18N
	                clear: 'Clear' // No I18N
	            },
	            // Not Exposed
	            filters: null
	        }
	    }
	    get propType() {
	        return {
	            selectOnFocus: 'boolean', // No I18N
	            filters: 'array', // No I18N
	            viewPerPage: 'number' // No I18N
	        }
	    }
	    get tagNames() {
	        return {
	            ITEM: 'z-listboxitem', // No I18N
	            GROUP: 'z-listboxgroup', // No I18N
	            BODY: 'z-listboxbody', // No I18N
	            HEADER: 'z-listboxheader', // No I18N
	            FOOTER: 'z-listboxfooter', // No I18N
	            SEPARATOR: 'z-listboxseparator' // No I18N
	        }
	    }
	    get SELECTORS() {
	        let tagNames = this.tagNames;
	        return {
	            OPTION: this.isCE ? tagNames.ITEM : 'option', // No I18N
	            OPTGROUP: this.isCE ? tagNames.GROUP : 'optgroup', // No I18N
	            OPTIONSBODY: tagNames.BODY, // No I18N
	            OPTIONSHEADER: tagNames.HEADER, // No I18N
	            OPTIONSFOOTER: tagNames.FOOTER, // No I18N
	            OPTIONSEPARATOR: tagNames.SEPARATOR // No I18N
	        }
	    }
	    get EVENTS() {
	        return [
	            'focus', // No I18N
	            'beforefocus', // No I18N
	            'blur', // No I18N
	            'beforeselect', // No I18N
	            'select', // No I18N
	            'beforedeselect', // No I18N
	            'deselect', // No I18N
	            'change', // No I18N
	            'itemclick', // No I18N
	            'beforeitemfocus', // No I18N
	            'itemfocus', // No I18N
	            'itemhover', // No I18N
	            'moreactionclick', // No I18N
	            'selectionlimitexceeded', // No I18N
	            'beforesearch', // No I18N
	            'searchsuccess', // No I18N
	            'searcherror', // No I18N
	            'noresults', // No I18N
	            'beforelistupdate', // No I18N
	            'listupdate', // No I18N
	            'imageerror', // No I18N
	            'dragstart', // No I18N
	            'drag', // No I18N
	            'dragend', // No I18N
	            'beforekeydown', // No I18N
	            'keydown', // No I18N
	            'beforesearchfieldupdate', // No I18N
	            'searchfieldupdate' // No I18N
	        ];
	    }
	    // Revisit - Remove it
	    get CLASSES() {
	        return {
	            container: 'zlistbox', // No I18N
	            /* Properties */
	            icon: 'zlistbox--withicon', // No I18N
	            listwithloader: 'zlistbox--loading', // No I18N
	            withicon: 'zlistbox--withicon', // No I18N
	            withhint: 'zlistbox--withdesc', // No I18N
	            withcheckbox: 'zlistbox--withcheckbox', // No I18N
	            withcheckedicon: 'zlistbox--withcheckedindication', // No I18N
	            withsearchfield: 'zlistbox--withsearchfield', // No I18N
	            icononly: 'zlistbox--icononly', // No I18N
	            icontext: 'zlistbox--iconwithtext', // No I18N
	            listwithcustom: 'zlistbox--withcustomitem', // No I18N
	            listwithcheckboxRight: 'zlistbox--checkboxright', // No I18N
	            listwithcheckediconRight: 'zlistbox--checkedindicationright', // No I18N
	            listwithactionbtnsvisible: 'zlistbox--actionbuttonvisible', // No I18N
	            withoutcheckeditem: 'zlistbox--withoutcheckeditem', // No I18N
	            listwithicononly: 'zlistbox--icononly', // No I18N
	            listwithimage: 'zlistbox--withimage', // No I18N
	            reorderable: 'zlistbox--reorderable', // No I18N
	            /* Listbox properties */
	            text: 'zlistbox__text', // No I18N
	            hint: 'zlistbox__description', // No I18N
	            body: 'zlistbox__body', // No I18N
	            header: 'zlistbox__header', // No I18N
	            footer: 'zlistbox__footer', // No I18N
	            item: 'zlistbox__item', // No I18N
	            itemgroup: 'zlistbox__itemgroup', // No I18N
	            itemgrouplabel: 'zlistbox__grouplabel', // No I18N
	            loader: 'zlistbox__loader', // No I18N
	            loadericon: 'zlistbox__loadericon', // No I18N
	            fullloader: 'zlistbox__fullloader', // No I18N
	            actionbuttonsWrapper: 'zlistbox__actions', // No I18N
	            actionbutton: 'zlistbox__action', // No I18N
	            separator: 'zlistbox__separator', // No I18N
	            checkediconWrapper: 'zlistbox__checkedindication', // No I18N
	            checkedicon: 'zlistbox__checkedicon', // No I18N
	            checkboxWrapper: 'zlistbox__checkbox', // No I18N
	            checkbox: 'zlistbox__inputcheckbox', // No I18N
	            checkboxlabel: 'zlistbox__checkboxlabel', // No I18N
	            avatar: 'zlistbox__avatar', // No I18N
	            icondiv: 'zlistbox__image', // No I18N
	            itemicon: 'zlistbox__icon', // No I18N
	            content: 'zlistbox__content', // No I18N
	            textIconWrapper: 'zlistbox__imagetext', // No I18N
	            moreresults: 'zlistbox__moreresults', // No I18N
	            noresults: 'zlistbox__noresults', // No I18N
	            noresultstext: 'zlistbox__noresultstext', // No I18N
	            search: 'zlistbox__search', // No I18N
	            searchcontainer: 'zlistbox__searchiconcontainer', // No I18N
	            searchicon: 'zlistbox__searchicon', // No I18N
	            searchfield: 'zlistbox__searchfield', // No I18N
	            clearbuttonicon: 'zlistbox__clearicon', // No I18N
	            clearbutton: 'zlistbox__clearbutton', // No I18N
	            grippyicon: 'zlistbox__grippy', // No I18N
	            /* States */
	            hoverable: 'is-hoverable', // No I18N
	            disabled: 'is-disabled', // No I18N
	            hover: 'on-hover', // No I18N
	            focussed: 'has-focus', // No I18N
	            selected: 'is-selected', // No I18N
	            rtl: 'zh-rtl' // No I18N
	        }
	    }
	    get isIE9() {
	        return ZC.Browser.getIEVersion() === 9;
	    }
	    // Method to initiate all the options
	    _init(element, options) {
	        this._data.classes = this._CLASSES;
	        this._id = element[0].id = this._getID(element);
	        // Local variables initialization
	        this._namespace = '.' + this.name; // No I18N
	        if (element[0].tagName === 'DIV') { // No I18N
	            this._skipParent = true;
	            this._useParent = true;
	        } else {
	            element[0].style.display = 'none'; // No I18N
	            this._useParent = false;
	        }
	        this._fromInit = true;
	        this._DOMChanges = {};
	        this.params = {};
	        this._wheelEvents = ('onwheel' in document || document.documentMode >= 9) ? 'wheel' : 'mousewheel'; // No I18N
	        this._imgErrHandlerRef = this._imgErrHandler.bind(this);
	        this._selectedItems = [];
	        if (!this.isCE && this.element[0].tagName === 'SELECT') { // No I18N
	            [ 'disabled', 'multiple' ].forEach((key) => { // No I18N
	                options[key] = options[key] || element[0][key];
	            });
	            element[0].multiple = options.multiple;
	        }
	        this._docMouseUpHandler = this._onDocMouseUp && this._onDocMouseUp.bind(this);
	        this._setNoResultsData();
	        this._initVars();
	        this._parseHTML();
	        this._initDS();
	        this._setInitValues();
	        this._savePrev();
	        this._afterPropInit();
	    }
	    _afterPropInit() {
	        this._reorderble = this._grippyIconData = false;
	        let options = this._opts;
	        if (options.reorderable && (!options.multiple || this._checkboxPattern || !options.allowDragToSelect) && this.staticData && !this.params.query && !this._lazyLoadData && !this.inputField) {
	            this._reorderble = true;
	            if (options.grippyIcon) {
	                ZC._getIconInfo(options.grippyIconClassName, options.grippySVGIconId, '#zc__svg--grippy-listbox', this._CLASSES.itemicon, this._grippyIconData = {}); // No I18N
	            }
	        }
	    }
	    _parseHTML() {
	        this._htmlTagData = false;
	        this._htmlHeaderItems = [];
	        this._htmlFooterItems = [];
	        !this._useParent && this._parseHTMLInput && this._parseHTMLInput();
	    }
	    _setInitValues() {
	        let options = this._opts;
	        let value = options.value;
	        if (!this._isNotNull(value)) {
	            value = [];
	            if (options.items && !this.ajaxSource) {
	                options.items.forEach((data) => {
	                    if (data.selected) {
	                        value.push(data);
	                    }
	                });
	            }
	        }
	        options.value = [];
	        this._setValues(value);
	    }
	    _initVars() {
	        let options = this._opts;
	        this._freshRequest = true;
	        this._actionBtns = false;
	        this.inputField = undefined;
	        this._highlightData = undefined;
	        this._searchable = undefined;
	        this._showSearchField = options.showSearchField;
	        if (this._showSearchField) {
	            this._setSearchFieldData();
	            this._searchable = true;
	        } else {
	            this._data.searchBox = undefined;
	            if (options.searchField) {
	                let inputField = $(options.searchField);
	                if (inputField.length) {
	                    this.inputField = inputField;
	                    this._searchable = true;
	                }
	            }
	        }
	        this._showCheckedIcon = options.checkedIcon;
	        this._checkboxPattern = options.multiple && options.multiSelectInterfacePattern === 'checkbox'; // No I18N
	        this._showCheckBox = this._checkboxPattern && !options.hideCheckbox;
	        if (this._checkboxPattern && options.hideCheckbox) {
	            this._selectOnFocus = false;
	        } else if (options.multiple && !this._checkboxPattern) {
	            this._selectOnFocus = true;
	        } else {
	            this._selectOnFocus = options.selectOnKeyNavigation === undefined ? (options.multiple ? false : !this._searchable) : options.selectOnKeyNavigation;
	        }
	        this._toggleOnItemClick = this._checkboxPattern ? (options.hideCheckbox || !this._selectOnFocus) : true;
	        this._focusOnHover = /* !this._selectOnFocus &&  */ options.focusItemOnItemMouseover;
	        !this._htmlTagData && this._assignDM();
	        this._isGrouped = !!this._dataMapping.groupLabel;
	        this._checkedIconData = {};
	        this._setContentProps(options.contentType);
	        let actionButtons = options.actionButtons.actions;
	        if (actionButtons && actionButtons.length) {
	            this._setActionBtns(actionButtons);
	        }
	        ZC._getIconInfo(options.checkedIconClassName || options.checkedIconClass, options.checkedSVGIconId, '#zc__svg--tick', this._CLASSES.checkedicon, this._checkedIconData); // No I18N
	    }
	    _bindEvents() {
	        this._addEvents({
	            focusIn: 'focusin', // No I18N
	            blur: 'focusout', // No I18N
	            mousedown: 'mousedown', // No I18N
	            keydown: 'keydown', // No I18N
	            click: 'click' // No I18N
	        });
	        this.container.on('click.' + this.name, '.' + this._CLASSES.checkboxWrapper, this._checkboxClickHandler.bind(this)); // No I18N
	    }
	    _keydownHandler(orgEvent) {
	        if (this._trigger('beforekeydown', orgEvent)) { // No I18N
	            return this._keydownActions(orgEvent);
	        }
	    }
	    _keydownActions(orgEvent) {
	        let response = this._navInstance.moveFocus(orgEvent);
	        this._trigger('keydown', orgEvent); // No I18N
	        return response;
	    }
	    _imgErrHandler(orgEvent) {
	        let imageElement = orgEvent.target;
	        if (imageElement.tagName === 'IMG') { // No I18N
	            this._trigger('imageerror', orgEvent, { // No I18N
	                imageElement
	            });
	        }
	    }
	    _mousedownHandler(orgEvent) {
	        if (!this._actionBtnClicked) {
	            if (!this._focussed) {
	                this._focussed = true;
	                // this.setFocus(orgEvent);
	            }
	        }
	        this._actionBtnClicked = false
	    }
	    _clickHandler(orgEvent) {
	        this._actionBtnClicked = false;
	    }
	    _getClosestItem($target) {
	        let item = $target.closest('.' + this._CLASSES.item); // No I18N
	        return item.length ? item : undefined;
	    }
	    _itemSelectHandler(orgEvent, select = true) {
	        let item = orgEvent.detail.item;
	        orgEvent = orgEvent.originalEvent;
	        if (!this._dragging) {
	            let preventDefault = true;
	            if (orgEvent) {
	                let clickedItem;
	                if (orgEvent.type === 'mouseup') { // No I18N
	                    if (orgEvent.isDefaultPrevented()) {
	                        return false;
	                    }
	                    clickedItem = this._getClosestItem($(orgEvent.target));
	                } else if (orgEvent.type === 'keydown') { // No I18N
	                    let keyCode = orgEvent.keyCode;
	                    let ZkeyCodes = ZC.keyCode;
	                    if (this._selectOnFocus || keyCode === ZkeyCodes.ENTER || keyCode === ZkeyCodes.SPACE) {
	                        clickedItem = this.getFocussed();
	                    } else {
	                        preventDefault = false;
	                    }
	                }
	                if (clickedItem) {
	                    if (clickedItem.data('selectable') && this._isValidClick(orgEvent, select, item)) { // No I18N
	                        preventDefault = false;
	                    }
	                } else {
	                    preventDefault = false;
	                }
	            } else if (item.data('selectable')) { // No I18N
	                preventDefault = false;
	            }
	            if (!preventDefault) {
	                return this._selectItem(item, select, orgEvent);
	            }
	        }
	        return false;
	    }
	    _isValidClick() {
	        if (this._opts.multiple) {
	            return this._isValidMultiSelectClick(...arguments);
	        }
	        return true;
	    }
	    _isCheckboxClick(orgEvent) {
	        let target = orgEvent && $(orgEvent.target);
	        let classes = this._CLASSES;
	        if (target && (target.hasClass(classes.checkboxlabel) || target.hasClass(classes.checkbox) || target.hasClass(classes.checkboxWrapper))) {
	            return true;
	        }
	    }
	    _checkboxClickHandler(orgEvent) {
	        orgEvent.preventDefault();
	    }
	    _itemClickHandler(orgEvent, $item, eventData) {
	        let itemData = eventData.itemMappedData;
	        if (!itemData.disabled) {
	            let eventData = this._getItemEventData($item);
	            if (!itemData.selectable) {
	                if (itemData.moreresults) {
	                    let moreResultsAction = this._opts.moreResultsAction;
	                    if (typeof moreResultsAction === 'function') { // No I18N
	                        moreResultsAction();
	                    }
	                    this._trigger('moreactionclick', orgEvent, eventData); // No I18N
	                }
	                this._focusEle($item, orgEvent);
	            }
	            this._trigger('itemclick', orgEvent, eventData); // No I18N
	        }
	    }
	    _getItemEventData($item, itemData) {
	        itemData = itemData || this._getStoredData($item);
	        return {
	            item: $item.length && $item[0],
	            itemMappedData: itemData,
	            itemData: itemData.originalData
	        }
	    }
	    _focusInHandler(orgEvent) {
	        let focussed = this._focussed;
	        this._focussed = this._focusCallbackCalled = true;
	        if (!focussed && !this._blurTimer) {
	            this._focusLastFocussed(this._opts.focusFirstItem, orgEvent);
	        }
	        this._trigger('focus', orgEvent); // No I18N
	    }
	    _focusLastFocussed(focusFirstItem, orgEvent) {
	        let considerSelectedItem = this._opts.focusSelectedItem;
	        // focusFirstItem = true  Selected Item is not considered, first item is focussed.
	        // considerSelectedItem - Whether the last selected needs to be considered when no item is in focus and focusFirstItem = false.
	        let itemToFocus = (this._domChanged || this._considerLastFocussed) && this.getFocussed();
	        if (!itemToFocus) {
	            if (focusFirstItem) {
	                // SelectOnFocus check is removed because it is userbased handling.
	                if (/* !this._selectOnFocus &&  */ !this._domChanged) {
	                    itemToFocus = this.getFirstValidItem();
	                }
	            } else if (considerSelectedItem) {
	                itemToFocus = this._listBody
	                    .find('.' + this._CLASSES.selected) // No I18N
	                    .first()[0];
	            }
	            // if (this._selectOnFocus) {
	            //     if (considerSelectedItem) {
	            //         itemToFocus = this._listBody
	            //             .find('.' + this._CLASSES.selected)// No I18N
	            //             .last()[0];
	            //     }
	            // } else if (focusFirstItem && !this._domChanged) {
	            //     itemToFocus = this.getFirstValidItem();
	            // }
	        }
	        if (itemToFocus) {
	            itemToFocus = $(itemToFocus);
	            this._focusEle(itemToFocus, orgEvent);
	            return itemToFocus;
	        }
	    }
	    _blurHandler(orgEvent) {
	        clearTimeout(this._blurTimer);
	        if (document.activeElement !== this.container[0]) {
	            this._focussed = false;
	            this._blurTimer = setTimeout(() => {
	                !this._focussed && this._focusOutHandler(orgEvent);
	                this._blurTimer = false;
	            });
	        }
	    }
	    _focusOutHandler(orgEvent) {
	        this._focussed = this._lastFocussedItem = false;
	        // this._unFocusItem(orgEvent);
	        this._setFocusClass(this.getFocussed(), false);
	        this._updateFieldClass();
	        this._removeDocEvent();
	        this._trigger('blur', orgEvent); // No I18N
	    }
	    _updateFieldClass() {
	        if (this._showSearchField) {
	            this.inputField[this.inputField[0] === document.activeElement ? 'addClass' : 'removeClass'](this._CLASSES.focussed); // No I18N
	        }
	        // this.inputField && this.inputField[this._focussed ? 'addClass' : 'removeClass'](this._CLASSES.focussed); // No I18N
	    }
	    _focusItemHandler($item, orgEvent) {
	        if (this._focussed && this._isFocussableItem($item)) {
	            let eventData = this._getItemEventData($item);
	            if (this._trigger('beforeitemfocus', orgEvent, eventData)) { // No I18N
	                let itemData = this._getStoredData($item);
	                if (itemData.clickable) {
	                    this.inputField && this._autofill($item, itemData, orgEvent);
	                    if (this._lastFocussed !== itemData.id) {
	                        this._unFocusItem();
	                    }
	                    this._lastFocussed = itemData.id;
	                    this._lastFocussedItem = $item;
	                    this._considerLastFocussed = !orgEvent || orgEvent.type !== 'mouseenter'; // No I18N
	                    this._setFocusClass($item);
	                    this._trigger('itemfocus', orgEvent, eventData); // No I18N
	                    return true;
	                }
	            }
	        }
	        if (!this._focussed) {
	            this._unFocusItem();
	            this.setFocus(orgEvent);
	        }
	        return false;
	    }
	    _unFocusItem() {
	        let focussedItem = this.getFocussed();
	        if (focussedItem) {
	            this._setFocusClass(focussedItem, false);
	        }
	        this._lastFocussed = undefined;
	    }
	    _getStoredData($item) {
	        return $item.length && $item[0].itemData;
	    }
	    _updateData(data) {
	        this._getById(data.id)[0].itemData = data;
	    }
	    _postRender() {
	        this._updateRenderedView();
	    }
	    // _displayList() {
	    // this.container[0].style.display = ''; // No I18N
	    // }
	    _fixHtWd() {
	        let height = this._opts.height || this.element[0].style.height;
	        let width = this._opts.width || this.element[0].style.width;
	        if (height) {
	            this.container[0].style.height = this._getCorrectedPx(height);
	        }
	        if (width) {
	            this.container[0].style.width = this._getCorrectedPx(width);
	        }
	    }
	    _getCorrectedPx(value) {
	        if (value === 'none') { // No I18N
	            return '';
	        }
	        return `${value}${isNaN(value) ? '' : 'px'}`;
	    }
	    _updateRenderedView() {
	        let data = this._data;
	        let options = this._opts;
	        if (this._fromInit) {
	            this.container[0].addEventListener('error', this._imgErrHandlerRef, true); // No I18N
	        }
	        data.className = this._getClass();
	        this._fixHtWd();
	        this._storeRef();
	        this.inputField && this._bindInputFieldEvents();
	        this._showSearchField && this._updateClearBtn();
	        let tabindex = this._opts.tabindex;
	        if (options.disabled) {
	            this.container.removeAttr('tabindex'); // No I18N
	        } else {
	            this.container.attr({
	                tabindex: this._isNotNull(tabindex) ? tabindex : (this._opts.showSearchField ? -1 : 0)
	            });
	        }
	        this._addEvents({
	            scroll: 'scroll' // No I18N
	        }, this._listBody);
	        /* Initialize navigation instance */
	        let selectableOptions = this._getOptsForSelectableUtil();
	        if (this._navInstance) {
	            this._navInstance.setAttributes(selectableOptions);
	        } else {
	            this._navInstance = ZC.selectable(this.container, selectableOptions);
	            this.container.off('keydown.zselectable'); // No I18N
	        }
	        // This is done after visibility
	        // if (this._fromInit) {
	        //     this._displayList();
	        // }
	        // this._fixMidHt();
	        this._fromInit = false;
	    }
	    _getOptsForSelectableUtil() {
	        let options = this._opts;
	        let classes = this._CLASSES;
	        let selectableOptions = {
	            items: `.${classes.item}[data-zplaceholder="true"], .${classes.item}[data-clickable=true]:not(.${classes.disabled})`, // No I18N
	            multiple: options.multiple,
	            toggle: this._checkboxPattern,
	            focusItemOnItemMouseover: this._focusOnHover,
	            selectOnFocus: this._selectOnFocus,
	            selectOnEnterKey: options.selectOnEnterKey,
	            selectOnSpaceKey: options.selectOnSpaceKey,
	            /* && !this.inputField */
	            allowDragToSelect: options.allowDragToSelect && !this._checkboxPattern,
	            keyNavigation: options.keyNavigation,
	            allowShiftSelection: options.allowShiftSelection,
	            keyNavigationOptions: {
	                direction: 'vertical', // No I18N
	                wrapAround: !this._lazyLoadData && options.wrapAround,
	                characterKeyFocus: options.characterKeyFocus,
	                keyMatchAttribute: 'zkeymatchlabel' // No I18N
	            },
	            select: (orgEvent) => {
	                // console.log('util - select');
	            },
	            beforeselect: (orgEvent) => this._itemSelectHandler(orgEvent, true),
	            beforedeselect: (orgEvent) => this._itemSelectHandler(orgEvent, false),
	            deselect: (orgEvent) => {
	                // console.log('util - deselect');
	            },
	            beforeblur: () => false,
	            beforereset: (orgEvent) => {
	                let activeItem = orgEvent.detail.item;
	                orgEvent = orgEvent.originalEvent;
	                if (!this._dragging && activeItem.data('selectable') && (!options.multiple || orgEvent.type !== 'mouseup' || !this._checkboxPattern || (this._selectOnFocus && !this._isCheckboxClick(orgEvent)))) { // No I18N
	                    return true;
	                }
	                return false;
	            },
	            change: (orgEvent) => {
	                this._triggerChange(orgEvent, orgEvent.detail.item);
	            },
	            reset: (orgEvent) => {
	                let activeItem = orgEvent.detail.item;
	                orgEvent = orgEvent.originalEvent;
	                return this._clearSelection(orgEvent, activeItem[0].itemData);
	            },
	            beforefocusmove: (orgEvent) => {
	                let item = orgEvent.detail.item;
	                let ahead = orgEvent.detail.ahead;
	                orgEvent = orgEvent.originalEvent;
	                if (orgEvent && orgEvent.type === 'mouseup') { // No I18N
	                    if (orgEvent.isDefaultPrevented()) {
	                        return false;
	                    } else if (!this._focussed) {
	                        this._focussed = true;
	                        this.setFocus(orgEvent);
	                    }
	                }
	                return (ahead !== 'select' || this._canFocusMove(item, orgEvent)) && this._focusItemHandler(item, orgEvent); // No I18N
	            },
	            focusmove: (orgEvent) => {
	                // console.log('on focus');
	            },
	            mouseenter: (orgEvent) => {
	                let $item = orgEvent.detail.item;
	                if (this._isFocussableItem($item)) {
	                    this._itemInHover = $item;
	                    this._trigger('itemhover', orgEvent, this._getItemEventData($item)); // No I18N
	                }
	            },
	            mouseleave: (orgEvent) => {
	                this._itemInHover = false;
	            },
	            beforemouseup: () => !this._actionBtnClicked,
	            beforemousedown: () => !this._actionBtnClicked
	        };
	        if (this._styleBasedFilter) {
	            selectableOptions.items += ':visible'; // No I18N
	        }
	        return selectableOptions;
	    }
	    _isFocussableItem($item) {
	        return $item && $item.length && $item.attr('data-clickable'); // No I18N
	    }
	    // FocusMovement is prevented to prevent shift+arrowKey movement focus when maximum limit is reached.
	    _canFocusMove(item, orgEvent) {
	        if (item && item.length && orgEvent && this._opts.multiple && this._selectOnFocus && !this._checkLimit()) { // No I18N
	            if (orgEvent.type === 'keydown' && orgEvent.shiftKey /* && orgEvent.keyCode === ZC.keyCode.DOWN */) { // No I18N
	                let keyCodes = ZC.keyCode;
	                let code = orgEvent.keyCode;
	                if (code === keyCodes.DOWN || code === keyCodes.UP) {
	                    return false;
	                }
	            }
	        }
	        return true;
	    }
	    _postEachRender() {
	        if (this._domChanged) {
	            this._updateRenderedView();
	        }
	        this._newAddedItems = this._getDomsForData(this._newAddedJSON);
	        this._setVisibility(this._data.orgEvent);
	        if (this._domChanged || !this._data.rendered || this._updateMidHt) {
	            this._fixMidHt();
	        }
	        this._manageReorderable();
	        this._bindScrollToLazyLoad();
	        this._updateCustomAttrs();
	        this._updateStates(this._data.orgEvent);
	        this._data.orgEvent = undefined;
	    }
	    _show(ele, show = true) {
	        if (ele && ele[0]) {
	            ele[0].style.display = show ? '' : 'none'; // No I18N
	        }
	    }
	    _hide(ele) {
	        return this._show(ele, false);
	    }
	    _setVisibility() {
	        let data = this._data;
	        let classes = this._CLASSES;
	        data.className = this._getClass();
	        let noResultsEle = this._noResultsEle;
	        let loadingELe = this._loaderEle;
	        let listBody = this._listBody;
	        let container = this.container;
	        container
	            .removeAttr('data-loading') // No I18N
	            .removeAttr('data-noresults'); // No I18N
	        if (this._loading) {
	            loadingELe[data.loader.fullloader ? 'addClass' : 'removeClass'](classes.fullloader); // No I18N
	            this._show(loadingELe);
	            this._show(listBody);
	            this._hide(noResultsEle);
	            this.container.attr('data-loading', true); // No I18N
	        } else {
	            loadingELe && loadingELe.removeClass(classes.fullloader);
	            if (this._noResults) {
	                this._hide(listBody);
	                this._show(noResultsEle);
	                this.container.attr('data-noresults', true); // No I18N
	            } else {
	                this._hide(loadingELe);
	                this._hide(noResultsEle);
	                this._show(listBody);
	            }
	        }
	        data.className = this._getClass();
	    }
	    _fixMidHt() {
	        let extraHt = 0;
	        let CLASSES = this._CLASSES;
	        let children = [ ...this.container[0].children ];
	        let midElements = [];
	        let fixedChildren = [];
	        children.forEach((child) => {
	            child = $(child);
	            if (child.hasClass(CLASSES.body) || child.hasClass(CLASSES.noresults) || child.hasClass(CLASSES.loader)) {
	                midElements.push(child[0]);
	            } else if (!child.attr('data-floating')) { // No I18N
	                fixedChildren.push(child[0]);
	            }
	        });
	        fixedChildren.forEach((child) => {
	            extraHt += (child.offsetHeight || 0);
	        });
	        this._childHt = 'calc(100% - ' + extraHt + 'px)'; // No I18N
	        midElements.forEach((child) => {
	            child.style.height = this._childHt;
	        });
	    }
	    _updateCustomAttrs() {
	        let currentItems = this._data.items;
	        let prevItems = this._prevItems;
	        if (currentItems.length) {
	            for (let i = 0; i < currentItems.length; i++) {
	                let prevCustomAttrs = prevItems && prevItems[i] && prevItems[i].customAttributes;
	                let currentCustomAttrs = currentItems[i].customAttributes;
	                let attrs = {};
	                let update = false;
	                if (prevCustomAttrs) {
	                    if (prevCustomAttrs === currentCustomAttrs) {
	                        continue;
	                    }
	                    for (let key in prevCustomAttrs) {
	                        attrs[key] = null
	                    }
	                    update = true;
	                }
	                if (currentCustomAttrs) {
	                    Object.assign(attrs, currentCustomAttrs);
	                    update = true;
	                }
	                if (update) {
	                    this._getById(currentItems[i].id).attr(attrs);
	                }
	            }
	        }
	        this._prevItems = [ ...currentItems ];
	    }
	    _getDomsForData(itemDatas) {
	        return itemDatas && itemDatas.map((itemData) => this._getById(itemData.id)[0]); // No I18N
	    }
	    _updateStates(orgEvent) {
	        let items = this._newAddedItems || this._getDomsForData(this._data.items);
	        let classes = this._CLASSES;
	        if (this._itemInHover) {
	            if (!this.container.find(this._itemInHover).length) {
	                this._itemInHover = undefined;
	            }
	        }
	        // if (this._data.headerItems) {
	        //     items.push(...this._data.headerItems);
	        // }
	        // if (this._data.footerItems) {
	        //     items.push(...this._data.footerItems);
	        // }
	        // let focusSet = this._freshRequest && this._opts.search.focusFirstResult && this._focussed && !this._rebuilt ? 0 : 1;
	        items.forEach((item) => {
	            let $item = $(item);
	            let itemData = this._getStoredData($item);
	            let selectedItems = this._selectedItems;
	            // $item.removeData();
	            if (itemData.selectable) {
	                let isSelected;
	                for (let i = 0; i < selectedItems.length; i++) {
	                    if (selectedItems[i].id === itemData.id) {
	                        selectedItems[i] = itemData;
	                        itemData.selected = isSelected = true;
	                    }
	                }
	                this._addSelectDataToItem($item, !!isSelected);
	                if (itemData.checkbox) {
	                    $item.find('.' + classes.checkbox)[0].checked = isSelected; // No I18N
	                }
	                if (itemData.actionButtons) {
	                    this._bindActionBtns($item, itemData);
	                }
	            }
	        });
	        this._setFocusAfterStateUpdate(items, orgEvent);
	        return items;
	    }
	    _addSelectDataToItem($item, select = true) {
	        if ($item.attr('data-selectable')) { // No I18N
	            let classes = this._CLASSES;
	            if (select) {
	                $item.addClass(classes.selected);
	            } else {
	                $item.removeClass(classes.selected);
	            }
	            $item.attr('aria-selected', select); // No I18N
	        } else {
	            $item.removeAttr('aria-selected'); // No I18N
	        }
	    }
	    _setFocusAfterStateUpdate(items, orgEvent) {
	        let reupdateFocus = !this._lazyLoaded || this._virtualization;
	        if (reupdateFocus && items.length) {
	            if (this._focussed) {
	                let itemToBeFocussed = this.getFocussed();
	                let lastFocussedItem = this._lastFocussed && this._lastFocussedItem;
	                if (this._fromSearch) {
	                    this._considerLastFocussed = false;
	                    itemToBeFocussed = this._focusLastFocussed(this.inputField ? this._opts.search.focusFirstResult : undefined, orgEvent);
	                } else {
	                    this._focusEle(itemToBeFocussed, orgEvent);
	                }
	                if (lastFocussedItem) {
	                    if (!itemToBeFocussed || lastFocussedItem[0] !== itemToBeFocussed[0]) {
	                        lastFocussedItem.removeClass(this._CLASSES.focussed + ' ' + this._CLASSES.hover); // No I18N
	                    }
	                }
	                if (this._itemInHover) {
	                    let itemInHover = this._itemInHover;
	                    this._itemInHover = undefined;
	                    itemInHover.trigger('mouseenter'); // No I18N
	                }
	            }
	        }
	    }
	    _setFocusClass(ele, set = true) {
	        // TabIndex Implementation is temporarily prevented
	        // item.attr('tabindex', set ? 0 : -1); // No I18N
	        // Adding class is handled in util
	        if (ele) {
	            let focusClass = this._CLASSES.focussed;
	            if (this._focusOnHover) {
	                focusClass += (' ' + this._CLASSES.hover); // No I18N
	            }
	            if (!set) {
	                ele.removeClass(focusClass);
	            }
	        }
	    }
	    _storeRef() {
	        let classes = this._CLASSES;
	        let data = this._data;
	        let list = this.container;
	        this._noResultsEle = this._loaderEle = undefined;
	        if (this._showSearchField) {
	            this.inputField = this._getById(data.searchBox.id);
	        }
	        this._listBody = list.find('.' + classes.body); // No I18N
	        this._listHeader = list.find('.' + classes.header); // No I18N
	        this._listFooter = list.find('.' + classes.footer); // No I18N
	        if (data.noResults) {
	            this._noResultsEle = this._getById(data.noResults.id);
	        }
	        if (data.loader) {
	            this._loaderEle = this._getById(data.loader.id);
	        }
	        let placeholder = this._opts.searchFieldOptions.placeholder;
	        if (this.inputField && placeholder) {
	            this.inputField.attr('placeholder', placeholder); // No I18N
	        }
	    }
	    _bindScrollToLazyLoad() {
	        if (this._freshRequest && this._lazyLoadData && (this.params.totalPages > this.params.pageIndex || this.params.moreServerPages)) {
	            this._bindScroll();
	        }
	    }
	    _selectItem($item, select = true, orgEvent) {
	        let itemData;
	        let classes = this._CLASSES;
	        select = !!select;
	        if ($item.id) {
	            itemData = $item;
	            $item = this._getById(itemData.id);
	        }
	        if ($item.length) {
	            itemData = this._getStoredData($item); // No I18N
	        }
	        let isSelected = this._isSelectedItem(itemData);
	        if (itemData.selectable && isSelected !== select) {
	            if (!$item.length) {
	                this._dsInit && this.DSInstance.getData(itemData.originalData, (_originalData) => {
	                    if (_originalData) {
	                        itemData = this.getItemData(_originalData);
	                    }
	                });
	            }
	            let eventName = select ? 'select' : 'deselect'; // No I18N
	            if (this._trigger('before' + eventName, orgEvent)) { // No I18N
	                if (select) {
	                    if (!this._addToSelection(itemData, orgEvent)) {
	                        return false;
	                    }
	                } else {
	                    this._removeFromSelection(itemData, orgEvent);
	                }
	                this._addSelectDataToItem($item, !!select);
	                itemData.selected = select;
	                if (this._showCheckBox && $item.length) {
	                    $item[0].querySelector('.' + classes.checkbox).checked = select; // No I18N
	                }
	                select && this.inputField && this._setFieldValue($item, itemData, orgEvent);
	                // Note: Change is removed because it should be handled at the end of an action.
	                this._trigger(eventName, orgEvent, this._getItemEventData($item, itemData));
	                this._changed = true;
	            } else {
	                return false;
	            }
	        }
	        return itemData.selectable;
	    }
	    _triggerChange(orgEvent, $item) {
	        orgEvent = orgEvent && orgEvent.originalEvent;
	        let eventData = {};
	        if ($item && $item.length) {
	            eventData = this._getItemEventData($item);
	        }
	        if (this._changed) {
	            let ariaDesc = 'aria-activedescendant'; // No I18N
	            let descendants = this._selectedItems.map((itemData) => itemData.id);
	            this.container && this.container.attr(ariaDesc, descendants.join(',')); // No I18N
	            eventData.previousValue = this._prevValues;
	            this._trigger('change', orgEvent, eventData); // No I18N
	            this._savePrev();
	        }
	        if (orgEvent) {
	            let keyCodes = ZC.keyCode;
	            let code = orgEvent.keyCode;
	            let eventType = orgEvent.type;
	            if (orgEvent && eventData.item && (eventType === 'mouseup' || (eventType === 'keydown' && (code === keyCodes.ENTER || code === keyCodes.SPACE)))) { // No I18N
	                this._itemClickHandler(orgEvent, $item, eventData);
	            }
	        }
	        this._changed = false;
	    }
	    _savePrev() {
	        this._prevValues = [ ...this._opts.value ];
	    }
	    values() {
	        return this._selectedItems;
	    }
	    _initialRender() {
	        this._search();
	        if (!this._data.rendered) {
	            this._replaceBodyItems([]);
	        }
	    }
	    _setContentProps(contentType) {
	        // Validating the contentType
	        if (!/^(image-text|image-text-desc|text-desc|text|custom|image)$/.test(contentType)) { // No I18N
	            contentType = 'text'; // No I18N
	        }
	        // Validating the list content type
	        this._isCustom = contentType.indexOf('custom') > -1; // No I18N
	        this._hasImage = this._hasIcon = false;
	        if (!this._isCustom) {
	            this._hasText = contentType.indexOf('text') > -1; // No I18N
	            this._hasDesc = contentType.indexOf('desc') > -1; // No I18N
	            if (contentType.indexOf('image') > -1) { // No I18N
	                this._hasIcon = !(this._hasImage = this._dataMapping.image);
	            }
	        }
	    }
	    _assignDM() {
	        this._dataMapping = {
	            ...this._opts.dataMapping
	        };
	    }
	    // Method to create datasource instance
	    _initDS() {
	        let options = this._opts;
	        let data = this._data;
	        if (!this.DSInstance) {
	            data.loader = this._loading = false;
	        }
	        // this.inputField && this.inputField.val(''); // No I18N
	        data.items = [];
	        this._datasource = [];
	        this._groupsIncluded = [];
	        this._dataLoaded = false;
	        this._groupHeads = [];
	        // Header and Footer render items are reset
	        data.headerItems = data.footerItems = data.moreAction = data.virtualHeightBelow = data.virtualHeightAbove = undefined;
	        let dataSource = options.dataSource;
	        let itemDatas = options.items;
	        this._dsInit = this.staticData = false;
	        this.ajaxSource = this._isAjaxSource(dataSource);
	        if (this.ajaxSource || (itemDatas && itemDatas.length)) {
	            this._dsInit = this.staticData = true;
	            let DSSettings = {
	                callbacks: {}
	            };
	            if (this.ajaxSource) {
	                this._bindAjaxEvents(DSSettings.callbacks);
	            } else if (options.dataStructure === 'nested') { // No I18N
	                itemDatas = this._flattenData(itemDatas);
	            }
	            this._virtualization = false;
	            if (options.filterByCSSSelector && !this.ajaxSource && !options.search.highlightKeyword && !this._isGrouped) {
	                this._lazyLoadData = false;
	                this._styleBasedFilter = true;
	                this._filterFn = this._filterListViaStyles;
	            } else {
	                this._lazyLoadData = options.height === 'auto' ? false : options.lazyLoading; // No I18N
	                if (options.virtualization) {
	                    this._virtualization = this._lazyLoadData = true;
	                }
	                this._styleBasedFilter = false;
	                this._filterFn = this._filterByAddRemoval;
	            }
	            DSSettings.search = options.search;
	            DSSettings.filters = options.filters;
	            [ 'sort', // No I18N
	                'sortBy', // No I18N
	                'sortOrder', // No I18N
	                'customSorter', // No I18N
	                'serverSearch', // No I18N
	                'isResponseFiltered', // No I18N
	                'cacheData', // No I18N
	                'customSearch' // No I18N
	            ].forEach((key) => {
	                DSSettings[key] = options[key];
	            });
	            this._viewPerPage = this._lazyLoadData ? (this._isNotNull(options.viewPerPage) ? options.viewPerPage : 10) : 0;
	            DSSettings.maxResults = this._viewPerPage;
	            DSSettings.searchIncrementsInCache = options.search.searchIncrementsInCache;
	            DSSettings.dataMapping = this._dataMapping;
	            DSSettings.callbacks.update = this._onDSUpdate.bind(this);
	            DSSettings.allowDuplicateValues = options.allowDuplicateItems;
	            if (this.DSInstance) {
	                this.DSInstance.setAttributes(DSSettings);
	            } else {
	                this._lastScrollTop = 0;
	                DSSettings.dataSource = dataSource;
	                DSSettings.data = itemDatas;
	                this.DSInstance = this._initDSInstance(DSSettings);
	            }
	            if (this.DSInstance._serverSearch || this.DSInstance._serverPaging) {
	                this.staticData = false;
	            }
	            this.ajaxSource && this._setLoaderData();
	        }
	    }
	    _preRender() {
	        // clearTimeout(this._blurTimer);
	        let data = this._data;
	        let options = this._opts;
	        let DOMChanges = this._DOMChanges;
	        let prevMoreAction = data.moreAction;
	        if (DOMChanges && Object.keys(DOMChanges).length) {
	            this._replaceMovedItems();
	        }
	        this._DOMChanges = {};
	        if (!data.rendered || this._domChanged) {
	            data.attrs = {
	                role: 'listbox', // No I18N
	                'aria-multiselectable': !!options.multiple // No I18N
	            }
	        }
	        if (options.moreResultsAction) {
	            if (this._noResults) {
	                data.moreAction = undefined;
	            } else {
	                this._setMoreResults();
	            }
	        } else if (!data.rendered || this._domChanged) {
	            this._setHeaderFooterItems && this._setHeaderFooterItems();
	        }
	        this._updateMidHt = (!!prevMoreAction !== !!this._data.moreAction);
	        return data;
	    }
	    // Item Object created from the datasource record using data mapping.
	    getItemData(data, groupID, heading, type) {
	        /*
	            info:
	                1. type = heading | item | separator
	                2. contentType = img | img-text | img-text-desc | text-desc | custom
	                3. checkbox
	                4. radiobutton
	        */
	        let itemData = {
	            ...this._getBasicItemData(data),
	            ...{
	                name: groupID,
	                separator: data.separator,
	                heading: heading,
	                custom: data.contentType === 'custom', // No I18N
	                view: {},
	                selectable: false
	            }
	        };
	        if (typeof data !== 'object') { // No I18N
	            let text = data;
	            data = {};
	            if (!data.separator) {
	                this._setProp(data, heading ? 'groupLabel' : 'text', text); // No I18N
	            }
	        }
	        itemData.normalisedData = data;
	        // Our local changes should not affect the user's object.
	        let attrs = itemData.customAttributes = {
	            ...(data.customAttributes || {})
	        };
	        if (heading) {
	            this._setHeadingData(itemData);
	        } else if (!data.separator) {
	            this._setViewData(itemData, type);
	        }
	        // Updating required class for the item
	        this._updateItemClass(itemData);
	        if (data.style) {
	            attrs.style = data.style;
	        }
	        if (this._isNotNull(data.title)) {
	            attrs.title = data.title;
	        }
	        if (ZC.isEmpty(attrs)) {
	            delete itemData.customAttributes;
	        }
	        return itemData;
	    }
	    _getBasicItemData(data) {
	        return {
	            id: this._getItemId(data),
	            originalData: data,
	            normalisedData: data,
	            zlistitem: true,
	            selectable: true
	        }
	    }
	    _setKeyValue(itemData, key, encode) {
	        encode = this._isEncoded() ? false : encode;
	        let value = this._getProp(itemData.normalisedData, key, encode);
	        itemData[key] = value;
	    }
	    _isEncoded() {
	        return this._opts.isTextHTMLEncoded;
	    }
	    _setHeadingData(itemData) {
	        this._setKeyValue(itemData, 'groupLabel'); // No I18N
	        itemData.disabled = this._opts.disabled;
	        let groupHeadingTemplate = this._opts.groupHeadingTemplate;
	        if (groupHeadingTemplate) {
	            itemData.view.innerHTML = this._getCustomContent(itemData, this._opts.groupHeadingTemplate, true, 'text'); // No I18N
	        } else {
	            itemData.view.text = this._highlight(ZC.encodeHTML(itemData.groupLabel), this._dataMapping.groupLabel);
	        }
	    }
	    _updateItemClass(itemData) {
	        let className = itemData.originalData.className || ''; // No I18N
	        let customAttrs = itemData.customAttrs;
	        let addToClass = (classToAdd) => {
	            className += ' ' + classToAdd; // No I18N
	        }
	        // Handled in template
	        // if (itemData.disabled) {
	        //     addToClass(classes.disabled);
	        // } else if (!itemData.clickable) {
	        //     addToClass(classes.nonselectable);
	        // }
	        if (customAttrs && customAttrs.className) {
	            addToClass(customAttrs.className);
	            delete customAttrs.className;
	        }
	        // Classes that are updated dynamically
	        // info: This is commented because we are maintaining it separately. We are not letting templates to handle it.
	        // if (this._isSelectedItem(itemData)) {
	        //     addToClass(classes.selected);
	        //     itemData.selected = true;
	        // }
	        // if (this._lastFocussed) {
	        //     if (this._lastFocussed[0].id === itemData.id) {
	        //         addToClass(classes.focussed);
	        //         itemData.focussed = true;
	        //     }
	        // }
	        itemData.className = className;
	    }
	    // This is called only on new page creation
	    _afterFilter(orgEvent, eventData) {
	        if (this._freshRequest) {
	            let itemsExists;
	            if (this._styleBasedFilter) {
	                itemsExists = this.getFirstItem();
	                // this._focusEle($(itemsExists), orgEvent);
	            } else {
	                let addedItems = eventData && eventData.addedItems;
	                itemsExists = addedItems && addedItems.length;
	            }
	            if (itemsExists) {
	                this._hideNoResults(undefined, orgEvent);
	            } else {
	                this._showNoResults(orgEvent);
	                return;
	            }
	        }
	        if (this._opts.search.highlightKeyword && !this._noResults && this._styleBasedFilter) {
	            this._highlightInList();
	        }
	        // Perf: to avoid rerender
	        if (this._itemsRendered) {
	            this._setScrollTop();
	        }
	        this._itemsRendered = true;
	        this._triggerUpdate(orgEvent, eventData);
	    }
	    // Method to remove no results item
	    _hideNoResults(updateUI = true, orgEvent) {
	        this._noResults = false;
	        this._status = 'ok'; // No I18N
	        updateUI && this._setVisibility(orgEvent);
	    }
	    _showNoResults(orgEvent) {
	        let eventData = {
	            query: this.params.query
	        }
	        if (this._trigger('noresults', orgEvent, eventData)) { // No I18N
	            this._showWarning('noResults', orgEvent); // No I18N
	        }
	    }
	    _showWarning(msgKey, orgEvent) {
	        let warningCode = msgKey.toLowerCase();
	        let eventData = {
	            params: this.params,
	            status: warningCode
	        }
	        this._noResults = true;
	        this._status = warningCode;
	        let warningMsg = this._getText(msgKey);
	        this._data.noResults.innerHTML = warningMsg;
	        if (this._styleBasedFilter) {
	            if (this._data.rendered) {
	                if (!this._domChanged || !this._reInit) {
	                    this._renderView();
	                }
	                // Directly manipulating the HTML removes the comment section that causes error while repopulating it using template.
	                // this._noResultsEle.html(warningMsg)
	                // this._setVisibility(orgEvent);
	            }
	        }
	        this._hideAllItems(orgEvent);
	        this._noResultsEle.attr('data-warning', warningCode); // No I18N
	        return this._triggerUpdate(orgEvent, eventData); // No I18N
	    }
	    // If there are no items, the items must be removed.
	    _hideAllItems(orgEvent) {
	        if (this._styleBasedFilter && this._data.rendered) {
	            return this._hideItemsUsingCSS();
	        }
	        this._replaceBodyItems([], undefined, orgEvent);
	    }
	    // Method to get the display messages
	    _getMsg(key) {
	        return this._getI18NText(key);
	    }
	    // Class needed.
	    _getClass() {
	        let classes = this._CLASSES;
	        let classToBeAdded = classes.container;
	        let addClass = (newClass) => {
	            classToBeAdded += ' ' + newClass; // No I18N
	        };
	        if (this._loading) {
	            addClass(classes.listwithloader);
	        }
	        if (this._opts.className) {
	            addClass(this._opts.className);
	        }
	        if (this._opts.rtl) {
	            addClass(classes.rtl);
	        }
	        if (this._opts.disabled) {
	            addClass(classes.disabled);
	        }
	        if (this._showCheckBox || this._showCheckedIcon) {
	            if (this._showCheckBox) {
	                addClass(classes.withcheckbox);
	                if (this._opts.checkboxPosition === 'right') { // No I18N
	                    addClass(classes.listwithcheckboxRight);
	                }
	            }
	            if (this._showCheckedIcon) {
	                addClass(classes.withcheckedicon);
	                if (this._opts.checkedIconPosition === 'right') { // No I18N
	                    addClass(classes.listwithcheckediconRight);
	                }
	            }
	        } else {
	            addClass(classes.withoutcheckeditem);
	        }
	        if (this._actionBtns && this._opts.actionButtons.displayType === 'contextual') { // No I18N
	            addClass(classes.listwithactionbtnsvisible);
	        }
	        if (this._opts.showSearchField) {
	            addClass(classes.withsearchfield);
	        }
	        if (this._isCustom) {
	            addClass(classes.listwithcustom);
	        } else {
	            if (this._hasIcon) {
	                addClass(classes.withicon);
	            } else if (this._hasImage) {
	                addClass(classes.listwithimage);
	            }
	            if (this._hasDesc) {
	                addClass(classes.withhint);
	            }
	            if (this._opts.contentType === 'image') { // No I18N
	                addClass(classes.listwithicononly);
	            }
	        }
	        if (this._reorderble) {
	            // addClass(classes.withicon);
	            addClass(classes.reorderable);
	        }
	        return classToBeAdded;
	    }
	    _getBool(value) {
	        if (value === true || value === 'true') { // No I18N
	            return true;
	        }
	    }
	    _setCheckboxData(itemData) {
	        if (this._showCheckedIcon) {
	            itemData.checkedIconPosition = this._opts.checkedIconPosition;
	            itemData.checkedIcon = this._checkedIconData;
	        }
	        if (this._showCheckBox) {
	            itemData.checkbox = true;
	            itemData.checkboxId = 'zcheckbox-' + itemData.id; // No I18N
	            itemData.checkboxPosition = this._opts.checkboxPosition;
	        }
	    }
	    // Updating image && content for the item.
	    _setViewData(itemData, type) {
	        let view = itemData.view;
	        let normalisedData = itemData.normalisedData;
	        let customAttrs = itemData.customAttributes;
	        // Updating required states
	        itemData.hidden = normalisedData.hidden;
	        itemData.disabled = normalisedData.disabled || this._opts.disabled;
	        let selectable = this._isNotNull(normalisedData.selectable) ? this._getBool(normalisedData.selectable) : !type;
	        itemData.selectable = selectable;
	        if (!itemData.disabled) {
	            itemData.clickable = selectable || (this._isNotNull(normalisedData.clickable) ? this._getBool(normalisedData.clickable) : true);
	        }
	        // Updating checkbox and checkedIcon related settings.
	        if (selectable) {
	            this._setCheckboxData(itemData);
	            itemData.actionButtons = this._actionBtns;
	            itemData.grippyIcon = this._grippyIconData;
	        }
	        let unselectable = type && !selectable;
	        if (this._styleBasedFilter && this._searchable && !unselectable) {
	            this._getAttrForCSSFilter(normalisedData, customAttrs);
	        }
	        let label = customAttrs['data-label'] || this._mapJSONToData(normalisedData, this._dataMapping.text, false); // No I18N
	        view.ariaLabel = label || ''; // No I18N
	        view.ariaValue = this._getProp(normalisedData, 'value') || view.ariaLabel; // No I18N
	        if (normalisedData.custom || this._isCustom) {
	            view.innerHTML = this._getCustomContent(normalisedData, normalisedData.zinnerHTML || normalisedData.innerHTML || this._opts.template, true, 'text'); // No I18N
	            itemData.custom = true;
	        } else {
	            let setKeyValue = this._setKeyValue.bind(this, itemData);
	            if (this._hasIcon || this._hasImage) {
	                this._setImageData(itemData);
	            }
	            if (this._hasText) {
	                setKeyValue('text', true); // No I18N
	                view.text = unselectable ? itemData.text : this._highlight(itemData.text, this._dataMapping.text);
	                customAttrs['data-label'] = label // No I18N
	                if (this._opts.characterKeyFocus) {
	                    customAttrs['data-zkeymatchlabel'] = label && label.toLowerCase(); // No I18N
	                }
	            }
	            if (this._hasDesc) {
	                setKeyValue('informativeText', true); // No I18N
	                view.description = unselectable ? itemData.informativeText : this._highlight(itemData.informativeText, this._dataMapping.informativeText);
	            }
	        }
	    }
	    _triggerUpdate(orgEvent, eventData) {
	        return this._trigger('listupdate', orgEvent, eventData); // No I18N
	    }
	    _triggerBeforeUpdate(orgEvent, eventData) {
	        return this._trigger('beforelistupdate', orgEvent, eventData); // No I18N
	    }
	    _highlight(content, key) {
	        if (content) {
	            if (this.params.query && this._opts.search.highlightKeyword) {
	                content = this._highlightValidKey(content, key);
	            }
	        }
	        return content;
	    }
	    // Method to get the first visible item
	    getFirstItem(selector) {
	        return this.container.find(`.${this._CLASSES.item}[data-selectable]`).toArray().find((item) => { // No I18N
	            let $item = $(item);
	            return (!selector || $item.is(selector)) && (!this._styleBasedFilter || $item.css('display') !== 'none') // No I18N
	        });
	    }
	    getFirstValidItem() {
	        return this.getFirstItem(':not(.' + this._CLASSES.disabled + ')'); // No I18N
	    }
	    _scrollHandler(orgEvent) {
	        if (this._considerScrollForLazyLoad) {
	            this._scrollHandlerToLoadPage(orgEvent);
	        } else {
	            this._lastScrollTop = this._listBody[0].scrollTop;
	        }
	    }
	    _focusInputField() {
	        this.inputField.focus();
	    }
	    getFocussed() {
	        if (this._lastFocussed) {
	            let focussed = this._getById(this._lastFocussed);
	            return focussed.length ? focussed : undefined;
	        }
	    }
	    // Method to call callback functions
	    _trigger(customEvent, orgEvent, eventData) {
	        if (!this._fromInit) {
	            eventData = eventData || {};
	            eventData.value = this.getValue();
	            eventData.initialized = !this._fromInit;
	            return this._dispatchEvent(customEvent, orgEvent, eventData, undefined, !!orgEvent);
	        }
	        return true;
	    }
	    _getItemJSON(dataSource, fixedItems) {
	        if (this._isGrouped && !fixedItems) {
	            return this._getItemJSONForGroupedData(dataSource);
	        }
	        return dataSource.map((data) => this.getItemData(data));
	    }
	    _addBodyItems(data, isRaw = true, orgEvent) {
	        let itemJSON = data;
	        if (isRaw && data.length) {
	            this._datasource.push(...data);
	            itemJSON = this._getItemJSON(data);
	        }
	        this._data.items.push(...itemJSON);
	        this._lazyLoaded = true;
	        let items = this._renderView(itemJSON, orgEvent);
	        this._lazyLoaded = false;
	        return items;
	    }
	    _renderView(addedJSON, orgEvent) {
	        this._data.orgEvent = orgEvent;
	        this._newAddedJSON = addedJSON;
	        this._render();
	        this._data.rendered = true;
	        this._domChanged = false;
	        return this._newAddedItems;
	    }
	    _replaceBodyItems(data, isRaw = true, orgEvent) {
	        let itemJSON = data;
	        if (isRaw && data.length) {
	            this._datasource = [ ...data ];
	            itemJSON = this._getItemJSON(data);
	        }
	        this._data.items = itemJSON;
	        let items = this._renderView(itemJSON, orgEvent);
	        return items;
	    }
	    _getKeyID(key) {
	        return 'z' + this._id + '-' + key; // No I18N
	    }
	    _loadDataSource(successCallback, orgEvent) {
	        if (this._dsInit) {
	            // Incase of static data, data is fetched only once
	            this.fetchData(this.params, (data) => {
	                let results = data.results;
	                delete data.results;
	                this.params = {
	                    ...this.params,
	                    ...data
	                };
	                let eventData = {
	                    results: results,
	                    params: {
	                        ...this.params
	                    }
	                }
	                this._triggerBeforeUpdate(orgEvent, eventData);
	                successCallback(eventData.results, orgEvent);
	            });
	        } else {
	            successCallback([]);
	        }
	    }
	    _getItemId(data) {
	        return super._getItemId(data, this._id);
	    }
	    _removeStyle() {
	        if (this.styletag) {
	            if (this._opts.search.highlightKeyword) {
	                this._highlightInList(undefined, true);
	            }
	            this.styletag.remove();
	            this.styletag = undefined;
	        }
	    }
	    _manageReorderable() {
	        if (this._reorderble && !this._opts.disabled) {
	            this._initSortable();
	        } else {
	            this._destroySortable();
	        }
	    }
	    _initDSInstance(options) {
	        return new ZC.ZDatasourceHandler(null, options);
	    }
	    _setScrollTop() {
	        this._listBody[0].scrollTop = this._lastScrollTop;
	    }
	    _destroySortable() {
	        this._grippyIconData = false;
	        this._listBody.data('zsortable') && ZC.sortable(this._listBody).destroy(); // No I18N
	    }
	    _getText(feature) {
	        let innerText = ZC.encodeHTML(this._getMsg(feature));
	        let key = 'query'; // No I18N
	        let value = this.params.query;
	        if (feature === 'minKeywordLength') { // No I18N
	            key = 'minKeywordLength'; // No I18N
	            value = this._opts.search.minKeywordLength;
	        }
	        innerText = innerText.replace(new RegExp(`#${key}#`, 'g'), '<b class="zh-bold">' + (value || '') + '</b>'); // No I18N
	        return innerText;
	    }
	    _destroyDSIns() {
	        this._removeStyle();
	        this._lazyLoadData && this._unbindScroll();
	        this._dsInit = false;
	        if (this.DSInstance) {
	            this.DSInstance.destroy();
	            this.DSInstance = undefined;
	        }
	    }
	    _detachInputEv() {
	        if (this.inputField) {
	            this._removeEvents('', this.inputField); // No I18N
	        }
	    }
	    _reSearch() {
	        this._skipScrollTopReset = !this._dataReset;
	        this.params.previousQuery = undefined;
	        this._search(this.params.query, {
	            setItemFocus: false
	        });
	        this._skipScrollTopReset = false;
	    }
	    _isSelectedItem(itemData) {
	        return !!this._selectedItems.find((sItemData) => sItemData.id === itemData.id);
	    }
	    _clearSelection(orgEvent, excludeValues) {
	        let itemsToBeDeselected = [ ...this._selectedItems ];
	        if (excludeValues) {
	            excludeValues = this._toArr(excludeValues);
	            itemsToBeDeselected = itemsToBeDeselected.filter((itemData) => !excludeValues.find((excludeData) => {
	                let excludedId = excludeData.originalData && excludeData.zlistitem ? excludeData.id : this._getItemId(excludeData);
	                return excludedId === itemData.id;
	            }));
	        }
	        itemsToBeDeselected.forEach((itemData) => {
	            this._selectItem(itemData, false, orgEvent);
	        });
	    }
	    _addToSelection(itemData, orgEvent) {
	        if (this._checkLimit()) {
	            if (!this._isSelectedItem(itemData)) {
	                if (this._opts.multiple) {
	                    this._selectedItems.push(itemData);
	                } else {
	                    this._clearSelection(orgEvent, itemData);
	                    this._selectedItems = [ itemData ];
	                }
	                this._updateValues();
	            }
	            return true;
	        }
	        this._trigger('selectionlimitexceeded', orgEvent, { // No I18N
	            valueToBeSelected: itemData.originalData
	        });
	    }
	    _updateValues() {
	        this._opts.value = this._selectedItems.map((itemData) => itemData.originalData);
	    }
	    _removeFromSelection(itemData) {
	        let selectedItems = this._selectedItems;
	        for (let index = 0; index < selectedItems.length; index++) {
	            if (selectedItems[index].id === itemData.id) {
	                selectedItems.splice(index, 1);
	                this._updateValues();
	                break;
	            }
	        }
	    }
	    _checkLimit() {
	        let selectionLimit = Number(this._opts.selectionLimit);
	        if (!selectionLimit || isNaN(selectionLimit) || selectionLimit > this._selectedItems.length) {
	            return true;
	        }
	    }
	    _setValues(values, properties) {
	        properties = properties || {};
	        let clearPrevValues = properties.clearOtherValues;
	        let orgEvent = properties.event;
	        this._changed = false;
	        values = this._toArr(values);
	        if (clearPrevValues) {
	            this._clearSelection(orgEvent, values);
	        }
	        values.forEach((value) => {
	            value = this._getBasicItemData(value);
	            this._selectItem(value, true, orgEvent);
	        });
	        this._triggerChange(orgEvent);
	    }
	    _removeDocEvent() {
	        if (this._docMouseUpHandler) {
	            document.removeEventListener('mouseup', this._docMouseUpHandler, true); // No I18N
	        }
	    }
	    _destroy() {
	        // It is garbage collected if there are no reference.
	        this.container[0].removeEventListener('error', this._imgErrHandlerRef, true); // No I18N
	        clearTimeout(this._searchTimer);
	        clearTimeout(this._focusTimer);
	        clearTimeout(this._blurTimer);
	        this._detachInputEv();
	        this._removeDocEvent();
	        if (this._navInstance) {
	            this._navInstance.destroy();
	            this._navInstance = undefined;
	        }
	        if (this.element[0].tagName === 'SELECT' && !this.element.attr('multiple')) { // No I18N
	            this.element[0].multiple = false;
	        }
	        this._destroyDSIns();
	        this.container.empty();
	    }
	    _focusCallback($item, orgEvent, scrollToView) {
	        if (this._focussed) {
	            let itemId = typeof $item === 'string' ? $item : $item[0].id; // No I18N
	            $item = this._getById(itemId);
	            if ($item && $item.length) {
	                // Class is removed here because it present beforemousemove event will not be called from selectable.
	                $item.removeClass(this._CLASSES.focussed);
	                // let selectOnFocus = this._selectOnFocus;
	                // if (selectOnFocus && (!orgEvent || orgEvent.type !== 'keydown' || orgEvent.keyCode !== ZC.keyCode.UP || orgEvent.keyCode !== ZC.keyCode.DOWN)) { // No I18N
	                //     selectOnFocus = false;
	                // }
	                // this._navInstance[ this._selectOnFocus ? 'selectItem' : 'focusItem' ]($item, orgEvent, true); // No I18N
	                this._focusItemUsingNavInstance($item, orgEvent, scrollToView);
	            }
	        }
	    }
	    _focusEle($item, orgEvent, scrollToView, immediate) {
	        clearTimeout(this._focusTimer);
	        if ($item && $item.length) {
	            if (immediate) {
	                this._focusCallback($item, orgEvent, scrollToView);
	            } else {
	                this._focusTimer = setTimeout(this._focusCallback.bind(this, $item, orgEvent, scrollToView));
	            }
	        }
	    }
	    _focusItemUsingNavInstance($item, orgEvent, scrollToView = false) {
	        this._navInstance.focusItem($item, orgEvent, scrollToView);
	    }
	    _focusItem(itemData, orgEvent, scrollToView, immediate) {
	        if (itemData) {
	            if (itemData.nodeType === 1) {
	                this._focusEle($(itemData), orgEvent, scrollToView, immediate);
	            } else {
	                this._focusEle(this._getItemId(itemData), orgEvent, scrollToView, immediate);
	            }
	        }
	    }
	    _onDSUpdate(eventData) {
	        this.params.previousQuery = undefined;
	        if (!this.ajaxSource) {
	            this._opts.items = eventData.results;
	        }
	        this._reSearch();
	    }
	    _refresh(external) {
	        this._detachInputEv();
	        this._destroyDSIns();
	        this._initVars();
	        if (external) {
	            if (this._htmlTagData) {
	                this._opts.items = [];
	            }
	            this._parseHTML();
	        }
	        this._initDS();
	        this._afterPropInit();
	        this._reSearch();
	    }
	    _getItem(data, searchBody = true, searchHeaderFooter = true) {
	        if (this._isNotNull(data) && this.staticData) {
	            if (data.nodeType) {
	                return data.hasClass(this._CLASSES.item) ? data.itemData.originalData : data.optData; // No I18N
	            }
	            let matchedData = searchHeaderFooter && this._getHeaderFooterItem && this._getHeaderFooterItem(data);
	            if (!matchedData && searchBody) {
	                matchedData = this.DSInstance.getData(matchedData);
	            }
	            return matchedData;
	        }
	    }
	    focusItem(itemData, scrollToView, orgEvent) {
	        this.setFocus(orgEvent);
	        this._focusItem(itemData, orgEvent, scrollToView);
	    }
	    unfocusItem() {
	        this._unFocusItem();
	    }
	    setValue(value, properties) {
	        this._setValues(value, properties);
	    }
	    getValue() {
	        let value = this._opts.value;
	        return Array.isArray(value) ? [ ...value ] : value;
	    }
	    deselect(values, orgEvent) {
	        this._changed = false;
	        values = this._toArr(values);
	        values.forEach((value) => {
	            this._selectItem(this._getBasicItemData(value), false, orgEvent);
	        });
	        this._triggerChange(orgEvent);
	    }
	    deselectAll(orgEvent) {
	        this._changed = false;
	        this._clearSelection(orgEvent);
	        this._triggerChange(orgEvent);
	    }
	    refresh() {
	        this._domChanged = true;
	        this._refresh(true);
	        this._domChanged = false;
	    }
	    setFocus(orgEvent) {
	        // if (!this.container.is(':focus') || !this.inputField || !this.inputField.is(':focus')) { // No I18N
	        if (this._trigger('beforefocus', orgEvent)) { // No I18N
	            this._focusCallbackCalled = false;
	            this.container.focus();
	            !this._focusCallbackCalled && this._focusInHandler(orgEvent);
	        }
	        // }
	    }
	    getItem(data) {
	        this._getItem(data);
	    }
	    handleKeyCode(orgEvent) {
	        return this._keydownHandler(orgEvent);
	    }
	    isFocussed() {
	        return this._focussed;
	    }
	    fetchData() {
	        return this.DSInstance.fetch(...arguments);
	    }
	    clearCache() {
	        this.params.previousQuery = undefined;
	        this._dataLoaded = false;
	        this._dsInit && this.DSInstance.clearCache();
	        this._reSearch();
	    }
	    getSearchField() {
	        return this.inputField;
	    }
		_bindActionBtns  ($item, itemData) {
		    let namespace = this._namespace;
		    $item
		        .find('.' + this._CLASSES.actionbuttonsWrapper) // No I18N
		        .off(namespace)
		        .on(`click${namespace} mousedown${namespace} mouseup${namespace}`, (orgEvent) => { // No I18N
		            this._focussed = true;
		            if (orgEvent.type === 'mousedown') { // No I18N
		                this._unFocusItem();
		            }
		            this._actionBtnClicked = true;
		            // StopPropagation should be avoided to the maximum extent.
		            // orgEvent.stopPropagation();
		        })
		        .find('.' + this._CLASSES.actionbutton) // No I18N
		        .toArray()
		        .forEach((actionBtn, index) => {
		            actionBtn = $(actionBtn);
		            let actionBtndata = this._actionBtns[index];
		            let customAttrs = actionBtndata.customAttributes;
		            customAttrs && actionBtn.attr(customAttrs);
		            actionBtn
		                .off(namespace)
		                .on('click' + namespace, (orgEvent) => { // No I18N
		                    let action = actionBtndata.action;
		                    action && action.call(this.element, itemData.originalData, $item[0], orgEvent);
		                });
		        });
		}
		_setActionBtns  (actionBtns) {
		    if (!this._opts.disabled || this._opts.actionButtons.displayType === 'contextual') { // No I18N
		        this._actionBtns = actionBtns.map((actionBtn) => {
		            let actionConfig = {};
		            ZC._getIconInfo(actionBtn.iconClassName, actionBtn.SVGIconId, '', this._CLASSES.itemicon, actionConfig); // No I18N
		            actionConfig.title = actionBtn.title;
		            actionConfig.action = actionBtn.action;
		            actionConfig.className = actionBtn.className || ''; // No I18N
		            actionConfig.disabled = actionBtn.disabled || this._opts.disabled;
		            return actionConfig;
		        });
		    }
		}
		_removeItems  (datasToRemove, indexes, groupsToRemove, focusNextItem) {
		    datasToRemove = this._toArr(datasToRemove);
		    let removeItemsCallback = () => {
		        let DSInstance = this.DSInstance;
		        if (datasToRemove) {
		            DSInstance.removeItems(datasToRemove);
		        } else if (indexes) {
		            DSInstance.removeItemsAt(indexes);
		        } else if (groupsToRemove) {
		            DSInstance.removeGroups(groupsToRemove);
		        }
		    }
		    removeItemsCallback();
		    // if (focusNextItem) {
		    //     this._focusNextItemOnRemoval(datasToRemove, indexes, groupsToRemove, removeItemsCallback);
		    // } else {
		    // }
		}
		// _focusNextItemOnRemoval  (datasToRemove, indexes, groupsToRemove, callback) {
		//     this.fetchData((response) => {
		//         let results = response.results;
		//         if (indexes) {
		//             datasToRemove = indexes.map((indexToBeRemoved) => results[indexToBeRemoved]);
		//         }
		//         let ToBeFocussed;
		//         this._datasource.forEach((cData) => {
		//             let itemId = this._getItemId(cData);
		//             let valueToMatch = this._getUniqueValue(cData);
		//             if (!ToBeFocussed) {
		//                 ToBeFocussed = cData;
		//             }
		//             for (let i = 0; i < datasToRemove.length; i++) {
		//                 let dataToRemove = datasToRemove[i];
		//                 if (valueToMatch === this._getUniqueValue(dataToRemove)) {
		//                     dataToRemove.removed = true;
		//                     if (itemId === this._lastFocussed) {
		//                         ToBeFocussed = undefined;
		//                     }
		//                     break;
		//                 }
		//             }
		//         });
		//         this._lastFocussed && ToBeFocussed && this._focusItem(ToBeFocussed);
		//         callback();
		//     });
		// }
		addItems  (datasToAdd, groupLabel) {
		    this.DSInstance.addItems(datasToAdd, groupLabel);
		}
		addItemsAt  (datasToAdd, index, groupLabel) {
		    this.DSInstance.addItemsAt(datasToAdd, index, groupLabel);
		}
		removeItems  (datasToRemove, focusNext) {
		    this._removeItems(datasToRemove, null, null, focusNext);
		}
		removeItemsAt  (indexes, focusNext) {
		    this._removeItems(null, indexes, null, focusNext);
		}
		removeGroups  (groupsToRemove) {
		    this._removeItems(null, null, groupsToRemove);
		}
		removeAllItems  () {
		    this._unFocusItem();
		    this.DSInstance.removeAllItems();
		}
		_showLoader  () {
		    let eventData = {
		        params: this.params,
		        loading: true
		    }
		    this._loading = true;
		    let fullloader = this._loaderData.fullloader = this._freshRequest;
		    if (fullloader) {
		        this._replaceBodyItems([]);
		    } else if (this._loaderEle) {
		        this._setVisibility();
		    } else {
		        this._renderView([]);
		    }
		    return this._triggerUpdate({}, eventData);
		}
		_setLoaderData  () {
		    let data = this._data;
		    let options = this._opts;
		    let loaderIconClassName = options.loaderIconClassName;
		    let loaderData = this._loaderData = {};
		    let loaderSVGIconId = options.loaderSVGIconId;
		    loaderData.icon = undefined;
		    if (loaderIconClassName || loaderSVGIconId) {
		        loaderData.icon = ZC._getIconInfo(loaderIconClassName, loaderSVGIconId, '#zc__svg--loader zeffects--rotate', this._CLASSES.loader + ' zh-loading', data.loader = {}); // No I18N
		    }
		    loaderData.id = this._getKeyID('loader'); // No I18N
		    this._data.loader = this._loaderData;
		}
		_removeLoader  () {
		    this._loading = false;
		}
		_bindAjaxEvents  (callbacks) {
		    callbacks.requeststart = this._onReqStart.bind(this);
		    callbacks.requestend = this._onReqEnd.bind(this);
		    callbacks.requesterror = this._onReqErr.bind(this);
		}
		// Method to handle before ajax request starts
		_onReqStart  (eventData) {
		    this._showLoader();
		    this._trigger('requeststart', null, eventData); // No I18N
		}
		// Method to handle when ajax reuwst ends
		_onReqEnd  (eventData) {
		    this._removeLoader();
		    this._trigger('searchsuccess', null, eventData); // No I18N
		}
		// Method to handle when ajax request fails
		_onReqErr  (eventData) {
		    this._removeLoader();
		    this._showWarning('serverError'); // No I18N
		    this._trigger('searcherror', null, {// No I18N
		        response: eventData
		    });
		    // console.log("ajaxreq error");
		}
		_bindInputFieldEvents  () {
		    let inputSettings = this._opts.searchFieldOptions;
		    if (inputSettings.handleEvents) {
		        this.inputField.off('.' + this.name); // No I18N
		        let events = {
		            fieldFocus: 'focus', // No I18N
		            fieldBlur: 'blur', // No I18N
		            fieldKeydown: 'keydown', // No I18N
		            inputMouseup: 'mouseup', // No I18N
		            inputKeyup: 'keyup' // No I18N
		        }
		        // When pasted, input event is automatically triggered for recent browsers.
		        if (ZC.Browser.isIE) {
		            events.paste = 'paste'; // No I18N
		        }
		        this._addEvents(events, this.inputField);
		        // 'input' event is erroneous even in IE11, hence keyup event is used instead for IE all versions.
		        this.inputField.on((ZC.Browser.isIE ? 'keyup' : 'input') + '.' + this.name, this._inputHandler.bind(this)); // No I18N
		    }
		}
		_fieldKeydownHandler  (orgEvent) {
		    let code = orgEvent.keyCode;
		    let ZkeyCode = ZC.keyCode;
		    if (this._opts.searchFieldOptions.preventUPDOWNKeysDefault) {
		        if (code === ZkeyCode.UP || code === ZkeyCode.DOWN) {
		            orgEvent.preventDefault();
		        }
		    }
		    // In Firefox, pressing ESC shows old value bug --> https://bugzilla.mozilla.org/show_bug.cgi?id=524360 and hence the event is prevented.
		    if (code === ZkeyCode.ESCAPE) {
		        orgEvent.preventDefault();
		    }
		    if (!this._showSearchField) {
		        this._keydownHandler(orgEvent);
		    }
		}
		_fieldFocusHandler  (orgEvent) {
		    this._updateFieldClass();
		    if (!this._showSearchField) {
		        this._focusInHandler(orgEvent);
		    }
		}
		_fieldBlurHandler  (orgEvent) {
		    this._updateFieldClass();
		    if (!this._showSearchField) {
		        this._blurHandler(orgEvent);
		    }
		}
		_inputHandler  (orgEvent) {
		    /* Note -- Issue fix - activeElement check is done here because in IE10 and IE11, input is triggered whenever placeholder is shown in the input field on blur. */
		    if (!ZC.Browser.isIE || orgEvent.target === document.activeElement) {
		        if (!orgEvent.target.disabled) {
		            if (orgEvent.type === 'input' || this._isAlphaNumericKey(orgEvent)) { // No I18N
		                this._inputChangeHandler(orgEvent);
		            }
		        }
		    }
		}
		_inputChangeHandler  (orgEvent) {
		    let value = orgEvent.target.value;
		    if (this._trigger('input', orgEvent, {// No I18N
		        pasteAction: orgEvent.type === 'input' && orgEvent.originalEvent && orgEvent.originalEvent.inputType === 'insertFromPaste' // No I18N
		    })) {
		        /* Value is passed here because the input content might vary when autoComplete is done in combobox */
		        this._searchWithDelay(value, {
		            event: orgEvent,
		            delay: this._opts.search.delay
		        });
		    }
		}
		_inputKeyupHandler  (orgEvent) {
		    if (this._opts.searchFieldOptions.filterBasedOnCurPos) {
		        let ZkeyCode = ZC.keyCode;
		        let keyCode = orgEvent.keyCode;
		        if ([ ZkeyCode.LEFT,
		            ZkeyCode.RIGHT,
		            ZkeyCode.HOME,
		            ZkeyCode.END ].indexOf(keyCode) > -1) {
		            this._searchBasedOnCurPos(orgEvent);
		        }
		    }
		}
		_searchBasedOnCurPos  (orgEvent, delay) {
		    if (!orgEvent.button) {
		        this._searchWithDelay(undefined, {
		            event: orgEvent,
		            delay: delay || this._opts.search.delay,
		            searchOnCurPos: true
		        });
		    }
		}
		_inputMouseupHandler  (orgEvent) {
		    if (this._opts.searchFieldOptions.filterBasedOnCurPos) {
		        this._searchBasedOnCurPos(orgEvent);
		    }
		}
		_pasteHandler  (orgEvent) {
		    clearTimeout(this._searchTimer);
		    if (!orgEvent.target.disabled) {
		        this._searchTimer = setTimeout(() => {
		            // let value = orgEvent.target.value;
		            if (this._trigger('input', orgEvent, {// No I18N
		                pasteAction: true
		            })) {
		                this._searchWithDelay(undefined, {
		                    event: orgEvent,
		                    delay: this._opts.search.delay
		                });
		            }
		        });
		    }
		}
		// Method to set the inputfield value if given
		_setFieldValue  ($item, itemData, orgEvent, autoCompleted) {
		    if (itemData.selectable && (autoCompleted || this._opts.searchFieldOptions.updateOnSelect)) {
		        let eventData = this._getItemEventData($item, itemData);
		        if (autoCompleted) {
		            eventData.autoCompleted = true;
		        }
		        if (this._trigger('beforesearchfieldupdate', orgEvent, eventData)) { // No I18N
		            this.inputField[0].value = this._getProp(itemData.normalisedData, 'text'); // No I18N
		            this._trigger('searchfieldupdate', orgEvent, eventData); // No I18N
		        }
		    }
		}
		_autofill  ($item, itemData, orgEvent) {
		    if (orgEvent && orgEvent.type === 'keydown' && (orgEvent.keyCode === ZC.keyCode.UP || orgEvent.keyCode === ZC.keyCode.DOWN)) { // No I18N
		        if (!this._selectOnFocus && this._opts.searchFieldOptions.autoComplete) {
		            this._setFieldValue($item, itemData, orgEvent, true);
		        }
		    }
		}
		_filterByAddRemoval  (orgEvent) {
		    // Initialisation related to virtualisation
		    this.params.pageIndex = 1;
		    this._scroll = {};
		    this._groupsIncluded = [];
		    if (this.DSInstance._serverPaging) {
		        this.params.serverPageIndex = 0;
		        this.params.moreServerPages = true;
		    }
		    this._unbindScroll && this._unbindScroll();
		    if (this._virtualization) {
		        this._showVirtualData(orgEvent);
		    } else {
		        this[this._lazyLoadData ? '_loadFirstPage' : '_loadDataSource'](this._addDataToMenu.bind(this), orgEvent); // No I18N
		    }
		}
		_addDataToMenu  (filteredData, orgEvent) {
		    let eventData = {
		        results: filteredData,
		        params: this.params
		    };
		    filteredData = eventData.results;
		    eventData.addedItems = this[this._freshRequest ? '_replaceBodyItems' : '_addBodyItems'](filteredData, true, orgEvent); // No I18N
		    // else if (this._freshRequest) {
		    //     // If there are no items, the items must be removed.
		    //     this._hideAllItems();
		    // }
		    this._afterFilter(orgEvent, eventData, !this._freshRequest);
		}
		_filterListViaStyles  (orgEvent) {
		    if (this._dataLoaded) {
		        this._triggerBeforeUpdate(orgEvent);
		        this._applyFilterStyles();
		        this._updateStates(orgEvent);
		        this._afterFilter(orgEvent);
		    } else {
		        this._openList(orgEvent, true);
		    }
		}
		// Filter results using css style tag
		_openList  (orgEvent, applyFilterStyle) {
		    let query = this.params.query;
		    this.params.query = ''; // No I18N
		    this._loadDataSource((dataSource) => {
		        let eventData = {
		            results: dataSource,
		            params: this.params
		        };
		        this.params.query = query;
		        applyFilterStyle && this._applyFilterStyles();
		        eventData.addedItems = this._replaceBodyItems(dataSource, true, orgEvent);
		        this._afterFilter(orgEvent, eventData);
		        this._dataLoaded = true;
		    }, orgEvent);
		}
		/* Function to inject styles for filtering */
		_applyFilterStyles  () {
		    let query = this.params.query;
		    if (query && query.length) {
		        let search = this._opts.search || {};
		        if (!search.caseSensitive) {
		            query = query.toLowerCase();
		        }
		        let operator = search.criteria === 'startswith' ? '^' : '*'; // No I18N
		        let styles = `#${this._id} .${this._CLASSES.body} > *:not(.${this._CLASSES.itemgroup})${this._getSearchBy(this._opts.search.by).map((by) => `:not([data-${by}${operator}="${this._escapeQuery(query)}"])`).join('')}:not(#${this._getKeyID('noresults')}) {display:none !important;}`; // No I18N
		        this._injectStyle(styles);
		        // if (this._isGrouped) {
		        //     let groupIDsToHide = [];
		        //     this._groupsIncluded.forEach((groupData) => {
		        //         let groupId = groupData.id;
		        //         if (!this.getFirstItem('[name=' + groupId + ']')) {// No I18N
		        //             groupIDsToHide.push('#' + groupId); // No I18N
		        //         }
		        //     });
		        //     if (groupIDsToHide.length) {
		        //         styles += (groupIDsToHide.join(',') + '{display:none; !important}'); // No I18N
		        //     }
		        //     this._injectStyle(styles);
		        // }
		    } else {
		        this._removeStyle();
		    }
		}
		_getAttrForCSSFilter  (data, attrs) {
		    let searchBy = this._getSearchBy(this._opts.search.by);
		    searchBy.forEach((by) => {
		        let value = data[by];
		        if (this._isNotNull(value)) {
		            attrs['data-' + by] = this._opts.search.caseSensitive ? value : value.toLowerCase(); // No I18N
		        }
		    });
		}
		_injectStyle  (styles) {
		    if (!this.styletag) {
		        this.styletag = $('<style id=' + this._getKeyID('style') + '>').appendTo($('head')); // No I18N
		    }
		    this.styletag.text(styles);
		}
		_hideItemsUsingCSS  () {
		    this._injectStyle(`#${this._id} .${this._CLASSES.body} > * {display:none; !important}`); // No I18N
		}
		// Since highlighting in filterByCSSSelector method causes reference issues while using templates, -- this is not currently used.
		// _highlightInList  (eventData, removeStyle) {
		//     let addedItems = eventData && eventData.addedItems;
		//     let query = removeStyle ? '' : this.params.query;
		//     if (query || this._highlighted) {
		//         this._highlighted = !!query;
		//         let highlightData = this._getHighlightData(query);
		//         let includeText = highlightData.includeText;
		//         let includeTitle = highlightData.includeTitle;
		//         let includeDesc = highlightData.includeDesc;
		//         let classes = this._CLASSES;
		//         let selector = ''; // No I18N
		//         if (includeTitle) {
		//             selector += ('.' + classes.itemgrouplabel); // No I18N
		//         }
		//         if (includeText) {
		//             selector += ((selector ? ',' : '') + '.' + classes.text); // No I18N
		//         }
		//         if (includeDesc) {
		//             selector += ((selector ? ',' : '') + '.' + classes.hint); // No I18N
		//         }
		//         if (selector) {
		//             addedItems = addedItems || [ ...this._listBody[0].children ];
		//             addedItems.forEach((item) => {
		//                 if (!this._styleBasedFilter || $(item).css('display') !== 'none') { // No I18N
		//                     item = $(item);
		//                     if (includeTitle || !item.is('.' + classes.itemgroup)) { // No I18N
		//                         let elements = item.find(selector);
		//                         for (let i = 0; i < elements.length; i++) {
		//                             let innerHTML = elements[i].textContent;
		//                             elements[i].innerHTML = query ? this._highlightContent(innerHTML, highlightData.pattern) : innerHTML;
		//                         }
		//                     }
		//                 }
		//             });
		//         }
		//     }
		// }
		_getItemJSONForGroupedData  (dataSource) {
		    let itemJSON = [];
		    dataSource.forEach((data) => {
		        let groupLabelMapKey = 'groupLabel'; // No I18N
		        let groupLabel = this._getProp(data, groupLabelMapKey);
		        let groupID;
		        let groupData = groupLabel = this._isNotNull(groupLabel) ? groupLabel : ''; // No I18N
		        // Directly .groupLabel is taken since it is assigned directly.
		        // let matchingGroupData = this._groupsIncluded.find((gData) => groupLabel === gData.groupLabel);
		        // Only last group is compared becos if the current group even when arrived before is not the same as that of last group, then it must be displayed again.
		        let groupsIncluded = this._groupsIncluded;
		        let lastGroup = groupsIncluded[groupsIncluded.length - 1];
		        if (lastGroup && lastGroup.groupLabel === groupLabel) {
		            groupData = lastGroup;
		        } else {
		            if (this._groupHeads.length) {
		                groupData = this._groupHeads.find((data) => groupLabel === data.label) || ''; // No I18N
		            }
		            groupData = this.getItemData(groupData, null, true);
		            // Empty heading is not added as group
		            groupLabel && itemJSON.push(groupData);
		            this._groupsIncluded.push(groupData);
		        }
		        groupID = groupData.id;
		        let itemData = this.getItemData(data, groupID)
		        itemJSON.push(itemData);
		    });
		    return itemJSON;
		}
		_setHeaderFooterItems  () {
		    let headerItems = (this._opts.headerItems || []).concat(this._htmlHeaderItems);
		    let footerItems = (this._opts.footerItems || []).concat(this._htmlFooterItems);
		    if ((headerItems && headerItems.length) || (footerItems && footerItems.length)) {
		        let headerArr = [],
		            footerArr = [];
		        if (headerItems) {
		            headerArr = headerItems.map((data) => this.getItemData(data, null, null, 'header')); // No I18N
		        }
		        if (footerItems) {
		            footerArr = footerItems.map((data) => this.getItemData(data, null, null, 'footer')); // No I18N
		        }
		        this._data.headerItems = headerArr.length && headerArr;
		        this._data.footerItems = footerArr.length && footerArr;
		    } else {
		        this._data.headerItems = this._data.footerItems = undefined;
		    }
		}
		_getHeaderFooterItem  (data) {
		    let headerItems = (this._opts.headerItems || []).concat(this._htmlHeaderItems);
		    let footerItems = (this._opts.footerItems || []).concat(this._htmlFooterItems);
		    let headerFooterItems = headerItems.concat(footerItems);
		    let valueToMatch = this._getUniqueValue(data);
		    for (let i = 0; i < headerFooterItems.length; i++) {
		        let itemData = headerFooterItems[i];
		        if (valueToMatch === this._getUniqueValue(itemData)) {
		            return itemData;
		        }
		    }
		}
		_getHighlightData  (query) {
		    let search = this._opts.search;
		    if (!this._highlightData) {
		        let searchBy = this._getSearchBy(search.by);
		        let includeText;
		        let includeTitle;
		        let includeDesc;
		        if (this.DSInstance._isJSONSource) {
		            let dataMapping = this._dataMapping;
		            let text = dataMapping.text;
		            let groupLabel = dataMapping.groupLabel;
		            let description = dataMapping.informativeText;
		            includeText = searchBy.indexOf(text) > -1;
		            includeTitle = searchBy.indexOf(groupLabel) > -1;
		            includeDesc = searchBy.indexOf(description) > -1;
		        }
		        this._highlightData = {
		            includeText,
		            includeTitle,
		            includeDesc
		        }
		    }
		    this._highlightData.pattern = this._getMatchingRegex(query, search);
		    return this._highlightData;
		}
		_highlightValidKey  (content, key) {
		    let search = this._opts.search;
		    let query = this.params.query;
		    let pattern = this._getMatchingRegex(ZC.encodeHTML(query), search);
		    let fieldsToHighlight = search.fieldsToHighlight;
		    if (fieldsToHighlight && fieldsToHighlight.length) {
		        fieldsToHighlight = Array.isArray(fieldsToHighlight) ? fieldsToHighlight : fieldsToHighlight.split(','); // No I18N
		    } else {
		        fieldsToHighlight = this._getSearchBy(search.by);
		    }
		    if (fieldsToHighlight.indexOf(key) !== -1) {
		        return this._highlightContent(content, pattern);
		    }
		    return content;
		}
		_highlightContent  (content, pattern) {
		    return content.replace(pattern, "<b class='zh-bold'>$1</b>"); // No I18N
		}
		_parseHTMLInput  () {
		    let options = this._opts;
		    let dataSource = options.dataSource;
		    let itemDatas = options.items;
		    if (!this._isAjaxSource(dataSource) && (!itemDatas || !itemDatas.length)) {
		        let initialDS = this._getDataSource();
		        itemDatas = [];
		        initialDS.forEach((item) => {
		            if (item.isHeader) {
		                this._htmlHeaderItems.push(item);
		            } else if (item.isFooter) {
		                this._htmlFooterItems.push(item);
		            } else {
		                itemDatas.push(item);
		            }
		        });
		        if (this._isGrouped) {
		            itemDatas = this._flattenData(itemDatas);
		        }
		        options.items = itemDatas;
		        if (itemDatas.length) {
		            this._htmlTagData = true;
		        }
		    }
		}
		_getDataSource  () {
		    let subOptions = this._getValidSubOptions(this.element, true);
		    if (this.isCE) {
		        let selectors = this._SELECTORS;
		        let newOptions = [];
		        let regex = new RegExp(`(${selectors.OPTIONSHEADER}|${selectors.OPTIONSFOOTER}|${selectors.OPTIONSBODY})`, 'i'); // No I18N
		        subOptions.forEach((option) => {
		            let tagName = option.tagName.toLowerCase();
		            if (regex.test(tagName)) {
		                let isHeader, isFooter;
		                if (tagName === selectors.OPTIONSHEADER) {
		                    isHeader = true;
		                } else if (tagName === selectors.OPTIONSFOOTER) {
		                    isFooter = true;
		                }
		                let subOptions = this._getValidSubOptions($(option), true);
		                subOptions.forEach((subOption) => {
		                    let optData = ZC._getOpts(subOption);
		                    optData.isHeader = isHeader;
		                    optData.isFooter = isFooter;
		                });
		                newOptions.push(...this._getValidSubOptions($(option), true));
		            } else {
		                newOptions.push(option);
		            }
		        });
		        if (!newOptions.length || !newOptions[0]._initialized) {
		            return [];
		        }
		        subOptions = newOptions;
		    }
		    return this._genDataForTag(subOptions);
		}
		_getValidSubOptions  (parent, includeOptGroup) {
		    let selectors = this._SELECTORS;
		    let allowedTags = [ selectors.OPTION ];
		    if (includeOptGroup) {
		        allowedTags.push(selectors.OPTGROUP);
		    }
		    if (this.isCE) {
		        allowedTags.push(...[ selectors.OPTIONSEPARATOR ]);
		        if (parent.is(this.element)) {
		            allowedTags.push(...[ selectors.OPTIONSHEADER, selectors.OPTIONSFOOTER, selectors.OPTIONSBODY ]);
		        }
		    }
		    return parent.children(allowedTags.join(',')).toArray(); // No I18N
		}
		/* Function to construct the menu object with which menu can be created */
		_genDataForTag  (options, groupData) {
		    return options.map((option) => {
		        let optData = ZC._getOpts(option);
		        optData.id = option.id;
		        let tagName = option.tagName.toLowerCase();
		        if (this.isCE && tagName === this._SELECTORS.OPTIONSEPARATOR) {
		            optData.separator = true;
		        }
		        if (!optData.separator) {
		            let label = this._isNotNull(option.label) ? option.label : ''; // No I18N
		            optData.value = this._isNotNull(option.value) ? option.value : label;
		            if (tagName === this._SELECTORS.OPTGROUP) {
		                let subOptions = this._getValidSubOptions($(option));
		                if (!this.isCE || subOptions[0]._initialized) {
		                    optData.options = this._genDataForTag(subOptions, optData);
		                }
		                optData.isOptGroup = this._isGrouped = true;
		                optData.groupLabel = label;
		            } else {
		                optData.innerHTML = option.innerHTML || option.zinnerHTML;
		                label = label || option.textContent.trim();
		                optData.selected = option.selected || optData.selected;
		            }
		            optData.text = label;
		            optData.title = optData.title || (this._opts.contentType === 'image' ? optData.label : undefined); // No I18N
		        }
		        optData.disabled = optData.disabled || option.disabled;
		        if (groupData) {
		            optData.groupName = groupData.value;
		            optData.isHeader = groupData.isHeader;
		            optData.isFooter = groupData.isFooter;
		            optData.disabled = optData.disabled || groupData.disabled;
		        }
		        // Since hidden property is not available in IE10 and below, attribute check is included.
		        optData.hidden = optData.hidden || (typeof option.hidden === 'boolean' ? option.hidden : option.hasAttribute('hidden')) || undefined; // No I18N
		        optData.className = option.className || optData.className;
		        optData.style = optData.style || option.getAttribute('style'); // No I18N
		        // if (!optData.zitemid) {
		        //     let itemid;
		        //     if (optData.id) {
		        //         itemid = this.name + '-' + this._menuID + '-option-' + optData.id; // No I18N
		        //     } else {
		        //         itemid = this._getKeyID(null, this._menuID + '-option');// No I18N
		        //     }
		        //     optData.zitemid = itemid;
		        // }
		        // optData.zpopulated = true;
		        // if (this.isCE) {
		        //     let parentEle = option.parentElement;
		        //     if (groupData) {
		        //         parentEle = parentEle.parentElement;
		        //     }
		        //     if (parentEle) {
		        //         // this._addedByComponent = true;
		        //         // option.setAttribute('data-zitemid', optData.zitemid); // No I18N
		        //         // this._addedByComponent = false;
		        //         // optData.element = option;
		        //         /* For isCE - instance is stored */
		        //         option.saveParentIns(this.element);
		        //     }
		        // }
		        option.optData = optData;
		        return optData;
		    });
		}
		_setImageData  (itemData) {
		    itemData.hasImage = true;
		    let view = itemData.view;
		    [ 'SVGIconId', 'iconClassName', 'image', 'textIcon' ].forEach((key) => { // No I18N
		        this._setKeyValue(itemData, key, false);
		    });
		    let textIcon = itemData.textIcon;
		    if (this._hasIcon) {
		        let SVGIconId = itemData.SVGIconId;
		        let iconClassName = itemData.iconClassName;
		        if (iconClassName || SVGIconId || !textIcon) {
		            view.icon = {};
		            ZC._getIconInfo(iconClassName, SVGIconId, '', this._CLASSES.itemicon, view.icon); // No I18N
		            return;
		        }
		    } else if (this._hasImage) {
		        if (itemData.image) {
		            view.hasImageURL = true;
		            view.image = itemData.image;
		            return;
		        }
		    }
		    view.textIcon = textIcon;
		}
		/* Function to bind scroll to menu */
		_bindScroll  () {
		    this._addEvents({
		        wheel: this._wheelEvents
		    }, this._listBody);
		    this._considerScrollForLazyLoad = true;
		}
		/* Function to unbind scroll for menu */
		_unbindScroll  () {
		    this._removeEvents(this._wheelEvents, this._listBody);
		    this._considerScrollForLazyLoad = false;
		}
		_wheelHandler  () {
		    this._scrolledOnKeyDown = false;
		}
		_scrollHandlerToLoadPage  (orgEvent) {
		    let scrollTop = this._listBody[0].scrollTop;
		    this._lastScrollTop = scrollTop;
		    /* In the middle of ajax request, when another request is made, previous request is aborted which results in some page not getting loaded. Hence when there is an ongoing request, scrollhandler is not executed */
		    if (!this._loading) {
		        this._freshRequest = false;
		        let isBackwards = this._lastScrollTop > scrollTop;
		        let menuHt = this._listBody[0].offsetHeight;
		        let exceeded = !isBackwards && (scrollTop + menuHt + 5) > this._listBody[0].scrollHeight;
		        this._scroll = {
		            isBackwards,
		            exceeded,
		            menuHt
		        }
		        if (this._virtualization) {
		            this._showVirtualData(orgEvent);
		        } else if (exceeded) {
		            /*
		                Get Next page and load it to menu
		                If next page is not present. Scroll is unbinded.
		            */
		            this._getNextPage((filteredData) => this._addDataToMenu(filteredData, orgEvent));
		        }
		    }
		}
		_noMorePageHandler  (orgEvent) {
		    if (this._virtualization) {
		        this._updateVirtualData(orgEvent);
		    } else {
		        this._unbindScroll();
		    }
		}
		_getNextPage  (successCallback, orgEvent) {
		    let params = this.params;
		    if (!this._firstRequest) {
		        if (params.pageIndex < params.totalPages) {
		            params.pageIndex++;
		        } else if (params.moreServerPages) {
		            params.pageIndex = 1;
		            params.serverPageIndex++;
		            // this._groupsIncluded = [];
		        } else {
		            if (this._results) {
		                let finalResults = this._results;
		                this._results = undefined;
		                successCallback(finalResults);
		            }
		            this._noMorePageHandler(orgEvent);
		            return;
		        }
		    }
		    this._firstRequest = false;
		    this._loadDataSource((_results) => {
		        params = this.params;
		        this._results = (this._results || []).concat(_results);
		        let totalCount = this._results.length;
		        if (this._dsInit && totalCount < this._viewPerPage && (params.moreServerPages || params.pageIndex < params.totalPages)) {
		            this._getNextPage(successCallback, this._results);
		        } else {
		            let finalResults = this._results;
		            this._results = undefined;
		            successCallback(finalResults, orgEvent);
		        }
		    }, orgEvent);
		}
		_loadFirstPage  (successCallback, orgEvent) {
		    this._firstRequest = true;
		    this._getNextPage(successCallback, orgEvent);
		}
		_setMoreResults  () {
		    let classes = this._CLASSES;
		    this._data.moreAction = {
		        id: this._getKeyID('moreresults'), // No I18N
		        custom: true,
		        className: classes.moreresults, // No I18N
		        disabled: this._opts.disabled,
		        moreresults: true,
		        clickable: true,
		        view: {
		            innerHTML: '<span class=' + classes.text + '>' + this._getText('moreAction') + '</span>' // No I18N
		        }
		    }
		}
		_isValidMultiSelectClick  (orgEvent, select = true, item) {
		    let target = orgEvent.target;
		    let isCheckboxClick = this._isCheckboxClick(orgEvent);
		    let selectorToIgnoreSelection = this._opts.selectorToIgnoreSelection;
		    if (!isCheckboxClick && selectorToIgnoreSelection && $(target).is(selectorToIgnoreSelection)) {
		        return false;
		    }
		    if (this._selectOnFocus) {
		        if (!select) {
		            if (this._toggleOnItemClick || isCheckboxClick) {
		                return true;
		            }
		            if (item[0] === target || item.find(target).length) {
		                return false;
		            }
		        }
		    } else {
		        if (this._toggleOnItemClick || isCheckboxClick) {
		            return true;
		        }
		        return false;
		    }
		    return true;
		}
		selectAll  (orgEvent) {
		    if (this._opts.multiple && this.staticData) {
		        this.fetchData((response) => {
		            this._setValues(response.results, {
		                event: orgEvent
		            });
		        });
		    }
		}
		setValues  () {
		    this._opts.multiple && this.setValue(...arguments);
		}
		getValues  () {
		    return this.getValue();
		}
		// Method to convert grouped datas to flat datas
		_flattenData  (dataSource) {
		    let dataMapping = this._dataMapping;
		    this._isGrouped = true;
		    this._groupHeads = this._groupHeads || [];
		    dataMapping.groupLabel = dataMapping.groupLabel || 'groupLabel'; // No I18N
		    // if (!this._flatted) {
		    dataSource = this._restructData(dataSource, null, this._opts.dataMapping.groupLabel || dataMapping.text);
		    // }
		    // this._flatted = true;
		    return dataSource;
		}
		_restructData  (dataSource, groupData, groupLabelKey) {
		    let newDS = [];
		    let dataMapping = this._dataMapping;
		    let subGroupLabel = dataMapping.options;
		    dataSource.forEach((data) => {
		        let subOptions = data[subGroupLabel];
		        if (subOptions) {
		            this._groupHeads.push(data);
		            this._setProp(data, 'groupLabel', this._mapJSONToData(data, groupLabelKey)); // No I18N
		            newDS = newDS.concat(this._restructData(subOptions, data));
		        } else {
		            if (groupData) {
		                this._setProp(data, 'groupLabel', this._getProp(groupData, 'groupLabel')); // No I18N
		                data.hidden = data.hidden || groupData.hidden;
		                data.disabled = data.disabled || groupData.disabled;
		            }
		            newDS.push(data);
		        }
		    });
		    return newDS;
		}
		_setNoResultsData  () {
		    this._data.noResults = {
		        // innerHTML: this._warningMsg || this._getText('noResults'), // No I18N\
		        id: this._getKeyID('noresults'), // No I18N
		        noresults: true
		    }
		}
		_initSortable  () {
		    let listBody = this._listBody;
		    let instance = listBody.data('zsortable'); // No I18N
		    if (instance) {
		        ZC.sortable(listBody).refresh();
		    } else {
		        ZC.sortable(listBody, {
		            region: 'parent', // No I18N
		            items: `.${this._CLASSES.item}[data-selectable=true]:not(.${this._CLASSES.disabled})`, // No I18N
		            end: this._onDragEnd.bind(this),
		            drag: this._onDragStart.bind(this)
		        });
		    }
		}
		_onDocMouseUp  (orgEvent) {
		    this._removeDocEvent();
		    orgEvent.preventDefault();
		}
		_onDragStart  (orgEvent) {
		    if (this._dragging) {
		        this._trigger('drag', orgEvent, { // No I18N
		            item: this._draggedEle
		        });
		    } else {
		        document.addEventListener('mouseup', this._docMouseUpHandler, true); // No I18N
		        orgEvent = orgEvent.originalEvent;
		        let draggedElement = this._getClosestItem($(orgEvent.target));
		        this._draggedEle = this._prevEleBeforeDrag = undefined;
		        if (draggedElement) {
		            let eventData = {
		                item: draggedElement
		            };
		            this._dragging = true;
		            this._draggedEle = draggedElement;
		            let id = draggedElement[0].id;
		            this.focusItem(draggedElement[0], orgEvent, false);
		            if (!this._DOMChanges[id]) {
		                this._DOMChanges[id] = draggedElement[0].previousSibling;
		            }
		            this._trigger('dragstart', orgEvent, eventData); // No I18N
		        }
		    }
		}
		_replaceMovedItems  () {
		    let DOMChanges = this._DOMChanges;
		    let lastScrollTop = this._lastScrollTop;
		    for (let key in DOMChanges) {
		        this._getById(key).insertAfter(DOMChanges[key]);
		    }
		    this._listBody[0].scrollTop = lastScrollTop;
		}
		_onDragEnd  (orgEvent) {
		    orgEvent = orgEvent.originalEvent;
		    let draggedElement = this._draggedEle;
		    if (draggedElement) {
		        let datasource = this._datasource;
		        let prevEle = draggedElement.prev();
		        let count = 0;
		        let items = this._data.items;
		        for (let i = 0; i < items.length; i++) {
		            items[i].index = count;
		            if (!items[i].heading) {
		                count++;
		            }
		        }
		        let initialIndex = this._getStoredData(draggedElement).index;
		        let prevEleIndex = -1;
		        let isHeading;
		        if (prevEle.length) {
		            let prevEleData = this._getStoredData(prevEle);
		            isHeading = prevEleData.heading;
		            prevEleIndex = prevEleData.index;
		        }
		        let currentIndex = prevEleIndex + (isHeading ? 0 : 1);
		        if (initialIndex !== currentIndex) {
		            // Todo: Temp - it is a temporary since templates doesn't work well with cached elements.
		            // draggedElement.insertAfter(this._prevEleBeforeDrag);
		            let itemData = datasource[initialIndex];
		            if (this._isGrouped) {
		                // let groupLabel = this._dataMapping.groupLabel;
		                let sibData = datasource[prevEleIndex];
		                let groupLabelMapKey = 'groupLabel'; // No I18N
		                let groupLabel = this._getProp(sibData, groupLabelMapKey); // No I18N
		                this._setProp(itemData, groupLabelMapKey, groupLabel); // No I18N
		            }
		            if (initialIndex < currentIndex) {
		                currentIndex = currentIndex - 1;
		            }
		            datasource.splice(initialIndex, 1);
		            datasource.splice(currentIndex, 0, itemData);
		            if (this._opts.cacheData) {
		                let DSOptions = this.DSInstance._opts;
		                DSOptions.data = this._datasource;
		                DSOptions.dataSource = null;
		                this.DSInstance = this._initDSInstance(DSOptions);
		            } else {
		                this.DSInstance.setCachedData(datasource);
		            }
		            this._rebuildItems(true);
		            this._data.items.forEach((itemData) => this._updateData(itemData));
		            this._trigger('dragend', orgEvent, { // No I18N
		                item: draggedElement,
		                itemData,
		                initialIndex,
		                currentIndex
		            });
		            // orgEvent.stopImmediatePropagation();
		        }
		    }
		    this._dragging = false;
		}
		// searchOnCurPos
		search  (query, searchOpts = {}) {
		    // this.params.previousQuery = undefined;
		    searchOpts.fromSearchMethod = true;
		    if (searchOpts.delay) {
		        this._searchWithDelay(query, searchOpts);
		    } else {
		        this._search(query, searchOpts);
		    }
		}
		// delay, searchOnCurPos
		searchWithDelay  (query, searchOpts = {}) {
		    // this.params.previousQuery = undefined;
		    searchOpts.fromSearchMethod = true;
		    this._searchWithDelay(...arguments);
		}
		// delay, searchOnCurPos
		_searchWithDelay  (query, searchOpts = {}) {
		    clearTimeout(this._searchTimer);
		    let args = [ query, searchOpts ];
		    if (searchOpts.delay) {
		        this._searchTimer = setTimeout(() => {
		            this._search(...args);
		        }, searchOpts.delay);
		    } else {
		        this._search(...args);
		    }
		}
		// searchOnCurPos, force
		_search  (query, searchOpts = {}) {
		    let inputField;
		    if (this.inputField) {
		        if (searchOpts.fromSearchMethod) {
		            if (searchOpts.updateField !== false) {
		                let oldValue = this.inputField.val();
		                // The field is updated only when the previous value doesn't match current value since simply updating it moves the cursor position to the end in Safari browser.
		                if (oldValue !== query) {
		                    this.inputField.val(query);
		                }
		            }
		        }
		        inputField = this.inputField[0];
		        this._showSearchField && this._updateClearBtn();
		    }
		    if (!this._isNotNull(query) && inputField) {
		        query = inputField.value;
		    }
		    if (query && searchOpts.searchOnCurPos && inputField) {
		        let selectionStart = inputField.selectionStart;
		        let selectionEnd = inputField.selectionEnd;
		        if (selectionStart !== selectionEnd) {
		            selectionStart = query.length - 1;
		        }
		        query = query.substring(0, selectionStart);
		    }
		    searchOpts = $.extend({}, this._opts.search, searchOpts);
		    query = query || ''; // No I18N
		    if (searchOpts.trimWhitespace) {
		        query = query.trim();
		    }
		    this.params.query = this._opts.query = query;
		    if (this._trigger('beforesearch', searchOpts.event, {// No I18N
		        params: this.params,
		        searchOptions: searchOpts
		    })) {
		        this._filterData(searchOpts.event, searchOpts);
		    }
		}
		_filterData  (orgEvent, searchOpts) {
		    let options = this._opts;
		    let params = this.params;
		    this._opts.query = params.query;
		    let isSufficientQuery = this._checkQueryLength(params.query, searchOpts);
		    // Check with previous and open the previous menu incase query is the same.
		    this._fromSearch = this._isNotNull(searchOpts.setItemFocus) ? searchOpts.setItemFocus : true;
		    if (!searchOpts.force && options.cacheData && params.query === params.previousQuery) {
		        this._updateStates(orgEvent);
		        return;
		    }
		    this.params.previousQuery = this.params.query;
		    this._hideNoResults(false);
		    this._freshRequest = true;
		    if (!this._skipScrollTopReset) {
		        this._lastScrollTop = 0;
		    }
		    this._skipScrollTopReset = false;
		    if (this._dsInit && isSufficientQuery) {
		        this._filterFn(orgEvent);
		    } else if (isSufficientQuery) {
		        this._showNoResults(orgEvent);
		    } else {
		        params.previousQuery = undefined;
		        this._showWarning('minKeywordLength', orgEvent); // No I18N
		    }
		    this._fromSearch = false;
		}
		_checkQueryLength  (query, searchOpts) {
		    let minKeywordLength = searchOpts.minKeywordLength;
		    return !minKeywordLength || !this._searchable || (query.length >= minKeywordLength);
		}
		_setSearchFieldData  () {
		    let searchFieldOptions = this._opts.searchFieldOptions;
		    let classes = this._CLASSES;
		    let searchBox = this._data.searchBox = {
		        disabled: this._opts.disabled,
		        id: this._getKeyID('searchbox') // No I18N
		    }
		    ZC._getIconInfo(searchFieldOptions.iconClassName, searchFieldOptions.SVGIconId, '#zc__svg--search', classes.searchicon, searchBox.icon = {}); // No I18N
		    if (searchFieldOptions.clearButton) {
		        searchBox.clearButtonId = this._getKeyID('clearbutton'); // No I18N
		        ZC._getIconInfo(searchFieldOptions.clearButtonIconClassName || searchFieldOptions.clearButtonIconClass, searchFieldOptions.clearButtonSVGIconId, '#zc__svg--clear', classes.clearbuttonicon, searchBox.clearButton = {}); // No I18N
		        searchBox.clearButtonTitle = this._getMsg('clear'); // No I18N
		        searchBox.clearFn = {
		            handler: () => {
		                let value = this.inputField.val();
		                if (value) {
		                    this.inputField
		                        .val('')// No I18N
		                        .trigger('input');// No I18N
		                }
		                this._focusInputField();
		            },
		            namespace: this.name
		        }
		    }
		}
		_updateClearBtn  () {
		    let clearBtnId = this._data.searchBox.clearButtonId;
		    if (clearBtnId) {
		        let clearBtn = this._getById(clearBtnId);
		        if (this.inputField.val()) {
		            clearBtn[0].style.display = ''; // No I18N
		        } else {
		            clearBtn[0].style.display = 'none'; // No I18N
		        }
		    }
		}
		_setInnerAttr  (optionName, value) {
		    let propResetter = this._propResetter;
		    switch (optionName) {
		        case 'contentType': // No I18N
		        case 'multiSelectInterfacePattern': // No I18N
		        case 'hideCheckbox': // No I18N
		        case 'checkboxPosition': // No I18N
		        case 'checkedIcon': // No I18N
		        case 'checkedIconClassName': // No I18N
		        case 'checkedSVGIconId': // No I18N
		        case 'checkedIconPosition': // No I18N
		        case 'toggleOnItemClick': // No I18N
		        case 'searchFieldOptions': // No I18N
		        case 'actionButtons': // No I18N
		        case 'template': // No I18N
		        case 'focusItemOnItemMouseover': // No I18N
		        case 'selectOnKeyNavigation': // No I18N
		        case 'disabled': // No I18N
		        case 'reorderable': // No I18N
		            propResetter.vars = true;
		            break;
		        case 'searchField': // No I18N
		        case 'showSearchField': // No I18N
		            propResetter.vars = propResetter.search = true;
		            break;
		        case 'dataMapping': // No I18N
		            propResetter.vars = true;
		            if (this._dataMapping.groupLabel !== value.groupLabel) {
		                propResetter.ds = true;
		            }
		            break;
		        case 'multiple': // No I18N
		            propResetter.vars = propResetter.values = true;
		            break;
		        case 'isGrouped': // No I18N
		        case 'lazyLoading': // No I18N
		        case 'virtualization': // No I18N
		        case 'maxPage': // No I18N
		        case 'viewPerPage': // No I18N
		        case 'filterByCSSSelector': // No I18N
		        case 'serverSearch': // No I18N
		        case 'customSearch': // No I18N
		        case 'sort': // No I18N
		        case 'sortBy': // No I18N
		        case 'sortOrder': // No I18N
		        case 'customSorter': // No I18N
		        case 'cacheData': // No I18N
		        case 'filters': // No I18N
		            propResetter.ds = true;
		            break;
		        case 'items': // No I18N
		        case 'dataSource': // No I18N
		        case 'dataStructure': // No I18N
		            if (!this._internal) {
		                this._htmlTagData = this._flatted = undefined;
		            }
		            this._destroyDSIns();
		            propResetter.ds = true;
		            break;
		        case 'search': // No I18N
		            propResetter.vars = propResetter.ds = true;
		            break;
		        case 'allowDragToSelect': // No I18N
		        case 'keyNavigation': // No I18N
		        case 'moreResultsAction': // No I18N
		        case 'allowShiftSelection': // No I18N
		        case 'height': // No I18N
		        case 'width': // No I18N
		        case 'headerItems': // No I18N
		        case 'footerItems': // No I18N
		            this._domChanged = true;
		            break;
		        case 'characterKeyFocus': // No I18N
		            propResetter.rebuildItems = true;
		            break;
		        case 'loaderIconClassName':// No I18N
		        case 'loaderSVGIconId':// No I18N
		            this._domChanged = true;
		            if (this._data.loader) {
		                this._setLoaderData();
		            }
		            break;
		        case 'value': // No I18N
		        case 'selectionLimit': // No I18N
		            this._domChanged = propResetter.values = true;
		            break;
		        case 'messages': // No I18N
		            propResetter.search = true;
		            break;
		        case 'query': // No I18N
		            this.params.query = value;
		            propResetter.search = true;
		            break;
		    }
		}
		_setAttribute  (optionName, value) {
		    let propResetter = this._propResetter;
		    if (!propResetter) {
		        propResetter = this._propResetter = {};
		    }
		    this._opts[optionName] = value;
		    this._setInnerAttr(optionName, value);
		    if (propResetter.vars || propResetter.ds || propResetter.values || propResetter.rebuildItems || propResetter.search || propResetter.rebuildHeaderFooterItems) {
		        this._reInit = true;
		    }
		}
		_buildData  () {
		    this._dataReset = !this.DSInstance;
		    let propResetter = this._propResetter || {};
		    clearTimeout(this._searchTimer);
		    if (propResetter.ds || propResetter.search) {
		        this.params.previousQuery = undefined;
		    }
		    if (propResetter.vars && propResetter.ds) {
		        this._refresh();
		    } else if (propResetter.vars) {
		        this._detachInputEv();
		        this._initVars();
		        this._afterPropInit();
		        if (propResetter.search) {
		            this._reSearch();
		        } else {
		            this._rebuildItems();
		        }
		    } else if (propResetter.ds) {
		        this._initDS();
		        this._afterPropInit();
		        this._reSearch();
		    } else if (propResetter.search) {
		        this._reSearch();
		    } else if (propResetter.rebuildItems) {
		        this._rebuildItems();
		    }
		    this._propResetter = {};
		    this._dataReset = false;
		    if (propResetter.values) {
		        let values = this._opts.value;
		        if (values) {
		            values = this._toArr(values);
		            if (values.length > 1) {
		                if (this._opts.multiple) {
		                    if (this._opts.selectionLimit) {
		                        values.splice(this._opts.selectionLimit);
		                    }
		                } else {
		                    values.splice(1);
		                }
		            }
		        }
		        this._setValues(values, {
		            clearOtherValues: true
		        });
		    }
		}
		// Method to reconstruct items
		_rebuildItems  (skipRender) {
		    this._rebuilt = true;
		    this._groupsIncluded = [];
		    this._setHeaderFooterItems();
		    this._data.items = this._getItemJSON(this._datasource);
		    !skipRender && this._renderView();
		    this._rebuilt = false;
		}
		_setItemAttribute  (option, optionName, value, isGroup) {
		    let optData = option;
		    if (option.nodeType) {
		        optData = option.optData;
		        if (option.tagName === this._SELECTORS.OPTGROUP) {
		            isGroup = true;
		        }
		    }
		    if (optData) {
		        if (optionName === 'selected') { // No I18N
		            this[value ? 'setValue' : 'deselect' ](optData); // No I18N
		            return;
		        }
		        let matchedData = this._getItem(optData, false);
		        if (matchedData) {
		            matchedData[optionName] = value;
		            this._rebuildItems();
		            return;
		        }
		        this.DSInstance.setItemAttribute(optData, optionName, value, isGroup);
		    }
		}
		setItemAttributes  (options, optionName, value, isGroup) {
		    let render;
		    if (this.staticData) {
		        this._toArr(options)
		            .forEach((option) => {
		                this._skipRender = true;
		                if (option) {
		                    if (typeof optionName === 'object' && !$.isEmptyObject(optionName)) { // No I18N
		                        for (let key in optionName) {
		                            this._setItemAttribute(option, key, optionName[key], isGroup);
		                        }
		                    } else {
		                        this._setItemAttribute(option, optionName, value, isGroup);
		                    }
		                }
		                if (!render && !this._skipRender) {
		                    render = true;
		                }
		            });
		    }
		    if (render) {
		        this._renderView();
		    }
		    this._skipRender = false;
		}
		_calcItemHts  () {
		    if (!this._ht[0]) { // Item Ht stored in 0th pos
		        this._ht[0] = this._getItemHt(this._listBody[0].querySelector('[data-selectable=true]')); // No I18N
		    }
		    if (this._isGrouped && !this._ht[1]) { // Group Ht stored in 1st pos
		        this._ht[1] = this._getItemHt(this._listBody[0].querySelector('[role=group]')); // No I18N
		    }
		}
		_getItemHt  (element) {
		    return element ? $(element).outerHeight(true) : 0;
		}
		_cacheData  (rawJSON) {
		    this._cachedData.push({
		        raw: rawJSON,
		        processed: this._getItemJSON(rawJSON)
		    });
		    /*
		    //The following case could be included if met.
		    let backedUpdata = this._cachedData;
		    if (rawJSON.length) {
		        let maxResults = this.DSInstance._maxResults;
		        let length = backedUpdata.length;
		        if (length) {
		            let lastPage = backedUpdata[length - 1];
		            let missedCount = maxResults - lastPage.length;
		            if (missedCount) {
		                lastPage.push(...rawJSON.splice(0, missedCount));
		            }
		        }
		        if (rawJSON.length) {
		            backedUpdata.push(rawJSON.splice(0, maxResults));
		            this._cacheData(rawJSON);
		        }
		    } */
		}
		_getPagedItems  (pageIndex) {
		    return this._cachedData[pageIndex - 1];
		}
		_calcHt  (pageIndex) {
		    this._calcItemHts();
		    let height = 0;
		    let pageData = this._getPagedItems(pageIndex);
		    if (pageData) {
		        pageData.processed.forEach((data) => {
		            height += this._ht[data.itemType === 'itemgroup' ? 1 : 0]; // No I18N
		        });
		    }
		    return height;
		}
		_showVirtualData  (orgEvent) {
		    let eventData = {};
		    let updateVirtualData = this._updateVirtualData.bind(this, orgEvent, eventData);
		    let onDataFetch = (filteredData) => {
		        eventData.results = filteredData;
		        filteredData = eventData.results;
		        if (filteredData.length) {
		            this._cacheData(filteredData);
		            updateVirtualData();
		        } else if (this._freshRequest) {
		            // this._hideAllItems();
		            this._afterFilter(orgEvent, eventData);
		        }
		    }
		    if (this._freshRequest) {
		        this._cachedData = [];
		        this._startPage = this._endPage = null;
		        this._ht = [ 0, 0 ];
		        this._loadFirstPage(onDataFetch, orgEvent);
		    } else if (this._scroll.exceeded) {
		        this._getNextPage(onDataFetch);
		    } else {
		        updateVirtualData();
		    }
		}
		_updateVirtualData  (orgEvent, eventData) {
		    let dummyHtAbove = 0;
		    let dummyHtBelow = 0;
		    let maxPagePerView = this._opts.maxPage;
		    let startPage = 1;
		    let maxPageLen = this._cachedData.length;
		    let endPage = maxPageLen;
		    if (maxPageLen > maxPagePerView) {
		        let elementsHt = 0;
		        let scrollTop = this._lastScrollTop + ((this._scroll.isBackwards ? -1 : 1) * 40);
		        while (startPage < maxPageLen) {
		            elementsHt += this._calcHt(startPage);
		            if (scrollTop < elementsHt) {
		                endPage = startPage;
		                let totalExistingHt = elementsHt;
		                while (endPage < maxPageLen) {
		                    let totalScrollTop = scrollTop + this._scroll.menuHt;
		                    if (totalScrollTop < totalExistingHt) {
		                        break;
		                    }
		                    totalExistingHt += this._calcHt(endPage);
		                    endPage++;
		                }
		                break;
		            }
		            dummyHtAbove = elementsHt;
		            startPage++;
		        }
		    }
		    if (startPage < this._startPage || endPage > this._endPage) {
		        /* Calculating Dummy Height below */
		        for (let i = endPage + 1; i <= maxPageLen; i++) {
		            dummyHtBelow += this._calcHt(i);
		        }
		        this._startPage = startPage;
		        this._endPage = endPage;
		        let itemJSON = [];
		        this._datasource = [];
		        /* IMP-- Later we can try to achieve this using transform */
		        this._data.virtualHeightAbove = dummyHtAbove;
		        for (let i = startPage; i <= endPage; i++) {
		            let cachedData = this._getPagedItems(i);
		            itemJSON.push(...cachedData.processed);
		            this._datasource.push(...cachedData.raw);
		        }
		        this._data.virtualHeightBelow = dummyHtBelow;
		        eventData = eventData || {};
		        eventData.addedItems = this._replaceBodyItems(itemJSON, false, orgEvent);
		        this._afterFilter(orgEvent, eventData);
		    }
		}
	}
	ZC.registerComponent('ZListBox', ZListBox); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zlistbox.Templates; 
let utilities = ZC.Templates.Utilities; 
template.WCContainer = (data) => ZT.html `<div>${data.children && template.WCChildren(data)}</div>`; 
template.WCChildren = (data) => { 
let classes = data.classes; 
let responseHTML = ZT.html ` ${data.searchBox && template.WCSearchField(data.searchBox, classes)} ${data.headerItems && template.WCHeaderLayout(data, classes)} ${data.items && template.WCConstructBody(data, classes)} ${data.noResults && template.WCNoresultsLayout(data.noResults, classes)} ${(data.footerItems || data.moreAction) && template.WCFooterLayout(data, classes)} `; return responseHTML; }; 
template.WCConstructBody = (data, classes) => { 
let responseHTML = ZT.html `<ul style='display:none;' tabindex=-1 class='${classes.body} zh-scroll_y'> ${data.virtualHeightAbove && template.WCVirtualHolder(data.virtualHeightAbove, classes)} ${data.items.map((item) => template.WCItem(item, classes))} ${data.virtualHeightBelow && template.WCVirtualHolder(data.virtualHeightBelow, classes)} ${data.loader && template.WCLoader(data.loader, classes)} </ul>`; return responseHTML; } 
template.WCItem = (data, classes) => { 
let responseHTML = data.separator ? template.WCSeparator(data, classes) : (data.heading ? template.WCHeading(data, classes) : template.WCDefaultItem(data, classes)); return responseHTML; } 
template.WCDefaultItem = (data, classes) => { 
let responseHTML = ZT.html `<li ?id=${data.id} class="${classes.item} ${data.className} ${data.disabled ? 'is-disabled' : ''} ${data.clickable ? '' : 'zlistbox__item--nonselectable'}" role="option" ?aria-disabled="${data.disabled ? 'true' : ''}" ?disabled="${data.disabled ? 'true' : ''}" aria-label="${data.view.ariaLabel}" aria-value="${data.view.ariaValue}" ?name=${data.name} ?data-selectable=${data.selectable ? 'true' : ''} ?data-clickable=${data.clickable ? 'true' : ''} ?data-ignore-focus=${data.clickable ? '' : 'true'} .itemData="${data}"> ${data.grippyIcon && template.WCGrippyIcon(data, classes)} ${data.checkbox && template.WCCheckbox(data, classes)} ${data.checkedIcon && template.WCCheckedIcon(data, classes)} ${template.WCContent(data, classes)} ${data.actionButtons && template.WCActionButtons(data.actionButtons, classes)} </li>`; return responseHTML; } 
template.WCGrippyIcon = (data, classes) => { 
let responseHTML = ZT.html `<div class="${classes.icondiv} ${classes.grippyicon}"> ${utilities.WCIcon(data.grippyIcon)} </div>`; return responseHTML; } 
template.WCSeparator = (data, classes) => { 
let responseHTML = ZT.html `<li ?id=${data.id} class="${classes.separator} ${data.className}" role="separator" data-ignore-focus=true .itemData="${data}"></li>`; return responseHTML; } 
template.WCContent = (data, classes) => { 
let responseHTML = data.custom ? ZT.html `${ZT.customHTML(data.view.innerHTML || '')}` : ZT.html `${data.hasImage && template.WCImageLayout(data.view, classes)} <div class="${classes.content}"> ${data.view.text && ZT.html `<span class='${classes.text}'>${ZT.customHTML(data.view.text)}</span>`} ${data.view.description && ZT.html `<span class='${classes.hint}'>${ZT.customHTML(data.view.description)}</span>`} </div>`; return responseHTML; } 
template.WCActionButtons = (data, classes) => { 
let responseHTML = ZT.html `<div class="${classes.actionbuttonsWrapper}"> ${data.map((actionBtnData) => ZT.html `<button tabindex=-1 ?title=${actionBtnData.title} ?disabled=${actionBtnData.disabled ? 'true' : ''} class="${classes.actionbutton} ${actionBtnData.className} ${actionBtnData.disabled?'is-disabled':''}">${utilities.WCIcon(actionBtnData)}</button>`)} </div>`; return responseHTML; } 
template.WCCheckbox = (data, classes) => { 
let responseHTML = ZT.html `<div class='${classes.checkboxWrapper} zcheckbox'><input id=${data.checkboxId} ?disabled="${data.disabled}" type="checkbox" class='zcheckbox__helper ${classes.checkbox}' tabindex=-1 /><label for=${data.checkboxId} class="zcheckbox__label ${classes.checkboxlabel} ${data.disabled ? 'is-disabled ' : ''}"></label></div>`; return responseHTML; } 
template.WCCheckedIcon = (data, classes) => { 
let responseHTML = ZT.html `<div class='${classes.checkediconWrapper}'>${utilities.WCIcon(data.checkedIcon)}</div>`; return responseHTML; } 
template.WCHeading = (data, classes) => { 
let responseHTML = ZT.html `<li ?id=${data.id} class="${classes.itemgroup} ${data.className} ${data.disabled ? 'is-disabled' : ''}" data-ignore-focus=true role="group" .itemData="${data}"> ${data.view.text ? ZT.html `<span class="${classes.itemgrouplabel}" >${ZT.customHTML(data.view.text)}</span>` : ZT.customHTML(data.view.innerHTML || '') } </li>`; return responseHTML; } 
template.WCHeaderLayout = (data, classes) => { 
let responseHTML = ZT.html `<ul class='${classes.header}'> ${data.headerItems.map((item) => template.WCItem(item, classes))} </ul>`; return responseHTML; } 
template.WCFooterLayout = (data, classes) => { 
let responseHTML = ZT.html `<ul class='${classes.footer}'> ${data.footerItems && data.footerItems.map((item) => template.WCItem(item, classes))} ${data.moreAction && template.WCItem(data.moreAction, classes)} </ul>`; return responseHTML; } 
template.WCImageLayout = (data, classes) => { 
let responseHTML = ZT.html `<div class='${classes.icondiv} ${data.textIcon ? classes.textIconWrapper : ''}'> ${data.hasImageURL ? (ZT.html `<img src="${data.image || 'invalid.jpg'}" />`) : (data.icon ? utilities.WCIcon(data.icon) : ZT.html `<span class="${classes.icon}">${data.textIcon}</span>` )} </div>`; return responseHTML; } 
template.WCLoader = (data, classes) => { 
let responseHTML = ZT.html `<li id=${data.id} class="${classes.loader}"> ${template.WCLoaderIcon(data, classes)} </li>`; return responseHTML; } 
template.WCLoaderIcon = (data, classes) => { 
let responseHTML = ZT.html `${data.icon ? utilities.WCIcon(data.icon) : ZT.html `<i class="${classes.loadericon} zh-loading"> <svg class="zeffects--rotate" viewBox="0 0 20 20"> <circle class="circle__track" cx="10" cy="10" r="9" /> <circle class="circle__load" cx="10" cy="10" r="9" /> </svg> </i>`}`; return responseHTML; } 
template.WCNoresultsLayout = (data, classes) => { 
let responseHTML = ZT.html `<div style='display:none;' id=${data.id} class="${classes.noresults}"> <span class="${classes.noresultstext}">${ZT.customHTML(data.innerHTML)}</span> </div>`; return responseHTML; } 
template.WCSearchField = (data, classes) => { 
let response = ZT.html `<div class='${classes.search} ${data.disabled ? classes.disabled : ''}'> <div class="${classes.searchcontainer}"> ${utilities.WCIcon(data.icon)} </div> <input id="${data.id}" ?disabled=${data.disabled ? 'true' : ''} autocomplete="off" type="text" class="${classes.searchfield}" autocomplete="off"> ${data.clearButton && ZT.html `<button class="${classes.clearbutton}" ?title="${data.clearButtonTitle}" tabindex=-1 id="${data.clearButtonId}" on-click=${data.clearFn}> ${utilities.WCIcon(data.clearButton)} </button>`} </div> `; return response; } 
template.WCVirtualHolder = (data, classes) => { 
let responseHTML = ZT.html `<li class="${classes.item}" data-ignore-focus=true data-zplaceholder="true" style='height:${data}px;'></li>`; return responseHTML; } }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zlistbox.Templates; 
let utilities = ZC.Templates.Utilities; 
template.container = (data) => ZT.html `<div>${data.children && template.children(data)}</div>`; 
template.children = (data) => { 
let classes = data.classes; 
let responseHTML = ZT.html ` ${data.searchBox && template.searchField(data.searchBox, classes)} ${data.headerItems && template.headerLayout(data, classes)} ${data.items && template.constructBody(data, classes)} ${data.noResults && template.noresultsLayout(data.noResults, classes)} ${(data.footerItems || data.moreAction) && template.footerLayout(data, classes)} `; return responseHTML; }; 
template.constructBody = (data, classes) => { 
let responseHTML = ZT.html `<ul style='display:none;' tabindex=-1 class='${classes.body} zh-scroll_y'> ${data.virtualHeightAbove && template.virtualHolder(data.virtualHeightAbove, classes)} ${data.items.map((item) => template.item(item, classes))} ${data.virtualHeightBelow && template.virtualHolder(data.virtualHeightBelow, classes)} ${data.loader && template.loader(data.loader, classes)} </ul>`; return responseHTML; } 
template.item = (data, classes) => { 
let responseHTML = data.separator ? template.separator(data, classes) : (data.heading ? template.heading(data, classes) : template.defaultItem(data, classes)); return responseHTML; } 
template.defaultItem = (data, classes) => { 
let responseHTML = ZT.html `<li ?id=${data.id} class="${classes.item} ${data.className} ${data.disabled ? 'is-disabled' : ''} ${data.clickable ? '' : 'zlistbox__item--nonselectable'}" role="option" ?aria-disabled="${data.disabled ? 'true' : ''}" ?disabled="${data.disabled ? 'true' : ''}" aria-label="${data.view.ariaLabel}" aria-value="${data.view.ariaValue}" ?name=${data.name} ?data-selectable=${data.selectable ? 'true' : ''} ?data-clickable=${data.clickable ? 'true' : ''} ?data-ignore-focus=${data.clickable ? '' : 'true'} .itemData="${data}"> ${data.grippyIcon && template.grippyIcon(data, classes)} ${data.checkbox && template.checkbox(data, classes)} ${data.checkedIcon && template.checkedIcon(data, classes)} ${template.content(data, classes)} ${data.actionButtons && template.actionButtons(data.actionButtons, classes)} </li>`; return responseHTML; } 
template.grippyIcon = (data, classes) => { 
let responseHTML = ZT.html `<div class="${classes.icondiv} ${classes.grippyicon}"> ${utilities.icon(data.grippyIcon)} </div>`; return responseHTML; } 
template.separator = (data, classes) => { 
let responseHTML = ZT.html `<li ?id=${data.id} class="${classes.separator} ${data.className}" role="separator" data-ignore-focus=true .itemData="${data}"></li>`; return responseHTML; } 
template.content = (data, classes) => { 
let responseHTML = data.custom ? ZT.html `${ZT.customHTML(data.view.innerHTML || '')}` : ZT.html `${data.hasImage && template.imageLayout(data.view, classes)} <div class="${classes.content}"> ${data.view.text && ZT.html `<span class='${classes.text}'>${ZT.customHTML(data.view.text)}</span>`} ${data.view.description && ZT.html `<span class='${classes.hint}'>${ZT.customHTML(data.view.description)}</span>`} </div>`; return responseHTML; } 
template.actionButtons = (data, classes) => { 
let responseHTML = ZT.html `<div class="${classes.actionbuttonsWrapper}"> ${data.map((actionBtnData) => ZT.html `<button tabindex=-1 ?title=${actionBtnData.title} ?disabled=${actionBtnData.disabled ? 'true' : ''} class="${classes.actionbutton} ${actionBtnData.className} ${actionBtnData.disabled?'is-disabled':''}">${utilities.icon(actionBtnData)}</button>`)} </div>`; return responseHTML; } 
template.checkbox = (data, classes) => { 
let responseHTML = ZT.html `<div class='${classes.checkboxWrapper} zcheckbox'><input id=${data.checkboxId} ?disabled="${data.disabled}" type="checkbox" class='zcheckbox__helper ${classes.checkbox}' tabindex=-1 /><label for=${data.checkboxId} class="zcheckbox__label ${classes.checkboxlabel} ${data.disabled ? 'is-disabled ' : ''}"></label></div>`; return responseHTML; } 
template.checkedIcon = (data, classes) => { 
let responseHTML = ZT.html `<div class='${classes.checkediconWrapper}'>${utilities.icon(data.checkedIcon)}</div>`; return responseHTML; } 
template.heading = (data, classes) => { 
let responseHTML = ZT.html `<li ?id=${data.id} class="${classes.itemgroup} ${data.className} ${data.disabled ? 'is-disabled' : ''}" data-ignore-focus=true role="group" .itemData="${data}"> ${data.view.text ? ZT.html `<span class="${classes.itemgrouplabel}" >${ZT.customHTML(data.view.text)}</span>` : ZT.customHTML(data.view.innerHTML || '') } </li>`; return responseHTML; } 
template.headerLayout = (data, classes) => { 
let responseHTML = ZT.html `<ul class='${classes.header}'> ${data.headerItems.map((item) => template.item(item, classes))} </ul>`; return responseHTML; } 
template.footerLayout = (data, classes) => { 
let responseHTML = ZT.html `<ul class='${classes.footer}'> ${data.footerItems && data.footerItems.map((item) => template.item(item, classes))} ${data.moreAction && template.item(data.moreAction, classes)} </ul>`; return responseHTML; } 
template.imageLayout = (data, classes) => { 
let responseHTML = ZT.html `<div class='${classes.icondiv} ${data.textIcon ? classes.textIconWrapper : ''}'> ${data.hasImageURL ? (ZT.html `<img src="${data.image || 'invalid.jpg'}" />`) : (data.icon ? utilities.icon(data.icon) : ZT.html `<span class="${classes.icon}">${data.textIcon}</span>` )} </div>`; return responseHTML; } 
template.loader = (data, classes) => { 
let responseHTML = ZT.html `<li id=${data.id} class="${classes.loader}"> ${template.loaderIcon(data, classes)} </li>`; return responseHTML; } 
template.loaderIcon = (data, classes) => { 
let responseHTML = ZT.html `${data.icon ? utilities.icon(data.icon) : ZT.html `<i class="${classes.loadericon} zh-loading"> <svg class="zeffects--rotate" viewBox="0 0 20 20"> <circle class="circle__track" cx="10" cy="10" r="9" /> <circle class="circle__load" cx="10" cy="10" r="9" /> </svg> </i>`}`; return responseHTML; } 
template.noresultsLayout = (data, classes) => { 
let responseHTML = ZT.html `<div style='display:none;' id=${data.id} class="${classes.noresults}"> <span class="${classes.noresultstext}">${ZT.customHTML(data.innerHTML)}</span> </div>`; return responseHTML; } 
template.searchField = (data, classes) => { 
let response = ZT.html `<div class='${classes.search} ${data.disabled ? classes.disabled : ''}'> <div class="${classes.searchcontainer}"> ${utilities.icon(data.icon)} </div> <input id="${data.id}" ?disabled=${data.disabled ? 'true' : ''} autocomplete="off" type="text" class="${classes.searchfield}" autocomplete="off"> ${data.clearButton && ZT.html `<button class="${classes.clearbutton}" ?title="${data.clearButtonTitle}" tabindex=-1 id="${data.clearButtonId}" on-click=${data.clearFn}> ${utilities.icon(data.clearButton)} </button>`} </div> `; return response; } 
template.virtualHolder = (data, classes) => { 
let responseHTML = ZT.html `<li class="${classes.item}" data-ignore-focus=true data-zplaceholder="true" style='height:${data}px;'></li>`; return responseHTML; } }(ZComponents)); 
(function(ZC, $){
	class ZDropdownList extends ZC.ZListBox {
			get name(){
				return "zdropdownlist";
			}
	    get attrs() {
	        return {
	            position: 'auto', // No I18N
	            selectOnTabPress: false,
	            forElement: null,
	            viewport: null,
	            displayType: 'box', // No I18N
	            focusFirstItemOnOpen: false,
	            focusSelectedItemOnOpen: true,
	            title: '',
	            closeButton: false,
	            closeIconClassName: '',
	            closeSVGIconId: '',
	            positionAlterable: false,
	            doneButton: false,
	            clearButton: false,
	            resetButton: false,
	            doneButtonLabel: null,
	            clearButtonLabel: null,
	            resetButtonLabel: null,
	            handleFocusNavigation: null,
	            /* ListBox API whose default value have been modified */
	            selectOnKeyNavigation: null,
	            focusItemOnItemMouseover: null,
	            /* Options that are added to support other components */
	            minWidth: null,
	            // For Listbox
	            focusSelectedItem: false
	        }
	    }
	    get propType() {
	        let boolType = 'boolean'; // No I18N
	        return {
	            selectOnKeyNavigation: boolType,
	            focusItemOnItemMouseover: boolType
	        }
	    }
	    get props() {
	        return {
	            appendTo: null,
	            offset: null,
	            animation: {},
	            margin: {},
	            commandBar: null,
	            messages: {
	                doneButtonLabel: 'Done', // No I18N
	                resetButtonLabel: 'Reset', // No I18N
	                clearButtonLabel: 'Clear', // No I18N
	                closeButtonLabel: 'Close' // No I18N
	            },
	            search: {
	                showNoResultsMessage: true,
	                criteria: 'startswith' // No I18N
	            },
	            searchFieldOptions: {
	                updateOnSelect: false,
	                autoComplete: false,
	                listAllItemsOnDOWNPress: false,
	                suggestOnFieldFocus: false,
	                filterBasedOnCurPos: false
	            }
	        }
	    }
	    get EVENTS() {
	        return [
	            'beforeopen', // No I18N
	            'open', // No I18N
	            'beforefocus', // No I18N
	            'beforeclose', // No I18N
	            'close', // No I18N
	            'update', // No I18N
	            'beforeupdate', // No I18N
	            'done', // No I18N
	            'reset', // No I18N
	            'clear' // No I18N
	        ];
	    }
	    get CLASSES() {
	        return {
	            container: 'zdropdownlist', // No I18N
	            /* Properties */
	            icon: 'zdropdownlist--withicon', // No I18N
	            listwithloader: 'zdropdownlist--loading', // No I18N
	            withicon: 'zdropdownlist--withicon', // No I18N
	            withhint: 'zdropdownlist--withdesc', // No I18N
	            withcheckbox: 'zdropdownlist--withcheckbox', // No I18N
	            withcheckedicon: 'zdropdownlist--withcheckedindication', // No I18N
	            withoutcheckeditem: 'zdropdownlist--withoutcheckeditem', // No I18N
	            listwithcustom: 'zdropdownlist--withcustomitem', // No I18N
	            withsearchfield: 'zdropdownlist--withsearchfield', // No I18N
	            icononly: 'zdropdownlist--icononly', // No I18N
	            icontext: 'zdropdownlist--iconwithtext', // No I18N
	            listwithcheckboxRight: 'zdropdownlist--checkboxright', // No I18N
	            listwithcheckediconRight: 'zdropdownlist--checkedindicationright', // No I18N
	            listwithactionbtnsvisible: ' zdropdownlist--actionbuttonvisible', // No I18N
	            listwithimage: 'zdropdownlist--withimage', // No I18N
	            reorderable: 'zdropdownlist--reorderable', // No I18N
	            /* Dropdown list properties */
	            text: 'zdropdownlist__text', // No I18N
	            title: 'zdropdownlist__title', // No I18N
	            hint: 'zdropdownlist__description', // No I18N
	            body: 'zdropdownlist__body', // No I18N
	            header: 'zdropdownlist__header', // No I18N
	            footer: 'zdropdownlist__footer', // No I18N
	            item: 'zdropdownlist__item', // No I18N
	            itemgroup: 'zdropdownlist__itemgroup', // No I18N
	            itemgrouplabel: 'zdropdownlist__grouplabel', // No I18N
	            loader: 'zdropdownlist__loader', // No I18N
	            fullloader: 'zdropdownlist__fullloader', // No I18N
	            loadericon: 'zdropdownlist__loadericon', // No I18N
	            actionbuttonsWrapper: 'zdropdownlist__actions', // No I18N
	            actionbutton: 'zdropdownlist__action', // No I18N
	            separator: 'zdropdownlist__separator', // No I18N
	            checkediconWrapper: 'zdropdownlist__checkedindication', // No I18N
	            checkedicon: 'zdropdownlist__checkedicon', // No I18N
	            checkboxWrapper: 'zdropdownlist__checkbox', // No I18N
	            checkbox: 'zdropdownlist__inputcheckbox', // No I18N
	            checkboxlabel: 'zdropdownlist__checkboxlabel', // No I18N
	            avatar: 'zdropdownlist__avatar', // No I18N
	            icondiv: 'zdropdownlist__image', // No I18N
	            itemicon: 'zdropdownlist__icon', // No I18N
	            content: 'zdropdownlist__content', // No I18N
	            textIconWrapper: 'zdropdownlist__imagetext', // No I18N
	            moreresults: 'zdropdownlist__moreresults', // No I18N
	            noresults: 'zdropdownlist__noresults', // No I18N
	            noresultstext: 'zdropdownlist__noresultstext', // No I18N
	            search: 'zdropdownlist__search', // No I18N
	            searchcontainer: 'zdropdownlist__searchiconcontainer', // No I18N
	            searchicon: 'zdropdownlist__searchicon', // No I18N
	            searchfield: 'zdropdownlist__searchfield', // No I18N
	            clearbuttonicon: 'zdropdownlist__clearicon', // No I18N
	            clearbutton: 'zdropdownlist__clearbutton', // No I18N
	            listwithicononly: 'zdropdownlist--icononly', // No I18N
	            /* States */
	            hoverable: 'is-hoverable', // No I18N
	            disabled: 'is-disabled', // No I18N
	            hover: 'on-hover', // No I18N
	            focussed: 'has-focus', // No I18N
	            selected: 'is-selected', // No I18N
	            rtl: 'zh-rtl', // No I18N
	            leftColumn: 'zdropdownlist__commandbaractionsleft', // No I18N
	            rightColumn: 'zdropdownlist__commandbaractionsright', // No I18N
	            centerColumn: 'zdropdownlist__commandbaractionscenter' // No I18N
	        }
	    }
	    get SELECTORS() {
	        return {
	            OPTION: this.isCE ? 'z-dropdownlistitem' : 'option', // No I18N
	            OPTGROUP: this.isCE ? 'z-dropdownlistgroup' : 'optgroup', // No I18N
	            OPTIONSBODY: 'z-dropdownlistbody', // No I18N
	            OPTIONSHEADER: 'z-dropdownlistheader', // No I18N
	            OPTIONSFOOTER: 'z-dropdownlistfooter', // No I18N
	            OPTIONSEPARATOR: 'z-dropdownlistseparator' // No I18N
	        }
	    }
	    _init(ele, options) {
	        let opts = this._opts,
	            data = this._data;
	        data.attrs = data.attrs || {};
	        data.attrs.role = 'dropdown'; // No I18N
	        this._userOptions = $.extend({}, options);
	        this._validateOpts();
	        this._constructTitleBar();
	        if (opts.commandBar || this._defaultCBar) {
	            this._constructBtns();
	        }
	        super._init(...arguments);
	    }
	    _constructTitleBar() {
	        let opts = this._opts,
	            data = this._data;
	        data.title = opts.title;
	        data.close = opts.closeButton ? this._getCloseProps() : null;
	    }
	    _validateOpts() {
	        let opts = this._opts,
	            userOpts = this._userOptions,
	            selectOnKeyNavigation = userOpts.selectOnKeyNavigation,
	            focusItemOnItemMouseover = userOpts.focusItemOnItemMouseover,
	            isSingle = this._isSingle = !this._opts.multiple;
	        this._forElement = opts.forElement && $(opts.forElement);
	        this._data.isCallout = opts.displayType === 'callout'; // No I18N
	        opts.selectOnKeyNavigation = (selectOnKeyNavigation === null && focusItemOnItemMouseover === null) ? isSingle : selectOnKeyNavigation;
	        opts.focusItemOnItemMouseover = (focusItemOnItemMouseover === null && selectOnKeyNavigation === null) ? !isSingle : focusItemOnItemMouseover;
	        /* After a discussion, we concluded that if focusFirstItemOnOpen is true, then focusFirstResult should also be true */
	        if (opts.focusFirstItemOnOpen) {
	            opts.search.focusFirstResult = true;
	        }
	        /* Validating buttons and setting default commandBar */
	        this._defaultCBar = null;
	        if (!opts.commandBar && (opts.doneButton || opts.resetButton || opts.clearButton)) {
	            this._setDefaultCBar();
	        }
	        /* As discussed, when command buttons are present, focus should be navigating within the container */
	        opts.handleFocusNavigation = opts.handleFocusNavigation === null ? !!(opts.commandBar || this._defaultCBar) : opts.handleFocusNavigation;
	    }
	    _initialRender() {
	        /* Handling for loading the data only when open called */
	        if (this._initialized) {
	            this._search();
	        } else {
	            this._renderView([]);
	        }
	    }
	    _postRender() {
	        super._postRender(...arguments);
	        if (!this._useParent) {
	            this.container.attr('id', this._getID(this.element) + '-' + this.name); // No I18N
	        }
	        /* After a meeting, we have decided to provide focusHandler only based on needs and no need to include it in build.json */
	        this._opts.handleFocusNavigation && ZC.FocusHandler && ZC.FocusHandler.init(this.container);
	        this._setShowHideOpts();
	        this._appendEle(this._opts.appendTo);
	        /* Removed due to an issue which removes this class in showhidehandler. So, ht and scollCls shouldn't be added before calling showhideHandler */
	        this._listBody.removeClass('zh-scroll_y'); // No I18N
	        this.container[0].style.display = 'none'; // No I18N
	    }
	    _fixMidHt() {
	        /* Height need not to be set from listbox. Hence it is overwritten */
	    }
	    _postEachRender(element, data) {
	        super._postEachRender(...arguments);
	        let modifiedAttr = data.attrModified,
	            firstRender = !data.rendered,
	            value = this._opts.value;
	        if (firstRender || modifiedAttr) {
	            if ((firstRender || [ 'title', 'closeButton' ].indexOf(modifiedAttr) > -1) && data.close && !data.close.mainElement) { // No I18N
	                this._updateCloseEle();
	            }
	            if (data.isCallout && !this._pointer) {
	                this._pointer = this.container.find('.zdropdownlist__pointer'); // No I18N
	                this._setShowHideOpts();
	            }
	            data.attrModified = undefined;
	        }
	        if ((firstRender || this._btnAttrChanged) && this._isBtns) { // No I18N
	            this._btnAttrChanged = undefined;
	            this._updateBtns();
	        }
	        if (this._isSingle && value && this._toArr(value).length) {// No I18N
	            this._savePrevSelection(this._selectedItems[0].id);
	        }
	    }
	    _getClass() {
	        let clsName = super._getClass(...arguments),
	            data = this._data;
	        clsName += data.title ? ' zdropdownlist--withtitle' : ''; // No I18N
	        clsName += (data.close && !data.title) ? ' zdropdownlist--withclose' : ''; // No I18N
	        return clsName;
	    }
	    _setVisibility(orgEvent) {
	        let isInputFld = this.inputField && !this._showSearchField,
	            warningMsg = this._status,
	            doNotShowNoResults = warningMsg === 'noresults' && !this._opts.search.showNoResultsMessage; // No I18N
	        if (isInputFld && (warningMsg === 'minkeywordlength' || doNotShowNoResults)) { // No I18N
	            this.close(orgEvent);
	        } else if (!isInputFld && doNotShowNoResults) {
	            this._hide(this._listBody);
	        } else {
	            let fixHt;
	            if (this.container.attr('data-loading') !== String(this._loading) || this.container.attr('data-noresults') !== String(this._noResults)) { // No I18N
	                fixHt = true;
	            }
	            super._setVisibility(...arguments);
	            /* Updating the list height when loader, no_results message or warning message is shown */
	            if (fixHt && this._isShown && this._freshRequest) {
	                ZC.Helpers.fixHeight(this.container, this._showHideProps);
	            }
	        }
	    }
	    _trigger(customEvent, evObj) {
	        /* By default, listbox will have the autocomplete behavior. To overwrite it, selected data alone is stored when change triggered
	            and actual change event of dropdownlist is triggered when the selected value is committed. */
	        if (customEvent === 'change') { // No I18N
	            let type = evObj && evObj.type,
	                opts = this._opts,
	                btnClicked = this._btnClicked,
	                isCommitted = type && [ 'keydown', 'mouseup' ].indexOf(type) > -1; // No I18N
	            /* done should be considered for commiting only when the value is manually selected */
	            let returnFalse = this._doneBtn ? isCommitted ? btnClicked !== 'done' : false : btnClicked ? false : this._isSingle && opts.selectOnKeyNavigation && isCommitted; // No I18N
	            if (this._internalChange || returnFalse) {
	                return false;
	            }
	        }
	        return super._trigger(...arguments);
	    }
	    _triggerUpdate(orgEvent, eventData) {
	        if ((this._freshRequest || this._updateHtAndPos) && this._isShown && this._direction) {
	            this._updatePos(null, orgEvent);
	        }
	        return this._trigger('update', orgEvent, eventData); // No I18N
	    }
	    _triggerBeforeUpdate(orgEvent, eventData) {
	        return this._trigger('beforeupdate', orgEvent, eventData); // No I18N
	    }
	    _itemClickHandler(evObj, item, itemData) {
	        super._itemClickHandler(...arguments);
	        let shouldClose;
	        if (itemData.itemMappedData.moreresults) {
	            shouldClose = true;
	        } else if (this._isSingle && !this._doneBtn && evObj.type === 'mouseup') { // No I18N
	            if (this._getStoredData(item).selectable) {
	                this._saveCommitedItemData(item);
	            }
	            shouldClose = true;
	        }
	        shouldClose && this.close(evObj);
	    }
	    _saveCommitedItemData(item) {
	        let curSelected = this._curSelectedItem,
	            /* curSelected will be undefined when no change happened and space/enter pressed over already selected item */
	            shouldCommit = item ? item.is('.' + this.CLASSES.item) : (curSelected && curSelected !== this._prevSelectedItem); // No I18N
	        if (!shouldCommit && this._opts.focusItemOnItemMouseover) {
	            item = this.getFocussed();
	            if (item) {
	                shouldCommit = true
	            }
	        }
	        if (shouldCommit) {
	            if (item) {
	                curSelected = '#' + item.attr('id'); // No I18N
	            }
	            this._curSelectedItemData = this._getItemEventData($(curSelected));
	            this._curSelectedItem = curSelected;
	            this._isCommitted = true;
	        }
	    }
	    _selectItem(item) {
	        let response = super._selectItem(...arguments);
	        if (response !== false) {
	            let selectedItems = this._selectedItems;
	            if (this._isSingle) {
	                if (selectedItems.length) {
	                    this._valCleared = false;
	                    let selectedItemData = selectedItems[0];
	                    this._curSelectedItem = '#' + selectedItemData.id; // No I18N
	                    /* curSelectedItemData saves the data that has to be passed while triggering change */
	                    this._curSelectedItemData = this._getItemEventData(item.length ? item : this._getById(item.id));
	                } else if (this._valCleared) {
	                    /* If value cleared using setAttribute, deselectValues or in any means */
	                    this._curSelectedItem = this._curSelectedItemData = this._prevSelectedItem = this._prevSelectedItemData = null;
	                }
	            }
	            if (this._isBtns && this._isShown) { /* To avoid changes that is done while opening the list */
	                this._updateBtnsOnItemSelect()
	            }
	        }
	        return response;
	    }
	    _keydownActions(evObj) {
	        let isBtnClicked = this._btnClicked,
	            response = isBtnClicked ? true : super._keydownActions(...arguments);
	        if (isBtnClicked) {
	            this._resetFocus(isBtnClicked, evObj);
	        } else {
	            let keyCode = ZC.keyCode,
	                keyPressed = evObj.keyCode,
	                opts = this._opts,
	                isTab = keyCode.TAB === keyPressed && !this._isBtns,
	                doNotClose,
	                isSingle = this._isSingle,
	                hasSelectableItem = this._getStoredData($(this.getFocussed())).selectable,
	                shouldCommit = keyCode.ENTER === keyPressed && opts.selectOnEnterKey || (keyCode.SPACE === keyPressed && !this.inputField),
	                isTabOrEsc = keyCode.ESCAPE === keyPressed || isTab;
	            if (keyCode.ESCAPE === keyPressed) {
	            /* If list is present within some dialog or something, esc key should not close the dialog, hence it is prevented when the focus is on dropdown list */
	                evObj.stopPropagation();
	                evObj.preventDefault();
	            }
	            if (isTabOrEsc || (isSingle && opts.keyNavigation && shouldCommit)) {
	            /* this._curSelectedItem is checked because, when searchfield present and searched for a text for which no results present and when enter key pressed -> list should not be closed */
	            /* has-focus check is added for header or footer items being not selectable when selectionFollowsFocus is true */
	                if (isSingle && !this._doneBtn && (shouldCommit || (isTab && opts.selectOnTabPress)) && hasSelectableItem) { // No I18N
	                    this._saveCommitedItemData();
	                } else if (!isTabOrEsc) {
	                    doNotClose = true;
	                }
	                !doNotClose && this.close(evObj);
	            }
	        }
	        return response;
	    }
	    _setAriaAttrs(hidden) {
	        this.container.attr({
	            'aria-hidden': !!hidden, // No I18N
	            'aria-expanded': !hidden // No I18N
	        });
	        this._forElement.attr({
	            'aria-expanded': !hidden // No I18N
	        });
	    }
	    _setShowHideOpts() {
	        /* opts that are need to be passed to zshowhidehandler */
	        let opts = this._opts,
	            CLASSES = this.CLASSES,
	            animateCallback = this._animateOpenOrClose && this._animateOpenOrClose.bind(this);
	        this._showHideProps = {
	            cname: this.name,
	            forElement: this._forElement,
	            isCE: this.isCE,
	            rtl: opts.rtl,
	            originalElement: this.element,
	            bodyCls: CLASSES.body, // No I18N
	            headerCls: CLASSES.header, // No I18N
	            footerCls: CLASSES.footer, // No I18N
	            widthCls: 'zdropdownlist__width', // No I18N
	            arrowElement: this._pointer,
	            arrowCallback: this._arrowCallback.bind(this),
	            direction: opts.position,
	            offset: opts.margin,
	            position: opts.offset,
	            appendTo: opts.appendTo,
	            hideMethodName: 'close', // No I18N
	            hideEventName: 'close', // No I18N
	            onShowWithAnimation: animateCallback,
	            onHideWithAnimation: animateCallback,
	            beforeFocus: () => false /* Focus handling in showHideHandler is prevented because, based on the searchfield presence, focus should be set. */
	        };
	        [ 'height', 'viewport', 'displayType', 'positionAlterable', 'animation' ].forEach((opt) => this._showHideProps[opt] = opts[opt]); // No I18N
	        let minWidth = parseFloat(opts.minWidth || 0),
	            width = parseFloat(opts.width || 0);
	        if (minWidth > width) {
	            this._showHideProps.minWidth = minWidth;
	        } else {
	            this._showHideProps.width = width;
	        }
	    }
	    _arrowCallback(ele, direction) {
	        let classes = {
	                top: 'zh-top', // No I18N
	                bottom: 'zh-bottom', // No I18N
	                left: 'zh-left', // No I18N
	                right: 'zh-right'// No I18N
	            },
	            pointerCls = classes[direction],
	            pointerEle = this._pointer,
	            pointerbg = 'zdropdownlist--pointerwithbg';// No I18N
	        if ($(pointerEle).length && !pointerEle.hasClass(pointerCls)) {
	            pointerEle.removeClass(this._prevArrowCls || '');
	            pointerEle.addClass(pointerCls)
	            this._prevArrowCls = pointerCls;
	        }
	        if (this.inputField || this._data.title || this._data.close) {
	            this._updateClass(pointerbg, [ 'top', 'bottom' ].indexOf(direction) < 0); // No I18N
	        }
	    }
	    _focusInHandler(evObj) {
	        super._focusInHandler(...arguments);
	        let inputFld = this.inputField,
	            orgEv = evObj && evObj.originalEvent,
	            isBtns;
	        if (this._isBtns && orgEv && !this._isItemsNavigation) {// No I18N
	            let target = $(evObj.target);
	            isBtns = !this._btnClicked && !target.hasClass('has-mfocus') && target.is('.clear-zdropdownlist,.done-zdropdownlist,.reset-zdropdownlist'); // No I18N
	        }
	        /* handleEvents is given for internal use ALONE for tokenfield case. Where some of the handlings like pressing keydown
	        should open the list, left arrow should close the list when it reaches the top for which this option has been included. */
	        if (!isBtns && inputFld && this._opts.searchFieldOptions.handleEvents && document.activeElement !== inputFld[0]) {
	            inputFld[0].focus();
	        }
	    }
	    _storeForElement(forElement) {
	        this._opts.forElement = forElement;
	        this._forElement = $(forElement);
	        this._setShowHideOpts();
	    }
	    _savePrevSelection(selectedItemId) {
	        if (selectedItemId) {
	            selectedItemId = '#' + selectedItemId;
	        }
	        this._prevSelectedItem = this._curSelectedItem || selectedItemId;
	        this._prevSelectedItemData = this._curSelectedItemData && this._curSelectedItemData.itemData || selectedItemId && this._selectedItems[0].originalData;
	    }
	    _updateSelectedItem(evObj) {
	        let curSelected = this._curSelectedItem,
	            previousValue = this._prevSelectedItemData,
	            orgEv = evObj && evObj.originalEvent,
	            opts = this._opts,
	            prevValId = this._getPrevValId();
	        if (this._isCommitted || this._opts.autoCommit) { /* autoCommit - used in combobox for autocomplete behavior */
	            this._savePrevSelection();
	            /* For focusItemOnItemMouseover case, change will not be triggered only when selection happens on tab press. Hence it is handled here */
	            if (opts.selectOnKeyNavigation || (opts.focusItemOnItemMouseover && orgEv && orgEv.type === 'keydown' && orgEv.keyCode === ZC.keyCode.TAB)) {
	                this._dispatchEvent('change', evObj, { // No I18N
	                    ...this._curSelectedItemData,
	                    previousValue: previousValue ? [ previousValue ] : undefined,
	                    value: [ this._prevSelectedItemData ]
	                });
	            }
	        } else if (curSelected && curSelected !== prevValId) { /* If value set through setValue or using some other methods, isCommitted won't be set at that case */
	            /* Clearing the uncommitted selection */
	            this._select(false, $(curSelected), null, evObj);
	            this._unFocusItem();
	            /* Selecting the previous value */
	            previousValue && this._select(true, null, previousValue, evObj);
	        }
	        this._isCommitted = this._curSelectedItem = this._curSelectedItemData = undefined;
	    }
	    _getPrevValId() {
	        let prevValue = this._prevSelectedItemData;
	        return prevValue ? '#' + this._getItemId(prevValue) : undefined;
	    }
	    _setScrollPos(evObj) {
	        let itemToScroll,
	            opts = this._opts,
	            isSingle = this._isSingle,
	            focusFirstItemOnOpen = opts.focusFirstItemOnOpen,
	            prevSelected = this._prevSelectedItemData,
	            focusSelected = opts.focusSelectedItemOnOpen,
	            selectedEle,
	            prevSelectedEle = $(this._getPrevValId());
	        if (focusSelected) {
	            if (isSingle) {
	                selectedEle = (prevSelectedEle.length && prevSelectedEle.is(':visible')) ? prevSelectedEle : undefined; // No I18N
	            } else {
	                selectedEle = $(this._listBody.find('.' + this.CLASSES.item + '.is-selected')[0]);// No I18N
	                if (!selectedEle.length || !selectedEle.is(':visible')) { // No I18N
	                    /* If none of the item is selected or the selected item is not visible */
	                    selectedEle = undefined;
	                }
	            }
	        }
	        if (focusSelected && selectedEle) {
	            if (isSingle) {
	                /* Retaining the last selection and scrolling it to view */
	                this._select(true, null, prevSelected, evObj, true);
	            } else {
	                itemToScroll = selectedEle;
	            }
	        } else if (focusFirstItemOnOpen) {
	            itemToScroll = this.getFirstValidItem();
	        }
	        if (itemToScroll) {
	            itemToScroll = $(itemToScroll);
	            this._select(true, itemToScroll, null, evObj, true);
	        }
	        /* Resetting the scrollTop */
	        if ((!itemToScroll || focusFirstItemOnOpen) && !prevSelected) {
	            this._lastScrollTop = 0;
	            this._setScrollTop();
	        }
	    }
	    _focusLastFocussed() {
	        if (!this._fromOpenMethod || this.params.query) {
	            return super._focusLastFocussed(...arguments);
	        }
	    }
	    _select(selectOrFocus, item, selectPrev, evObj, doNotSelect) {
	        this._internalChange = true;
	        if (selectPrev) {
	            selectOrFocus = true;
	            item = $(this._getPrevValId());
	        }
	        if (!doNotSelect) {
	            this._navInstance[selectOrFocus ? 'selectItem' : 'deSelectItem'](item, evObj);// No I18N
	        }
	        if (selectOrFocus) {
	            /* Selected item is focussed */
	            this._focusEle(item, evObj, true);
	        }
	        this._internalChange = false;
	    }
	    _destroy() {
	        let opts = this._opts,
	            container = this.container;
	        Object.keys(opts.animation).length && ZC.clearAnimationData(container);
	        opts.handleFocusNavigation && ZC.FocusHandler && ZC.FocusHandler.destroy(container);
	        this.element.removeData('zshowhide actualDirection arrowDirection arrowPosition availableHeight availableWidth componentName direction elementPosition pos prevDirection'); // No I18N
	        if (this.isCE) {
	            this.element.removeClass(this._data.className).empty();
	        }
	        super._destroy(...arguments);
	    }
	    _search(query, searchOpts) {
	        this._focussed = true; /* It is added since focusFirstResult will work only when the list is focussed */
	        this._updateHtAndPos = true;
	        let evObj = searchOpts.event,
	            isInputFld = this.inputField && !this._showSearchField;
	        super._search(...arguments);
	        if (!this._isShown && (searchOpts.shouldOpen || isInputFld && evObj && evObj.target === this.inputField[0])) {
	            if (isInputFld) {
	                searchOpts.shouldOpen = false; /* Because even when shouldOpen is true, warningMsg has to be checked */
	            }
	            let warningMsg = this._status,
	                open = searchOpts.shouldOpen || (warningMsg === 'noresults' ? this._opts.search.showNoResultsMessage : warningMsg !== 'minkeywordlength'); // No I18N
	            if (open) {
	                this.open({
	                    fromSearch: true
	                }, evObj);
	            }
	        }
	        this._updateHtAndPos = false;
	    }
	    _callOpen(props) {
	        return ZC.Helpers.open(this.container, props || this._showHideProps);
	    }
	    _setValues(values, properties) {
	        /* Autocomplete cases in combobox need this behavior */
	        let setInternalChange = properties && properties.commit === false;
	        if (setInternalChange) {
	            this._internalChange = true;
	        }
	        super._setValues(...arguments);
	        if (this._isSingle) {
	            if (this._selectedItems.length) {
	                this._savePrevSelection(this._selectedItems[0].id)
	            }
	        }
	        if (setInternalChange) {
	            this._internalChange = false;
	        }
	    }
	    _reSearch() {
	        this.params.previousQuery = this.params.query = undefined;
	        if (this._isShown) {
	            super._reSearch();
	        } else {
	            this._shouldReSearch = true;
	        }
	    }
	    _focusItemUsingNavInstance($item, orgEvent, scrollToView = true) {
	        this._navInstance.focusItem($item, orgEvent, scrollToView);
	    }
	    _openHandler(evObj) {
	        let dispatchEv = this._dispatchEvent.bind(this);
	        this._isShown = true;
	        this._setAriaAttrs();
	        if (dispatchEv('beforefocus', evObj)) { // No I18N
	            this.setFocus();
	        }
	        dispatchEv('open', evObj); // No I18N
	    }
	    _closeHandler(evObj) {
	        if (Object.keys(this._opts.animation).length) {
	            this._display(true, this.container);
	        }
	        ZC.Helpers.removeScrollClass(this.element);
	        this._setAriaAttrs(true);
	        this._dispatchEvent('close', evObj); // No I18N
	        if (this._isSingle && this._curSelectedItem) {
	            this._updateSelectedItem(evObj);
	        } else {
	            this._unFocusItem();
	        }
	    }
	    _focusCallback() {
	        this._focussed = true;
	        super._focusCallback(...arguments);
	    }
	    open(options = {}, evObj) {
	        if (!this._isShown) {
	            let opts = this._opts,
	                shouldOpen = true,
	                isSearchFld = opts.searchField,
	                minKeywordLength = options.minKeywordLength === undefined ? opts.search.minKeywordLength : options.minKeywordLength,
	                searchQuery;
	            if (options.searchQuery !== undefined) { /* It might also have empty string */
	                searchQuery = options.searchQuery;
	            } else if (isSearchFld) {
	                searchQuery = this.inputField.val();
	            } else if (this._shouldReSearch) {
	                searchQuery = this.params.query || '';
	            }
	            if (minKeywordLength && searchQuery !== undefined && !this._shouldReSearch) {
	                shouldOpen = this._opts.search.showNoResultsMessage || searchQuery.length >= minKeywordLength;
	            }
	            if (shouldOpen && this._dispatchEvent('beforeopen', evObj)) {
	                this._fromOpenMethod = true; /* Included for focusLastFocussed case and while _search calling it has to be checked whether it is called when open executing since isShown can't be used because open is called after search */
	                if (options.forElement) {
	                    this._storeForElement(options.forElement);
	                }
	                if (!this._initialized) {
	                    this._initialized = true;
	                    searchQuery = searchQuery || '';
	                }
	                options.event = evObj;
	                !options.fromSearch && searchQuery !== undefined && this.search(searchQuery, options);
	                if (opts.offset) {
	                    this._callOpen();
	                } else {
	                    this._updatePos(true, evObj);
	                }
	                this._opts.handleFocusNavigation && ZC.FocusHandler && ZC.FocusHandler.refresh(this.container);
	                /* If open is called from search, then focusFirstResult should have the higher priority */
	                if (!options.fromSearch || !opts.search.focusFirstResult) {
	                    this._setScrollPos(evObj);
	                }
	                if (this._isBtns) {
	                    this._handleBtnsOnOpen();
	                }
	                let animation = opts.animation;
	                animation = Object.keys(animation).length ? animation.open : null;
	                if (!animation) {
	                    this._openHandler(evObj)
	                }
	                this._fromOpenMethod = this._shouldReSearch = false;
	            }
	        }
	    }
	    close(evObj) {
	        let dispatchEv = this._dispatchEvent.bind(this),
	            container = this.container,
	            inputFld = this.inputField;
	        if (this._isShown && dispatchEv('beforeclose', evObj)) { // No I18N
	            ZC.Helpers.close(container, {
	                ...this._showHideProps,
	                event: evObj
	            });
	            this._maxHt = this._direction = undefined;
	            this._isShown = false;
	            /* Clearing the last searched value */
	            if (!this._opts.searchField && inputFld && inputFld.val().length) {
	                this.search('', { // No I18N
	                    event: evObj
	                });
	            }
	            if (this._doneBtn && this._valueChanged && !this._doneClicked) {
	                this._internalChange = true;
	                this._resetClickHandler(evObj, true);
	            }
	            this._valueChanged = undefined;
	            let animation = this._opts.animation;
	            animation = Object.keys(animation).length ? animation.close : null;
	            if (!animation) {
	                this._closeHandler(evObj)
	            }
	        }
	    }
	    setFocus(orgEvent) {
	        if (this._trigger('beforefocus', orgEvent)) { // No I18N
	            this.container.focus();
	            this._focusInHandler(orgEvent);
	        }
	    }
	    getValue() {
	        let prevData = this._prevSelectedItemData;
	        return (this._isSingle && this._opts.selectOnKeyNavigation) ? prevData ? [ prevData ] : undefined : this._opts.value;
	    }
	    deselect() {
	        this._valCleared = this._isSingle;
	        super.deselect(...arguments);
	    }
	    deselectAll() {
	        this._valCleared = this._isSingle;
	        super.deselectAll(...arguments);
	    }
	    search(query, searchOpts = {}, open) {
	        if (open) {
	            /* !forElement check added for offset given cases */
	            searchOpts.shouldOpen = open ? !this._forElement || this._forElement.is(':visible') : undefined; // No I18N
	        }
	        super.search(query, searchOpts); // No I18N
	    }
		_animateOpenOrClose  (ele, opts) {
		    let animation = this._opts.animation;
		    if (!opts.mustBeShown) {
		        let isShown = this._isShown,
		            animate = isShown ? animation.close : animation.open;
		        if (!animate.name && !isShown) { /* For close, hiding will be done in closeHandler */
		            this._display(false, this.container);
		        }
		        ZC.animationHandler({
		            action: isShown ? 'close' : 'open', // No I18N
		            animation,
		            element: this.container,
		            ctype: this.name,
		            callback: isShown ? this._closeHandler.bind(this) : this._openHandler.bind(this)
		        });
		    }
		}
		_bindInputFieldEvents  () {
		    super._bindInputFieldEvents(...arguments);
		    if(this._opts.searchFieldOptions.handleEvents){
		        this._addEvents({
		            inputMousedown: 'mousedown' // No I18N
		        }, this.inputField);
		    }
		}
		_checkCurPos  (){
		    let inputField = this.inputField[0],
		    searchFieldOptions = this._opts.searchFieldOptions;
		    return (searchFieldOptions.filterBasedOnCurPos || searchFieldOptions.suggestOnFieldFocus)  && inputField.selectionStart === inputField.selectionEnd;
		}
		_inputMousedownHandler  (evObj){
		    let searchFieldOptions = this._opts.searchFieldOptions;
		    this._filteredOnMouseDown = false;
		    if (this._checkCurPos()) {
		        this._filteredOnMouseDown = true;
		        if(searchFieldOptions.filterBasedOnCurPos){
		            this._searchBasedOnCurPos(evObj)
		        }else {
		            this._search(undefined, {event: evObj})
		        }
		    }
		}
		_inputMouseupHandler  (evObj){
		    let inputField = this.inputField[0];
		    if(!this._filteredOnMouseDown && inputField.selectionStart === inputField.selectionEnd) {
		        super._inputMouseupHandler(evObj);
		    }
		}
		_getCloseProps  () {
		    let opts = this._opts;
		    return this._data.close || ZC._getIconInfo(opts.closeIconClassName, opts.closeSVGIconId, '#zc__svg--close', 'zdropdownlist__closeicon');// No I18N
		}
		_updateCloseEle  () {
		    let close = this._data.close.mainElement = this.container.find('.zdropdownlist__closeiconcontainer')[0];
		    close = $(close)
		    close.attr({
		        tabindex: 0,
		        role: 'button', // No I18N
		        title: this._getI18NText('closeButtonLabel') // No I18N
		    })
		    this._addEvents({
		        closeClick: 'click' // No I18N
		    }, close);
		}
		_closeClickHandler  (evObj) {
		    this.close(evObj);
		}
		_constructBtns  () {
		    let cBar = this._data.cBar = {},
		        commandBar = this._opts.commandBar || this._defaultCBar;
		    this._isBtns = !!commandBar;
		    this._btnsArr = [];
		    this._emptyBtnData();
		    for (let col in commandBar) {
		        let colArr = commandBar[col],
		            align = col.replace('Column', ''); // No I18N
		        cBar[align] = [];
		        cBar[align + 'Class'] = this.CLASSES[col];
		        colArr.forEach((btn, index) => {
		            this._btnsArr.push(btn);
		            let btnName = '_' + btn + 'Btn'; // No I18N
		            this[btnName] = true;
		            this[btnName + 'Data'] = cBar[align][index] = this._getBtnAttr(btn); // No I18N
		        });
		    }
		    this._data.cBar = this._btnsArr.length ? cBar : null;
		}
		_emptyBtnData  () {
		    [ 'done', 'reset', 'clear' ].forEach((btn) => { // No I18N
		        let btnName = '_' + btn + 'Btn'; // No I18N
		        this[btnName] = this[btnName + 'Data'] = undefined;
		    });
		}
		_setDefaultCBar  () {
		    let cBar = null,
		        opts = this._opts,
		        defaultCBar = {
		            done: 'rightColumn', // No I18N
		            reset: 'rightColumn', // No I18N
		            clear: 'leftColumn'// No I18N
		        },
		        btnArr = [ 'clear', 'reset', 'done' ]; // No I18N
		    btnArr.forEach((btn) => {
		        if (opts[btn + 'Button']) { // No I18N
		            if (!cBar) {
		                cBar = {};
		            }
		            let col = defaultCBar[btn];
		            cBar[col] = cBar[col] || [];
		            cBar[col].push(btn);
		        }
		    })
		    this._defaultCBar = cBar;
		}
		_getBtnAttr  (btn) {
		    let label = btn + 'ButtonLabel', // No I18N
		    isReset = btn === 'reset'; // No I18N
		    label = this._opts[btn + 'ButtonLabel'] || this._getI18NText(label); // No I18N
		    return ZC.ZButton.getBtnProps({
		        customAttributes: {
		            name: btn,
		            'aria-label': label // No I18N
		        },
		        name: btn,
		        tabindex: 0,
		        className: btn + '-' + this.name + (isReset ? ' zdropdownlist__textbutton' : ''), // No I18N
		        text: label, // No I18N
		        appearance: btn === 'done' ? 'primary' : 'normal', // No I18N
		        size: 'small', // No I18N
		        isCE: this.isCE,
		        templateRender: true
		    });
		}
		_updateBtns  () {
		    let btns = this._btnsArr || []; // No I18N
		    btns.forEach((btn) => {
		        let btnData = this['_' + btn + 'BtnData']; // No I18N
		        if (btnData) {
		            let elem = btnData.mainElement = this.container.find('.' + btn + '-' + this.name);
		            this._addEvents({
		                [btn + 'Click']: 'mousedown keydown', // No I18N
		                btnFocusIn: 'focusin' // No I18N
		            }, elem);
		            this._handleFocus(elem);
		        }
		    });
		}
		_btnFocusInHandler  (evObj) {
		    if ($(evObj.target).hasClass('has-mfocus')) { // No I18N
		        this._focusInHandler(evObj);
		    }
		}
		_doneClickHandler  (evObj) {
		    if (evObj.type === 'mousedown' || this._isKeyDown(evObj)) {
		        this._doneClicked = true;
		        this._btnClicked = 'done';// No I18N
		        if (this._isSingle) {
		            this._savePrevSelection();
		        }
		        if (this._valueChanged) {
		            this._trigger('change', evObj); // No I18N
		        }
		        this.close(evObj);
		        this._doneClicked = false;
		        this._trigger('done', evObj);// No I18N
		        this._btnClicked = undefined;
		    }
		}
		_resetClickHandler  (evObj, forceReset) {
		    let elem = this._resetBtnData && this._resetBtnData.mainElement;
		    elem = $(elem);
		    if (forceReset || evObj && elem.length && !$(evObj.target).closest(elem).hasClass('is-disabled') && (evObj.type === 'mousedown' || this._isKeyDown(evObj))) { /* Since anchor tags can't be disabled */
		        if (this._valueChanged) {
		            this._setInternalChange();
		            this._setValues(this._prevSelectedItems, {
		                event: evObj,
		                clearOtherValues: true
		            });
		            !this._doneBtn && super._trigger('change', evObj); // No I18N
		        }
		        evObj && this._trigger('reset', evObj);// No I18N
		        if (elem.length) {
		            this._updateBtnState(true, 'reset');// No I18N
		            this._btnClicked = 'reset'; // No I18N
		        }
		        this._internalChange = false;
		        if(evObj && evObj.type === 'mousedown'){
		            this._btnClicked = undefined;
		        }
		    }
		}
		_clearClickHandler  (evObj) {
		    if (evObj.type === 'mousedown' || this._isKeyDown(evObj)) {
		        this._btnClicked = 'clear';// No I18N
		        this._setInternalChange();
		        this._valueChanged = true;
		        this.deselectAll(evObj);
		        this._updateBtnState(true, 'clear');// No I18N
		        this._trigger('clear', evObj);// No I18N
		        // !this._doneBtn && super._trigger('change', evObj); // No I18N
		        this._internalChange = false;
		        if(evObj.type === 'mousedown'){
		            this._btnClicked = undefined;
		        }
		    }
		}
		_setInternalChange  () {
		    if (this._doneBtn) {
		        this._internalChange = true;
		    }
		}
		_isKeyDown  (evObj) {
		    let keyCode = ZC.keyCode;
		    if(evObj.type === 'keydown'){ // No I18N
		        if([keyCode.UP, keyCode.DOWN].indexOf(evObj.keyCode) > -1){
		            this._isItemsNavigation = true;
		            this.setFocus(evObj);
		            this._isItemsNavigation = undefined;
		        }
		        return [ keyCode.ENTER, keyCode.SPACE ].indexOf(evObj.keyCode) > -1;
		    }
		}
		_disableOrEnableBtns  (disable) {
		    this._doneBtn && this._updateBtnState(disable, 'done');// No I18N
		    this._resetBtn && this._updateBtnState(disable, 'reset');// No I18N
		}
		_updateBtnState  (disable, btn) {
		    btn = '_' + btn + 'Btn'; // No I18N
		    let disableCls = ' is-disabled', // No I18N
		        btnData = this[ btn + 'Data'], // No I18N
		        clsName = btnData.className;
		    if (disable) {
		        clsName = clsName.indexOf(disableCls) > 0 ? clsName : clsName + disableCls;
		    } else {
		        clsName = clsName.replace(disableCls, '');
		    }
		    this._disable(disable, btnData.mainElement);
		    btnData.className = clsName;
		}
		_handleBtnsOnOpen  () {
		    let selecteditems = this._selectedItems;
		    if (this._clearBtn) {
		        this._updateBtnState(!selecteditems.length, 'clear');// No I18N
		    }
		    let prevValues = this._selectedItems.slice(); /* To duplicate the array without reference */
		    this._prevSelectedItems = prevValues.map((value) => value.originalData);
		    this._disableOrEnableBtns(true);
		}
		_updateBtnsOnItemSelect  () {
		    this._disableOrEnableBtns();
		    /* To avoid triggering change on done click when no change is happened */
		    this._valueChanged = true;
		    this._clearBtn && this._updateBtnState(!this._selectedItems.length, 'clear'); // No I18N
		}
		_handleBtnAttrs  (name, value) {
		    if (name.indexOf('Label') > -1) { // No I18N
		        this._setBtnValue({
		            text: value
		        }, this['_' + name.replace('ButtonLabel', '') + 'BtnData']); // No I18N
		    } else {
		        /* Modified Attr is not used since if setAttributes called, different value will be assigned to it and events will not be bind to buttons */
		        this._btnAttrChanged = true; // No I18N
		        this._validateOpts();
		        this._constructBtns();
		    }
		}
		_resetFocus  (btn, evObj) {
		    /* To remove the classes added by _handleFocus() in zgeneral-main. */
		    this['_' + btn + 'BtnData'].mainElement.removeClass('has-focus has-mfocus has-kfocus');// No I18N
		    this.setFocus(evObj);
		    this._btnClicked = undefined;
		}
		_updateSearchFldPos  (pos) {
		    let shouldAdd;
		    if (this.inputField && !this._opts.searchField && !this._data.title && !this._isBtns) { /* only if internal searchfield exists */
		        shouldAdd = pos.indexOf('top') > -1;
		    }
		    this.container[ shouldAdd ? 'addClass' : 'removeClass']('zdropdownlist--searchbottom'); // No I18N
		}
		_updatePos  (fromOpen, evObj) {
		    let opts = this._opts,
		        direction = opts.position,
		        positionAlterable = opts.positionAlterable,
		        showHideProps = {
		            ...this._showHideProps,
		            event: evObj,
		            mustBeShown: !fromOpen, /* If it is not set, element will be closed and opened again. */
		            positionAlterable,
		            direction
		        };
		    if (positionAlterable) {
		        if (direction === 'auto') { // No I18N
		            showHideProps.direction = direction = 'bottom-left'; // No I18N
		            // Modified: positionAlterable can be different values - later when handled in showHideHandler - it can be removed.
		            showHideProps.positionAlterable = showHideProps.positionAlterable || true;
		        }
		        showHideProps.callbacks = {
		            beforeComputingDir: {
		                dimensionModifier: (targetDim, elementDim, withinDim, options) => {
		                    if (!this._maxHt) {
		                        this._maxHt = elementDim.height;
		                    } else if (elementDim.height >= this._maxHt) {
		                        this._maxHt = elementDim.height;
		                    } else {
		                        options.positionAlterable = false;
		                        options.direction = this._direction; // No I18N
		                    }
		                }
		            }
		        }
		    }
		    let pos = this._callOpen(showHideProps).actualDirection;
		    if (fromOpen) {
		        this._direction = pos;
		        this._updateSearchFldPos(pos);
		    }
		}
		updatePosition  () {
		    this._updatePos();
		}
		_fieldKeydownHandler  (evObj) {
		    let code = evObj.keyCode;
		    this._lastKeyCode = code;
		    this._shiftPressed = evObj.shiftKey;
		    if (this._isShown || this._showSearchField) {
		        return super._fieldKeydownHandler(...arguments);
		    } 
		    let ZkeyCode = ZC.keyCode;
		    // Opening list on UP and DOWN key press.
		    if (code === ZkeyCode.UP || code === ZkeyCode.DOWN) {
		        // It leads to movement of the cursor to the first and the last
		        evObj.preventDefault();
		        let query, minKeywordLength;
		        let methodName = 'search'; //No I18N
		        // Query is made empty to display all the items
		        if (this._opts.searchFieldOptions.listAllItemsOnDOWNPress) {
		            methodName = 'open'; //No I18N
		            query = ''; // No I18N
		            minKeywordLength = 0;
		        } else {
		            query = this.inputField.val();
		        }
		        let searchOptions = {
		            event: evObj,
		            minKeywordLength,
		            updateField:false
		        };
		        if(methodName === 'open'){ //No I18N
		            searchOptions.searchQuery = query;
		            this.open(searchOptions);
		        }else{
		            this.search(query, searchOptions, true);
		        }
		    }
		}
		_inputKeyupHandler  (evObj) {
		    let ZkeyCode = ZC.keyCode;
		    let keyCode = evObj.keyCode;
		    let inputFieldSettings = this._opts.searchFieldOptions;
		    if (inputFieldSettings.suggestOnFieldFocus && keyCode === ZkeyCode.TAB && (keyCode !== this._lastKeyCode || this._shiftPressed !== evObj.shiftKey)) {
		        this.searchWithDelay(undefined, {
		            event:evObj,
		            delay:1
		        }); 
		    } else {
		        super._inputKeyupHandler(...arguments);
		    }
		    this._lastKeyCode = undefined;
		    this._shiftPressed = false;
		}
		_setAttribute  (name, value) {
		    let opts = this._opts,
		        data = this._data,
		        domChanged;
		    this._userOptions[name] = value;
		    opts[name] = value;
		    if (name === 'forElement') { // No I18N
		        this._storeForElement(value);
		    }else if ([ 'title', 'closeButton', 'closeIconClassName', 'closeSVGIconId' ].indexOf(name) > -1) { // No I18N
		        if ([ 'title', 'closeButton' ].indexOf(name) > -1) { // No I18N
		            this._constructTitleBar();
		            data.attrModified = name;
		            domChanged = true; // No I18N
		        } else if (opts.closeButton) {
		            name = name === 'closeSVGIconId' ? 'SVGIconId' : 'iconClassName'; // No I18N
		            this._setBtnValue({
		                [name]: value
		            }, data.close)
		        }
		    } else if ([ 'clearButton', 'doneButton', 'resetButton', 'commandBar', 'resetButtonLabel', 'clearButtonLabel', 'doneButtonLabel' ].indexOf(name) > -1) { // No I18N
		        this._handleBtnAttrs(name, value);
		        domChanged = name.indexOf('Label') < 0;
		    }else if(name === 'displayType'){  // No I18N
		        data.attrModified = "displayType"; // No I18N
		        this._validateOpts();
		        if(value === 'box'){
		            this._pointer = undefined;
		        }
		        domChanged = true;
		    } else {
		        if ([ 'selectOnKeyNavigation', 'focusItemOnItemMouseover', 'multiple' ].indexOf(name) > -1) { // No I18N
		            if(name === 'multiple' && value){
		                this._prevSelectedItem = this._prevSelectedItemData = this._curSelectedItem = this._curSelectedItemData = null;
		            }
		            this._validateOpts();
		        }
		        super._setAttribute(...arguments);
		        domChanged = this._domChanged;
		        if (name === 'value' && this._isSingle) { // No I18N
		            if (value) {
		                data.attrModified = 'value';  // No I18N
		            } else {
		                this._valCleared = true;
		            }
		        }
		    }
		    if (['position', 'positionAlterable', 'offset', 'animation', 'margin', 'height', 'width', 'minWidth', 'viewport', 'appendTo', 'rtl' ].indexOf(name) > -1) { // No I18N
		        this._setShowHideOpts();
		    } 
		    if(this._reInit){
		        this._shouldReSearch = true;
		    }
		    this._domChanged = domChanged;
		}
	}
	ZC.registerComponent('ZDropdownList', ZC.ZListBox, ZDropdownList); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let listboxTemplate = ZC.zlistbox.Templates, template = ZC.zdropdownlist.Templates, utilities = ZC.Templates.Utilities; 
template.WCChildren = (data) => ZT.html `${data.isCallout && ZT.html `<div class='zdropdownlist__pointer'></div>`} ${(data.title || data.close) && template.WCTitle(data)} ${listboxTemplate.WCChildren(data)} ${data.cBar && ZT.html `<div class='zdropdownlist__commandbar'> ${utilities.WCCommandBarCol(data.cBar)} </div>`}` 
template.WCClose = (data) => ZT.html `<button class='zdropdownlist__closeiconcontainer'> ${ZC.Templates.Utilities.WCIcon(data)} </button>`; 
template.WCTitle = (data) => ZT.html `<div class='zdropdownlist__titlebar' role='heading'> ${data.title ? ZT.html `<span class='zdropdownlist__title'>${ZT.customHTML(data.title)}</span>` : ''} ${data.close && template.WCClose(data.close)} </div>` }(ZComponents)); 
 (function(ZC){ 
let listboxTemplate = ZC.zlistbox.Templates, template = ZC.zdropdownlist.Templates, utilities = ZC.Templates.Utilities; 
template.children = (data) => ZT.html `${data.isCallout && ZT.html `<div class='zdropdownlist__pointer'></div>`} ${(data.title || data.close) && template.title(data)} ${listboxTemplate.children(data)} ${data.cBar && ZT.html `<div class='zdropdownlist__commandbar'> ${utilities.commandBarCol(data.cBar)} </div>`}` 
template.close = (data) => ZT.html `<button class='zdropdownlist__closeiconcontainer'> ${ZC.Templates.Utilities.icon(data)} </button>`; 
template.title = (data) => ZT.html `<div class='zdropdownlist__titlebar' role='heading'> ${data.title ? ZT.html `<span class='zdropdownlist__title'>${ZT.customHTML(data.title)}</span>` : ''} ${data.close && template.close(data.close)} </div>` }(ZComponents)); 
(function(ZC, $){
	/* API DOUBTS
	    serverSearch - option - is it necessary
	    moreResultsAction
	    showNoResultsMessage
	*/
	/******
	    TAGS
	    1. z-optionsheader
	    2. z-optionsfooter
	    3. z-optionsbody
	    4. z-option
	    5. z-optgroup
	    6. z-optionsseparator
	*****/
	class ZSelect  extends ZC.CoreComponent{
			get name(){
				return "zselect";
			}
	    get attrs() {
	        return {
	            multiple: false,
	            selectionLimit: 0,
	            selectedIndex: null,
	            selectedValue: null,
	            value: null,
	            placeholder: null,
	            disabled: false,
	            contentType: 'text', // No I18N
	            template: null,
	            arrowIconClass: '',
	            arrowSVGIconId: '',
	            selectOnCharPress: true,
	            // className: null
	            // zclassName: null,
	            /* API TO ARRIVE */
	            sort: false,
	            sortBy: null,
	            sortOrder: 'asc', // No I18N
	            width: null,
	            isLabelHTMLEncoded: false,
	            cacheData: true,
	            isResponseFiltered: true,
	            serverSearch: false,
	            acceptNewValues: false,
	            newValuePattern: false,
	            showSearchField: false,
	            clearButton: false,
	            clearButtonSVGIconId: '', // No I18N
	            clearButtonIconClass: '', // No I18N
	            lazyLoading: false,
	            filterByCSSSelector: false,
	            viewPerPage: 10,
	            // Not exposed
	            dataStructure: 'flat', // No I18N
	            delimiter: undefined,
	            considerEmptySpacedValue: false,
	            allowHiddenOptionsForSelection: false,
	            allowDisabledOptionsForSelection: false
	        }
	    }
	    get props() {
	        return {
	            customSorter: null,
	            customSearch: null,
	            arrowIconClassName: '', // No I18N
	            clearButtonIconClassName: '', // No I18N
	            options: [],
	            dataSource: {},
	            dropdownList: {
	                focusFirstItemOnOpen: true,
	                focusSelectedItemOnOpen: undefined,
	                focusItemOnItemMouseover: true,
	                selectOnKeyNavigation: false,
	                hideCheckbox: true,
	                characterKeyFocus: true,
	                selectOnTabPress: true,
	                contentType: undefined,
	                template: undefined,
	                height: undefined,
	                width: undefined,
	                appendTo: undefined,
	                direction: 'auto', // No I18N
	                viewport: undefined,
	                /* API TO ARRIVE */
	                checkedIcon: undefined,
	                checkedIconClassName: undefined,
	                checkedSVGIconId: undefined,
	                // Loader Icon
	                loaderIconClassName: undefined,
	                loaderSVGIconId: undefined,
	                // className: null,
	                positionAlterable: false,
	                virtualization: false
	            },
	            search: {
	                // Changed
	                delay: 150,
	                criteria: 'contains', // No I18N
	                caseSensitive: false,
	                minKeywordLength: 0,
	                by: 'label', // No I18N
	                /* API TO ARRIVE */
	                focusFirstResult: true,
	                highlightKeyword: false,
	                maxKeywordLength: 0,
	                showNoResultsMessage: true,
	                searchIncrementsInCache: false
	            },
	            messages: {
	                allOptionsSelected: 'All Selected', // No I18N
	                noResults: 'No results found', // No I18N
	                serverError: 'Server request failed. Please try again later.', // No I18N
	                /* API TO ARRIVE */
	                clear: 'Clear', // No I18N
	                moreAction: 'See more results', // No I18N
	                placeholder: 'Select' // No I18N
	            },
	            /* API TO ARRIVE */
	            dataMapping: {
	                id: 'id', // No I18N
	                label: 'label', // No I18N
	                value: 'value', // No I18N
	                informativeText: 'informativeText', // No I18N
	                iconClassName: 'iconClassName', // No I18N
	                SVGIconId: 'SVGIconId', // No I18N
	                options: 'options', // No I18N
	                optgroupLabel: null,
	                zitemid: 'zitemid' // No I18N
	            },
	            depCompClassNames: {
	                dropdownlist: 'DropdownList' // No I18N
	            }
	        }
	    }
	    get propType() {
	        return {
	            selectedIndex: 'number' // No I18N
	        }
	    }
	    get ARIA_ROLES() {
	        return {
	            CONTAINER: 'listbox' // No I18N
	        }
	    }
	    get SELECTORS() {
	        let isCE = this.isCE;
	        return {
	            OPTION: isCE ? 'z-option' : 'option', // No I18N
	            OPTGROUP: isCE ? 'z-optgroup' : 'optgroup', // No I18N
	            OPTIONSBODY: 'z-selectbody', // No I18N
	            OPTIONSHEADER: 'z-selectheader', // No I18N
	            OPTIONSFOOTER: 'z-selectfooter', // No I18N
	            OPTIONSEPARATOR: 'z-optionseparator', // No I18N
	            ADDOPTION: 'z-addoption' // No I18N
	        }
	    }
	    get CLASSES() {
	        return {
	            CONTAINER: 'zselectbox', // No I18N
	            ICON: 'zselectbox__icon', // No I18N
	            ICONTEXT: 'zselectbox--icontext', // No I18N
	            ICONONLY: 'zselectbox--icononly', // No I18N
	            TEXT: 'zselectbox__text', // No I18N
	            DROPUP: 'zselectbox--top', // No I18N
	            DROPDOWN: 'zselectbox--bottom', // No I18N
	            ACTIVE: 'is-active', // No I18N
	            FOCUS: 'has-focus', // No I18N
	            DISABLED: 'is-disabled', // No I18N
	            CLEARBUTTON: 'zselectbox__clearbutton', // No I18N
	            MENU: {
	                CLASSNAME: 'zmenu--selectmenu', // No I18N
	                ITEM: 'zmenu__item', // No I18N
	                BODY: 'zmenu__body' // NO I18N
	            }
	        }
	    }
	    get EVENTS() {
	        return [
	            'init', // No I18N
	            'beforedropdownlistopen', // No I18N
	            'dropdownlistopen', // No I18N
	            'beforedropdownlistclose', // No I18N
	            'dropdownlistclose', // No I18N
	            'beforechange', // No I18N
	            'change', // No I18N
	            'select', // No I18N
	            'deselect', // No I18N
	            'beforeselect', // No I18N
	            'beforedeselect', // No I18N
	            'itemclick', // No I18N
	            'optionclick', // No I18N
	            'optionhover', // No I18N
	            'addoptionclick', // No I18N
	            'blur', // No I18N
	            'beforefocus', // No I18N
	            'focus', // No I18N
	            'noresults', // No I18N
	            'beforedropdownlistupdate', // No I18N
	            'dropdownlistupdate', // No I18N
	            'newvalueadd', // No I18N
	            'beforesearch', // No I18N
	            'searcherror', // No I18N
	            'searchsuccess' // No I18N
	        ]
	    }
	    _init(element, options) {
	        this._fromInit = true;
	        this._useParent = false;
	        this._elementId = element[0].id || this._getID();
	        this._listID = options.menuId || (this._elementId + '-listbox'); // No I18N
	        this._selected = [];
	        [ 'disabled', 'multiple', 'placeholder' ].forEach((key) => { // No I18N
	            options[key] = options[key] || element[0][key];
	        });
	        if (options.multiple) {
	            this._initMultiple();
	        }
	        this._initDS();
	        // this._createListBox();
	        this._setInitial();
	        this._savePrev();
	    }
	    _savePrev() {
	        this._lastValues = this._opts.value;
	    }
	    _getPrev() {
	        return this._lastValues;
	    }
	    _createListBox() {
	        let listSettings = this._getListSettings();
	        let className = this._opts.depCompClassNames.dropdownlist;
	        let createMethod = 'create' + className; // No I18N
	        let componentName = className.toLowerCase();
	        let listRootElement = ZC[createMethod](listSettings);
	        let listInstance = this.listInstance = ZC[componentName](listRootElement);
	        this.ajaxSource = listInstance.ajaxSource;
	        this.staticData = listInstance.staticData;
	        this._listbox = listInstance.getElement();
	        this._bindListEvents();
	    }
	    _setListBoxAttrs(listSettings) {
	        // clearTimeout(this._focusListTimer);
	        let listInstance = this.listInstance;
	        listSettings = listSettings || this._getListSettings();
	        listInstance.setAttributes(listSettings);
	        this.ajaxSource = listInstance.ajaxSource;
	        this.staticData = listInstance.staticData;
	    }
	    _preRender() {
	        let options = this._opts;
	        let data = this._data;
	        if (!this._data.rendered || this._domChanged) {
	            this._onAttrChange(data, options);
	        }
	        let attrs = data.attrs;
	        attrs['aria-expanded'] = this._opened; // No I18N
	        this._setValueData(options, data);
	        return this._data;
	    }
	    _onAttrChange(data, options) {
	        let element = this.element;
	        // let style = element.attr('style') || ''; // No I18N
	        data.alwaysSetAttrs = true;
	        data.clearButton = options.clearButton;
	        data.disabled = options.disabled;
	        data.multiple = options.multiple;
	        data.placeholder = options.placeholder || this._getI18NText('placeholder'); // No I18N
	        // ContentType
	        data.isCustom = options.contentType === 'custom'; // No I18N
	        data.hasText = data.hasIcon = false;
	        if (!data.isCustom) {
	            data.hasText = options.contentType.indexOf('text') > -1; // No I18N
	            data.hasIcon = options.contentType.indexOf('image') > -1; // No I18N
	        }
	        data.width = this._getWidth(options.width);
	        data.tabindex = data.disabled ? null : (options.tabindex || element.attr('tabindex') || 0); // No I18N
	        data.attrs = {
	            // style: style && style.replace(/(display\s*:\s*none\s*;?)/g, '') || '', // No I18N
	            style: data.width ? ('width:' + data.width) : undefined, // No I18N
	            title: element.attr('title'), // No I18N
	            'aria-disabled': options.disabled, // No I18N
	            'aria-haspopup': 'listbox', // No I18N
	            'aria-owns': this._listID, // No I18N
	            'aria-required': false, // No I18N
	            id: this._elementId + '-container', // No I18N
	            role: this.ARIA_ROLES.CONTAINER,
	            tabindex: data.tabindex
	        }
	        if (this._opts.multiple) {
	            data.attrs['aria-multiselectable'] = this._opts.multiple; // No I18N
	        }
	        ZC._getIconInfo(options.arrowIconClassName || options.arrowIconClass, options.arrowSVGIconId, '#zc__svg--downarrow zselectbox__arrow', 'zselectbox__icon zselectbox__arrowicon', data.arrow = {}); // No I18N
	    }
	    _setValueData(options, data) {
	        let selected = this._selected;
	        data.label = data.icon = data.noSelection = data.innerHTML = null;
	        if (data.clearButton) {
	            this._setClrBtnData(options, data);
	        }
	        if (selected.length) {
	            this._setContentData(selected, options, data);
	        } else {
	            data.noSelection = true;
	        }
	    }
	    _setContentData(selected, options, data) {
	        if (options.multiple) {
	            data.label = this._getLabelForMultiple(selected);
	        } else {
	            let optData = this._getData(selected[0]);
	            if (data.isCustom) {
	                data.innerHTML = this._getCustomContent(optData, options.template || optData.zinnerHTML || optData.innerHTML);
	            } else {
	                this._setIconTextData(optData, data);
	            }
	            data.attrs['aria-activedescendant'] = optData.zitemid; // No I18N
	        }
	    }
	    _setIconTextData(optData, data) {
	        if (data.hasText) {
	            data.label = this._getRenderText(optData);
	        }
	        if (data.hasIcon) {
	            ZC._getIconInfo(this._getProp(optData, 'iconClassName'), this._getProp(optData, 'SVGIconId'), null, this._CLASSES.ICON, data.icon = {}); // No I18N
	        }
	    }
	    _getRenderText(optData) {
	        return this._getLabel(optData);
	    }
	    _getLabel(optData, encode = true) {
	        return this._getProp(optData, 'label', encode); // No I18N
	    }
	    _postRender() {
	        this._storeRef();
	        this._createListBox();
	        this._fromInit = false;
	        this._trigger('init'); // No I18N
	    }
	    _storeRef() {
	        if (this._data.clearButton) {
	            this._storeClrBtn();
	        }
	    }
	    _postEachRender() {
	        if (this._domChanged) {
	            this._storeRef();
	        }
	        this._setTitle();
	        this._setClassName();
	    }
	    _setClassName() {
	        let options = this._opts;
	        let classes = this._CLASSES;
	        let className = classes.CONTAINER + ' ' + (this.element.attr('class') || '') + ' ' + (options.className || options.zclassName || ''); // No I18N
	        if (options.contentType === 'image') { // No I18N
	            className += (' ' + classes.ICONONLY); // No I18N
	        } else if (options.contentType === 'image-text') { // No I18N
	            className += ' ' + classes.ICONTEXT; // No I18N
	        }
	        if (options.rtl) {
	            className += ' zh-rtl'; // No I18N
	        }
	        if (options.disabled) {
	            className += ' ' + classes.DISABLED; // No I18N
	        } else if (this._isFocussed()) {
	            className += ' ' + classes.FOCUS; // No I18N
	            if (this._opened || this._active) {
	                let direction = this._listbox && this._listbox.data('direction'); // No I18N
	                className += ' ' + classes.ACTIVE + ' ' + (direction && (direction.indexOf('top') === 0 ? classes.DROPUP : classes.DROPDOWN)); // No I18N
	            }
	        }
	        if (this._data.clearButton) {
	            className += ' zselectbox--withclear'; // No I18N
	            this._hideClrBtn();
	        }
	        this._data.className = className;
	    }
	    _isFocussed() {
	        let activeElement = document.activeElement;
	        if (activeElement) {
	            activeElement = $(activeElement);
	            return activeElement[0] === this.container[0] || this._opened && this.listInstance.isFocussed() || this.container.find(activeElement).length;
	        }
	    }
	    _setTitle() {
	        let data = this._data;
	        let options = this._opts;
	        let title = ''; // No I18N
	        if (!data.noSelection && !data.isCustom) {
	            let textspan = this.container[0].querySelector('.' + this._CLASSES.TEXT); // No I18N
	            if (options.contentType === 'image' || textspan && textspan.clientWidth < textspan.scrollWidth) { // No I18N
	                title = this._opts.multiple ? data.label : this._getLabel(this._getData(this._selected[0]), false);
	            }
	        }
	        this.container[0].title = title;
	    }
	    _isNotNull(value) {
	        return super._isNotNull(value) && (this._opts.considerEmptySpacedValue ? true : !/^\s*$/.test(value)); // No I18N
	    }
	    _getWidth(width) {
	        width = width || this.element[0].style.width;
	        if (width) {
	            return isNaN(width) ? width : width + 'px'; // No I18N
	        }
	    }
	    _getListSettings() {
	        let options = this._opts;
	        let listSettings = options.dropdownList;
	        let checkedIcon = listSettings.checkedIcon;
	        this._isCheckBoxType = checkedIcon = checkedIcon || (options.multiple && !this._isNotNull(options.checkedIcon));
	        let dataMapping = {
	            ...options.dataMapping
	        }
	        let settings = {
	            id: this._listID,
	            multiple: options.multiple,
	            selectionLimit: options.selectionLimit,
	            forElement: this.container,
	            rtl: options.rtl,
	            search: options.search,
	            // isCE: this.isCE,
	            dataMapping: dataMapping,
	            moreResultsAction: this._opts.search.moreResultsAction,
	            showNoResultsMessage: this._opts.search.showNoResultsMessage,
	            searchFieldOptions: {}
	        };
	        $.extend(settings, listSettings);
	        if (settings.focusSelectedItemOnOpen === undefined) {
	            settings.focusSelectedItemOnOpen = !options.multiple;
	        }
	        settings.className = (settings.className || '') + ' ' + this._CLASSES.MENU.CLASSNAME; // No I18N
	        settings.contentType = settings.contentType || options.contentType;
	        settings.checkedIcon = checkedIcon;
	        settings.template = settings.template || options.template;
	        settings.position = settings.position || settings.direction;
	        settings.positionAlterable = settings.positionAlterable || (settings.position === 'auto' && 'flipsidefit'); // No I18N
	        if (this._fromInit || this._resetValue || !this._dsInited) {
	            settings.value = this._getReselectValue();
	        }
	        [ 'showSearchField', // No I18N
	            'filterByCSSSelector', // No I18N
	            'lazyLoading', // No I18N
	            'viewPerPage', // No I18N
	            'sort', // No I18N
	            'sortBy', // No I18N
	            'sortOrder', // No I18N
	            'customSorter', // No I18N
	            'cacheData', // No I18N
	            'isResponseFiltered', // No I18N
	            'serverSearch', // No I18N
	            'customSearch', // No I18N
	            'messages' // No I18N
	        ].forEach((key) => settings[key] = options[key]);
	        // EVENTS
	        [ 'itemClick', // No I18N
	            'itemHover', // No I18N
	            'itemFocus', // No I18N
	            'beforeUpdate', // No I18N
	            'update', // No I18N
	            'noResults', // No I18N
	            'beforeSearch', // No I18N
	            'searcherror', // No I18N
	            'searchsuccess', // No I18N
	            'change', // No I18N
	            'select', // No I18N
	            'deselect', // No I18N
	            'beforeSelect', // No I18N
	            'beforeDeselect', // No I18N
	            'input' // No I18N
	        ].forEach((event) => settings[event.toLowerCase()] = this['_' + event + 'Handler'].bind(this)); // No I18N
	        [ 'BeforeOpen', // No I18N
	            'BeforeClose', // No I18N
	            'Open', // No I18N
	            'Close', // No I18N
	            'BeforeKeyDown' // No I18N
	        ].forEach((event) => settings[event.toLowerCase()] = this['_list' + event + 'Handler'].bind(this)); // No I18N
	        settings.beforefocus = (orgEvent) => {
	            if (!this._opts.showSearchField) {
	                orgEvent.preventDefault();
	                this.container.focus();
	            }
	        };
	        dataMapping.text = dataMapping.label;
	        dataMapping.groupLabel = dataMapping.optgroupLabel;
	        dataMapping.label = dataMapping.optgroupLabel = null;
	        if (!this.ajaxSource) {
	            dataMapping.value = 'zitemid'; // No I18N
	        }
	        settings.focusFirstItemOnOpen = settings.search.focusFirstResult;
	        if (!this._dsInited) {
	            $.extend(true, settings, this._listDSAPI);
	            this._dsInited = true;
	        }
	        return settings;
	    }
	    _inputHandler(orgEvent, eventData) {
	        orgEvent = orgEvent.originalEvent;
	        this._trigger('input', orgEvent, eventData); // No I18N
	    }
	    _searcherrorHandler(orgEvent, eventData) {
	        orgEvent = orgEvent.originalEvent;
	        this._trigger('searcherror', orgEvent, eventData); // No I18N
	    }
	    _searchsuccessHandler(orgEvent, eventData) {
	        orgEvent = orgEvent.originalEvent;
	        if (this.staticData) {
	            this._dataFetched = true;
	            this._updateData(eventData.results, true);
	        }
	        this._trigger('searchsuccess', orgEvent, eventData); // No I18N
	    }
	    _beforeSearchHandler(orgEvent, eventData) {
	        orgEvent = orgEvent.originalEvent;
	        return this._trigger('beforesearch', orgEvent, eventData) // No I18N
	    }
	    _noResultsHandler(orgEvent, eventData) {
	        orgEvent = orgEvent.originalEvent;
	        return this._trigger('noresults', orgEvent, eventData) // No I18N
	    }
	    _beforeUpdateHandler(orgEvent, eventData) {
	        orgEvent = orgEvent.originalEvent;
	        this._trigger('beforedropdownlistupdate', orgEvent, eventData); // No I18N
	    }
	    _updateHandler(orgEvent, eventData) {
	        orgEvent = orgEvent.originalEvent;
	        this._trigger('dropdownlistupdate', orgEvent, eventData); // No I18N
	    }
	    _bindListEvents() {
	        this._addEvents({
	            listBlur: 'focusout' // No I18N
	        }, this._listbox);
	    }
	    _listBlurHandler() {
	        this._blurHandler();
	    }
	    _listBeforeCloseHandler(orgEvent) {
	        orgEvent = orgEvent.originalEvent;
	        if (this._isFocussed()) {
	            this._setFocus(false, true);
	        }
	        return this._trigger('beforedropdownlistclose', orgEvent) // No I18N
	    }
	    _listBeforeOpenHandler(orgEvent) {
	        orgEvent = orgEvent.originalEvent;
	        this.listInstance.setAttribute('minWidth', this.container[0].offsetWidth); // No I18N
	        if (!this._opened) {
	            return this._trigger('beforedropdownlistopen', orgEvent); // No I18N
	        }
	    }
	    _listBeforeKeyDownHandler(orgEvent) {
	        let originalEvent = orgEvent.originalEvent;
	        if (originalEvent && originalEvent.keyCode === ZC.keyCode.TAB) {
	            originalEvent.preventDefault();
	        }
	    }
	    search(query, searchOptions) {
	        searchOptions.searchQuery = query;
	        this.listInstance.open(searchOptions);
	    }
	    _listCloseHandler(orgEvent) {
	        orgEvent = orgEvent.originalEvent;
	        this._opened = false;
	        this._setClassName();
	        this._setExpandAttr();
	        this._trigger('dropdownlistclose', orgEvent); // No I18N
	    }
	    _focusList() {
	        clearTimeout(this._focusListTimer);
	        this._focusListTimer = setTimeout(() => {
	            this.listInstance.setFocus();
	        }, 100);
	    }
	    _listOpenHandler(orgEvent) {
	        orgEvent = orgEvent.originalEvent;
	        let alreadyOpened = this._opened;
	        this._opened = true;
	        this._setClassName();
	        this._focusList();
	        this._setExpandAttr();
	        if (!alreadyOpened) {
	            this._trigger('dropdownlistopen', orgEvent); // No I18N
	        }
	    }
	    _setExpandAttr() {
	        if (this._opened) {
	            this.container.attr('aria-expanded', this._opened); // No I18N
	        } else {
	            this.container.removeAttr('aria-expanded'); // No I18N
	        }
	    }
	    _getSelectionFromDS() {
	        let dsOptions = this._dataSource.options;
	        let options = this._opts;
	        let callback = (dsOption) => dsOption.selected;
	        if (options.multiple) {
	            return dsOptions.filter(callback); // No I18N
	        }
	        return dsOptions.find(callback); // No I18N
	    }
	    _isOptionSelectable(optionData) {
	        return (this._opts.allowDisabledOptionsForSelection || !optionData.disabled) && (this._opts.allowHiddenOptionsForSelection || !optionData.hidden) && !optionData.separator
	    }
	    _setInitial() {
	        let options = this._opts;
	        let defaultOption = this._isNotNull(options.value) ? options.value : options.selectedValue;
	        if (this._isNull(defaultOption)) {
	            let dsOptions = this._dataSource.options;
	            if (dsOptions.length) {
	                let selectedIndex = options.selectedIndex;
	                if (selectedIndex === null) {
	                    defaultOption = this._getSelectionFromDS();
	                    if (!options.multiple && !defaultOption) {
	                        defaultOption = dsOptions.find((dsOption) => this._isOptionSelectable(dsOption));
	                    }
	                } else if (parseInt(selectedIndex) > -1) {
	                    defaultOption = this._getDataAt(selectedIndex);
	                }
	            }
	        }
	        if (!this.isCE) {
	            this.element[0].selectedIndex = -1;
	        }
	        defaultOption = this._toArr(defaultOption);
	        if (defaultOption.length) {
	            if (options.multiple) {
	                if (options.selectionLimit) {
	                    defaultOption = defaultOption.splice(-1 * options.selectionLimit);
	                }
	            } else {
	                defaultOption = [ defaultOption[0] ];
	            }
	        }
	        this._allowTagCreation = true;
	        defaultOption.map((option) => {
	            option = this._getSelectableOption(option)
	            if (option) {
	                this._selected.push(option);
	                this._addedByComponent = true;
	                option.selected = true;
	                this._addedByComponent = false;
	            }
	        });
	        this._allowTagCreation = false;
	        this._updateValues();
	    }
	    _getDataAt(indexes) {
	        return this._toArr(indexes).map((index) => this._dataSource.options[index]);
	    }
	    _initDS() {
	        this.ajaxSource = undefined;
	        if (!this._dsInited) {
	            let options = this._opts;
	            let initialDS = this._initialDS = this._getDataSource();
	            let dataSource = options.dataSource;
	            let optionsData = options.options;
	            this._dataFetched = true;
	            this.ajaxSource = this._isAjaxSource(options.dataSource);
	            if (Array.isArray(optionsData)) {
	                optionsData = JSON.parse(JSON.stringify(optionsData));
	                initialDS = initialDS.concat(optionsData);
	            }
	            if (dataSource && dataSource.URL) {
	                this._dataFetched = false;
	            }
	            this._updateData(initialDS);
	        }
	    }
	    _updateData(finalDS, fromAjaxSuccess) {
	        this._isGrouped = false;
	        let ds = this._dataSource = this._splitDS(finalDS);
	        let header = ds.header;
	        let footer = ds.footer;
	        if (fromAjaxSuccess) {
	            header = this._listDSAPI.headerItems;
	            footer = this._listDSAPI.footerItems;
	        }
	        this._listDSAPI = {
	            items: ds.body,
	            headerItems: header,
	            footerItems: footer,
	            dataSource: this._opts.dataSource
	        };
	        this._updateLocalDS();
	    }
	    _getListType() {
	        return this._opts.dropdownList.contentType || this._opts.contentType;
	    }
	    _getDatas(options) {
	        return options.map((option) => this._getData(option));
	    }
	    _getData(option) {
	        if (!option.optData) {
	            let itemId = option.getAttribute('data-zitemid'); // No I18N
	            option.optData = this._dataSource.options.find((data) => data.zitemid === itemId);
	        }
	        return option.optData;
	    }
	    /* Function to construct the menu object with which menu can be created */
	    _genTagData(options, groupData) {
	        return options.map((option) => {
	            let optData = ZC._getOpts(option);
	            optData.id = option.id;
	            let isGroup;
	            let altLabel;
	            if (!optData.separator) {
	                if (option.tagName.toLowerCase() === this._SELECTORS.OPTGROUP) {
	                    isGroup = true;
	                    altLabel = option.label;
	                } else {
	                    altLabel = option.textContent.trim() || option.label || ''; // No I18N
	                    optData.selected = optData.selected || option.selected;
	                }
	                optData.disabled = optData.disabled || option.disabled;
	                optData.label = this._isNotNull(optData.label) ? optData.label : altLabel;
	            }
	            this._setProp(optData, 'label', optData.label); // No I18N
	            this._setProp(optData, 'value', option.value); // No I18N
	            if (isGroup) {
	                this._setProp(optData, 'optgroupLabel', optData.label); // No I18N
	            }
	            // Since hidden property is not available in IE10 and below, attribute check is included.
	            optData.className = optData.className || option.className;
	            optData.hidden = option.hasAttribute('hidden'); // No I18N
	            optData.title = option.getAttribute('title'); // No I18N
	            optData.style = option.getAttribute('style'); // No I18N
	            if (!optData.zitemid) {
	                let itemid;
	                if (optData.id) {
	                    itemid = this.name + '-' + this._listID + '-option-' + optData.id; // No I18N
	                } else {
	                    itemid = this._getID(null, this._listID + '-option');// No I18N
	                }
	                optData.zitemid = itemid;
	            }
	            this._mapReqData(optData, isGroup, groupData);
	            if (isGroup) {
	                let subOptions = this._getValidSubOptions($(option));
	                if (!this.isCE || subOptions[0]._initialized) {
	                    optData.options = this._genTagData(subOptions, optData);
	                }
	            }
	            optData.zpopulated = true;
	            this._addedByComponent = true;
	            this._updateOptionAttrs(option, optData);
	            this._addedByComponent = false;
	            this.isCE && !this._opts.isLyteComponent && option.saveParentIns(this.element);
	            option.optData = optData;
	            return optData;
	        });
	    }
	    _getItemId(optData) {
	        return super._getItemId(optData, this._listID);
	    }
	    _bindEvents() {
	        this._addEvents({
	            focus: 'focusin', // No I18N
	            containerBlur: 'focusout', // No I18N
	            keyDown: 'keydown', // No I18N
	            click: 'click'// No I18N
	        });
	        this._addEvents({
	            mouseDown: 'mousedown' // No I18N
	        }, this._arrowTarget);
	        this._handleFocus(this.container);
	    }
	    // Fix for Chrome which loses inputField focus on mouseup of the container
	    _clickHandler() {
	        this._opened && this._focusList();
	    }
	    _focusHandler(orgEvent) {
	        this._setClassName();
	        this._trigger('focus', orgEvent); // No I18N
	    }
	    _keyDownHandler(orgEvent) {
	        let options = this._opts;
	        if (!options.disabled) {
	            if (this._opened) {
	                return this.listInstance.handleKeyCode(orgEvent);
	            }
	            let ZkeyCode = ZC.keyCode;
	            let eventCode = orgEvent.keyCode;
	            switch (eventCode) {
	                case ZkeyCode.SPACE:
	                    this._open(orgEvent);
	                    orgEvent.preventDefault();
	                    return;
	                case ZkeyCode.ENTER:
	                    this._open(orgEvent);
	                    return;
	                case ZkeyCode.DOWN:
	                case ZkeyCode.UP:
	                    this._open();
	                    orgEvent.preventDefault();
	                    return;
	                default:
	                    if (this._isAlphaNumericKey(orgEvent)) {
	                        if (options.showSearchField) {
	                            if (eventCode !== ZkeyCode.DELETE && eventCode !== ZkeyCode.BACKSPACE) {
	                                this.search(String.fromCharCode(eventCode), {
	                                    event: orgEvent,
	                                    updateField: false
	                                });
	                            }
	                        } else if (options.selectOnCharPress) {
	                            this._selectItemOnKeydown(orgEvent);
	                        }
	                    }
	            }
	        }
	    }
	    _mouseDownHandler(orgEvent) {
	        if (!this._opts.disabled && !orgEvent.button) {
	            this[this._opened ? '_close' : '_open'](orgEvent, true); // No I18N
	            orgEvent.preventDefault();
	        }
	    }
	    _containerBlurHandler(orgEvent) {
	        this._blurHandler(orgEvent);
	    }
	    _blurHandler(orgEvent) {
	        clearTimeout(this._focusoutTimer);
	        this._focusoutTimer = setTimeout(this._afterBlur.bind(this, orgEvent));
	    }
	    _afterBlur(orgEvent) {
	        if (this.container && !this._isFocussed()) { // method invoked after destroy. So, container check is added.
	            this._close(orgEvent);
	            this._setClassName();
	            this._trigger('blur', orgEvent); // No I18N
	        }
	    }
	    _itemClickHandler(orgEvent) {
	        let eventData = orgEvent.detail;
	        orgEvent = orgEvent.originalEvent;
	        let menuitem = eventData.item;
	        let optionData = eventData.itemData;
	        eventData = {
	            menuitem,
	            optionData
	        }
	        if (optionData.isHeader || optionData.isFooter) {
	            if (this.isCE) {
	                this._trigger('addoptionclick', orgEvent, eventData); // No I18N
	            }
	        }
	        this._trigger('optionclick', orgEvent, eventData); // No I18N
	    }
	    _beforeSelectHandler(orgEvent, select) {
	        let eventData = orgEvent.detail;
	        orgEvent = orgEvent.originalEvent;
	        let optionData = eventData.itemData;
	        let action = select ? 'select' : 'deselect'; // No I18N
	        eventData = {
	            optionData,
	            menuitem: eventData.item
	        }
	        return this._trigger('before' + action, orgEvent, eventData) // No I18N
	    }
	    _beforeDeselectHandler(orgEvent) {
	        return this._beforeSelectHandler(orgEvent, false);
	    }
	    _selectHandler(orgEvent, select) {
	        let eventData = orgEvent.detail;
	        orgEvent = orgEvent.originalEvent;
	        let optionData = eventData.itemData;
	        let action = select ? 'select' : 'deselect'; // No I18N
	        eventData = {
	            optionData,
	            menuitem: eventData.item
	        }
	        this._setValueFromHandler(optionData, orgEvent, select);
	        return this._trigger(action, orgEvent, eventData)
	    }
	    _changeHandler(orgEvent) {
	        let eventData = orgEvent.detail;
	        orgEvent = orgEvent.originalEvent;
	        this._updateView();
	        let optionData = eventData.itemData;
	        eventData = {
	            optionData,
	            menuitem: eventData.item,
	            previousValue: this._getPrev()
	        }
	        this._savePrev();
	        return this._trigger('change', orgEvent, eventData) // No I18N
	    }
	    _deselectHandler(orgEvent) {
	        return this._selectHandler(orgEvent, false);
	    }
	    _setValueFromHandler(optionData, orgEvent, select) {
	        return this[select ? '_selectOption' : '_deselectOption' ](optionData, orgEvent); // No I18N
	    }
	    _itemHoverHandler(orgEvent) {
	        let eventData = orgEvent.detail;
	        orgEvent = orgEvent.originalEvent;
	        let optionData = eventData.itemData;
	        return this._trigger('optionhover', orgEvent, {// No I18N
	            item: eventData.item,
	            optionData
	        });
	    }
	    _itemFocusHandler(orgEvent) {
	        // let eventData = orgEvent.detail;
	        // orgEvent = orgEvent.originalEvent;
	        // let optionData = eventData.itemData;
	        // return this._trigger('optionfocus', orgEvent, {// No I18N
	        //     item: eventData.item,
	        //     optionData
	        // });
	    }
	    _getOptionForData(optData, orgEvent) { // optData can be value/completeData
	        let existingData = true;
	        if (this._dataFetched) {
	            let matchedOptData = this._getMatchData(optData);
	            if (matchedOptData) {
	                optData = matchedOptData;
	            } else {
	                existingData = false;
	            }
	        }
	        let option = this._getOptionByZItemId(this._getItemId(optData));
	        // querySelector doesn't support values that starts with digit. It needs to be escaped.
	        // let option = this.element[0].querySelector('[data-zitemid=' + this._getItemId(optData) + ']'); // No I18N
	        if (!option && this._allowTagCreation) {
	            if (existingData) {
	                option = this._addOptionTag(optData);
	            } else if (this._opts.acceptNewValues) {
	                option = this._acceptNewValues(optData, orgEvent);
	            }
	        }
	        return option;
	    }
	    _getOptionByZItemId(zitemid) {
	        return this.element.find('[data-zitemid="' + zitemid + '"]')[0]; // No I18N
	    }
	    /* Function to match the option that are selectable */
	    _getMatchData(value, items = this._dataSource.options) {
	        let matchingKey = this._opts.dataMapping.value;
	        if (typeof value === 'object') { // No I18N
	            let uniqueIds = [ 'zitemid', 'id' ]; // No I18N
	            for (let i = 0; i < uniqueIds.length; i++) {
	                let key = uniqueIds[i];
	                let tempValue = this._getProp(value, key);
	                if (this._isNotNull(tempValue)) {
	                    matchingKey = key;
	                    value = tempValue;
	                    break;
	                }
	            }
	        } else {
	            value = String(value);
	        }
	        return items.find((item) => {
	            let response = String(this._getProp(item, matchingKey)) === value;
	            return response;
	        });
	    }
	    _getValidSubOptions(parent, includeOptGroup) {
	        let selectors = this._SELECTORS;
	        let allowedTags = [ selectors.OPTION ];
	        if (includeOptGroup) {
	            allowedTags.push(selectors.OPTGROUP);
	        }
	        if (this.isCE) {
	            allowedTags.push(...[ selectors.OPTIONSEPARATOR, selectors.ADDOPTION ]);
	            if (parent.is(this.element)) {
	                allowedTags.push(...[ selectors.OPTIONSHEADER, selectors.OPTIONSFOOTER, selectors.OPTIONSBODY ]);
	            }
	        }
	        return parent.children(allowedTags.join(',')).toArray(); // No I18N
	    }
	    _getDataSource() {
	        let options = this._getValidSubOptions(this.element, true);
	        if (this.isCE) {
	            let selectors = this._SELECTORS;
	            let newOptions = [];
	            let regex = new RegExp(`(${selectors.OPTIONSHEADER}|${selectors.OPTIONSFOOTER}|${selectors.OPTIONSBODY})`, 'i'); // No I18N
	            options.forEach((option) => {
	                if (regex.test(option.tagName)) {
	                    newOptions.push(...this._getValidSubOptions($(option), true));
	                } else {
	                    newOptions.push(option);
	                }
	            });
	            if (!newOptions.length || !newOptions[0]._initialized) {
	                return [];
	            }
	            options = newOptions;
	        }
	        return this._genTagData(options.filter((option) => !option.getAttribute('data-ztemp'))); // No I18N
	    }
	    _splitDS(dataSource) {
	        let newSource = {
	            body: [],
	            header: [],
	            footer: []
	        };
	        dataSource.forEach((data) => {
	            data = this._getCompleteData(data);
	            if (data.isFooter) {
	                newSource.footer.push(data);
	            } else if (data.isHeader) {
	                newSource.header.push(data);
	            } else {
	                newSource.body.push(data);
	                if (data.options) {
	                    this._isGrouped = true;
	                }
	            }
	        });
	        return newSource;
	    }
	    _dataModifyHandler() {
	        this._updateLocalDS();
	        this._setListBoxAttrs({
	            ...this._listDSAPI,
	            ...{
	                value: this._getValueToSet(this._selected)
	            }
	        });
	        this._render();
	    }
	    _getReselectValue() {
	        return this._getValueToSet(this.getValue(true));
	    }
	    _updateLocalDS(DSSplits = this._dataSource) {
	        let options = DSSplits.options = [];
	        DSSplits.body.forEach((data) => {
	            if (data.options) {
	                options.push(...data.options);
	                this._isGrouped = true;
	            } else {
	                options.push(data);
	            }
	        });
	        this._dataSource = DSSplits;
	        this._listDSAPI.dataStructure = this._isGrouped ? 'nested' : 'flat'; // No I18N
	        // Updating options API is causing issues.
	        // this._opts.options = DSSplits.body.concat(DSSplits.header).concat(DSSplits.footer);
	        // this._opts.headerItems = DSSplits.header;
	        // this._opts.footerItems = DSSplits.footer;
	    }
	    _selectOption(valueToBeSelected, orgEvent) {
	        this._allowTagCreation = true;
	        let optionToBeSelected = this._getSelectableOption(valueToBeSelected, orgEvent);
	        this._allowTagCreation = false;
	        let options = this._opts;
	        this._addedByComponent = true;
	        if (!options.multiple) {
	            this._selected = [];
	        }
	        optionToBeSelected.selected = true;
	        this._selected.push(optionToBeSelected);
	        this._addedByComponent = false;
	        this._updateValues();
	    }
	    _deselectOption(valueToBeDeselected) {
	        let optionToBeUnSelected = this._getMatchedOptions(valueToBeDeselected)[0];
	        if (this._selected.length) {
	            if (!optionToBeUnSelected) {
	                let zitemid = this._getItemId(valueToBeDeselected);
	                optionToBeUnSelected = this._selected.find((option) => option.getAttribute('data-zitemid') === zitemid); // No I18N
	            }
	            if (optionToBeUnSelected) {
	                let optionIndex = this._selected.indexOf(optionToBeUnSelected);
	                this._addedByComponent = true;
	                optionToBeUnSelected.selected = false;
	                this._addedByComponent = false;
	                if (optionIndex !== -1) {
	                    this._selected.splice(optionIndex, 1);
	                }
	            }
	        }
	        this._updateValues();
	    }
	    _updateValues() {
	        let options = this._opts;
	        if (this._selected.length) {
	            options.selectedValue = options.value = [];
	            options.selectedIndex = [];
	            let optDatas = this._getDatas(this._selected);
	            this._selected.forEach((item, index) => {
	                let value = this._getProp(optDatas[index], 'value'); // No I18N
	                options.value.push(value);
	                options.selectedIndex.push(this._dataSource.options.indexOf(optDatas[index]));
	            });
	            if (!options.multiple) {
	                options.value = options.selectedValue = options.value[0];
	                options.selectedIndex = options.selectedIndex[0];
	            }
	        } else {
	            options.value = options.selectedValue = options.multiple ? [] : ''; // No I18N
	            this._addedByComponent = true;
	            options.selectedIndex = this.element[0].selectedIndex = -1;
	            this._addedByComponent = false;
	        }
	        this._updateView(true);
	    }
	    /* Function to update the value in combobox */
	    _updateView(delay) {
	        clearTimeout(this._renderTimer);
	        if (this._data.rendered && !this._skipRender && !this._domChanged) {
	            if (delay) {
	                this._renderTimer = setTimeout(this._render.bind(this));
	            } else {
	                this._render();
	            }
	        }
	    }
	    _trigger(customEvent, originalEvent, data) {
	        if (!this._fromInit) {
	            data = data || {};
	            data.dropdownList = this.getDropdownList();
	            data.selectedValue = data.value = this._opts.value || ''; // No I18N
	            data.selectedIndex = this._opts.selectedIndex;
	            let optionData = data.optionData;
	            if (optionData) {
	                data.optionData = optionData = {
	                    ...optionData
	                }
	                optionData.element = this._getOptionByZItemId(optionData.zitemid);
	            }
	            return this._dispatchEvent(customEvent, originalEvent, data, undefined, !!originalEvent);
	        }
	        return true;
	    }
	    _getMatchedOptions(values) {
	        let matchedOptions = this._toArr(values, true)
	            .map((value) => this._getMatchedOption(value));
	        return this._removeNulls(matchedOptions);
	    }
	    _getValidVal(value) {
	        if (value instanceof $) {
	            value = value[0];
	        }
	        return value;
	    }
	    _getMatchedOption(value, orgEvent) {
	        value = this._getValidVal(value);
	        if (this._isNotNull(value)) {
	            return value.nodeType ? this._contains(value) && value : this._getOptionForData(value, orgEvent);
	        }
	    }
	    _getMatchDataForUpdate(option, isGroup, items) {// items are passed incase of header and footer
	        option = this._getValidVal(option);
	        if (this._isNotNull(option)) {
	            if (option.nodeType) {
	                return option.optData;
	            }
	            return this._getMatchData(option, items || this._dataSource[isGroup ? 'body' : 'options']); // No I18N
	        }
	    }
	    _contains(node) {
	        return this.element[0].contains(node);
	    }
	    _isSelected(option) {
	        return this._selected.indexOf(option) !== -1;
	    }
	    _setValue(values, properties) {
	        this.listInstance.setValue(this._getValueToSet(values), properties);
	    }
	    _getValueToSet(values, orgEvent) {
	        let valuesToSet = [];
	        values = this._toArr(values);
	        values.forEach((value) => {
	            this._allowTagCreation = true;
	            let matchedOption = this._getSelectableOption(value, orgEvent);
	            this._allowTagCreation = false;
	            if (matchedOption) {
	                valuesToSet.push(matchedOption.optData);
	            }
	        });
	        return valuesToSet;
	    }
	    _desetValue(values, orgEvent) {
	        values = this._toArr(values);
	        let newValues = [];
	        for (let i = 0; i < values.length; i++) {
	            let matchedOption = this._getSelectableOption(values[i], orgEvent);
	            if (matchedOption && this._isSelected(matchedOption)) {
	                newValues.push(matchedOption.optData);
	            }
	        }
	        this.listInstance.deselect(newValues, orgEvent);
	    }
	    _getSelectableOption(value, orgEvent) {
	        let matchedOption = this._getMatchedOption(value, orgEvent);
	        if (matchedOption) {
	            let optData = matchedOption.optData;
	            return optData.selectable && this._isOptionSelectable(optData) && matchedOption;
	        }
	    }
	    _addOptionTag(optData) {
	        optData = this._getCompleteData(optData);
	        // DOMUTIL check
	        let option = /* optData.element = */ $('<' + this._SELECTORS.OPTION + '/>')
	            .attr({ // No I18N
	                selected: optData.selected,
	                id: optData.id,
	                value: this._getProp(optData, 'value') // No I18N
	            })[0];
	        this._updateOptionAttrs(option, optData, true);
	        option.optData = optData;
	        if (this.isCE) {
	            // Option needs to be appended to z-selectbody
	            this._appendTag(option);
	        } else {
	            this.element.append(option);
	        }
	        return option;
	    }
	    _updateOptionAttrs(option, optionData, created) {
	        this._addedByComponent = true;
	        let attributes = {
	            'data-zitemid': optionData.zitemid // No I18N
	        }
	        if (created) {
	            attributes['data-ztemp'] = true; // No I18N
	        }
	        if (optionData.isHeader) {
	            attributes['data-is-header'] = true; // No I18N
	        }
	        if (optionData.isFooter) {
	            attributes['data-is-footer'] = true; // No I18N
	        }
	        $(option).attr(attributes);
	        this._addedByComponent = false;
	    }
	    _getCompleteData(optData, isGroup, groupData) {
	        if (optData.nodeType) {
	            return this._genTagData([ optData ], groupData)[0];
	        }
	        if (/(number|string)/.test(typeof optData)) {
	            let data = {};
	            this._setProp(data, 'label', optData); // No I18N
	            optData = data;
	        }
	        this._mapReqData(optData, isGroup, groupData);
	        if (optData.options) {
	            optData.options = optData.options.map((option) => this._getCompleteData(option, false, optData));
	        }
	        return optData;
	    }
	    _mapReqData(originalData, isGroup, groupData) {
	        let optData = originalData;
	        let contentType = this._getListType();
	        optData.zitemid = this._getItemId(originalData);
	        let label = this._getProp(originalData, 'label'); // No I18N
	        label = this._isNotNull(label) ? String(label) : ''; // No 118N
	        let value = this._getProp(originalData, 'value'); // No I18N
	        value = this._isNotNull(value) ? String(value) : label;
	        this._setProp(originalData, 'label', label); // No I18N
	        this._setProp(originalData, 'value', value); // No I18N
	        let properties = Object.keys(originalData);
	        if (properties.indexOf('label') === -1) { // No I18N
	            originalData.label = label;
	        }
	        // optData.label = this._mapJSONToData(originalData, dataMapping.label);
	        // optData.label = this._isNotNull(optData.label) ? String(optData.label) : ''; // No I18N
	        // optData.value = this._mapJSONToData(originalData, dataMapping.value);
	        // optData.value = this._isNotNull(optData.value) ? String(optData.value) : optData.label;
	        optData.selectable = false;
	        // [ 'separator', 'isHeader', 'isFooter', 'hidden', 'disbled', 'title', 'style', 'className', 'id', 'iconClassName' ].forEach((key) => { // No I18N
	        //     optData[key] = originalData[key];
	        // });
	        if (optData.isHeader || optData.isFooter) {
	            optData.custom = true;
	        }
	        if (groupData) {
	            optData.groupName = this._getProp(groupData, 'value'); // No I18N
	            optData.hidden = groupData.hidden || originalData.hidden;
	            optData.disabled = groupData.disabled || originalData.disabled;
	        } else if (optData.options || isGroup) {
	            // this._isGrouped = true;
	            optData.options = optData.options || [];
	        }
	        if (!optData.isOptGroup && !optData.separator && !optData.isHeader && !optData.isFooter) {
	            optData.title = originalData.title;
	            if (optData.title === undefined) {
	                optData.title = contentType === 'image' ? optData.label : undefined;// No I18N
	            }
	            optData.selectable = true;
	            optData.selected = originalData.selected;
	        }
	        // optData.originalData = originalData;
	        return optData;
	    }
	    _close(orgEvent) {
	        this.listInstance.close(orgEvent);
	    }
	    _open(orgEvent) {
	        this.search('', { // No I18N
	            event: orgEvent,
	            updateField: false
	        });
	    }
	    _setFocusFn(focusContainer) {
	        if (!focusContainer && this._opened) {
	            this._focusList();
	        } else {
	            this.container.focus();
	        }
	    }
	    _setFocus(fromUser, focusContainer) {
	        if (this._trigger('beforefocus')) { // No I18N
	            this._setFocusFn(focusContainer);
	            // if (fromUser) {
	            //     this.container.addClass(this._CLASSES.FOCUS);
	            // }
	        }
	    }
	    _selectItemOnKeydown(orgEvent) {
	        let options = this._opts;
	        /* To handle keypress selection when menu is not opened */
	        if (this.staticData && !options.multiple) {
	            let selectedIndex = options.selectedIndex;
	            if (options.sortOptions) {
	                this.listInstance.DSInstance.fetch((dataSource) => {
	                    if (selectedIndex > -1) {
	                        let zitemid = this._dataSource.options[selectedIndex].zitemid;
	                        dataSource.find((data, index) => {
	                            if (data.zitemid === zitemid) {
	                                selectedIndex = index;
	                                return true;
	                            }
	                        });
	                    }
	                    this._selectNextMatchingItem(orgEvent, dataSource, selectedIndex);
	                });
	            } else {
	                this._selectNextMatchingItem(orgEvent, this._dataSource.options, selectedIndex);
	            }
	        }
	    }
	    _selectNextMatchingItem(orgEvent, quickSearchData, selectedIndex) {
	        if (quickSearchData.length) {
	            let startIndex = selectedIndex + 1;
	            let searchKey = orgEvent.key;
	            let currentTime = new Date().getTime();
	            if (this._prevKey) {
	                let timeDiff = currentTime - this._prevTimeStamp;
	                if (timeDiff < 300 && this._prevKey !== searchKey) {
	                    searchKey = this._prevKey + searchKey;
	                    startIndex--;
	                }
	            }
	            this._prevTimeStamp = currentTime;
	            this._prevKey = searchKey;
	            if (startIndex >= 0) {
	                let search = (start, end) => {
	                    for (let x = start; x < end; x++) {
	                        let data = quickSearchData[x];
	                        if (!data.hidden && !data.disabled && this._getProp(data, 'label').match(pattern)) { // No I18N
	                            return data;
	                        }
	                    }
	                    /* If the data is not found in the last half... first half is searched */
	                    return start && search(0, start);
	                };
	                let pattern = this._getMatchingRegex(searchKey, {
	                    criteria: 'startswith', // No I18N
	                    caseSensitive: false
	                });
	                let data = search(startIndex, quickSearchData.length);
	                data && this._setValue(data);
	            }
	        }
	    }
	    _setAttribute(optionName, value) {
	        this._addedByComponent = true;
	        switch (optionName) {
	            case 'selectedIndex': // No I18N
	                this._setAttribute('value', this._getDataAt(value)); // No I18N
	                break;
	            case 'value': // No I18N
	            case 'selectedValue': // No I18N
	                this._domChanged = true;
	                this.setValue(value, {
	                    clearOtherValues: true
	                });
	                break;
	            default:
	                this._setAdvAttribute(...arguments);
	        }
	        this._addedByComponent = false;
	    }
	    /** **PUBLIC FUNCTIONS*** */
	    /** ******************** */
	    setFocus() {
	        if (!this._opts.disabled) {
	            this._setFocus(true);
	        }
	    }
	    close() {
	        this._close();
	    }
	    open() {
	        if (!this._opts.disabled) {
	            this.setFocus();
	            this._open();
	        }
	    }
	    setValue(value, properties) {
	        this._setValue(value, properties);
	    }
	    deselectAllOptions(orgEvent) {
	        this.listInstance.deselectAll(orgEvent);
	    }
	    deselectOption() {
	        this._desetValue(...arguments);
	    }
	    getData(optionTags) {
	        return this._getDatas(optionTags);
	    }
	    getValue(completeData) {
	        if (completeData) {
	            return this.getData(this._selected);
	        }
	        return this._opts.value;
	    }
	    getOptions(type = 'body') { // No I18N
	        let _dataSource = this._dataSource;
	        if (type === 'header') { // No I18N
	            return _dataSource.header;
	        } else if (type === 'footer') { // No I18N
	            return _dataSource.footer;
	        } else if (type === 'body') { // No I18N
	            return _dataSource.body;
	        }
	        return _dataSource.header.concat(_dataSource.body).concat(_dataSource.footer);
	    }
	    refresh() {
	        this._dsInited = false;
	        this._buildData();
	    }
	    _buildData() {
	        let dsChanged = !this._dsInited;
	        this._initDS();
	        // this._reselect();
	        this._setListBoxAttrs();
	        if (dsChanged) {
	            let values = [];
	            this._selected.forEach((_selectedOption) => {
	                let option = this._getOptionByZItemId(_selectedOption.getAttribute('data-zitemid')); // No I18N
	                if (option) {
	                    values.push(option);
	                }
	            });
	            this._selected = values;
	        }
	        this._render();
	        this._domChanged = this._resetValue = false;
	    }
	    clearCache() {
	        this.listInstance.clearCache();
	    }
	    getDropdownList() {
	        return this._listbox[0];
	    }
	    _destroy() {
	        clearTimeout(this._renderTimer);
	        clearTimeout(this._focusoutTimer);
	        clearTimeout(this._focusListTimer);
	        this.listInstance.destroy();
	        this._listbox.remove();
	        this.element.find('[data-ztemp]').remove(); // No I18N
	        this._removeEvents('', this._arrowTarget); // No I18N
	    }
		_acceptNewValues  (optData, orgEvent) {
		    let eventData = {
		        newOptionData: optData
		    };
		    let newValuePattern = this._opts.newValuePattern;
		    if (!newValuePattern || newValuePattern.test(typeof optData === 'string' ? optData : this._mapJSONToData(optData, this._opts.dataMapping.label))) { // No I18N
		        if (this._trigger('newvalueadd', orgEvent, eventData)) { // No I18N
		            return this._addOptionTag(eventData.newOptionData);
		        }
		    }
		}
		_addOptionToGroup  (optDatas, action, refEle) {
		    let index, items;
		    if (typeof action === 'number') { // No I18N
		        // action is index here
		        if (refEle) {
		            index = action;
		            items = this._getMatchDataForUpdate(refEle, true).options;
		        } else {
		            let elementAtIndex = this._dataSource.options[action];
		            if (elementAtIndex) {
		                let data = this._getGroupAndIndex(elementAtIndex);
		                index = data.index;
		                items = data.items;
		            }
		        }
		    } else if (refEle) {
		        if (action === 'append') { // No I18N
		            items = this._getMatchDataForUpdate(refEle, true).options;
		        } else {
		            let refEleData = this._getMatchDataForUpdate(refEle);
		            if (refEleData) {
		                let data = this._getGroupAndIndex(refEleData);
		                index = data.index;
		                items = data.items;
		                if (action === 'after') { // No I18N
		                    index++;
		                }
		            }
		        }
		    }
		    // if (!items) {
		    //     items = items[items.length - 1].options;
		    // }
		    this._addDatasAt(optDatas, items, index);
		}
		removeOptGroup  (groupLabels) {
		    this._removeOption(groupLabels, true);
		    this._dataModifyHandler();
		}
		addOptGroup  (optDatas, refElement) {
		    this._addOption(optDatas, 'before', refElement, true); // No I18N
		    this._dataModifyHandler();
		}
		_getGroupAndIndex  (optData) {
		    let groupOptData = this._getMatchDataForUpdate(optData.groupName, true);
		    return {
		        items: groupOptData.options,
		        index: groupOptData.options.indexOf(optData)
		    }
		}
		_addOption  (optDatas, action, refEle, isGroup) {
		    optDatas = this._toArr(optDatas);
		    let optgroupTagName = this.isCE ? 'Z-OPTGROUP' : 'OPTGROUP'; // No I18N
		    optDatas = optDatas.map((optData) => {
		        let groupData;
		        if (!isGroup && optData.nodeType) {
		            let parentElement = optData.parentElement;
		            if (parentElement && parentElement.tagName === optgroupTagName) {
		                groupData = ZC._getOpts(parentElement);
		            }
		        }
		        return this._getCompleteData(optData, isGroup, groupData);
		    });
		    let type = optDatas[0].isHeader ? 'header' : (optDatas[0].isFooter ? 'footer' : 'body'); // No I18N
		    if (!this.ajaxSource || type !== 'body') { // No I18N
		        this[((!isGroup && this._isGrouped) && type === 'body') ? '_addOptionToGroup' : '_addOptionDirectly'](optDatas, action, refEle, type); // No I18N
		    }
		}
		_addOptionDirectly  (optDatas, action, refEle, type) {
		    let index;
		    let items = this._dataSource[type];
		    if (typeof action === 'number') { // No I18N
		        index = action;
		    } else if (refEle) {
		        index = items.indexOf(this._getMatchDataForUpdate(refEle, null, items));
		        if (action === 'after') { // No I18N
		            index++;
		        }
		    }
		    this._addDatasAt(optDatas, items, index);
		}
		_addDatasAt  (newDatas, existingDatas, index) {
		    if (index === undefined || index === -1) {
		        existingDatas.push(...newDatas);
		    } else {
		        existingDatas.splice(index, 0, ...newDatas);
		    }
		}
		_getOptionType  (type) {
		    return /(header|footer)/.test(type) ? type : 'body'; // No I18N
		}
		_removeOptionsAt  (indexes, isGroup, type) {
		    if (!this.ajaxSource || type === 'header' || type === 'footer') { // No I18N
		        indexes = indexes.filter((index, i) => index > -1 && indexes.indexOf(index) === i);
		        indexes.sort(function(a, b) {return b - a});
		        type = this._getOptionType(type);
		        let items = this._dataSource[type];
		        indexes.forEach((index) => {
		            if (this._isGrouped && !isGroup && type === 'body') { // No I18N
		                let optData = this._dataSource.options[index];
		                index = undefined;
		                if (optData) {
		                    let data = this._getGroupAndIndex(optData);
		                    index = data.index;
		                    items = data.items;
		                }
		            }
		            this._removeDataAt(index, items);
		        });
		    }
		}
		_removeDataAt  (index, items) {
		    if (index !== undefined && index > -1) {
		        if (!this._opts.acceptNewValues) {
		            let option = this._getOptionByZItemId(items[index].zitemid);
		            if (option) {
		                $(option).remove();
		            }
		            items.splice(index, 1);
		        }
		    }
		}
		_removeOption  (values, isGroup, type) {
		    type = this._getOptionType(type);
		    let items = isGroup ? this._dataSource.body : (type === 'body' ? this._dataSource.options : this._dataSource[type]); // No I18N
		    values = this._toArr(values);
		    let indexesToBeRemoved = values.map((value) => items.indexOf(this._getMatchDataForUpdate(value, isGroup, items)));
		    this._removeOptionsAt(indexesToBeRemoved, isGroup, type);
		}
		removeAllOptions  (type) {
		    let dataSource = this._dataSource;
		    if (type === 'header' || type === 'footer') { // No I18N
		        this.removeOption(dataSource[type]);
		    } else if (!this.ajaxSource) {
		        this.element.empty();
		        this._opts.options = [];
		        this._dsInited = false;
		        this._buildData();
		    }
		}
		addOption  (optDatas, action, refElement) {
		    this._addOption(optDatas, action, refElement);
		    this._dataModifyHandler();
		}
		addOptionAt  (optDatas, index, group) {
		    this._addOption(optDatas, index, group);
		    this._dataModifyHandler();
		}
		removeOption  (values, type) {
		    if (this._isNotNull(values)) {
		        this._removeOption(values, undefined, type);
		        this._dataModifyHandler();
		    } else {
		        this.removeAllOptions(type);
		    }
		}
		removeOptionAt  (indexes, type) {
		    this._removeOptionsAt(this._toArr(indexes), null, type);
		    this._dataModifyHandler();
		}
		_setClrBtnData  (options, data) {
		    if (!data.rendered || this._domChanged) {
		        let clearBtnClass = options.clearButtonIconClassName || options.clearButtonIconClass;
		        data.clearButton = {
		            iconClassName: clearBtnClass,
		            SVGIconId: options.clearButtonSVGIconId || (!clearBtnClass && 'zc__svg--clear'), // No I18N
		            className: this._CLASSES.CLEARBUTTON,
		            disabled: options.disabled,
		            templateRender: true,
		            rtl: this.rtl,
		            isCE: this.isCE,
		            title: this._getI18NText('clear'), // No I18N
		            customAttributes: {
		                tabindex: -1
		            }
		        }
		    }
		}
		_storeClrBtn  () {
		    let clearButton = this._data.clearButton.mainElement = $(this.container[0].querySelector(`.${this._CLASSES.CLEARBUTTON}`));
		    this._bindClrBtn(clearButton);
		}
		_bindClrBtn  (clearButton) {
		    this._addEvents({
		        clrBtnMouseDown: 'mousedown' // No I18N
		    }, clearButton);
		}
		_clrBtnMouseDownHandler  (orgEvent) {
		    if (!orgEvent.button) {
		        this.deselectAllOptions(orgEvent);
		        orgEvent.stopPropagation();
		        orgEvent.preventDefault();
		        this._setFocus();
		    }
		}
		_hideClrBtn  () {
		    let data = this._data;
		    data.clearButton.mainElement[0].style.display = (data.noSelection || data.disabled) ? 'none' : ''; // No I18N
		}
		disableOptions  (options) {
		    this.setOptionAttributes(options, 'disabled', true); // No I18N
		}
		enableOptions  (options) {
		    this.setOptionAttributes(options, 'disabled', false); // No I18N
		}
		_disable  (disable) {
		    disable && this.close();
		    this.element[0].disabled = !!disable;
		    this._domChanged = true;
		}
		_initMultiple  () {
		    let options = this._opts;
		    this.element[0].multiple = true;
		    let selectedIndex = options.selectedIndex;
		    if (!isNaN(parseInt(selectedIndex))) {
		        options.selectedIndex = String(selectedIndex).split(','); // No I18N
		    }
		    let values = this._isNotNull(options.value) ? options.value : options.selectedValue;
		    if (typeof values === 'string') { // No I18N
		        options.value = values.split(options.delimiter);
		    }
		    this._data.hasText = true;
		}
		_getLabelForMultiple  (selectedOptions) {
		    if (!this.ajaxSource) {
		        // Check whether all the options are selected.
		        let selectableOptions = this._dataSource.options.filter((dsOption) => !dsOption.separator);
		        let allSelected = selectableOptions.every((optData) => {
		            this._skipTagCreation = true;
		            let optionTag = this._getOptionForData(optData);
		            this._skipTagCreation = false;
		            return optionTag && optionTag.selected;
		        });
		        if (allSelected) {
		            return this._getI18NText('allOptionsSelected'); // No I18N
		        }
		    }
		    return selectedOptions.map((option) => this._mapJSONToData(this._getData(option), this._opts.dataMapping.label)).join(', '); // No I18N
		}
		// Public methods related to multiple selection
		getValues  (completeData) {
		    if (completeData) {
		        return this.getValue();
		    }
		    return [ ...this._opts.value ];
		}
		setValues  (values, reset) {
		    if (reset) {
		        this.setAttribute('value', values); // No I18N
		    } else {
		        return this.setValue(values);
		    }
		}
		_setAdvAttribute  (optionName, value) {
		    let options = this._opts;
		    switch (optionName) {
		        case 'acceptNewValues':// No I18N
		        case 'newValuePattern': // No I18N
		        case 'selectOnCharPress':// No I18N
		            options[optionName] = value;
		            break;
		        case 'arrowIconClassName': // No I18N
		        case 'arrowSVGIconId': // No I18N
		        case 'clearButton': // No I18N
		        case 'placeholder': // No I18N
		        case 'width': // No I18N
		            options[optionName] = value;
		            this._domChanged = true;
		            break;
		        case 'multiple': // No I18N
		            this.element[0].multiple = value;
		            options[optionName] = value;
		            this._reInit = this._resetValue = true;
		            break;
		        case 'selectionLimit': // No I18N
		            options[optionName] = value;
		            this._reInit = this._resetValue = true;
		            break;
		        case 'options':// No I18N
		        case 'dataSource': // No I18N
		            /* Previous option tags are removed except header and footer items  */
		            {
		                let childSelector = '[data-zitemid]:not([data-is-header]):not([data-is-footer])'; // No I18N
		                this.element
		                    .find(childSelector)
		                    .remove();
		                options[optionName] = value;
		                this._reInit = true;
		                this._dsInited = false;
		            }
		            break;
		        case 'dataMapping': // No I18N
		            options[optionName] = value;
		            this._reInit = true;
		            this._dsInited = false;
		            break;
		        case 'isResponseFiltered':// No I18N
		        case 'serverSearch': // No I18N
		        case 'cacheData':// No I18N
		        case 'viewPerPage':// No I18N
		        case 'lazyLoading':// No I18N
		        case 'filterByCSSSelector':// No I18N
		        case 'sort': // No I18N
		        case 'sortBy': // No I18N
		        case 'sortOrder': // No I18N
		        case 'customSorter': // No I18N
		        case 'customSearch': // No I18N
		        case 'contentType': // No I18N
		        case 'dropdownList': // No I18N
		        case 'showSearchField': // No I18N
		        case 'search': // No I18N
		        case 'rtl': // No I18N
		        case 'template': // No I18N
		            options[optionName] = value;
		            this._reInit = true;
		            break;
		        default:
		            options[optionName] = value;
		    }
		}
		_updateMenuAttribute  (optionName, value) {
		    this._menu && this._menuInstance.setAttribute(optionName, value);
		}
		_setOptionAttribute  (optData, optionName, value) {
		    if (optData) {
		        let updateTag = false;
		        if (optionName === 'options') { // No I18N
		            optData.options = value;
		            this._getCompleteData(optData);
		        } else if (optionName === 'value' || optionName === 'label') { // No I18N
		            optData[optionName] = value;
		            updateTag = true;
		        } else if (optionName === 'disabled' || optionName === 'hidden') { // No I18N
		            optData[optionName] = value;
		            updateTag = true;
		            if (optData.options) {
		                optData.options.forEach((subOptData) => this._setOptionAttribute(subOptData, optionName, value));
		            } else {
		                // Disabled items are allowed to be selected.
		                // value && this.deselectOption(optData);
		            }
		        } else if (optionName === 'selected') { // No I18N
		            if (value) {
		                this._setValue(optData);
		            } else {
		                this.deselectOption(optData);
		            }
		            return;
		        } else {
		            optData[optionName] = value;
		        }
		        let optionTag = this._getOptionForData(optData);
		        if (optionTag && updateTag) {
		            optionTag[optionName] = value;
		        }
		        this._updateDataVar = true;
		    }
		}
		setOptionAttributes  (options, optionName, value) {
		    this._addedByComponent = true;
		    this._updateDataVar = false;
		    if (!this._ajaxSource) {
		        this._toArr(options).forEach((option) => {
		            let optData = this._getMatchDataForUpdate(option, null, this._isGrouped ? this._dataSource.body.concat(this._dataSource.options) : null);
		            if (typeof optionName === 'object' && !$.isEmptyObject(optionName)) { // No I18N
		                for (let key in optionName) {
		                    this._setOptionAttribute(optData, key, optionName[key]);
		                }
		            } else {
		                this._setOptionAttribute(optData, optionName, value);
		            }
		        });
		        // replace list items
		        if (this._updateDataVar) {
		            this._dataModifyHandler();
		        }
		    }
		    this._addedByComponent = false;
		}
	}
	ZC.registerComponent('ZSelect', ZSelect); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zselect.Templates; 
let utilities = ZC.Templates.Utilities; 
template.WCContainer = (data) => ZT.html `<div>${data.children && template.WCChildren(data)}</div>`; 
template.WCChildren = (data) => { 
let response = ZT.html `<div class="zselectbox__selected"> ${data.noSelection ? ZT.html `<span class="zselectbox__text zselectbox__placeholder">${data.placeholder}</span>` : ZT.html `${ZT.customHTML(data.innerHTML || '')} ${data.icon && utilities.WCIcon(data.icon)} ${data.label && ZT.html `<span class="zselectbox__text">${ZT.customHTML(data.label)}</span>`}`} </div> ${data.clearButton && ZC.createButton(data.clearButton)} ${utilities.WCIcon(data.arrow)}`; return response; } }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zselect.Templates; 
let utilities = ZC.Templates.Utilities; 
template.container = (data) => ZT.html `<div>${data.children && template.children(data)}</div>`; 
template.children = (data) => { 
let response = ZT.html `<div class="zselectbox__selected"> ${data.noSelection ? ZT.html `<span class="zselectbox__text zselectbox__placeholder">${data.placeholder}</span>` : ZT.html `${ZT.customHTML(data.innerHTML || '')} ${data.icon && utilities.icon(data.icon)} ${data.label && ZT.html `<span class="zselectbox__text">${ZT.customHTML(data.label)}</span>`}`} </div> ${data.clearButton && ZC.createButton(data.clearButton)} ${utilities.icon(data.arrow)}`; return response; } }(ZComponents)); 
(function(ZC, $){
	class ZComboBox extends ZC.ZSelect {
			get name(){
				return "zcombobox";
			}
	    get attrs() {
	        return {
	            autoComplete: false
	        }
	    }
	    get props() {
	        return {
	            dropdownList: {
	                selectOnKeyNavigation: true
	            }
	        }
	    }
	    get CLASSES() {
	        return {
	            CONTAINER: 'zselectbox zcombobox' // No I18N
	        }
	    }
	    get SELECTORS() {
	        return {
	            OPTIONSBODY: 'z-comboboxbody', // No I18N
	            OPTIONSHEADER: 'z-comboboxheader', // No I18N
	            OPTIONSFOOTER: 'z-comboboxfooter' // No I18N
	        }
	    }
	    get ARIA_ROLES() {
	        return {
	            CONTAINER: 'combobox' // No I18N
	        }
	    }
	    _init(element, options) {
	        options.showSearchField = options.multiple = false;
	        super._init(element, options);
	    }
	    _storeRef() {
	        super._storeRef();
	        this._arrowTarget = this.container.find('i.zselectbox__arrowicon'); // No I18N
	        this._inputField = this.container.find('input');// No I18N
	    }
	    _postRender() {
	        super._postRender();
	        this._inputField[0].id = this.listInstance._getID('searchbox'); // No I18N
	        this._addEvents({
	            inputMouseUp: 'mouseup' // No I18N
	        }, this._inputField);
	    }
	    _inputMouseUpHandler(orgEvent) {
	        if (!this._skipHighlightingOnMouseUp) {
	            this._highlightContent();
	            this._skipHighlightingOnMouseUp = true;
	        }
	        orgEvent.preventDefault();
	    }
	    _preRender() {
	        if (this._skipDataSetting) {
	            return this._data;
	        }
	        let data = super._preRender(...arguments);
	        data.rendered && this._opts.selectedIndex !== -1 && this._iconShow(''); // No I18N
	        return data;
	    }
	    _getListSettings() {
	        let settings = super._getListSettings();
	        let searchFieldOptions = settings.searchFieldOptions;
	        searchFieldOptions.showSearchField = searchFieldOptions.multiple = false;
	        searchFieldOptions.listAllItemsOnDOWNPress = true;
	        // settings.autoComplete = true;
	        settings.autoCommit = true;
	        settings.searchField = this._inputField;
	        this._autoComplete = this._opts.autoComplete && this._opts.dropdownList.selectOnKeyNavigation;
	        if (this._autoComplete) {
	            settings.search.focusFirstResult = true;
	            settings.search.criteria = 'startswith'; // No I18N
	        }
	        settings.beforefocus = (orgEvent) => {
	            this._setFocus();
	        };
	        settings.focusFirstItemOnOpen = settings.search.focusFirstResult;
	        return settings;
	    }
	    _itemFocusHandler(orgEvent) {
	        let originalEvent = orgEvent.originalEvent;
	        if (originalEvent && originalEvent.type === 'input') { // No I18N
	            if (this._autoComplete) {
	                this._skipRender = true;
	                this._setValue(orgEvent.detail.itemData, {
	                    event: orgEvent,
	                    commit: false
	                });
	                this._skipRender = false;
	            }
	        }
	        return super._itemFocusHandler(...arguments);
	    }
	    _changeHandler(orgEvent) {
	        let originalEvent = orgEvent.originalEvent;
	        if (originalEvent && originalEvent.type === 'input') { // No I18N
	            this._active = true;
	            return;
	        }
	        return super._changeHandler(...arguments);
	    }
	    _beforeSearchHandler(orgEvent) {
	        let eventData = orgEvent.detail;
	        let originalEvent = orgEvent.originalEvent;
	        let showAll;
	        if (originalEvent) {
	            if (originalEvent.type === 'keydown') {// No I18N
	                showAll = originalEvent.keyCode === ZC.keyCode.DOWN || originalEvent.keyCode === ZC.keyCode.UP;
	            } else if (originalEvent.type === 'mousedown') { // No I18N
	                showAll = this._arrowTarget[0] === originalEvent.target || this._arrowTarget.find(originalEvent.target).length;
	            }
	        }
	        if (showAll || !originalEvent) {
	            eventData.searchOptions.minKeywordLength = 0;
	            eventData.params.query = ''; // No I18N
	        }
	        super._beforeSearchHandler(...arguments);
	    }
	    _noResultsHandler(orgEvent) {
	        this._noResults = true;
	        this._skipRender = true;
	        this._setValue([], {
	            clearOtherValues: true,
	            commit: false
	        });
	        this._skipRender = false;
	        return super._noResultsHandler(...arguments);
	    }
	    _updateHandler(orgEvent, eventData) {
	        this._noResults = eventData.status === 'noresults'; // No I18N
	        super._updateHandler(...arguments);
	    }
	    _onAttrChange(data) {
	        super._onAttrChange(...arguments);
	        if (data.isCustom) {
	            data.isCustom = false;
	            data.hasText = true;
	        }
	        data.attrs.tabindex = data.disabled ? null : -1;
	        data.attrs['aria-autocomplete'] = 'list'; // No I18N
	    }
	    _newValueHandler(orgEvent) {
	        if (this._altered && this._opts.acceptNewValues) {
	            this._setValue(this._inputField[0].value, {
	                event: orgEvent
	            });
	        } else {
	            this._setPrevValue(orgEvent)
	        }
	        this._opened && this._close(orgEvent);
	    }
	    _setPrevValue(orgEvent) {
	        this._skipRender = true;
	        this._setValue(this._getPrev(), {
	            event: orgEvent
	        });
	        this._skipRender = false;
	        this._updateView();
	    }
	    _onESCPress(orgEvent) {
	        this._setPrevValue(orgEvent);
	        orgEvent.preventDefault();
	    }
	    _keyDownHandler(orgEvent) {
	        if (!this._keydownEventHandled) {
	            orgEvent = orgEvent.originalEvent;
	            this._lastKeydownEvent = orgEvent;
	            let options = this._opts;
	            if (!options.disabled) {
	                let ZkeyCode = ZC.keyCode;
	                switch (orgEvent.keyCode) {
	                    case ZkeyCode.ESCAPE:
	                        this._onESCPress(orgEvent);
	                        break;
	                    case ZkeyCode.ENTER:
	                        if (this._noResults) {
	                            this._newValueHandler(orgEvent);
	                        }
	                        break;
	                }
	            }
	        }
	        this._keydownEventHandled = false;
	    }
	    _listBeforeKeyDownHandler(orgEvent) {
	        this._keyDownHandler(orgEvent);
	        super._listBeforeKeyDownHandler(orgEvent);
	        this._keydownEventHandled = true;
	    }
	    _keyPressHandler() {
	    }
	    _inputHandler(orgEvent, eventData) {
	        clearTimeout(this._renderTimer);
	        super._inputHandler(orgEvent, eventData);
	        orgEvent = orgEvent.originalEvent;
	        this._altered = this._active = true;
	        let inputFieldValue = this._inputField[0].value;
	        let minKeywordLength = this._opts.search.minKeywordLength;
	        if (!this._autoComplete || !inputFieldValue) {
	            this._iconShow('none'); // No I18N
	        }
	        // This change is included to avoid autocomplete when the input length is less than the search.minKeywordLength
	        if (this._autoComplete && (!minKeywordLength || inputFieldValue.length >= minKeywordLength)) {
	            this._autoCompleteFn(orgEvent);
	        }
	        this._updateClrBtn();
	    }
	    _updateClrBtn() {
	        let data = this._data;
	        if (data.clearButton) {
	            data.clearButton.mainElement[0].style.display = (this._inputField[0].value && !data.disabled) ? '' : 'none'; // No I18N
	        }
	    }
	    _iconShow(display) {
	        if (this._data.hasIcon) {
	            this.container[0].querySelector('.zselectbox__icon').style.display = display; // No I18N
	        }
	    }
	    _afterBlur(orgEvent) {
	        if (!this._isFocussed()) {
	            super._afterBlur(...arguments);
	            this._newValueHandler(orgEvent);
	            this._altered = this._focussed = this._active = false;
	            this._skipHighlightingOnMouseUp = false;
	            // Triggering blur for the container results in repeatedly calling blurHandler
	            this.container.removeClass('has-focus has-mfocus has-kfocus'); // No I18N
	        }
	    }
	    _updateView(delay, optData) {
	        let data = this._data;
	        if (optData) {
	            this._skipDataSetting = true;
	            this._setIconTextData(optData, data);
	        }
	        super._updateView(...arguments);
	        this._skipDataSetting = false;
	    }
	    _beforeSelectHandler(orgEvent) {
	        // let originalEvent = orgEvent.originalEvent;
	        // if (originalEvent && this._lastKeydownEvent !== originalEvent && originalEvent.type === 'keydown' && originalEvent.keyCode === ZC.keyCode.ESCAPE) { // No I18N
	        //     return false;
	        // }
	        return super._beforeSelectHandler(...arguments);
	    }
	    _postEachRender() {
	        let data = this._data;
	        super._postEachRender(...arguments);
	        this._inputField[0].value = data.label;
	        this._updateClrBtn();
	        this._highlightContent();
	        this._active = false;
	    }
	    _getRenderText(optData) {
	        return this._getLabel(optData, false);
	    }
	    _focusHandler() {
	        if (document.activeElement !== this._inputField[0] && !this._manualFocus) {
	            this._manualFocus = true;
	            this._inputField.focus();
	        }
	        this._manualFocus = false;
	        if (!this._focussed) {
	            this._highlightContent(true);
	            this._skipHighlightingOnMouseUp = false;
	            this._focussed = true;
	        }
	        super._focusHandler();
	    }
	    _clrBtnMouseDownHandler(orgEvent) {
	        super._clrBtnMouseDownHandler(...arguments);
	        this._inputField.val(''); // No I18N
	        this._opened && this.listInstance.searchWithDelay('', {// No I18N
	            event: orgEvent
	        });
	    }
	    _highlightContent(force) {
	        clearTimeout(this._highlightTimer);
	        if (!this._skipHighlighting) {
	            this._highlightTimer = setTimeout(() => {
	                if (force || this._isFocussed()) {
	                    this._inputField.select();
	                    this._skipHighlightingOnMouseUp = true;
	                }
	            });
	        }
	    }
	    _setFocusFn() {
	        this._inputField.focus().focusin();
	    }
	    _setAttribute(optionName, value) {
	        if (optionName === 'autoComplete') { // No I18N
	            this._opts[optionName] = value;
	            this._reInit = true;
	        } else if (/^(multiple|selectionLimit|showSearchField)$/.test(optionName)) {
	            return;
	        }
	        super._setAttribute(optionName, value);
	    }
	    _destroy() {
	        super._destroy(...arguments);
	        clearTimeout(this._highlightTimer);
	    }
		_fetchAData  (params, callback) {
		    this._fetch(params, (results) => callback(results[0]));
		}
		_autoCompleteFn  (orgEvent) {
		    if (!this._ajaxSource) {
		        let inputType;
		        if (orgEvent.originalEvent) {
		            inputType = orgEvent.originalEvent.inputType;
		        }
		        let inputField = this._inputField[0];
		        let currentText = inputField.value;
		        if (currentText) {
		            this._fetchAData({
		                query: currentText
		            }, (result) => {
		                if (result) {
		                    if (inputType === 'insertText' || inputType === 'insertFromPaste' || !inputType) { // No I18N
		                        this._lastHoveredId = result.zitemid;
		                        this._skipHighlighting = true;
		                        this._updateView(undefined, result);
		                        this._skipHighlighting = false;
		                        let label = this._getProp(result, 'label'); // No I18N
		                        inputField.setSelectionRange(currentText.length, label.length);
		                    }
		                    // when matched result is found icon must be shown in all the cases.
		                    this._iconShow(''); // No I18N
		                } else {
		                    this._iconShow('none'); // No I18N
		                }
		            });
		        }
		    }
		}
		_fetchAData  (params, callback) {
		    this.listInstance.fetchData(params, (response) => callback(response.results[0]));
		}
		_hideClrBtn  () {
		    let data = this._data;
		    data.clearButton.mainElement[0].style.display = (this._inputField[0].value && !data.disabled) ? '' : 'none'; // No I18N
		}
	}
	ZC.registerComponent('ZComboBox', ZC.ZSelect, ZComboBox); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zcombobox.Templates; 
let utilities = ZC.Templates.Utilities; 
template.WCContainer = () => ZT.html `<div>`; 
template.WCChildren = (data) => ZT.html `<div class="zselectbox__selected"> ${ ZT.html `${data.icon && utilities.WCIcon(data.icon)} ${ZT.html `<input ?disabled=${data.disabled} ?tabindex=${data.tabindex} class="zselectbox__textbox" ?value=${data.label} ?placeholder=${data.placeholder} autocomplete="off" />`}` } </div> ${data.clearButton && ZC.createButton(data.clearButton)} ${utilities.WCIcon(data.arrow)}`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zcombobox.Templates; 
let utilities = ZC.Templates.Utilities; 
template.container = () => ZT.html `<div>`; 
template.children = (data) => ZT.html `<div class="zselectbox__selected"> ${ ZT.html `${data.icon && utilities.icon(data.icon)} ${ZT.html `<input ?disabled=${data.disabled} ?tabindex=${data.tabindex} class="zselectbox__textbox" ?value=${data.label} ?placeholder=${data.placeholder} autocomplete="off" />`}` } </div> ${data.clearButton && ZC.createButton(data.clearButton)} ${utilities.icon(data.arrow)}`; }(ZComponents)); 
(function(ZC, $){
	ZC.$document.on('keydown.zdateselect', (ev) => { // No I18N
	    let instance = ZC.openedDateSelect;
	    if (instance && ev.keyCode === ZC.keyCode.ESCAPE && instance._dtsMenu.is(':visible')) { // No I18N
	        instance.close();
	    }
	});
	class ZDateSelect  extends ZC.CoreComponent{
			get name(){
				return "zdateselect";
			}
	    get attrs() {
	        return {
	            calendarIcon: false,
	            clearButton: false,
	            clearButtonIconClassName: null,
	            clearButtonSVGIconId: null,
	            calendarSVGIconId: null,
	            calendarIconClass: null,
	            immediateCommit: true,
	            calendarIconAlignment: 'left', // No I18N
	            placeholder: '', // No I18N
	            locale: 'en-US', // No I18N
	            arrowIcon: false,
	            value: null,
	            fromValue: null,
	            toValue: null,
	            format: 'dd/MM/yyyy', // No I18N
	            arrowIconClass: null,
	            slideAnimate: true,
	            arrowSVGIconId: null,
	            position: 'bottom-left', // No i18n
	            selectedValueDisplayType: 'value', // No I18N
	            hideCancelButton: false,
	            OKButtonLabel: null,
	            cancelButtonLabel: null
	        }
	    }
	    get props() {
	        return {
	            options: [],
	            dropdownList: {},
	            calendarIconClassName: null,
	            arrowIconClassName: null,
	            otherInputFormats: [],
	            datePickerOptions: {
	                monthsPerView: 1
	            },
	            dateRangePickerOptions: {
	                monthsPerView: 2
	            },
	            labels: {
	                OKButtonLabel: 'OK', // No I18N
	                cancelButtonLabel: 'Cancel', // No I18N
	                specificDate: 'Specific date', // No I18N
	                customRange: 'Custom range', // No I18N
	                placeholder: 'Choose Date', // No I18N
	                clear: 'Clear' // No I18N
	            }
	        }
	    }
	    get EVENTS() {
	        return [ 'change', 'optionselect', 'beforedropdownlistopen', 'dropdownlistopen', 'beforedropdownlistclose', 'dropdownlistclose', 'pickerbeforeopen', 'pickeropen', 'pickerbeforeclose', 'pickerclose', 'pickerdateselect', 'todaybuttonclick', 'pickerchange', 'cancel', 'clear', 'beforedrilldown', 'drilldown', 'datemouseover', 'monthchange', 'yearchange', 'decadechange', 'beforedatecellrender' ]; // No i18n
	    }
	    get SELECTORS() {
	        let isCE = this.isCE;
	        return {
	            itemId: isCE ? 'zitemid' : 'data-zitemid', // No i18n
	            option: isCE ? 'z-option' : 'option', // No i18n
	            valueType: isCE ? 'value-type' : 'data-value-type' // No i18n
	        }
	    }
	    _getConstValues() {
	        return [ 'YESTERDAY', 'TODAY', 'TOMORROW', 'LAST_MONTH', 'THIS_MONTH', 'NEXT_MONTH', 'LAST_YEAR', 'THIS_YEAR', 'NEXT_YEAR', 'LAST_7_DAYS', 'LAST_30_DAYS', 'LAST_15_DAYS', 'NEXT_7_DAYS', 'NEXT_30_DAYS', 'NEXT_15_DAYS', 'THIS_WEEK', 'NEXT_WEEK', 'LAST_WEEK', 'WEEK_TO_TODAY', 'MONTH_TO_TODAY', 'YEAR_TO_TODAY' ] // No i18n
	    }
	    _init(elem, options) {
	        this._useParent = false;
	        let data = this._data,
	            opts = this._opts,
	            attrs = data.attrs = {},
	            datePickerOpts = opts['date' + (this._checkTime ? 'Time' : '') + 'PickerOptions'], // No i18n
	            rangePickerOpts = opts['date' + (this._checkTime ? 'Time' : '') + 'RangePickerOptions']; // No i18n
	        this._isText = opts.selectedValueDisplayType === 'text'; // No i18n
	        let arr = [ 'days', 'daysAbbreviated', 'monthsAbbreviated', 'months' ], // No I18N
	            labels = opts.labels,
	            localeInfo = ZC.localeInfo[opts.locale];
	        arr.forEach(function(key) {
	            labels[key] = localeInfo[key] || labels[key];
	        });
	        this._validateFormat();
	        if (this._invalidFormat) {
	            return;
	        }
	        typeof this._setFormat === 'function' && this._setFormat(); // No I18N
	        this._setOkCancelBtns(); // revisit
	        this._checkValues(opts);
	        this._checkValues(datePickerOpts);
	        this._checkValues(rangePickerOpts);
	        this._isMinMaxGiven = opts.minDate || opts.maxDate || datePickerOpts.minDate || datePickerOpts.maxDate || rangePickerOpts.minDate || rangePickerOpts.maxDate;
	        data.alwaysSetAttrs = true;
	        attrs.tabindex = elem.attr('tabindex') || 0; // No I18N
	        attrs.id = this._elementId = elem.attr('id') ? elem.attr('id') + '-container' : this._getID(elem);
	        attrs['aria-haspopup'] = true;// No i18n
	        attrs.role = 'select';// No i18n
	        opts.placeholder = options.placeholder || this._getI18NText('placeholder'); // No i18n
	        opts.calendarIcon && this._getCalendarIconProps(data, opts);
	        opts.arrowIcon && this._getArrowIconProps(opts);
	        opts.clearButton && this._getClrBtnProps(data, opts);
	        this._buildData();
	        this._setSelectedData();
	    }
	    _checkValues(opts) {
	        let arr = [ 'fromValue', 'toValue', 'minDate', 'maxDate' ]; // No i18n
	        arr.forEach((value) => {
	            let val = opts[value],
	                d, i;
	            if (val) {
	                d = this._parseDate(val);
	                i = [ 'YESTERDAY', 'TODAY', 'TOMORROW' ].indexOf(val); // No i18n
	                d = d.isValid ? d.date : undefined;
	                if (!d && (i > -1 || val.indexOf('NOW') > -1)) { // No i18n
	                    d = new Date();
	                    i > -1 && d.setDate(d.getDate() + i - 1);
	                    !this._checkTime && d.setHours(0, 0, 0, 0);
	                }
	                opts[value] = d || undefined;
	            }
	        });
	    }
	    _setOkCancelBtns() {
	        let opts = this._opts;
	        if (!opts.immediateCommit) {
	            opts.OKButton = true;
	            opts.cancelButton = !opts.hideCancelButton;
	        }
	    }
	    _validateFormat() {
	        this._checkFormat(/h|H|m|t/g); // No I18N
	    }
	    _checkFormat(partsRegex) {
	        this._invalidFormat = partsRegex.test(this._opts.format);
	    }
	    _buildData() {
	        this._setPlaceholder();
	        this._getMenuProps();
	    }
	    _disable(value) {
	        super._disable(value);
	        this.element.attr('disabled', value); // No i18n
	    }
	    _postRender(elem, data) {
	        // Special case and hence it is handled in postRender
	        if (this.isCE) {
	            this.element.hide();
	        }
	        if (data.clearButton) {
	            this._clear = $('#' + this._elementId + '--clear');
	            this._bindClrBtnEv();
	        }
	        this._data.className += ' zselectbox zdatetimeselectbox--container'; // No I18N
	        let menu = this._dtsMenu = elem.find('.zdatetimeselectbox'); // No I18Nt
	        this._placeholderElem = elem.find('.zdatetimeselectbox__label'); // No i18n
	        this._setPlaceholder(false);
	        // revisit - check whether it can be handled using render()
	        menu.appendTo($(data.dropdownList.appendTo || 'body'));// No I18N
	        data.disabled && this._disable(data.disabled);
	        this._pickerContainer = menu.find('.zdatetimeselectbox__datetimecontainer');// No i18n
	        data.width && (elem[0].style.width = data.width + 'px'); // No I18N
	        data.height && (elem[0].style.height = data.height + 'px'); // No I18N
	        if (!this._valueId) {
	            if (data.value) {
	                this.setValue(data.value);
	            } else if (data.fromValue && data.toValue) {
	                this._setFromToValue();
	            }
	        }
	    }
	    _setPickerVal(type) {
	        let obj = this._getOptionObj(type, 'valueType'); // No I18N
	        if (obj) {
	            this._setValue($('#' + obj.id));// No I18N
	        } else {
	            this._setSelectedData();
	            this._setPlaceholder();
	        }
	    }
	    _getOptionObj(value, prop) {
	        let arr = [ 'range', 'date' ]; // No i18n
	        return this._data.menu.optData.find((opt) => prop ? opt[prop] === value : (opt.isPicker || (opt.type && arr.indexOf(opt.type) > -1) || (opt.valueType && arr.indexOf(opt.valueType) > -1))); // No i18n
	    }
	    _postEachRender(elem, data) {
	        let firstRender = !data.rendered,
	            modifiedAttr = data.modifiedAttr,
	            menu = this._dtsMenu,
	            calendarCls = 'zdatetimeselect--withcalendaricon', // No I18N
	            clrBtnCls = 'zdatetimeselect--withclrbtn', // No I18N
	            arrowCls = 'zdatetimeselect--witharrow'; // No I18N
	        if (!this._listContainer || !this._listContainer.length) {
	            this._listContainer = menu.find('.zdatetimeselectbox__listboxdetails');
	            !this._pickerOpened && this._display(true, this._listContainer);
	        }
	        if (!this._pickerContainer || !this._pickerContainer.length) {
	            this._pickerContainer = menu.find('.zdatetimeselectbox__datetimecontainer');// No i18n
	        }
	        if (firstRender || modifiedAttr) {
	            let cls = this._data.className;
	            if (data.calendarIcon) {
	                cls += ' zselectbox--icontext';// No I18N
	                if (data.calendarIconAlignment === 'right') {// No I18N
	                    cls += ' zselectbox--dateandtime zdatetimeselectbox--calendariconright';// No I18N
	                } else {
	                    cls = cls.replace(/zselectbox--dateandtime|zdatetimeselectbox--calendariconright/g, '');
	                }
	            } else {
	                cls = cls.replace(/zselectbox--icontext/g, '');
	            }
	            this._data.className = cls;
	            this._updateClass('' + calendarCls + '|' + clrBtnCls + '|' + arrowCls, true);
	            this._data.className += (data.calendarIcon ? ' ' + calendarCls : '') + (data.clearButton ? ' ' + clrBtnCls : '') + (this._data.arrowIconProps ? ' ' + arrowCls : ''); // No I18N
	            if (modifiedAttr === 'rtl' && menu.is(':visible')) {
	                this._getPosition();
	            }
	        }
	        if (this._valueId && !data.disabled && !data.readonly) {
	            this._setValue($('#' + this._valueId));
	            this._valueId = undefined;
	        }
	        // this._getPosition();
	    }
	    _setSelectedData(optData) {
	        let opts = this._opts,
	            value = opts.value,
	            fromValue = opts.fromValue,
	            toValue = opts.toValue,
	            data = this._selectedData = {
	                label: optData ? optData.label : this._data.placeholder,
	                value,
	                fromValue,
	                toValue
	            },
	            getString = this._getStringVal.bind(this);
	        // data.valueString = optData && !optData.valueType && !optData.isPicker ? getString(value) : value || (fromValue && toValue) ? getString(value || fromValue, toValue) : undefined;
	        data.valueString = value ? getString(value) : fromValue && toValue ? getString(fromValue, toValue) : undefined;
	        data.fromValueString = fromValue && getString(fromValue);
	        data.toValueString = toValue && getString(toValue);
	        let valueString = data.valueString;
	        data.translatedValue = this._translateEToA(getString(value || fromValue, value ? undefined : toValue, undefined, true));
	        data.text = optData ? optData.label : valueString;
	        data.selectedValue = valueString;
	        return valueString;
	    }
	    _setPlaceholder(label) {
	        let data = this._data,
	            opts = this._opts,
	            value = opts.value,
	            elem = this._placeholderElem;
	        if (label){
	            value = label;
	        }else if(value && value instanceof Date) {
	            value = this._getStringVal(value, undefined, undefined, true);
	        } else if (opts.fromValue && opts.toValue) {
	            value = this._getStringVal(opts.fromValue, opts.toValue, undefined, true);
	        } else if(label === false) {
	            label = data.placeholder;
	        }
	        data.placeholder = value = value ? this._translateEToA(value) : opts.placeholder;
	        elem && elem.attr('title', value).text(value); // No i18n
	    }
	    _dispatchEvent(eventName, orgEvent, data) {
	        return super._dispatchEvent(eventName, orgEvent, {
	            menu: this._dtsMenu,
	            ...(data || {})
	        });
	    }
	    _getMenuProps() {
	        let opts = this._opts,
	            menuData = this._data.menu = {},
	            optionTag = this._SELECTORS.option,
	            optElems = this.element.find(optionTag),
	            options = opts.options,
	            cls = opts.dropdownList.className;
	        menuData.className = 'zdatetimeselectbox zdatetimepicker--group' + (cls ? ' ' + cls : '') + (opts.rtl ? ' zh-rtl' : '');// No I18N
	        menuData.optData = [];
	        menuData.prepend = menuData.append = false;
	        if (opts.selectedValue || opts.value || this.element.find(optionTag + '[selected]').length === 0) { // No i18n
	            this.element[0].selectedIndex = -1;
	        }
	        if (optElems.length) {
	            this._getOptionData(optElems);
	        } else if (options) {
	            this._getOptData(options);
	        }
	        this._setIsPickerVar();
	        menuData.containerClass = 'zdatetimeselectbox__listboxdetails'; // No I18N
	        menuData[[ 'left', 'bottom-right', 'top-right' ].indexOf(opts.position) > -1 ? 'prepend' : 'append'] = true; // No I18N
	        menuData.containerClass += menuData.prepend ? ' zh-rightlist' : ''; // No I18N
	    }
	    _getOptData(options, doNotAdd, optEle) {
	        let arr = [];
	        for (let i = 0; i < options.length; i++) {
	            let obj = options[i];
	            obj.selected = obj.selected || this._isSelected(obj);
	            obj = this._setData(obj, optEle);
	            arr.push(this._setOptData(obj, doNotAdd));
	        }
	        return arr;
	    }
	    _setOptData(obj, doNotAdd) {
	        let type = obj.type || obj.valueType;
	        obj.class = (obj.class ? obj.class + ' ' : '') + 'zdatetimeselectbox__option' + (obj.selected ? ' is-selected' : '') + (obj.disabled ? ' is-disabled' : ''); // No i18n
	        if (obj.valueType && [ 'date', 'range' ].indexOf(type) > -1) {// No i18n
	            obj.class += type === 'date' ? ' zdatetimeselectbox--customdate' : ' zdatetimeselectbox--customrange';// No i18n
	            obj.label += '...';
	        }
	        if (obj.hidden) {
	            (obj.style = (obj.style || '') + 'display:none'); // No i18n
	        } else if (!obj.disabled && obj.selected) {
	            this._valueId = obj.id;
	        }
	        !doNotAdd && this._data.menu.optData.push(obj);
	        return obj;
	    }
	    _getPosition() {
	        let opts = this._opts,
	            rtl = opts.rtl,
	            menu = this._dtsMenu;
	        menu.css('right', ''); // No i18n
	        let elePosition = ZC.Position.get(this.container, this._dtsMenu, {
	                direction: opts.position,
	                rtl,
	                positionAlterable: opts.positionAlterable
	            }).elementPosition,
	            isRight = [ 'left', 'bottom-right', 'top-right' ].indexOf(opts.position) > -1 || rtl; // No i18n
	        menu.css({
	            left: '',
	            right: '',
	            top: elePosition.top
	        });
	        menu.css(isRight ? 'right' : 'left', isRight ? ZC.$window[0].innerWidth - (elePosition.left + menu.outerWidth(true)) : elePosition.left); // No i18n
	    }
	    _setIsPickerVar() {
	        if (!this._isPicker) {
	            this._isPicker = !!this._getOptionObj();
	        }
	    }
	    _isSelected(option, optionData) {
	        let opts = this._opts,
	            value = opts.value,
	            optVal = option.value;
	        optionData = optionData || option;
	        return !this._valueId && !!((value && (optVal === value || optionData.valueType === 'date')) || (opts.fromValue && optionData.valueType === 'range') || (optVal && optVal === opts.selectedValue));// No I18N
	    }
	    _setData(optData, option) {
	        let optionTag = this._SELECTORS.option,
	            id,
	            shouldAppend;
	        if (!optData.zdatapopulated) {
	            if (option) {
	                id = option.getAttribute(this._SELECTORS.itemId);
	            } else {
	                option = $('<' + optionTag + '/>')[0]; // No i18n
	                shouldAppend = true;
	            }
	            id = (id || this._getID(option)) + '-item'; // No I18N
	            let label = optData.label = optData.label || option.textContent.trim(),
	                valueType = optData.type || optData.valueType;
	            if ([ 'date', 'range' ].indexOf(valueType) > -1 && !label) { // No I18N
	                label = this._getI18NText(valueType === 'date' ? 'specificDate' : 'customRange'); // No I18N
	            } else {
	                optData.value = optData.value || option.value || label;
	            }
	            let arr = [ 'label', 'hidden', 'disabled', 'selected' ] // No i18n
	            for (let i = 0; i < 4; i++) {
	                optData[arr[i]] = optData[arr[i]] || option[arr[i]];
	            }
	            optData.style = option.getAttribute('style'); // No I18N
	            this._addedByComponent = this.isCE;
	            option = $(option);
	            if (this.isCE && !this._opts.isLyteComponent) {
	                ZC.option(option).saveParentIns(this.element);
	            }
	            option.attr(optData);
	            option.removeAttr('valuetype'); // No I18N
	            optData.valueType && option.attr(this.isCE ? 'value-type' : 'data-value-type', optData.valueType); // No I18N
	            // }
	            option.text(label);
	            option.attr('id', id.replace('-item', '')); // No I18N
	            // optData.class -> should be checked if initialized with option tag
	            // optData.className -> should be checked if initialized with options array
	            optData.class = (option[0].getAttribute('class') || '') + (optData.class || optData.className || ''); // No I18N
	            this._addedByComponent = false;
	            // Has to be checked, orelse by appending the already available element, it selects the next element by default
	            shouldAppend && option.appendTo(this.element);
	            optData.zdatapopulated = true;
	            optData.id = id;
	        }
	        return optData;
	    }
	    _bindEvents() {
	        // this._handleFocus();
	        this._addEvents({
	            click: 'mousedown', // No I18N
	            focus: 'focusin focusout'// No I18N
	        });
	        this._addEvents({
	            menuClick: 'mousedown', // No i18n
	            menuBlur: 'focusout' // No I18N
	        }, this._dtsMenu);
	        if (this._opts.clearButton) {
	            this._addEvents({
	                mouseEnter: 'mouseenter' // No I18N
	            });
	        }
	        // this._dtsMenu.on(`${ZC._animationEnd}`, () => {
	        //     this._getPosition();
	        // })
	    }
	    _menuBlurHandler(ev) {
	        this._focusHandler(ev);
	    }
	    _focusHandler(ev) {
	        if (!this._opts.disabled) {
	            let dispatch = true;
	            if (ev.type === 'focusout') { // No I18N
	                dispatch = this._dtsMenu.is(':visible');// No I18N
	            }
	            dispatch && this._dispatchEvent(ev.type === 'focusout' ? 'blur' : 'focus', ev, {});// No I18N
	        }
	    }
	    _display(hide, elem) {
	        if (ZC.Browser.isIE && ZC.Browser.getIEVersion() === 9) {
	            elem[0].style.display = hide ? 'none' : 'inline-block';
	        } else {
	            super._display(...arguments);
	        }
	    }
	    _setMenuAttr(hide) {
	        this._display(hide, this._dtsMenu);
	        this.container.attr('aria-expanded', !hide); // No i18n
	        this._updateClass('is-active', hide || undefined); // No i18n
	    }
	    _clickHandler(orgEvent) {
	        if (!this._opts.readonly && !this._opts.disabled) {
	            if (this._dtsMenu.is(':visible')) { // No i18n
	                this.close(undefined, orgEvent);
	            } else {
	                this._showMenu(orgEvent);
	            }
	        }
	    }
	    _showMenu(orgEvent) {
	        if (this._dispatchEvent('beforedropdownlistopen', orgEvent, {}) && !this._opts.disabled) { // No I18N
	            ZC.openedDateSelect = this;
	            ZC.bindDocumentEvents({
	                element: this.element,
	                container: this._dtsMenu,
	                forElement: this.container,
	                ctype: this.name,
	                closeMethodName: '_closeHandlerClose', // No I18N
	                closeEvent: 'dropdownlistclose' // No I18N
	            })
	            this._setMenuAttr(false);
	            this._opts.slideAnimate && this._animateMenu(!!this._lastSelected);
	            this._pickerOpened && this._isPicker && this._openPicker(null, null, true);
	            if (this._scrollHt === undefined && this._curLi) {
	                this._scrollHt = this._curLi[0].offsetTop;
	            }
	            this._setDimensions();
	            this._dispatchEvent('dropdownlistopen', orgEvent, {}); // No I18N
	            this._getPosition();
	            this._opts.slideAnimate && this._pickerOpened && this._setWidth(this['_' + this._pickerOpened + 'Picker']); // since position is not set properly, animation is applied after position is set.
	        }
	    }
	    _closeHandlerClose(orgEvent) {
	        this.close(undefined, orgEvent);
	    }
	    _animateMenu(type, width) {
	        /* Number check is added bcoz, if width is 0, animation is not applied */
	        this._listContainer[type ? 'addClass' : 'removeClass' ]('zdts-transition').width(typeof width === 'number' ? width : ''); // No i18n
	    }
	    _setDimensions() {
	        let ht,
	            list = this._opts.dropdownList,
	            picker = this._pickerOpened && this['_' + this._pickerOpened + 'Picker'],
	            listBox = this._dtsMenu.find('.zdatetimeselectbox__listbox'),
	            optLen = listBox.find('.zdatetimeselectbox__option:visible').length;
	        listBox.css('height', ''); // No i18n
	        if (this._pickerContainer.children().length && picker && picker.is(':visible')) {
	            ht = picker.outerHeight(true); // No i18n
	        }
	        if (list.height && ht) {
	            ht = list.height < ht ? ht : list.height;
	        }
	        ht = ht || list.height || (optLen < 10 ? optLen * 33 : 310);
	        listBox.css('height', ht + (optLen > 6 ? -10 : 0));// No i18n
	        ht = null;
	        this._scrollHt !== undefined && (listBox[0].scrollTop = this._scrollHt);
	        list.width && listBox.css('width', list.width); // No I18N
	    }
	    _menuClickHandler(orgEvent) {
	        if (!this._opts.readonly && !this._opts.disabled) {
	            let li = $(orgEvent.target).closest('.zdatetimeselectbox__option'); // No i18n
	            if (li.length && !li.hasClass('is-disabled')) {// No i18n
	                this._scrollHt = li[0].offsetTop;
	                let optData = this._setValue(li);
	                this._checkForClose(orgEvent, optData);
	                this._dispatchEvent('optionselect', orgEvent, { // No i18n
	                    item: li,
	                    option: this._currentSelected
	                });
	                this._setDimensions();
	            // this._getPosition();
	            // this._render();
	            }
	        }
	    }
	    _checkForClose(orgEvent, optData) {
	        let type = optData.type || optData.valueType,
	            isPicker = type && [ 'range', 'date' ].indexOf(type) > -1 || optData.isPicker; // No i18n
	        if (!isPicker) {
	            this.close(undefined, orgEvent);
	            this._triggerChange(orgEvent);
	        }
	    }
	    _isComit(type) {
	        return this['_' + type + 'PickerInstance']._opts.immediateCommit;
	    }
	    _triggerChange(orgEvent) {
	        let option = this._getOptForItem(this._curLi[0].id), // No i18n
	            oldValue = this._lastSelected;
	        option[0].selected = true;
	        if (!oldValue || option.attr('id') !== oldValue.attr('id')) { // No i18n
	            this._dispatchEvent('change', orgEvent, { // No i18n
	                oldValue,
	                newValue: option,
	                ...this._selectedData
	            });
	        }
	    }
	    _getOptForItem(id) {
	        return this.element.find('[id=' + id.replace('-item', '') + ']'); // No i18n
	    }
	    _setValue(item, doNotSet) {
	        let prev = this._prevLi = this._curLi;
	        this._lastSelected = prev && prev.length && this._getOptForItem(prev.attr('id')); // No i18n
	        this._selectOpt('last', false); // No i18n
	        this._updateSelectClass(prev, false);
	        this._curLi = item;
	        this._currentSelected = item && item.length && this._getOptForItem(item.attr('id')); // No i18n
	        this._selectOpt('current', true);// No i18n
	        let data = this._updateSelectClass(item, true);
	        if (!doNotSet) {
	            this._setPlaceholder(this._getPlaceHolder(data));
	            this._setSelectedData(data && data.valueType ? undefined : data);
	        }
	        return data;
	    }
	    _selectOpt(elem, select) {
	        this._addedByComponent = this.isCE;
	        elem = this['_' + elem + 'Selected']; // No i18n
	        elem && elem.attr('selected', select);// No i18n
	        this._addedByComponent = false;
	    }
	    _updateSelectClass(option, add) {
	        let selectCLs = 'is-selected'; // No i18n
	        if (option) {
	            option[(add ? 'add' : 'remove') + 'Class'](selectCLs); // No i18n
	            let data = this._data.menu.optData[option.index()],
	                prevCls = data.class;
	            data.class = add ? prevCls + (data.class.indexOf(selectCLs) < 0 ? ' ' + selectCLs : '') : prevCls.replace(selectCLs, '');
	            return data;
	        }
	    }
	    _parseDate(value, format) {
	        return ZC.Date._parseDateValue(value, format || this._opts.format, this._opts.otherInputFormats) || {
	            date: undefined
	        };
	    }
	    _getPlaceHolder(data) {
	        let picker = this._pickerOpened;
	        if (data) {
	            let value = data.value,
	                date1 = new Date(),
	                date2 = new Date(),
	                offset,
	                returnFalse = false,
	                getValues,
	                parsedVal = this._parseDate(value),
	                isRange = true,
	                type = data.type || data.valueType,
	                todayDate = date1.getDate(),
	                dayIndex = [ 'YESTERDAY', 'TODAY', 'TOMORROW' ].indexOf(value), // No i18n
	                monthIndex = [ 'LAST_MONTH', 'THIS_MONTH', 'NEXT_MONTH' ].indexOf(value), // No i18n
	                yearIndex = [ 'LAST_YEAR', 'THIS_YEAR', 'NEXT_YEAR' ].indexOf(value), // No i18n
	                isPickerType = [ 'range', 'date' ].indexOf(type) > -1; // No i18n
	            // closing the picker if any other option is chosen
	            if (picker && (!isPickerType || data.valueType !== picker)) {
	                this._pickerOpenOrClose(true);
	                this._lastOpened = this._pickerOpened;
	                this._pickerOpened = undefined;
	            }
	            if (data.type && data.type === 'custom') { // No i18n
	                this._updateValues(data.value, null, 'custom'); // No i18n
	                return this._isText ? data.label : data.value;
	            } else if (dayIndex > -1) {
	                date1.setDate(todayDate + dayIndex - 1);
	                date2 = new Date(+date1);
	                if (data.isPicker) {
	                    data.type = type = type || 'date'
	                } else {
	                    isRange = false;
	                }
	            } else if ([ 'LAST_7_DAYS', 'LAST_30_DAYS', 'LAST_15_DAYS', 'NEXT_7_DAYS', 'NEXT_30_DAYS', 'NEXT_15_DAYS' ].indexOf(value) > -1) { // No i18n
	                let isNext = value.indexOf('NEXT') > -1; // No i18n
	                offset = parseInt(value.split('_')[1]) - 1;
	                date2.setDate(todayDate + (offset * (+(isNext || -1))));
	                if (!isNext) {
	                    let temp = date1;
	                    date1 = date2;
	                    date2 = temp;
	                }
	            } else if (value === 'THIS_WEEK') {
	                date1.setDate(date1.getDate() - date1.getDay());
	                date2 = this._getDate(date1, 6);
	            } else if (value === 'NEXT_WEEK') {
	                date1.setDate(date1.getDate() + (7 - date1.getDay()));
	                date2 = this._getDate(date1, 6);
	            } else if (value === 'LAST_WEEK') {
	                date2.setDate(date2.getDate() - date2.getDay() - 1);
	                date1 = this._getDate(date2, -6);
	            } else if (monthIndex > -1) {
	                date1.setDate(1);
	                date2 = new Date(date1.setMonth(date1.getMonth() + monthIndex - 1));
	                date2.setMonth(date1.getMonth() + 1);
	                date2.setDate(0);
	            } else if (yearIndex > -1) {
	                date1 = new Date(date1.getFullYear() + yearIndex - 1, 0, 1);
	                date2 = new Date(date1.getFullYear(), 12, 0);
	            } else if ([ 'WEEK_TO_TODAY', 'MONTH_TO_TODAY', 'YEAR_TO_TODAY' ].indexOf(value) > -1) { // No i18n
	                date1.setDate(value.indexOf('WEEK') > -1 ? date1.getDate() - date1.getDay() : 1); // No i18n
	                value.indexOf('YEAR') > -1 && date1.setMonth(0); // No i18n
	            } else if (data.valueType === 'range' || data.valueType === 'date') { // No I18N
	                getValues = true;
	            } else if (typeof data.value === 'string' && parsedVal.isValid || parsedVal.isValid) { // No i18n
	                getValues = true;
	                type = type || 'date'; // No I18N
	                data.isPicker && (data.type = type || 'date'); // No i18n
	            } else if (data.fromValue && data.toValue) {
	                getValues = true;
	            }
	            !data.valueType && data.isPicker && (data.type = type = type || 'range'); // No i18n
	            isRange = type ? type === 'range' : isRange; // No i18n
	            if (getValues) {
	                let obj = this._handlePickerOptionClick(data, isRange);
	                date1 = obj.date1;
	                date2 = obj.date2;
	                data.valueGiven = date1 || date2;
	            }
	            if (!this._checkTime || !getValues) { // since getValues fetches the value that is given( with or without time) or the previous value
	                date2 && date2.setHours(0, 0, 0, 0);
	                date1 && date1.setHours(0, 0, 0, 0);
	            }
	            if (isRange && this._isMinMaxGiven) {
	                let f = this._isValidDate(date1, 'Range', !(isPickerType || data.isPicker)), // No i18n
	                    t = this._isValidDate(date2, 'Range', !(isPickerType || data.isPicker)); // No i18n
	                if (!f || !t) {
	                    this._getValidRangeVal(date1, date2);
	                }
	            }
	            let isValuesPresent = date1 || date2,
	                args = [ date1, isRange ? date2 || date1 : null ]; // No I18N
	            if (isPickerType || data.isPicker) {
	                let valueSet = this._valueSet || this._valueId;
	                // if the picker is not yet initialized, values should be assigned in this.opts orElse while initializing,
	                // opts.value will contain the previous value or null
	                isValuesPresent && (!this['_' + type + 'Picker'] && !data.valueType || valueSet || getValues) && this._updateValues(...args, isRange ? 'range' : 'date', data);
	                this._openPicker(data, type);
	                if (data.valueType) {
	                    return valueSet || (getValues && this._isComit(type) && (date1 || date2)) ? undefined : false;
	                // return !isRange && !opts.value ? false : this._getPickerLabel(data, true);
	                } else if (type && !this._isComit(type) && this._valueId !== data.id) {
	                    returnFalse = true;
	                }
	            } else {
	                this._prevWidth = 0;
	            }
	            let returnValue = isValuesPresent ? this._updateValues(...args, isRange ? 'range' : 'date', data, returnFalse) : undefined; // No i18n
	            return returnValue === undefined ? (returnFalse ? false : this._isText ? data.label : this._getStringVal(...args, undefined, true)) : returnValue; // No I18N
	        }
	        this._pickerOpenOrClose(true);
	        this._lastOpened = this._pickerOpened;
	        this._pickerOpened = undefined;
	    }
	    _getDate(date1, offset) {
	        let date = new Date(+date1);
	        date.setDate(date.getDate() + offset);
	        return date;
	    }
	    _getStringVal(date1, date2, format, translate) {
	        format = format || this._opts.format;
	        let formatDate = ZC.Date.formatDate.bind(ZC.Date),
	            labels = translate && this._opts.labels;
	        return date1 && formatDate(date1, format, labels) + (date2 ? ' - ' + formatDate(date2, format, labels) : ''); // No i18n
	    }
	    _updateValues(from, to, type, data, doNotUpdate) {
	        let opts = this._opts,
	            isBoth = to && from,
	            isCustom = type === 'custom'; // No i18n
	        if (!doNotUpdate) {
	            opts.value = isBoth ? undefined : isCustom ? from : from && new Date(+from);
	            opts.fromValue = from && !isCustom ? new Date(+from) : undefined;
	            opts.toValue = isBoth ? to && new Date(+to) : from && !isCustom ? new Date(+from) : undefined;
	        }
	        this._curFrom = from && new Date(+from);
	        this._curTo = isBoth ? new Date(+to) : undefined;
	        this._isPicker && this._setPickerValues(...arguments);
	    }
	    _resetValues() {
	        this._opts.value = undefined;
	        this._opts.fromValue = undefined;
	        this._opts.toValue = undefined;
	        this._setPlaceholder(this._opts.placeholder); // No i18n
	    }
	    open() {
	        if (!this._opts.disabled && !this._opts.readonly) {
	            this._showMenu();
	        }
	    }
	    close(type, orgEvent) {
	        if (this._dispatchEvent('beforedropdownlistclose', orgEvent, {})) { // No I18N
	            this._setMenuAttr(true);
	            this._pickerOpened && this._pickerOpenOrClose(true); // No i18n
	            this._dispatchEvent('dropdownlistclose', orgEvent, {}); // No I18N
	            ZC.openedDateSelect = undefined;
	        }
	    }
	    getValue(value) {
	        value = this._parseDate(value || this._opts.value).date;
	        let valueString = this._getStringVal(value);
	        if (value) {
	            return {
	                value,
	                valueString,
	                translatedValue: this._translateEToA(valueString)
	            };
	        }
	    }
	    setValue(value) {
	        let opts = this._opts,
	            obj = this._getOptionObj(value, 'value'); // No I18N
	        if (value) {
	            value = this._parseDate(value).date;
	            this._valueSet = true;
	            opts.value = value;
	            opts.fromValue = null;
	            opts.toValue = null;
	            if (obj) {
	                this._setValue($('#' + obj.id));
	            } else {
	                this._setPickerVal('date'); // No i18n
	            }
	        }
	        this._valueSet = false;
	    }
	    getFromValue() {
	        let obj = this.getValue(this._opts.fromValue);
	        return obj && {
	            fromValue: obj.value,
	            fromValueString: obj.valueString,
	            translatedFromValue: obj.translatedValue
	        }
	    }
	    getToValue() {
	        let obj = this.getValue(this._opts.toValue);
	        return obj && {
	            toValue: obj.value,
	            toValueString: obj.valueString,
	            translatedToValue: obj.translatedValue
	        }
	    }
	    getSelectedOption() {
	        return {
	            item: this._curLi,
	            option: this._currentSelected,
	            ...this.getValue(),
	            ...this.getFromValue(),
	            ...this.getToValue(),
	            selectedValue: this._selectedData.selectedValue
	        }
	    }
	    _destroy() {
	        this._isPicker && this._destroyPicker();
	        this._dtsMenu.remove();
	        this._setUndefined([ 'dtsMenu', 'placeholderElem', 'pickerContainer', 'lastSelected', 'currentSelected', 'selectedData' ], ''); // No i18n
	    }
		_getArrowIconProps  (opts) {
		    // Revisit - Change arrowicon className
		    if ((!opts.calendarIcon || opts.calendarIcon && opts.calendarIconAlignment !== 'right')) { // No i18n
		        this._data.arrowIconProps = ZC._getIconInfo(opts.arrowIconClassName, opts.arrowSVGIconId, 'zc__svg--downarrow zselectbox__arrow', 'zselectbox__icon arrowicon', { // No i18n
		            templateRender: true,
		            isCE: this.isCE
		        });
		    }
		}
		_getCalendarIconProps  (data, opts) {
		    // Revisit - Change calendaricon className
		    data.calendarIconProps = ZC._getIconInfo(opts.calendarIconClassName, opts.calendarSVGIconId, 'zc__svg--calendaricon zbutton__svg', 'zselectbox__icon calendaricon', { // No i18n
		        templateRender: true,
		        isCE: this.isCE
		    });
		    data.isRight = data.isLeft = false;
		    if (opts.calendarIconAlignment === 'right') { // No i18n
		        data.arrowIconProps = null;
		        data.isRight = true;
		    } else {
		        data.isLeft = true;
		    }
		}
		_getClrBtnProps  (data, opts) {
		    let label = this._getI18NText('clear'); // No I18N
		    data.clearButton = {
		        id: this._elementId + '--clear', // No I18N
		        iconClassName: opts.clearButtonIconClassName,
		        SVGIconId: opts.clearButtonSVGIconId || 'zc__svg--clear', // No I18N
		        className: 'zselectbox__clearbutton', // No I18N
		        templateRender: true,
		        rtl: this.rtl,
		        isCE: this.isCE,
		        customAttributes: {
		            tabindex: -1,
		            'aria-label': label, // No I18N
		            title: label
		        }
		    }
		}
		_bindClrBtnEv  () {
		    this._clear && this._addEvents({
		        clearClick: 'mousedown' // No I18N
		    }, this._clear);
		}
		_clearClickHandler  (event) {
		    this.deselectOption();
		    event.stopPropagation();
		    this._mouseEnterHandler();
		    this._scrollHt = 0;
		    this.close();
		}
		_mouseEnterHandler  () {
		    let opts = this._opts;
		    this._clear[(((opts.value || opts.fromValue || opts.toValue) && !opts.disabled && !opts.readonly) ? 'remove' : 'add') + 'Class']('zh-dnone'); // No I18N
		}
		_getOptionData  (optElems) {
		    for (let i = 0; i < optElems.length; i++) {
		        let option = optElems[i],
		            optionData = ZC._getOpts(option);
		        // avoid if not necessary
		        option._created = true;
		        optionData.selected = optionData.selected || option.selected || this._isSelected(option, optionData);
		        optionData = this._setData(optionData, option);
		        this._setOptData(optionData);
		    }
		}
		_isValidDate  (date, type, noPicker) {
		    let opts = this._opts,
		        pickerOpts = !noPicker && opts[ 'date' + (this._checkTime ? 'Time' : '') + (type || '') + 'PickerOptions'], // No i18n
		        min = this._parseDate(pickerOpts.minDate || opts.minDate).date,
		        max = this._parseDate(pickerOpts.maxDate || opts.maxDate).date;
		    min = min ? ZC.Date.isGreater(date, min) : true;
		    max = max ? ZC.Date.isGreater(max, date) : true;
		    return min && max ? date : null;
		}
		_getValidRangeVal  (from, to) {
		    let isFromValid = this._isValidDate(from, 'Range'), // No i18n
		        isToValid = this._isValidDate(to, 'Range'); // No i18n
		    while ((!isFromValid || !isToValid) && +from <= +to) {
		        if (!isFromValid) {
		            from.setDate(from.getDate() + 1);
		            isFromValid = this._isValidDate(from, 'Range'); // No i18n
		        }
		        if (!isToValid) {
		            to.setDate(to.getDate() - 1);
		            isToValid = this._isValidDate(to, 'Range'); // No i18n
		        }
		    }
		    this._curFrom = +from <= +to ? new Date(+from) : undefined; // If the fromValue and toValue both are not within the range, we have unset the value
		    this._curTo = +from <= +to ? new Date(+to) : undefined;
		}
		_openPicker  (data, type, doNotAnimate) {
		    !this._prevWidth && this._saveWidth();
		    if (data && !this['_' + type + 'Picker']) { // No i18n
		        this._initPicker(type);
		    }
		    if (type) {
		        if (this._pickerOpened !== type) {
		            this._pickerOpened = type;
		            if (type !== this._lastOpened) {
		                this._opts.slideAnimate && this._animateMenu();
		            }
		        }
		    }
		    this._setDimensions();
		    let picker = this._pickerOpened;
		    if (picker) {
		        this._pickerOpenOrClose(null, true);
		        this._getPosition();
		        // this._animateMenu(null, prevWidth);
		        this._setWidth(this['_' + picker + 'Picker'], doNotAnimate);
		    }
		}
		_pickerOpenOrClose  (hide, doNotSave) {
		    !doNotSave && this._saveWidth();
		    this._listContainer && this._display(hide, this._listContainer);
		    this._pickerOpened && this['_' + this._pickerOpened + 'PickerInstance'][hide ? 'close' : 'open']();
		    // if (!hide) {
		    //     this._menuHt = this._dtsMenu.find('.zdatetimeselectbox__listbox');
		    // }
		    this._setDimensions();
		}
		_saveWidth  () {
		    this._prevWidth = this._listContainer.innerWidth();
		}
		_setWidth  (element, doNotAnimate) {
		    if (!doNotAnimate && this._opts.slideAnimate) {
		        let width = this._listContainer.innerWidth(); // No i18n
		        !doNotAnimate && this._animateMenu(true, this._prevWidth);
		        setTimeout(() => {
		            this._listContainer.css({
		                width
		            });
		        }, 30);
		        this._prevWidth = null;
		    }
		}
		_getPickerOpts  (opts, isDate) {
		    return {
		        rtl: opts.rtl,
		        format: opts.format,
		        isCE: this.isCE,
		        hideCancelButton: opts.hideCancelButton,
		        immediateCommit: opts.immediateCommit,
		        OKButtonLabel: opts.OKButtonLabel || this._getI18NText('OKButtonLabel'), // No i18n
		        cancelButtonLabel: opts.cancelButtonLabel || this._getI18NText('cancelButtonLabel'), // No i18n
		        position: 'right', // No i18n
		        type: 'inline', // No i18n
		        locale: opts.locale,
		        fromValue: opts.fromValue,
		        minDate: opts.minDate,
		        maxDate: opts.maxDate,
		        toValue: opts.toValue,
		        value: isDate ? opts.value : undefined,
		        fromLabel: opts.fromLabel,
		        toLabel: opts.toLabel,
		        cancel: this._cancelHandler.bind(this),
		        className: isDate ? 'zdts-customdate' : 'zdts-customrange', // No i18n
		        appendTo: this._pickerContainer,
		        change: this._changeHandler.bind(this),
		        ...this._bindPickerEvents(),
		        clear: this._clearHandler.bind(this),
		        afterdrilldown: this._setDimensions.bind(this),
		    }
		}
		_initPicker  (type) {
		    let opts = this._opts,
		        isDate = type === 'date', // No i18n
		        options = this._getPickerOpts(opts, isDate),
		        elem;
		    options = $.extend(true, {}, options, opts[(isDate ? 'date' : 'dateRange') + 'PickerOptions']) // No i18n
		    this['_' + (isDate ? 'date' : 'range') + 'Picker'] = elem = $(ZC['createDate' + (isDate ? '' : 'Range') + 'Picker'](options)); // No i18n
		    elem.removeClass('zdatetimepicker zdatetimepicker--group'); // No i18n
		    this['_' + (isDate ? 'date' : 'range') + 'PickerInstance'] = ZC['date' + (isDate ? '' : 'range') + 'picker'](elem);// No i18n
		}
		_bindPickerEvents  () {
		    let pickerEvents = [ 'beforeopen', 'open', 'beforeclose', 'close' ], // No i18n
		        base = this,
		        events = [ 'beforedatecellrender', 'beforefocus', 'open', 'beforeopen', 'beforeclose', 'close', 'dateselect', 'todaybuttonclick', 'drilldown', 'beforedrilldown', 'afterdrilldown', 'datemouseover', 'monthchange', 'yearchange', 'decadechange', 'fromvalueselect', 'tovalueselect', 'clear' ], // No i18n
		        eventObj = {}; // No i18n
		    for (let i = 0; i < events.length; i++) {
		        eventObj[events[i]] = (ev, ui) => {
		            if (this.isCE) {
		                ev.stopPropagation();
		            }
		            if (pickerEvents.indexOf(events[i]) > -1) {
		                this._dispatchEvent('picker' + events[i], ev, ui); // No i18n
		            } else {
		                if(["yearchange", "monthchange"].indexOf(events[i]) > -1){
		                    base._setDimensions();
		                }
		                this._dispatchEvent(events[i], ev, ui);
		            }
		        }
		    }
		    return eventObj;
		}
		_clearHandler  (orgEvent) {
		    this._isComit(orgEvent.type.indexOf('rangepicker') > -1 ? 'range' : 'date') && (this._shouldClose = false); // No i18n
		    this._dispatchEvent('clear', orgEvent, {}); // No i18n
		}
		_setPickerValues  (from, to, type) {
		    if (this._datePicker) {
		        let instance = this._datePickerInstance,
		            shouldSet = type === 'date' ? !this._isSameDate({ // No i18n
		                value: instance.getAttribute('value')// No i18n
		            }) : true;
		        shouldSet && instance.setAttribute('value', type === 'date' ? from : undefined); // No i18n
		    }
		    if (this._rangePicker) {
		        let instance = this._rangePickerInstance,
		            shouldSet = type === 'range' ? !this._isSameDate({ // No i18n
		                fromValue: instance.getAttribute('fromValue'), // No i18n
		                toValue: instance.getAttribute('toValue')// No i18n
		            }) : true;
		        if (shouldSet) {
		            instance.setAttribute('toValue', null); // to avoid checking previous toValue with the fromValue that is set now
		            instance.setAttributes({
		                fromValue: from,
		                toValue: type === 'range' ? to : from// No i18n
		            });
		        }
		    }
		}
		_changeHandler  (ev, ui, doNotClose, doNotTrigger) {
		    if (ev.originalEvent) {
		        this._shouldClose === undefined && (this._shouldClose = true);
		        if (!doNotTrigger) {
		            let type;
		            if (this.isCE) {
		                ev.stopPropagation();
		                ui = ev.detail;
		                type = ui.container[0].tagName.indexOf('RANGE') > -1 ? 'range' : 'date'; // No I18N
		            } else {
		                type = ev.type.indexOf('range') > -1 ? 'range' : 'date'; // No I18N
		            }
		            let from = ui.fromValue,
		                value = ui.value,
		                curLiData = this._curLi && this._getOptionObj(this._curLi.attr('id'), 'id'), // No i18n
		                to = ui.toValue,
		                obj = this._getOptionObj(type, 'valueType'), // No i18n
		                isSame = this._isSameDate(ui);
		            this._updateValues(from || value, to, type, curLiData);
		            (!value && !(from && to)) && this._resetValues();
		            if (isSame && !this._isComit(type) && curLiData && this._getConstValues().indexOf(curLiData.value) > -1) { // No i18n
		                this._setSelectedData(curLiData);
		                this._setPlaceholder(this._isText ? curLiData.label : this._selectedData.valueString);
		            } else {
		                this._setSelectedData();
		                this._setPlaceholder(this._selectedData.valueString);
		                if (obj && this._curLi && this._curLi.attr('id') !== obj.id) { // No i18n
		                    this._setValue($('#' + obj.id)); // No i18n
		                }
		            }
		            this._triggerChange(ev); // No i18n
		        }
		        !doNotClose && (this._shouldClose || !$(ui.container).is(':visible')) && this.close();
		        this._shouldClose = true;
		    }
		}
		_isSameDate  (ui) {
		    let isEqual = ZC.Date.areDatesEqual.bind(this);
		    if (this._checkTime) {
		        return ui.value ? +ui.value === +this._curFrom : +ui.fromValue === +this._curFrom && +ui.toValue === +this._curTo;
		    }
		    return ui.value ? isEqual(ui.value, this._curFrom) : isEqual(ui.fromValue, this._curFrom) && isEqual(ui.toValue, this._curTo);
		}
		setFromValue  (value) {
		    this._setFromToValue(value);
		}
		setToValue  (value) {
		    this._setFromToValue(null, value);
		}
		_setFromToValue  (from, to) {
		    let opts = this._opts,
		        isFrom = !!from;
		    from = this._parseDate(from || opts.fromValue).date;
		    to = this._parseDate(to || opts.toValue).date;
		    if (from && to && ZC.Date.isGreater(to, from)) {
		        this._valueSet = true;
		        opts[(isFrom ? 'from' : 'to') + 'Value'] = isFrom ? from : to; // No i18n
		        opts.value = null;
		        this._setPickerVal('range'); // No i18n
		        this._valueSet = false;
		    }
		}
		_cancelHandler  (orgEvent) {
		    this.close();
		    this._dispatchEvent('cancel', orgEvent, {}); // No i18n
		}
		_getPickerLabel  (data, setValue) {
		    let opts = this._opts;
		    return (opts.value || opts.fromValue || opts.toValue) ? setValue ? null : false : data.label.replace('...', ''); // No I18N
		}
		_handlePickerOptionClick  (data, isRange) {
		    let parseDate = this._parseDate.bind(this),
		        opts = this._opts,
		        value = opts.value,
		        fromValue = opts.fromValue,
		        toValue = opts.toValue,
		        parsedVal = parseDate(data.value),
		        date1, date2,
		        isEqual = fromValue && toValue && (this._checkTime ? +fromValue === +toValue : ZC.Date.areDatesEqual(fromValue, toValue)); // No I18N
		    if (isRange) {
		        if (data.fromValue && data.toValue) {
		            let fromVal = data.fromValue,
		                toVal = data.toValue;
		            date1 = typeof fromVal === 'string' ? parseDate(fromVal).date : fromVal; // No I18N
		            date2 = typeof toVal === 'string' ? parseDate(toVal).date : toVal; // No I18N
		        } else if (parsedVal.isValid) { // for cases, if the option has type range as its type and has only one value
		            date1 = parsedVal.date;
		        } else {
		            date1 = parseDate(fromValue).date;
		            date2 = parseDate(toValue).date;
		        }
		    } else if (parsedVal.isValid) {
		        date1 = parsedVal.date;
		    } else if (isEqual) {
		        date1 = fromValue;
		        date2 = undefined;
		    } else {
		        date1 = value && ([ 'TODAY', 'NOW' ].indexOf(value) > -1 ? new Date() : parseDate(opts.value).date); // No I18N
		    }
		    return {
		        date1,
		        date2
		    };
		}
		_destroyPicker  () {
		    this._datePicker && this._datePickerInstance.destroy();
		    this._rangePicker && this._rangePickerInstance.destroy();
		    this._datePicker = this._datePicker = this._datePickerInstance = this._rangePickerInstance = undefined;
		}
		deselectOption  () {
		    if (this._currentSelected) {
		        this._resetValues();
		        this._setValue(null);
		        this._setPickerValues();
		    }
		}
		addOption  (items, action, selector, options) {
		    let len = this._data.menu.optData.length;
		    selector = action === 'append' ? 0 : selector ? $(selector).index() : len; // No I18N
		    action = (action === 'before' ? 0 : action === 'after' ? +(!selector) || 1 : len) + selector; // No I18N
		    this.addOptionAt(items, action, options);
		}
		_getItems  (items) {
		    return items instanceof Array ? items : [ items ];
		}
		addOptionAt  (items, index, options) {
		    let data = {},
		        i = 0,
		        menuData = this._data.menu.optData;
		    if (options) {
		        data = this._getOptData(this._getItems(options), true, items);
		    } else {
		        data = this._getOptionData(this._getItems(items), true);
		    }
		    for (i = 0; i < menuData.length; i++) {
		        let oldData = menuData[i];
		        let newData = data.filter((dsOption) => dsOption.id === oldData.id);
		        if (newData.length) {
		            data = data.filter((dsOption) => dsOption.id !== newData[0].id);
		            menuData.splice(i, 1, newData[0]);
		        }
		    }
		    // let data = this._getOptData(this._getItems(items), true),
		    //     menuData = this._data.menu.optData;
		    let arr = menuData.splice(0, index, ...data);
		    arr.length && (this._data.menu.optData = [ ...arr, ...menuData ]);
		    this._render();
		    this._setIsPickerVar();
		}
		removeOption  (items) {
		    items = this._getItems(items);
		    for (let i = 0, len = items.length; i < len; i++) {
		        let item = items[i];
		        if (item.indexOf('#') < 0) {
		            item = '#' + this._getOptionObj(item, 'value').id;
		        }
		        this.removeOptionAt($(item).index());
		    }
		}
		removeOptionAt  (index) {
		    this._data.menu.optData.splice(index, 1);
		    this.element.find(this._SELECTORS.option)[index].remove();
		    this._render();
		    this._setDimensions();
		    this._setIsPickerVar();
		}
		setOptionAttributes  (items, optionName, value) {
		    items = this._getItems(items);
		    if (typeof optionName === 'object' && Object.keys(optionName).length) { // No i18n
		        for (let key in optionName) {
		            this.setOptionAttributes(items, key, optionName[key]);
		        }
		    } else if (optionName) {
		        this._setOptionAttribute(items, optionName, value); // if ...arguments is used, changes in items is not reflected
		    }
		    this._setIsPickerVar();
		}
		_setOptionAttribute  (items, optionName, value) {
		    for (let i = 0; i < items.length; i++) {
		        let item = items[i],
		            menuData = this._data.menu.optData,
		            optData = $(item)[0].nodeType ? menuData[$(item).index()] : menuData.find((opt) => opt.label.indexOf(item.label) > -1), // No i18n
		            option = this._getOptForItem(optData.id),
		            oldValue = optData[optionName],
		            disabledCls = ' is-disabled', // No i18n
		            clearVal;
		        item = $('#' + optData.id);
		        optData[optionName] = value;
		        switch (optionName) {
		            case 'selected': // No i18n
		                if (value && !optData.disabled && !optData.hidden) {
		                    this._setValue(item);
		                } else {
		                    clearVal = true;
		                }
		                break;
		            case 'hidden': // No i18n
		                this._display(value, item);
		                clearVal =  item.hasClass('is-selected'); // No i18n
		                break;
		            case 'disabled': // No i18n
		                if (value) {
		                    if (optData.class.indexOf(disabledCls) < 0) {
		                        optData.class += disabledCls;// No i18n
		                    }
		                } else {
		                    optData.class = optData.class.replace(disabledCls, '');
		                }
		                item[value ? 'addClass' : 'removeClass'](disabledCls); // No i18n
		                if (value && item.hasClass('is-selected')) { // No i18n
		                    clearVal = true;
		                }
		                break;
		            case 'label': // No i18n
		                option[0].innerText = value;
		                item[0].innerText = value;
		                break;
		            case 'className': // No i18n
		                optData.class = value;
		                item.removeClass(oldValue).addClass(value);
		                break;
		            case 'valueType': // No i18n
		                optData.selected = this._isSelected(option, optData);
		                if(optData.selected){
		                    this._setValue(item);
		                }
		                break;
		        }
		        if (clearVal) {
		            this.deselectOption();
		            this._clear && this._clear.addClass('zh-dnone')
		        }
		    }
		}
		_setAttribute  (optionName, value) {
		    let opts = this._opts,
		        data = this._data,
		        oldValue = opts[optionName],
		        valueData = this._selectedData,
		        setPlaceholder,
		        dateInstance = this._datePickerInstance,
		        rangeInstance = this._rangePickerInstance,
		        menu = this._dtsMenu,
		        setPickerVal,
		        isValue = valueData.value || valueData.fromValue || valueData.toValue;
		    opts[optionName] = value;
		    if ([ 'arrowSVGIconId', 'arrowIcon', 'arrowIconClassName' ].indexOf(optionName) > -1) { // No i18n
		        if (value) {
		            this._getArrowIconProps(opts);
		        } else {
		            data.arrowIconProps = null;
		        }
		        data.modifiedAttr = 'arrowIcon' // No I18N
		        this._domChanged = true;
		    } else if ([ 'calendarIcon', 'calendarIconAlignment', 'calendarIconClassName', 'calendarSVGIconId' ].indexOf(optionName) > -1) { // No i18n
		        let isArrowIcon = true;
		        if (value && opts.calendarIcon) {
		            this._getCalendarIconProps(data, opts);
		            if (opts.calendarIconAlignment === 'right') { // No i18n
		                data.arrowIconProps = null;
		                isArrowIcon = false;
		            }
		        } else {
		            data.calendarIconProps = data.isRight = data.isLeft = null;
		        }
		        data.modifiedAttr = 'calendarIcon'; // No I18N
		        isArrowIcon && opts.arrowIcon && !data.arrowIconProps && this._getArrowIconProps(opts);
		        this._domChanged = true;
		    } else if (optionName === 'placeholder' && !this._curLi) { // No i18n
		        data.placeholder = value;
		        this._setPlaceholder(false);
		    } else if (optionName === 'format') { // No i18n
		        this._validateFormat();
		        if (!this._invalidFormat) {
		            let values = [ 'value', 'fromValue', 'toValue' ], // No i18n
		                selectedVal;
		                // Revisit - use forEach
		            for (let i = 0; i < values.length; i++) {
		                selectedVal = opts[values[i]];
		                if (selectedVal) {
		                    if (typeof selectedVal === 'string') {
		                        selectedVal = this._parseDate(selectedVal, oldValue);
		                        selectedVal = ZC.Date.formatDate(selectedVal, value);
		                        opts[ values[i] ] = selectedVal;
		                    }
		                    valueData[values[i] + 'String'] = ZC.Date.formatDate(selectedVal, value);
		                }
		            }
		            valueData.valueString = valueData.value ? valueData.valueString : valueData.fromValueString + ' - ' + valueData.toValueString;
		            valueData.translatedValue = this._translateEToA(valueData.valueString);
		            setPlaceholder = true;
		        }
		    } else if (optionName === 'selectedValueDisplayType') { // No i18n
		        this._isText = value === 'text'; // No i18n
		        setPlaceholder = true;
		    } else if (optionName === 'width') { // No i18n
		        this.container.width(value);
		    } else if (optionName === 'height') { // No i18n
		        this.container.height(value)
		    } else if (optionName === 'disabled') { // No i18n
		        this._disable(value);
		    } else if (optionName === 'datePickerOptions' && dateInstance) { // No i18n
		        dateInstance.setAttributes(value);
		        this._isMinMaxGiven = opts.minDate || opts.maxDate || value.minDate || value.maxDate || rangeInstance && (rangeInstance.getAttribute('minDate') || rangeInstance.getAttribute('maxDate'));
		        // Revisit
		        this._datePicker.removeClass('zdatetimepicker zdatetimepicker--group');
		    } else if (optionName === 'dateRangePickerOptions' && rangeInstance) { // No i18n
		        rangeInstance.setAttributes(value);
		        this._isMinMaxGiven = opts.minDate || opts.maxDate || dateInstance && (dateInstance.getAttribute('minDate') || dateInstance.getAttribute('maxDate')) || value.minDate || value.maxDate;
		        // Revisit
		        this._rangePicker.removeClass('zdatetimepicker zdatetimepicker--group'); // No i18n
		    } else if (optionName === 'value') { // No i18n
		        this.setValue(value);
		    } else if ([ 'fromValue', 'toValue' ].indexOf(optionName) > -1) { // No i18n
		        this['set' + (optionName === 'fromValue' ? 'FromValue' : 'ToValue')](value); // No i18n
		    } else if (optionName === 'dropdownList') { // No i18n
		        for (let key in value) {
		            let val = value[key];
		            if (key === 'className') { // No i18n
		                oldValue.className && menu.removeClass(oldValue.className);
		                menu.addClass(val)
		            } else if (key === 'appendTo') { // No i18n
		                menu.appendTo($(val));
		            } else if ([ 'height', 'width' ].indexOf(key)) { // No i18n
		                this._setDimensions();
		            }
		        }
		    } else if ([ 'immediateCommit', 'hideCancelButton', 'OKButtonLabel', 'cancelButtonLabel' ].indexOf(optionName) > -1) { // No i18n
		        (optionName === 'immediateCommit') && this._setOkCancelBtns(); // No i18n
		        this._domChanged = true;
		        setPickerVal = true;
		    } else if (optionName === 'options') { // No i18n
		        this._reInit = true;
		    } else if (optionName === 'rtl') { // No i18n
		        let prevCls = data.menu.className;
		        data.menu.className = value ? (prevCls + ' zh-rtl') : prevCls.replace('zh-rtl', '');
		        data.modifiedAttr = 'rtl'; // No i18n
		        this._domChanged = setPickerVal = true;
		    }
		    if (setPickerVal) {
		        dateInstance && dateInstance.setAttribute(optionName, value); // No i18n
		        rangeInstance && rangeInstance.setAttribute(optionName, value); // No i18n
		    }
		    if (isValue && setPlaceholder && this._curLi) {
		        valueData.label = valueData.valueString || data.placeholder; // revisit
		        this._setPlaceholder(this._isText && !this._checkTime ? valueData.text : valueData.label); // No I18N
		    }
		    return this._domChanged;
		}
	}
	ZC.registerComponent('ZDateSelect', ZDateSelect); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zdateselect.Templates, utilities = ZC.Templates.Utilities; 
template.WCContainer = (data) => ZT.html `<div>${data.children && template.WCChildren(data)}</div>` 
template.WCChildren = (data) => ZT.html `${data.isLeft && utilities.WCIcon(data.calendarIconProps)} <div class="zselectbox__selected"> <span class="zdatetimeselectbox__label zselectbox__text" aria-placeholder="${data.placeholder}"></span> </div> ${data.clearButton && ZC.createButton(data.clearButton)} ${data.isRight && utilities.WCIcon(data.calendarIconProps)} ${data.arrowIconProps && utilities.WCIcon(data.arrowIconProps)} ${data.menu && template.WCMenu(data.menu)}` 
template.WCMenu = (data) => ZT.html `<div ?class="${data.className}"> ${data.prepend && template.WCPickerContainer(data)} <ul class="zdatetimeselectbox__listbox"> ${data.optData.map((item) => ZT.html `<li ?class="${item.class}" ?valueType="${item.valueType}" id="${item.id}" ?style="${item.style}">${item.label}</li>`)} </ul> ${data.append && template.WCPickerContainer(data)} </div>` 
template.WCPickerContainer = (data) => ZT.html `<div class="${data.containerClass}"> <div class="zdatetimeselectbox__datetimecontainer"> </div> </div>` }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zdateselect.Templates, utilities = ZC.Templates.Utilities; 
template.container = (data) => ZT.html `<div>${data.children && template.children(data)}</div>` 
template.children = (data) => ZT.html `${data.isLeft && utilities.icon(data.calendarIconProps)} <div class="zselectbox__selected"> <span class="zdatetimeselectbox__label zselectbox__text" aria-placeholder="${data.placeholder}"></span> </div> ${data.clearButton && ZC.createButton(data.clearButton)} ${data.isRight && utilities.icon(data.calendarIconProps)} ${data.arrowIconProps && utilities.icon(data.arrowIconProps)} ${data.menu && template.menu(data.menu)}` 
template.menu = (data) => ZT.html `<div ?class="${data.className}"> ${data.prepend && template.pickerContainer(data)} <ul class="zdatetimeselectbox__listbox"> ${data.optData.map((item) => ZT.html `<li ?class="${item.class}" ?valueType="${item.valueType}" id="${item.id}" ?style="${item.style}">${item.label}</li>`)} </ul> ${data.append && template.pickerContainer(data)} </div>` 
template.pickerContainer = (data) => ZT.html `<div class="${data.containerClass}"> <div class="zdatetimeselectbox__datetimecontainer"> </div> </div>` }(ZComponents)); 
(function(ZC, $){
	class ZTimeInput extends ZC.CoreComponent {
			get name(){
				return "ztimeinput";
			}
	    get attrs() {
	        return {
	            timeFieldType: 'input',
	            minTime: null,
	            maxTime: null,
	            id: null,
	            selectedTime: '12:00 AM', // No I18N
	            valueUpdate: false,
	            timeLabelType: 'icon', // No I18N
	            timeLabel: 'Time', // No I18N
	            timeMultipleSelectBoxType: 'h-m-t', // No I18N
	            timeLabelIconClass: null,
	            timeLabelSVGIconId: null,
	            format: 'hh:mm tt',
	            hourStep: 1,
	            minuteStep: 5
	        }
	    }
	    get props() {
	        return {
	            fixedTimeOptions: [],
	            disabledTimeList: []
	        }
	    }
	    get EVENTS() {
	        return [ 'hourchange', 'minutechange', 'periodchange', 'timechange' ]; // No I18N
	    }
	    _init(ele, opts) {
	        this._is12HourFormat = opts.format.indexOf('h') > -1;
	        opts.viewDate = new Date();
	        opts.viewDate.setHours(0, 0, 0, 0);
	        opts.selectedTime = this._getDateVal(opts.selectedTime);
	        this._validateTimeOpts();
	        this._buildData();
	    }
	    update() {
	        this._checkForTime && this._checkForTime();
	    }
	    _validateLimits(tempDate) {
	        let opts = this._opts,
	            options = [ 'minTime', 'maxTime' ];// No I18N
	        for (let i = 0; i < 2; i++) {
	            let opt = options[i];
	            if (opts[opt]) {
	                this['_' + opt] = opts[opt] = this._parseTimeVal(opt);
	            }
	        }
	        let minTime = opts.minTime,
	            maxTime = opts.maxTime;
	        if (minTime && maxTime && ZC.Date.isGreater(minTime, maxTime)) {
	            maxTime = opts.maxTime = undefined;
	        }
	        if (maxTime && tempDate && ZC.Date.isGreater(tempDate, maxTime)) {
	            opts.selectedTime.setHours(maxTime.getHours(), maxTime.getMinutes(), 0, 0);
	        }
	        if (minTime && tempDate && ZC.Date.isGreater(minTime, tempDate)) {
	            opts.selectedTime.setHours(minTime.getHours(), minTime.getMinutes(), 0, 0);
	        }
	    }
	    _checkHourMinLimit(h, minute, hrCheck) {
	        let min = this._opts.minTime,
	            max = this._opts.maxTime;
	        return (min && (hrCheck && h < min.getHours() || (h === min.getHours() && minute < min.getMinutes()))) || (max && (hrCheck && h > max.getHours() || (h === max.getHours() && minute > max.getMinutes())));
	    }
	    _checkPeriod(tempDate, hours, isAM) {
	        let tempHours = tempDate.getHours();
	        let condition = !!((isAM ? tempHours >= 12 : tempHours < 12) && this._checkHourMinLimit(hours, tempDate.getMinutes(), true));
	        this._opts.disabledTimeList.length && (condition = this._checkIfDisabled(tempDate, tempDate.getMinutes(), condition, hours));
	        ZC.select(this._periodEle).setOptionAttributes(isAM ? 'AM' : 'PM', 'disabled', condition); // No I18N
	    }
	    _disableTime(tempDate, i, min) {
	        let condition = !!this._checkHourMinLimit(tempDate.getHours(), min || i);
	        this._opts.disabledTimeList.length && (condition = this._checkIfDisabled(tempDate, i, condition));
	        return condition;
	    }
	    _parseTimeVal(opt) {
	        let value = ZC.Date.parseDate(this._opts[opt], this._opts.format).date;
	        value.setSeconds(0, 0);
	        return value;
	    }
	    _validateTimeOpts() {
	        let opts = this._opts,
	            tempDate,
	            value = opts.selectedTime,
	            minTime = this._minTime;
	        if (value) {
	            tempDate = new Date();
	            tempDate.setHours(value.getHours(), value.getMinutes(), 0, 0);
	        }
	        this._opts.selectedTime = tempDate || (minTime ? new Date(minTime.getTime()) : this._opts.selectedTime);
	        /* Revisit - This case might not occur since the string values will be converted to object in datepicker.js itself.
	           Code for this method is also not present here and should move the function to date Util for future use. */
	        // if (list && list.length && typeof list[0] === 'string') { // No I18N
	        //     this._convertStringToObject({
	        //         disabledTimeList: list
	        //     });
	        // }
	        (opts.minTime || opts.maxTime) && this._validateLimits(tempDate);
	    }
	    _postEachRender(elem, data) {
	        let opts = this._opts,
	            modifiedAttr = data.modifiedAttr;
	        if (modifiedAttr === 'timeFieldType' || !this._hourEle || !this._input || !this._singleSelect || !this._combinedEle) { // No I18N
	            this._updateTimeInputs();
	        }
	        if (this._timeElemRendered || this._valueReset) {
	            // if (this._timeElemRendered) {
	            //     if (opts.timeFieldType === 'input') { // No I18N
	            //         let elem = this.element.find('.zinputfield'); // No I18N
	            //         this._input = this.isCE ? elem : elem.prev();// No I18N
	            //         timeProps.inputProps.mainElement = this._input[0];
	            //     } else {
	            //         this._setSelectElement(...arguments);
	            //     }
	            // }
	            if (opts.timeFieldType === 'multiple-select-box' && modifiedAttr !== 'singleSelect') { // No I18N
	                this._checkForTime();
	            }
	            this._updateSelectedTime(opts.timeFieldType, this._timeElemRendered);
	        }
	    }
	    _postRender() {
	        this._data.className += ' ';
	        this._updateTimeInputs();
	    }
	    _updateTimeInputs() {
	        let opts = this._opts,
	            id = this._opts.id,
	            element = this.element,
	            fieldType = opts.timeFieldType;
	        if (fieldType === 'input') { // No I18N
	            this._input = element.find('#' + id + '-type-input'); // No I18N
	        } else if (fieldType === 'multiple-select-box') { // No I18N
	            if (opts.timeMultipleSelectBoxType === 'h-m-t') { // No I18N
	                this._hourEle = element.find('#' + id + '-hour'); // No I18N
	                this._minuteEle = element.find('#' + id + '-minute'); // No I18N
	                if (this._is12HourFormat) {
	                    this._periodEle = element.find('#' + id + '-period'); // No I18N
	                }
	            } else {
	                this._combinedEle = element.find('#' + id + '-time-combined');
	                if (this._is12HourFormat) {
	                    this._periodEle = element.find('#' + id + '-combined-period');
	                }
	            }
	        } else {
	            this._singleSelect = element.find('#' + id + '-single-time-select');
	        }
	    }
	    _buildData() {
	        this.buildTimePicker();
	    }
	    _validateOpts() {
	        let opts = this._opts,
	            options = options = [ 'hourStep', 'minuteStep' ]; // No I18N
	        for (let i = 0; i < options.length; i++) {
	            let stepVal = Number(opts[options[i]]);
	            opts[options[i]] = stepVal <= 0 ? 1 : stepVal;
	        }
	    }
	    buildTimePicker() {
	        let opts = this._opts,
	            fieldType = opts.timeFieldType;
	        opts.timeLabelType !== 'none' && this._buildLabel(); // No I18N
	        if (fieldType === 'input') { // No I18N
	            this._buildInputElement();
	        } else if (fieldType !== 'none') { // No I18N
	            this._buildSelectElement(opts);
	        }
	        this._timeElemRendered = true;
	    }
	    _buildLabel() {
	        let opts = this._opts,
	            type = opts.timeLabelType;
	        if (type !== 'none') { // No I18N
	            this._data.timeLabel = {};
	            if ([ 'icon', 'icon-text' ].indexOf(type) > -1) {
	                this._getTimeIconProps();
	            }
	            if ([ 'text', 'icon-text' ].indexOf(type) > -1) {
	                this._data.timeLabel.text = opts.timeLabel;
	            }
	        }
	    }
	    getAttribute(optionName) {
	        if (optionName === 'value') {
	            let optionVal,
	                time,
	                fieldType = this._opts.timeFieldType;
	            if (fieldType === 'input') { // No I18N
	                optionVal = ZC.timefield(this._input).getValue().dateObject;
	            } else if (fieldType === 'multiple-select-box') { // No I18N
	                if (this._opts.timeMultipleSelectBoxType === 'h-m-t') { // No I18N
	                    optionVal = this._setSelectTimeForMultiple()
	                } else {
	                    time = ZC.select(this._combinedEle).getAttribute('selectedValue');
	                    let period = ''; // No I18N
	                    if (this._is12HourFormat) {
	                        period = ZC.select(this._periodEle).getAttribute('selectedValue'); // No I18N
	                    }
	                    time = time + ' ' + period; // No I18N
	                    optionVal = ZC.Date.parseDate(time, this._opts.format).date;
	                }
	            } else if (fieldType === 'single-select-box') { // No I18N
	                time = ZC.select(this._singleSelect).getAttribute('selectedValue'); // No I18N
	                optionVal = new Date(+(time));
	            }
	            return optionVal;
	        }
	        return super.getAttribute(...arguments);
	    }
	    _getTimeIconProps() {
	        let opts = this._opts,
	            labelProps = {
	                defaultIconClassName: 'zdatetimepicker__timeicon', // No I18N
	                iconClassName: opts.timeLabelIconClassName,
	                SVGIconClassName: 'zdatetimepicker__time', // No I18N
	                SVGIconId: opts.timeLabelSVGIconId,
	                defaultSVGIconId: 'zc__svg--time', // No I18N
	                isCE: this.isCE
	            };
	        this._data.timeLabel.icon = ZC._getIconInfo(opts.timeLabelIconClassName, opts.timeLabelSVGIconId, '#zc__svg--time', 'zdatetimepicker__timeicon', labelProps); // No I18N
	    }
	    _triggerChange(ev) {
	        let selectedTime = this.getAttribute('value')
	        this._opts.selectedTime = selectedTime;
	        this._dispatchEvent('timechange', ev, {
	            selectedTime
	        }, undefined, !!ev);
	    }
	    _updateSelectedTime(type, isRendered) {
	        if (type === 'input') { // No I18N
	            this._opts.selectedTime = ZC.timefield(this._input).getValue().dateObject;
	            isRendered && (this._initialVal = new Date(+this._opts.selectedTime));
	        } else {
	            this._checkSelectedTime(...arguments);
	        }
	    }
	    setTime(value) {
	        let fieldType = this._opts.timeFieldType,
	            minTime = this._opts.minTime,
	            tempDate = new Date();
	        // Need to handle cases where value is present
	        if (value) {
	            value = this._getDateVal(value);
	            if (value) {
	                tempDate.setHours(value.getHours());
	                tempDate.setMinutes(value.getMinutes());
	                tempDate.setSeconds(0, 0);
	            }
	        } else if (minTime) {
	            tempDate = new Date(+minTime);
	        } else {
	            tempDate.setHours(0, 0, 0, 0);
	        }
	        this._opts.viewDate = new Date(+tempDate);
	        if (fieldType === 'input') { // No I18N
	            ZC.timefield(this._input).setAttribute('value', tempDate || this._initialVal); // No I18N
	        } else if (fieldType === 'multiple-select-box') { // No I18N
	            this._setTimeOnMultipleSelect(!this._opts.valueUpdate, tempDate);
	        } else {
	            let date;
	            if (value) {
	                date = new Date();
	                date.setHours(value.getHours(), value.getMinutes(), 0, 0);
	                date = this._sortSingleSelectValues(date);
	            }
	            if (date) {
	                ZC.select(this._singleSelect).setAttribute('selectedValue', (+date).toString() || this._getSingleSelectFirstVal()); // No I18N
	            }
	        }
	        this._triggerChange();
	    }
	    clearTime() {
	        let fieldType = this._opts.timeFieldType;
	        // Need to handle cases where value is present
	        if (fieldType === 'input') {
	            ZC.timefield(this._input).setAttribute('value', (this._is12HourFormat ? '12:00 AM' : '00:00')); // No I18N
	        } else if (fieldType === 'multiple-select-box') {
	            this._setTimeOnMultipleSelect(true);
	        } else {
	            ZC.select(this._singleSelect).setAttribute('selectedValue', this._getSingleSelectFirstVal()); // No I18N
	        }
	        this._triggerChange();
	    }
	    refresh() {
	        this._refresh = true;
	        this._opts.valueUpdate = true;
	        this._checkForTime && this._checkForTime();
	        this._refresh = false;
	    }
	    _getDateVal(value, format) {
	        // revisit - move to datetimepicker if not used here
	        return ZC.Date.parseDate(value, format || this._opts.format).date;
	    }
	    _destroy() {
	        let fieldType = this._opts.timeFieldType,
	            inputElem = this._input;
	        if (fieldType === 'input' && inputElem && inputElem.length) { // No I18N
	            if (this.isCE) {
	                inputElem.remove();
	            } else {
	                ZC.timefield(inputElem).destroy();
	            }
	            this._input = undefined;
	        } else if (fieldType !== 'none') {// No I18N
	            this._destorySelectElement(fieldType);
	        }
	    }
		_buildhmT  () {
		    let timeString = '',
		        timeJSON = [],
		        is12Hr = this._is12HourFormat,
		        opts = this._opts,
		        value = opts.selectedTime,
		        timeProps = this._data,
		        minTime = this._minTime,
		        format = is12Hr ? this._opts.format.replace('tt', '') : this._opts.format, // No I18N
		        maxTime = this._maxTime,
		        hr, minute;
		    if (value) {
		        hr = this._getHourVal(value.getHours());
		        minute = value.getMinutes();
		    }
		    for (let i = (is12Hr ? 1 : 0), max = (is12Hr ? 12 : 23); i <= max; i = i + opts.hourStep) {
		        for (let j = 0; j < 59; j = j + opts.minuteStep) {
		            timeString = (i < 10 ? '0' + i : i) + ':' + (j < 10 ? '0' + j : j); // No I18N
		            let date = this._getDateVal(timeString, format);
		            if (i >= 12) {
		                date.setHours(i - 12);
		            }
		            let disabled = date && ((minTime && +date < +minTime) || (maxTime && +date > +maxTime));
		            timeJSON.push({
		                selected: i === hr && j === minute,
		                value: timeString,
		                disabled,
		                label: this._translateEToA(timeString)
		            });
		        }
		    }
		    timeProps.combinedProps = this._getElemProps('time-combined', timeJSON, '_combinedTime', 65, 200);// No I18N
		    if (is12Hr) {
		        timeProps.combinedPeriodProps = this._getElemProps('combined-period', this._getPeriodProps(), '_combinedPeriod', 50);// No I18N
		    }
		}
		_setCombinedTimeValues  () {
		    let selectedTime = ZC.select(this._combinedEle).getAttribute('selectedValue'); // No I18N
		    if (this._isFromUI(...arguments)) {
		        if (this._is12HourFormat) {
		            let selectedPeriod = ZC.select(this._periodEle).getAttribute('selectedValue'); // No I18N
		            selectedTime = selectedTime + ' ' + selectedPeriod; // No I18N
		        }
		        let date = this._getDateVal(selectedTime);
		        this._opts.viewDate.setHours(date.getHours(), date.getMinutes(), 0, 0);
		        this._opts.selectedTime = new Date(this._opts.viewDate.getTime());
		        this._opts.selectionType === 'multiple' && this._setTimeForMultiple(date); // No I18N
		        this._triggerChange(...arguments);
		    }
		}
		_combinedTimeClickHandler  (orgEvent, ui) {
		    this._checkCombinedTimeOptions && this._checkCombinedTimeOptions(orgEvent, ui);
		    this._setCombinedTimeValues(orgEvent, ui);
		}
		_combinedPeriodClickHandler  () {
		    this._isFromUI(...arguments) && this._combinedTimeClickHandler(...arguments);
		}
		_isFromUI  (orgEvent, ui) {
		    ui = !ui && orgEvent ? orgEvent.detail : ui;
		    return ui.fromUI;
		}
		_checkIfDisabled  (tempDate, minuteVal, isDisabled, hours) {
		    let list = this._opts.disabledTimeList;
		    minuteVal = minuteVal === undefined ? tempDate.getMinutes() : minuteVal;
		    for (let j = 0; j < list.length; j++) {
		        // revisit- change it in convertToString
		        let timeObj = list[j].date;
		        if ((hours || tempDate.getHours()) === timeObj.getHours() && (minuteVal === timeObj.getMinutes())) {
		            return true;
		        }
		    }
		    return isDisabled;
		}
		_buildInputElement  () {
		    let opts = this._opts,
		        value = opts.selectedTime,
		        is12Hr = this._is12HourFormat;
		    this._data.inputProps = {
		        rtl: opts.rtl,
		        templateRender: true,
		        locale: opts.locale,
		        format: is12Hr ? 'hh:mm tt' : 'HH:mm', // No I18N
		        value: value || (is12Hr ? '12:00 AM' : '00:00'), // No I18N
		        min: opts.minTime,
		        max: opts.maxTime,
		        hourStep: opts.hourStep,
		        minuteStep: opts.minuteStep,
		        id: this._opts.id + '-type-input', // No I18N
		        clearButton: 'none', // No I18N
		        spinend: this._spinEndHandler.bind(this),
		        isCE: this.isCE,
		        width: 100,
		        change: this._timeFieldChangeHandler.bind(this),
		        mainElement: this._input ? this._input[0] : null
		    };
		}
		_spinEndHandler  (orgEvent, ui) {
		    ui = !ui && orgEvent ? orgEvent.detail : ui;
		    let value = ui.dateValue;
		    this._timeModified = true;
		    this._opts.selectedTime = value;
		    if (value !== undefined && this._opts.viewDate) {
		        this._opts.viewDate.setHours(value.getHours(), value.getMinutes(), 0, 0);
		        this._triggerChange(orgEvent);
		    }
		}
		_timeFieldChangeHandler  (orgEvent, ui) {
		    ui = ui || (orgEvent && orgEvent.detail);
		    if (this.isCE) {
		        orgEvent.stopPropagation();
		    }
		    this._dispatchEvent('timechange', orgEvent, { // No I18N
		        selectedTime: this.getAttribute('value'),
		        value: ZC.timefield(this._input).getAttribute('value'), // No I18N
		        valueString: ZC.Date.formatDate(ui.dateValue, this._opts.format)
		    });
		}
		_checkTimeOptions  (valueCheck, date) {
		    this._opts.valueUpdate = true;
		    let opts = this._opts,
		        data = this._data,
		        tempDate = new Date(),
		        // setMin = this._checkToUnSetVal('_minTime'), // No I18N
		        // setMax = this._checkToUnSetVal('_maxTime'), // No I18N
		        hourInstance = ZC.select(this._hourEle),
		        minuteInstance = ZC.select(this._minuteEle),
		        hourData = data.hourProps.options,
		        min = this._minTime,
		        max = this._maxTime;
		    date = date || this._opts.viewDate;
		    tempDate.setHours(date.getHours(), date.getMinutes(), 0, 0);
		    let viewHr = tempDate.getHours();
		    if (this._is12HourFormat) {
		        this._setMinuteVal(tempDate);
		        let falseVal = [],
		            curValue = hourInstance.getAttribute('selectedValue');
		        for (let i = 1; i <= 12; i = i + opts.hourStep) {
		            let hour = i,
		                selectedMin = parseInt(minuteInstance.getAttribute('selectedValue')),
		                isGreater; // No I18N
		            if (viewHr >= 12) {
		                isGreater = true;
		                hour = i === 12 ? i : i + 12;
		            } else {
		                hour = i % 12;
		            }
		            let disabled = !!this._checkHourMinLimit(hour, selectedMin, true);
		            opts.disabledTimeList.length && (disabled = this._checkIfDisabled(tempDate, tempDate.getMinutes(), disabled, hour));
		            disabled = isGreater ? hour <= 23 && disabled : disabled;
		            hourData.find((obj) => obj.value === i).disabled = disabled;
		            if (!disabled) {
		                falseVal.push(i);
		            }
		            disabled && (+curValue === i) && (curValue = false);
		        }
		        hourInstance.setAttribute('options', [ ...hourData ]); // No I18N
		        curValue = curValue === false || curValue === '' ? falseVal[0] : curValue;
		        hourInstance.setAttribute('selectedValue', curValue);
		        // tempDate.setHours(+curValue);
		        let hours = viewHr - 12;
		        this._checkPeriod(tempDate, hours, true);
		        hours = viewHr + 12;
		        this._checkPeriod(tempDate, hours);
		        this.setTime(tempDate);
		    } else {
		        this._setMinuteVal(tempDate);
		        min && hourInstance.setOptionAttributes(min.getHours(), 'disabled', tempDate.getMinutes() < min.getMinutes()); // No I18N
		        max && hourInstance.setOptionAttributes(max.getHours(), 'disabled', tempDate.getMinutes() > max.getMinutes()); // No I18N
		    }
		    // (setMin || setMax) && this._setMinMaxVal(setMin, setMax);
		}
		_setMinuteVal  (tempDate) {
		    let step = this._opts.minuteStep,
		        minuteInstance = ZC.select(this._minuteEle),
		        minuteData = this._data.minuteProps.options,
		        curValue = minuteInstance.getAttribute('selectedValue'),
		        falseVal = [];
		    for (let i = 0; i <= 59; i = i + step) {
		        let disabled = this._disableTime(tempDate, i);
		        if (!disabled) {
		            falseVal.push((i < 10 ? '0' : '') + i);
		        }
		        minuteData.find((obj) => obj.value === i).disabled = disabled;
		        +curValue === i && disabled && (curValue = false);
		    }
		    let minuteOpts = {}
		    minuteOpts.options = [ ...minuteData ];
		    if (curValue === false) {
		        minuteOpts.selectedValue = minuteData.find((obj) => obj.label === falseVal[0]);
		    }
		    minuteInstance.setAttributes(minuteOpts);
		    tempDate.setMinutes(+curValue);
		}
		_checkCombinedTimeOptions  (orgEvent, ui) {
		    let isPM, options,
		        opts = this._opts,
		        curValue, curPeriod,
		        dateUtil = ZC.Date,
		        is12hr = this._is12HourFormat,
		        disabledLen = opts.disabledTimeList.length,
		        disabled,
		        date,
		        timeInstance = ZC.select(this._combinedEle),
		        periodInstance;
		    if (is12hr) {
		        periodInstance = ZC.select(this._periodEle);
		        curPeriod = periodInstance.getAttribute('selectedValue');
		        isPM = curPeriod === 'PM'; // No I18N
		    }
		    let min = this._minTime,
		        minHr, maxHr,
		        max = this._maxTime;
		    min && (minHr = min.getHours());
		    max && (maxHr = max.getHours());
		    if (!ui || this._isFromUI(...arguments)) {
		        options = this._data.combinedProps.options;
		        curValue = timeInstance.getAttribute('selectedValue'); // No I18N
		        let falseVal = [];
		        for (let i = 0, len = options.length; i < len; i++) {
		            let value = options[i].value;
		            date = this._getDateVal(value + ' ' + (curPeriod || ''));
		            if (curPeriod) {
		                disabled = !!(min && (isPM ? minHr > 12 : minHr < 12) && dateUtil.isTimeGreater(min, date) || (max && (isPM ? maxHr > 12 : maxHr < 12) && dateUtil.isTimeGreater(date, max)))
		                disabledLen && (disabled = this._checkIfDisabled(date, date.getMinutes(), disabled));
		            }
		            options[i].disabled = disabled;
		            if (!disabled) {
		                falseVal.push(value);
		            }
		            curValue === value && disabled && (curValue = false);
		        }
		        timeInstance.setAttribute('options', [ ...options ]); // No I18N
		        curValue = curValue || falseVal[0];
		        !orgEvent && timeInstance.setAttribute('selectedValue', curValue); // No I18N
		        if (is12hr) {
		            date = this._getDateVal(curValue + ' ' + curPeriod); // No I18N
		            date.setHours(date.getHours() + (isPM ? -12 : 12));
		            if (date) {
		                disabled = !!((min && dateUtil.isTimeGreater(min, date)) || (max && dateUtil.isTimeGreater(date, max)));
		                disabledLen && (disabled = this._checkIfDisabled(date, date.getMinutes(), disabled, date.getHours()));
		                periodInstance.setOptionAttributes(isPM ? 'AM' : 'PM', 'disabled', disabled); // No I18N
		            }
		        }
		    }
		}
		_getPeriodProps  () {
		    let opts = this._opts,
		        minTime = opts.minTime,
		        value = opts.selectedTime,
		        val = value ? value.getHours() : undefined,
		        minHr = minTime ? minTime.getHours() : undefined,
		        maxHr = opts.maxTime ? opts.maxTime.getHours() : undefined;
		    return [ {
		        value: 'AM', // No I18N
		        selected: (minHr || val) < 11,
		        label: 'AM', // No I18N
		        disabled: minHr > 11
		    }, {
		        value: 'PM', // No I18N
		        selected: (minHr || val) > 11,
		        label: 'PM', // No I18N
		        disabled: !!(maxHr && maxHr < 11)
		    } ];
		}
		_getElemProps  (elemType, dataSource, handler, width, Ht) {
		    let opts = this._opts;
		    return {
		        id: this._opts.id + '-' + elemType,
		        templateRender: true,
		        rtl: opts.rtl,
		        options: dataSource,
		        isCE: this.isCE,
		        dropdownList: {
		            width: width || 40,
		            height: Ht || 330,
		            className: 'zdatetimepicker--menu'// No I18N
		        },
		        width: 'auto', // No I18N
		        optionclick: handler ? this[handler + 'ClickHandler'].bind(this) : this._timeSelectClickHandler.bind(this)// No I18N
		    }
		}
		_checkForTime  (boolVal, unSetLimit) {
		    let opts = this._opts;
		    if ((opts.minTime || opts.maxTime || opts.disabledTimeList.length || this._refresh || unSetLimit) && opts.timeFieldType === 'multiple-select-box') {
		        if (opts.timeMultipleSelectBoxType === 'h-m-t') {
		            this._checkTimeOptions(boolVal);
		        } else if (opts.timeMultipleSelectBoxType === 'hm-t') {
		            this._checkCombinedTimeOptions();
		        }
		    }
		}
		_preventSelectEv  () {
		    [ '_singleSelect', '_hourEle', '_minuteEle', '_combinedEle', '_periodEle' ].forEach((val) => { // No I18N
		        let elem = this[val];
		        if (elem && elem.length) {
		            this._stopSelectEvents(elem);
		        }
		    });
		}
		_stopSelectEvents  (element) {
		    let events = ZC.ZSelect.prototype._EVENTS;
		    for (let i = 0; i < events.length; i++) {
		        element.on('z' + events[i], (ev) => ev.stopPropagation());
		    }
		}
		_getHourVal  (hourVal) {
		    if (this._is12HourFormat) {
		        // !(hourval % 12) will check the remainder for 0
		        hourVal = hourVal === 0 || (hourVal > 11 && !(hourVal % 12)) ? 12 : hourVal > 11 ? hourVal % 12 : hourVal;
		    }
		    return hourVal;
		}
		_buildSelectElement  (opts) {
		    switch (opts.timeFieldType) {
		        case 'multiple-select-box': // No I18N
		            this._data.multiSelect = true;
		            if (opts.timeMultipleSelectBoxType === 'h-m-t') { // No I18N
		                this._buildhMT();
		            } else if (opts.timeMultipleSelectBoxType === 'hm-t') { // No I18N
		                this._data.isCombined = true;
		                this._buildhmT();
		            }
		            break;
		        case 'single-select-box': // No I18N
		            this._buildSingleSelect();
		            break;
		    }
		}
		_destorySelectElement  (fieldType) {
		    let combinedEle = this._combinedEle,
		        singleSelect = this._singleSelect;
		    if (fieldType === 'multiple-select-box') {
		        if (this._opts.timeMultipleSelectBoxType === 'h-m-t') {
		            this._destroyhMT(); // No I18N
		        } else if (combinedEle && combinedEle.length) {
		            if (this.isCE) {
		                combinedEle.remove();
		                if (this._periodEle) {
		                    this._periodEle.remove();
		                }
		            } else {
		                ZC.select(combinedEle).destroy();
		                this._periodEle && ZC.select(this._periodEle).destroy();
		            }
		            this._combinedEle = undefined;
		        }
		        this._periodEle = undefined;
		    } else if (fieldType === 'single-select-box' && singleSelect && singleSelect.length) {
		        if (this.isCE) {
		            singleSelect.remove();
		        } else {
		            ZC.select(singleSelect).destroy();
		        }
		        this._singleSelect = undefined;
		    }
		}
		_checkSelectedTime  (type) {
		    let date;
		    if (type === 'multiple-select-box') {
		        date = this._setSelectTimeForMultiple(...arguments);
		    } else {
		        let value = new Date(+ZC.select(this._singleSelect).getAttribute('value'));
		        date = this._opts.selectedTime = new Date(value);
		    }
		    !this._valueSet && this._opts.viewDate.setHours(date.getHours(), date.getMinutes());
		}
		_buildhMT  () {
		    let opts = this._opts,
		        value = opts.selectedTime,
		        is12Hr = this._is12HourFormat,
		        minHours, maxHours, minMinutes,
		        minTime = this._opts.minTime,
		        maxTime = this._opts.maxTime,
		        timeProps = this._data,
		        selected, selectedHour, selectedH,
		        hourJSON = [],
		        minuteJSON = [],
		        disabled;
		    if (minTime) {
		        minHours = minTime.getHours();
		        minMinutes = minTime.getMinutes()
		    }
		    if (maxTime) {
		        maxHours = maxTime.getHours();
		    }
		    // data generation for hour element
		    selectedH = value ? this._getHourVal(value.getHours()) : (minHours ? this._getHourVal(minHours) : (is12Hr ? 12 : 0));
		    for (let i = (is12Hr ? 1 : 0), max = (is12Hr ? 12 : 23); i <= max; i = i + opts.hourStep) {
		        selected = (i === selectedH);
		        !is12Hr && selected && (selectedHour = i);
		        hourJSON.push({
		            selected,
		            disabled: ((minHours ? i < minHours : false) || (maxHours ? i > maxHours : false)), // revisit - what if selected value is also disabled ( inCase of hourValue-> 0)
		            value: i,
		            label: this._translateEToA((i < 10 ? '0' : '') + i)
		        });
		    }
		    timeProps.hourProps = this._getElemProps('hour', hourJSON); // No I18N
		    opts.viewDate.setHours(value ? value.getHours() : (minTime ? minHours : 0));
		    // data generation for minute element
		    let minuteVal = (value ? value.getMinutes() : (minTime ? minMinutes : 0));
		    opts.viewDate.setMinutes(minuteVal);
		    for (let i = 0; i <= 59; i += opts.minuteStep) {
		        if (is12Hr) {
		            // revisit - why zero ?
		            // selected = 0;
		        } else {
		            disabled = (i < minMinutes && selectedHour === minHours);
		        }
		        selected = (i - opts.minuteStep < minuteVal) && (i >= minuteVal);
		        minuteJSON.push({
		            value: i,
		            label: this._translateEToA((i < 10 ? '0' : '') + i),
		            disabled,
		            selected
		        });
		    }
		    timeProps.minuteProps = this._getElemProps('minute', minuteJSON);// No I18N
		    // revisit - postRender
		    // if (picker.isCE) {
		    //     this._stopSelectEvents(picker._hourEle);
		    //     this._stopSelectEvents(picker._minuteEle);
		    // }
		    if (is12Hr) {
		        timeProps.periodProps = this._getElemProps('period', this._getPeriodProps(), '_period', 50);// No I18N
		        // revisit - postRender
		        // this._stopSelectEvents(picker._periodEle);
		    }
		}
		_destroyhMT  () {
		    [ '_hourEle', '_minuteEle', '_periodEle' ].forEach((key) => { // No I18N
		        let element = this[key];
		        if (element && element.length) {
		            let instance = ZC.select(element);
		            if (this.isCE) {
		                element.remove();
		            } else {
		                instance.destroy();
		            }
		        }
		        this[key] = undefined;
		    });
		}
		_timeSelectClickHandler  (orgEvent, ui) {
		    let type,
		        viewDate = this._opts.viewDate;
		    ui = !ui && orgEvent ? orgEvent.detail : ui;
		    if (ui.fromUI) {
		        // parseInt changed to +
		        let value = +(ui.selectedValue);
		        if ($(ui.dropdownList).attr('id').indexOf('hour') > -1) { // No I18N
		            if (this._is12HourFormat) {
		                value = this._getHourValue(ZC.select(this._periodEle).getAttribute('selectedValue'), value); // No I18N
		            }
		            viewDate.setHours(value);
		            type = 'hour'; // No I18N
		        } else {
		            viewDate.setMinutes(value);
		            type = 'minute'; // No I18N
		        }
		        this._triggerEvent(orgEvent, ui, type);
		        this._checkForTime(false);
		        this._opts.selectedTime = new Date(+viewDate);
		        this._opts.selectionType === 'multiple' && this._setTimeForMultiple(viewDate); // No I18N
		        this._triggerChange(orgEvent);
		    }
		}
		_periodClickHandler  (orgEvent, ui) {
		    ui = !ui && orgEvent ? orgEvent.detail : ui;
		    let val = ui.selectedValue,
		        viewDate = this._opts.viewDate;
		    if (ui.fromUI) {
		        let hourValue = +(ZC.select(this._hourEle).getAttribute('selectedValue')); // No I18N
		        hourValue = this._getHourValue(val, hourValue);
		        this._selectedPeriod = val;
		        viewDate.setHours(hourValue);
		        this._triggerEvent(orgEvent, ui, 'period'); // No I18N
		        this._checkForTime(false);
		        this._opts.selectedTime = new Date(+viewDate);
		        this._triggerChange(orgEvent);
		    }
		}
		_getHourValue  (period, hourValue) {
		    let isAM = period === 'AM'; // No I18N
		    return hourValue % 12 === 0 ? (isAM ? 0 : 12) : (isAM ? hourValue : hourValue + 12);
		}
		_triggerEvent  (orgEvent, ui, type) {
		    let opts = this._opts;
		    // revisit - should the event be triggered even if the time is equal to the current time ?
		    this._dispatchEvent(type + 'change', orgEvent, { // No I18N
		        value: opts.selectedTime,
		        valueString: ZC.Date.formatDate(opts.selectedTime, opts.format),
		        selectedValue: parseInt(ui.selectedValue)
		    });
		}
		_setSelectTimeForMultiple  (type, isRendered) {
		    let select = ZC.select.bind(ZC),
		        value, shouldSet,
		        periodVal = this._is12HourFormat ? select(this._periodEle).getValue() : '';
		    if (this._opts.timeMultipleSelectBoxType === 'h-m-t') {
		        let hr = select(this._hourEle).getValue(),
		            minute = select(this._minuteEle).getValue();
		        if (isRendered) {
		            this._initialHr = hr;
		            this._initialMinute = minute;
		        }
		        value = hr + ':' + minute + ' ' + periodVal;
		        shouldSet = true;
		    } else {
		        value = select(this._combinedEle).getValue() + ' ' + periodVal;
		        isRendered && (this._initialVal = value)
		    }
		    let date = this._getDateVal(value);
		    this._opts.selectedTime = date;
		    shouldSet && isRendered && (this._initialVal = new Date(+date));
		    return new Date(date);
		}
		_setTimeOnMultipleSelect  (forceReset, value) {
		    let is12Hr = this._is12HourFormat,
		        opts = this._opts,
		        minTime = opts.minTime,
		        isEmpty,
		        shouldSet = value || forceReset,
		        getHr = this._getHourVal.bind(this);
		    if (opts.timeMultipleSelectBoxType === 'h-m-t') {	// No I18N
		        let hourInstance = ZC.select(this._hourEle),
		            minuteInstance = ZC.select(this._minuteEle),
		            val;
		        isEmpty = this._isEmpty(hourInstance.getAttribute('selectedValue'));
		        if (isEmpty || shouldSet) {
		            val = value && !forceReset ? getHr(value.getHours()) : (minTime ? getHr(minTime.getHours()) : this._is12HourFormat ? 12 : 0);
		            this._removeDisabled(hourInstance, val);
		            this._setSelectedVal('hour', val, hourInstance); // No I18N
		        }
		        isEmpty = this._isEmpty(minuteInstance.getAttribute('selectedValue')); // No I18N
		        if (isEmpty || shouldSet) {
		            val = (value && !forceReset ? value.getMinutes() : (minTime ? minTime.getMinutes() : 0));
		            this._removeDisabled(minuteInstance, val);
		            this._opts.viewDate.setMinutes(val);
		            this._setSelectedVal('minute', val, minuteInstance); // No I18N
		            this._setMinuteVal(this._opts.viewDate); // to make minDate or maxDate to be reflected on minutes when hour value changes
		        }
		    } else {
		        let val;
		        isEmpty = this._isEmpty(ZC.select(this._combinedEle).getAttribute('selectedValue')); // No I18N
		        if (isEmpty || shouldSet) {
		            let timeVal = minTime ? getHr(minTime.getHours()) + ':' + minTime.getMinutes() : '12:00'; // No I18N
		            val = (value && !forceReset ? ZC.Date.formatDate(value, this._opts.format) : timeVal).split(' ')[0];
		            ZC.select(this._combinedEle).setAttribute('selectedValue', val);
		        }
		    }
		    let hourValue = value && !forceReset ? value.getHours() : (minTime ? minTime.getHours() : 0);
		    if (typeof hourValue === 'number') {
		        this._opts.viewDate.setHours(hourValue);
		        if (is12Hr) {
		            let periodElem = this._periodEle,
		                periodInstance = ZC.select(periodElem),
		                period = periodInstance.getAttribute('selectedValue'); // No I18N
		            isEmpty = this._isEmpty(period);
		            if (isEmpty || shouldSet) {
		                this._removeDisabled(periodInstance, hourValue >= 12 ? 'PM' : 'AM'); // No I18N
		                periodElem && periodInstance.setAttribute('selectedValue', hourValue >= 12 ? 'PM' : 'AM'); // No I18N
		            }
		        }
		    }
		}
		_setSelectedVal  (type, value, instance) {
		    let step = this._opts[type + 'Step']; // No I18N
		    value = Math.ceil(value / step) * step;
		    this._removeDisabled(instance, value);
		    instance.setAttribute('selectedValue', value); // No I18N
		}
		_removeDisabled  (instance, value) {
		    instance.setOptionAttributes(value, 'disabled', false); // No I18N
		}
		_isEmpty  (value) {
		    return value !== null && value !== undefined && value.length === 0;
		}
		_setAttribute  (optionName, value) {
		    let domChange = true,
		        opts = this._opts;
		    if (optionName === 'timeFieldType' || optionName === 'timeMultipleSelectBoxType' || optionName === 'fixedTimeOptions') { // No I18N
		        this._data.modifiedAttr = 'timeFieldType'; // No I18N
		        domChange = optionName !== 'fixedTimeOptions'; // No I18N
		    }
		    if (optionName === 'timeLabelType') { // No I18N
		        opts[optionName] = value;
		        if (value === 'none') { // No I18N
		            this._data.timeLabel = null;
		        } else {
		            this._buildLabel();
		        }
		    } else if ([ 'timeLabel', 'timeLabelIconClassName', 'timeLabelSVGIconId' ].indexOf(optionName) > -1) { // No I18N
		        opts[optionName] = value;
		        this._buildLabel();
		    } else if (optionName === 'rtl') { // No I18N
		        opts[optionName] = value;
		        if (opts.timeFieldType === 'input') { // No I18N
		            ZC.timefield(this._input).setAttribute('rtl', value); // No I18N
		        } else {
		            let keys = [ '_hourEle', '_minuteEle', '_periodEle', '_singleSelect', '_combinedEle' ]; // No I18N
		            for (let i = 0; i < keys.length; i++) {
		                let element = this[keys[i]];
		                if (element && element.length) {
		                    ZC.select(element).setAttribute('rtl', value); // No I18N
		                }
		            }
		        }
		    } else if ([ 'minTime', 'maxTime', 'hourStep', 'minuteStep' ].indexOf(optionName) > -1) { // No I18N
		        if (optionName === 'minTime' || optionName === 'maxTime') { // No I18N
		            if (typeof value === 'string') {
		                value = this._getDateVal(value);
		                let today = new Date();
		                today.setHours(value.getHours(), value.getMinutes(), 0, 0);
		                value = new Date(+today);
		            }
		            this['_' + optionName] = this._opts[optionName] = value; // No I18N
		            if (opts.timeFieldType === 'input') { // No I18N
		                ZC.timefield(this._input).setAttribute(optionName.replace('Time', ''), value); // No I18N
		            } else if (opts.timeFieldType === 'single-select-box') { // No I18N
		                let instance = ZC.select(this._singleSelect),
		                    newOpts = this._buildSingleSelect(true);
		                instance.setAttribute('options', newOpts);
		                if (opts.selectedTime && optionName === 'minTime' && +opts.selectedTime < +value) {
		                    instance.setAttribute('value', newOpts[0].value);
		                }
		                this._reInit = true;
		            } else {
		                let tempDate = opts.selectedTime ? +opts.selectedTime < +value ? value : opts.selectedTime : value;
		                if (optionName === 'minTime') { // No I18N
		                    this._opts.viewDate.setHours(tempDate.getHours(), tempDate.getMinutes(), 0, 0);
		                }
		                opts[optionName] = value;
		                this._checkForTime(undefined, true);
		            }
		        } else if (opts.timeFieldType === 'input') { // No I18N
		            ZC.timefield(this._input).setAttribute(optionName.replace('Time', ''), value); // No I18N
		        } else {
		            this._destroy();
		            this._reInit = true;
		        }
		        opts[optionName] = value;
		    } else if (optionName !== 'viewDate' && optionName !== 'valueUpdate' || optionName === 'format') { // No I18N
		        if (optionName === 'format') {
		            opts[optionName] = value;
		            this._is12HourFormat = opts.format.indexOf('h') > -1;
		        }
		        this._destroy();
		        this._reInit = true;
		        opts[optionName] = value;
		    } else {
		        opts[optionName] = value;
		    }
		    if (this._reInit) {
		        let data = this._data;
		        data.isCombined = data.multiSelect = data.singleSelect = data.inputProps = data.hourProps = data.minuteProps = data.periodProps = data.combinedProps = data.combinedPeriodProps = null;
		    }
		    this._domChanged = domChange;
		}
		_buildSingleSelect  (getJSON) {
		    let opts = this._opts,
		        options = opts.fixedTimeOptions,
		        len = options.length,
		        tempDate,
		        timeJSON = [],
		        disabledList = opts.disabledTimeList,
		        minTime = this._minTime,
		        maxTime = this._maxTime,
		        value = opts.selectedTime;
		    if (value) {
		        tempDate = new Date();
		        tempDate.setHours(value.getHours(), value.getMinutes(), 0, 0);
		    }
		    let selectedVal = this._sortSingleSelectValues(tempDate);
		    if (len) {
		        for (let i = 0; i < len; i++) {
		            let date = this._getDateVal(options[i]),
		                isGreater,
		                disabled = false;
		            date.setSeconds(0, 0);
		            isGreater = (minTime ? ZC.Date.isGreater(date, minTime) : true) && (maxTime ? ZC.Date.isGreater(maxTime, date) : true);
		            for (let j = 0; j < disabledList.length; j++) {
		                let timeObj = disabledList[j].date;
		                if (+date === +timeObj) {
		                    disabled = true;
		                    break;
		                }
		            }
		            isGreater && timeJSON.push({
		                selected: +selectedVal === +date,
		                disabled,
		                value: +date,
		                label: this._translateEToA(options[i])
		            });
		        }
		    }
		    if (getJSON) {
		        return timeJSON;
		    }
		    this._data.singleSelect = this._getElemProps('single-time-select', timeJSON, '_singleSelect', 100, 200); // No I18N
		}
		_sortSingleSelectValues  (date) {
		    let options = this._opts.fixedTimeOptions;
		    options.sort((a, b) => {
		        a = this._getDateVal(a);
		        b = this._getDateVal(b);
		        return a - b;
		    });
		    for (let i = 0, len = options.length; i < len; i++) {
		        let val = this._getDateVal(options[i]);
		        if (date && (ZC.Date.areTimesEqual(val, date) || (+val > +date))) {
		            return val;
		        }
		    }
		}
		_singleSelectClickHandler  (orgEvent, ui) {
		    ui = !ui && orgEvent ? orgEvent.detail : ui;
		    let viewDate = this._opts.viewDate;
		    if (ui.fromUI) {
		        // + used instead of parseInt
		        let date = new Date(+(ui.selectedValue));
		        viewDate.setHours(date.getHours(), date.getMinutes(), 0, 0);
		        this._opts.selectedTime = new Date(+viewDate);
		        this._opts.selectionType === 'multiple' && this._setTimeForMultiple(viewDate); // No I18N
		        this._triggerChange(orgEvent);
		    }
		}
		_getSingleSelectFirstVal  (checkDate) {
		    let data = this._data.singleSelect.options,
		        value;
		    for (let i = 0, len = data.length; i < len; i++) {
		        if (checkDate) {
		            value = new Date(data[i].value);
		            value.setFullYear(checkDate.getFullYear());
		            value.setMonth(checkDate.getMonth());
		            value.setDate(checkDate.getDate());
		        }
		        if (!data[i].disabled && (!checkDate || +value === +checkDate || +value > +checkDate)) {
		            return checkDate ? value : data[i].value;
		        }
		    }
		}
	}
	ZC.registerComponent('ZTimeInput', ZTimeInput); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let utilities = ZC.Templates.Utilities, template = ZC.ztimeinput.Templates, select = ZC.createSelect; 
template.WCChildren = (data) => ZT.html `${data.timeLabel && ZT.html `${data.timeLabel.icon && utilities.WCIcon(data.timeLabel.icon)} ${data.timeLabel.text && ZT.html `<span class='zdatetimepicker__timelabel'>${data.timeLabel.text}</span>`}`} ${data.inputProps ? ZC.createTimeField(data.inputProps) : data.singleSelect ? select(data.singleSelect) : data.multiSelect && ZT.html `<div class='zdatetimepicker--multipleselectbox'> ${data.isCombined ? ZT.html `${select(data.combinedProps)} ${data.combinedPeriodProps && select(data.combinedPeriodProps)}` : ZT.html `${data.hourProps && select(data.hourProps)} ${data.minuteProps && select(data.minuteProps)} ${data.periodProps && select(data.periodProps)}`} </div >`} ` }(ZComponents)); 
 (function(ZC){ 
let utilities = ZC.Templates.Utilities, template = ZC.ztimeinput.Templates, select = ZC.createSelect; 
template.children = (data) => ZT.html `${data.timeLabel && ZT.html `${data.timeLabel.icon && utilities.icon(data.timeLabel.icon)} ${data.timeLabel.text && ZT.html `<span class='zdatetimepicker__timelabel'>${data.timeLabel.text}</span>`}`} ${data.inputProps ? ZC.createTimeField(data.inputProps) : data.singleSelect ? select(data.singleSelect) : data.multiSelect && ZT.html `<div class='zdatetimepicker--multipleselectbox'> ${data.isCombined ? ZT.html `${select(data.combinedProps)} ${data.combinedPeriodProps && select(data.combinedPeriodProps)}` : ZT.html `${data.hourProps && select(data.hourProps)} ${data.minuteProps && select(data.minuteProps)} ${data.periodProps && select(data.periodProps)}`} </div >`} ` }(ZComponents)); 
(function(ZC, $){
	class ZDateTimeSelect extends ZC.ZDateSelect {
			get name(){
				return "zdatetimeselect";
			}
	    get attrs() {
	        return {
	            immediateCommit: true,
	            format: 'dd/MM/yyyy, hh:mm tt', // No I18N
	            timeFieldType: 'multiple-select-box', // No I18N
	            timeMultipleSelectBoxType: 'h-m-t', // No I18N
	            timeLabelType: 'icon', // No I18N
	            timeLabel: null,
	            fromTimeLabel: null,
	            toTimeLabel: null,
	            disabledTimeList: [],
	            fixedTimeOptions: [],
	            hourStep: 1,
	            minuteStep: 5
	        }
	    }
	    get props() {
	        return {
	            dateTimePickerOptions: {},
	            dateTimeRangePickerOptions: {},
	            labels: {
	                timeLabel: 'Time', // No I18N
	                fromTimeLabel: 'Time', // No I18N
	                toTimeLabel: 'Time' // No I18N
	            }
	        }
	    }
	    get EVENTS() {
	        // revisit
	        return [ 'hourchange', 'minutechange' ]; // No I18N
	    }
	    // Revist - Removed since it is not used anywhere
	    // get SELECTORS() {
	    //     return {
	    //         select: this.isCE ? 'z-select' : 'select', // No I18N
	    //         field: this.isCE ? 'z-timefield' : 'input' // No I18N
	    //     }
	    // }
	    _init() {
	        this._checkTime = true;
	        super._init(...arguments);
	        let valueId = this._valueId;
	        valueId && !this._getOptionObj(valueId, 'id').valueType && this._buildTimePicker(); // No I18N
	    }
	    _postEachRender() {
	        let menuData = this._data.menu,
	            isTimeRendered = menuData.fromTimeProps && !this._timepicker,
	            elemId = this._elementId;
	        if (isTimeRendered) {
	            this._timepicker = this._dtsMenu.find('.zdatetimeselectbox__timecontainer'); // No I18N
	            this._fromInstance = ZC.timeinput($('#' + elemId + '-timeinput1')); // No I18N
	            this._toInstance = ZC.timeinput($('#' + elemId + '-timeinput2')); // No I18N
	            if (!this._opts.immediateCommit) {
	                let cBar = menuData.cBar.cols[0].right;
	                [ 'OK', 'cancel' ].forEach((btn) => { // No I18N
	                    let btnId = btn + '-btn-' + elemId, // No I18N
	                        elem = $('#' + btnId); // No I18N
	                    if (elem.length) {
	                        cBar.find((obj) => obj.id === btnId).mainElement = elem[0];
	                        this._addEvents({
	                            [btn + 'Click']: 'click' // No i18n
	                        }, elem);
	                    }
	                });
	            }
	        }
	        super._postEachRender(...arguments);
	        isTimeRendered && !this._data.rendered && this._openTimePicker();
	    }
	    _validateFormat() {
	        let format = this._opts.format;
	        this._validFormat = ((format.indexOf('d') > -1 && format.indexOf('M') > -1 && format.indexOf('y') > -1) && (format.indexOf('h') > -1 || format.indexOf('H') > -1));
	    }
	    _setFormat() {
	        let format = this._opts.format,
	            hourIndex = Math.max(format.indexOf('h'), format.indexOf('H')), // No I18N
	            dateIndex = Math.min(Math.min(format.indexOf('d'), format.indexOf('M')), format.indexOf('y')), // No I18N
	            lastIndex, first;
	        this._is12HourFormat = format.indexOf('h') > -1;
	        if (hourIndex > dateIndex) {
	            this._timeFormat = format.substring(hourIndex); // No I18N
	            format = format.replace(this._timeFormat, '');// No I18N
	            lastIndex = Math.max(Math.max(format.lastIndexOf('d'), format.lastIndexOf('M')), format.lastIndexOf('y'));// No I18N
	            first = '_date';// No I18N
	        } else {
	            // if timeFormat comes before dateFormat
	            this._dateFormat = format.substring(dateIndex);
	            format = format.replace(this._dateFormat, '');// No I18N
	            lastIndex = Math.max(format.lastIndexOf('m'), format.lastIndexOf('t'));// No I18N
	            first = '_time';// No I18N
	        }
	        this[first + 'Format'] = format.substring(0, lastIndex + 1); // No I18N
	    }
	    _menuClickHandler(orgEvent) {
	        if (!this._opts.readonly && !this._opts.disabled) {
	            let li = $(orgEvent.target).closest('.zdatetimeselectbox__option'); // No I18N
	            if (li.length && !li.hasClass('is-disabled')) { // No i18n
	                this._resetTimePickers();
	                super._menuClickHandler(orgEvent);
	            }
	        }
	    }
	    _getPlaceHolder(data) {
	        if (data) {
	            let type = data.valueType;
	            if (type === 'date' && !this._opts.fromValue && !this._opts.toValue) { // No I18N
	                this._placeholderElem && this._placeholderElem.removeClass('h-resetlabel'); // No i18n
	            }
	            if ([ 'date', 'range' ].indexOf(type) > -1) {
	                this._listContainer.removeClass('zdatetimepicker--timeonly');
	                this._display(true, this._dtsMenu.find('.zdatetimeselectbox__timecontainer')); // No i18n
	            }
	        } else {
	            this._openTimePicker(true);
	        }
	        return super._getPlaceHolder(data);
	    }
	    _updateValues(from, to, type, data) {
	        let opts = this._opts,
	            isBoth = to && from,
	            shouldCommit = opts.immediateCommit,
	            valueId = this._valueId,
	            valueType = data.valueType,
	            valueGiven = data.valueGiven && (valueType || shouldCommit);
	        if (valueType || shouldCommit || valueId || valueGiven) {
	            opts.value = isBoth ? undefined : from && new Date(+from);
	            from = opts.fromValue = from && new Date(+from);
	            to = opts.toValue = isBoth ? to && new Date(+to) : from ? new Date(+from) : undefined;
	        }
	        this._curFrom = new Date(+from);
	        this._curTo = new Date(+(to || from));
	        if (!valueType) {
	            opts.value = undefined;
	            // checking the element's availability fails if any of the option is initially selected (element is not created yet and so, object value is used)
	            !this._data.menu.fromTimeProps && this._buildTimePicker();
	            this._curFrom && this._curTo && this._unSetLimits(undefined, this._curFrom, this._curTo);
	            this._listContainer.addClass('zdatetimepicker--timeonly');// No i18n
	            this._openTimePicker();
	        }
	        this._isPicker && (valueType || shouldCommit) && this._setPickerValues(from, to, valueType || 'range');// No i18n
	        return shouldCommit || valueId || this._valueSet ? this._getStringVal(from, to, undefined, true) : false;
	    }
	    _unSetLimits(unSet, from, to) {
	        let fromInstance = this._fromInstance,
	            toInstance = this._toInstance;
	        from = new Date(+(from || this._opts.fromValue));
	        to = new Date(+(to || this._opts.toValue));
	        unSet = unSet === undefined ? !this._isEqual(from, to) : unSet;
	        if (fromInstance && toInstance) {
	            fromInstance.setAttribute('maxTime', unSet ? null : to); // No i18n
	            toInstance.setAttribute('minTime', unSet ? null : from);// No i18n
	            if (!unSet) {
	                fromInstance.setTime(from);
	                toInstance.setTime(to);
	            }
	        }
	    }
	    _checkForClose(orgEvent, optData) {
	        if ((!optData.valueType && this._opts.immediateCommit)) {
	            this._triggerChange(orgEvent);
	        }
	    }
	    _getStringVal(date1, date2, format, translate) {
	        let isRTL = this._opts.rtl;
	        if (isRTL) {
	            this._placeholderElem.addClass('zh-resetlabel'); // No i18n
	            format = this._timeFormat + ' ,' + this._dateFormat;
	        }
	        /* For specific date, only one date will be passed, so it should be handled - (isRtl && date2) check is added */
	        return super._getStringVal((isRTL && date2) ? date2 : date1, isRTL ? date1 : date2, format, translate);
	    }
	    _resetTimePickers(setPrevValue) {
	        let fromInstance = this._fromInstance,
	            toInstance = this._toInstance,
	            from = this._opts.fromValue,
	            to = this._opts.toValue;
	        if (fromInstance && toInstance) {
	            if (setPrevValue && from && to) {
	                // should set the value
	                fromInstance.setTime(from);
	                toInstance.setTime(to);
	                this._unSetLimits();
	            } else {
	                fromInstance.setAttribute('maxTime', null); // No i18n
	                toInstance.setAttribute('minTime', null); // No i18n
	                fromInstance.clearTime();
	                toInstance.clearTime();
	            }
	        }
	    }
	    _OKClickHandler(orgEvent, doNotClose) {
	        let opts = this._opts,
	            from = this._curFrom,
	            to = this._curTo,
	            fromTime = this._fromInstance.getAttribute('selectedTime'), // No i18n
	            toTime = this._toInstance.getAttribute('selectedTime');// No i18n
	        from = opts.fromValue = new Date(+from);
	        to = opts.toValue = new Date(+to);
	        this._setPickerValues(from, to, 'range'); // No I18N
	        from.setHours(fromTime.getHours(), fromTime.getMinutes());
	        to.setHours(toTime.getHours(), toTime.getMinutes());
	        this._setPlaceholder(this._getStringVal(from, to));
	        this._setSelectedData(this._selectedData); // data is sent only for updating label
	        this._isPicker && this._setPickerValues(from, to);
	        this._triggerChange(orgEvent);
	        this._valueChanged = false;
	        !doNotClose && this.close();
	    }
	    _cancelClickHandler(orgEvent) {
	        this._valueChanged = false;
	        this._resetTimePickers(true);
	        super._cancelHandler(orgEvent);
	    }
	    _buildCBar() {
	        let opts = this._opts,
	            ok = opts.OKButton,
	            cancel = opts.cancelButton,
	            cBar = [],
	            data = this._data.menu;
	        if ((ok || cancel) && !opts.immediateCommit) {
	            data.cBar = {};
	            data.cBar.cols = [];
	            cancel && (cBar.push(this._getbtnAttr('cancelButton'))); // No i18n
	            ok && (cBar.push(this._getbtnAttr('OKButton'))); // No i18n
	            data.cBar.cols.push({
	                right: cBar
	            });
	        } else {
	            data.cBar = null;
	        }
	    }
	    _getbtnAttr(btn) {
	        let btnName = btn.replace('Button', ''), // No i18n
	            label = btn + 'Label'; // No i18n
	        return ZC.ZButton.getBtnProps({
	            customAttributes: {
	                name: btn,
	                'aria-label': label // No I18N
	            },
	            initBtnComp: true,
	            id: btnName + '-btn-' + this._elementId, // No i18n
	            name: btn,
	            isCE: this.isCE,
	            className: (btnName === 'today' ? 'zdatetimepicker__todaylink ' : '') + btn + '-' + this.name, // No I18N
	            text: this._opts[label] || this._getI18NText(label), // No I18N
	            appearance: btn === 'OKButton' ? 'primary' : 'normal', // No I18N
	            size: 'small', // No I18N
	            templateRender: true
	        });
	    }
	    _timeChangeHandler(orgEvent, ui) {
	        let evData = orgEvent.detail,
	            opts = this._opts,
	            from = this._curFrom,
	            to = this._curTo;
	        if ((ui || evData).fromUI) {
	            this._valueChanged = !opts.immediateCommit;
	            this._fromInstance && this._toInstance && opts.immediateCommit && this._OKClickHandler(undefined, true);
	            if (this._isEqual(from, to)) {
	                if (evData.element.hasClass('zdatetimepicker__starttime')) {
	                    this._toInstance && this._toInstance.setAttribute('minTime', evData.selectedTime);
	                } else {
	                    this._fromInstance && this._fromInstance.setAttribute('maxTime', evData.selectedTime)
	                }
	            }
	        }
	    }
	    _isEqual(from, to) {
	        return from && to && ZC.Date.areDatesEqual(from, to);
	    }
	    _buildTimePicker() {
	        let menuData = this._data.menu,
	            timeOpts = [ 'timeFieldType', 'timeMultipleSelectBoxType', 'hourStep', 'minuteStep', 'timeLabelType', 'fixedTimeOptions', 'disabledTimeList', 'rtl' ], // No I18N
	            timeProps = {},
	            opts = this._opts
	        menuData.containerClass += ' zdatetimepicker--timeonly'; // No I18N
	        menuData.timeClass = 'zdatetimeselectbox__timecontainer'; // No I18N
	        for (let i = 0; i < 7; i++) {
	            timeProps[timeOpts[i]] = opts[timeOpts[i]];
	        }
	        timeProps.isCE = this.isCE;
	        timeProps.templateRender = true;
	        timeProps.format = this._timeFormat;
	        menuData.fromTimeProps = {
	            ...timeProps,
	            ...this._getTimeObj('from') // No I18N
	        };
	        menuData.toTimeProps = {
	            ...timeProps,
	            ...this._getTimeObj('to') // No I18N
	        }
	        menuData.timeBarClass = 'zdatetimepicker__timebar zdatetimepicker--twocolumn'; // No I18N
	        this._buildCBar(menuData);
	        this._data.rendered && this._render();
	    }
	    _getTimeObj(type) {
	        let opts = this._opts,
	            isFrom = type === 'from', // No I18N
	            value = this['_cur' + (isFrom ? 'From' : 'To')], // No I18N
	            label = type + 'TimeLabel', // No I18N
	            obj = {
	                id: this._elementId + '-timeinput' + (isFrom ? '1' : '2'), // No I18N
	                timeLabel: opts[label] || this._getI18NText(label), // No I18N
	                viewDate: new Date(opts[type + 'Value'] || new Date()),
	                selectedTime: value,
	                timechange: this._timeChangeHandler.bind(this),
	                className: 'zdatetimepicker__' + (isFrom ? 'start' : 'end') + 'time', // No I18N
	                ...this._bindChangeEvents()
	            };
	        value = this['_cur' + (isFrom ? 'To' : 'From')]; // No I18N
	        value && (obj[isFrom ? 'maxTime' : 'minTime'] = new Date(+value)) // No I18N
	        return obj;
	    }
	    _bindChangeEvents() {
	        let obj = {};
	        [ 'minutechange', 'hourchange', 'periodchange' ].forEach((event) => { // No i18n
	            obj[event] = (ev, ui) => {
	                this._dispatchEvent(event, ev, ui);
	            }
	        })
	        return obj;
	    }
	    _openTimePicker(hide) {
	        let elem = this._timepicker;
	        if (elem) {
	            this._setDimensions();
	            this._saveWidth();
	            this._lastOpened = null; /* Since, lastOpened and pickerOpened values should be different for the animation to have effect */
	            this._listContainer.width('') /* Since, width set for picker open animation is not removed */
	            this._display(!!hide, this._listContainer);
	            this._display(!!hide, elem); // No I18N
	            this._setWidth(elem);
	        }
	    }
	    _destroy() {
	        this._fromInstance && this._fromInstance.destroy();
	        this._toInstance && this._toInstance.destroy();
	        super._destroy();
	    }
	    close() {
	        this._valueChanged && this._resetTimePickers(true);
	        super.close(...arguments);
	    }
	    getFromValue() {
	        if (this._opts.fromValue) {
	            let date = new Date(this._opts.fromValue.getTime());
	            return {
	                fromValue: date,
	                fromValueString: ZC.Date.formatDate(date, this._opts.format),
	                options: this.options,
	                element: this.element
	            };
	        }
	    }
	    getToValue() {
	        if (this._opts.toValue) {
	            let date = new Date(this._opts.toValue.getTime());
	            return {
	                toValue: date,
	                toValueString: ZC.Date.formatDate(date, this._opts.format),
	                options: this.options,
	                element: this.element
	            };
	        }
	    }
	    setFromValue(value) {
	        value && this._rangePicker && ZC.datetimerangepicker(this._rangePicker).setAttribute('fromValue', value); // No I18N
	    }
	    setToValue(value) {
	        value && this._rangePicker && ZC.datetimerangepicker(this._rangePicker).setAttribute('toValue', value); // No I18N
	    }
		_initPicker  (type) {
		    let opts = this._opts,
		        isDate = type === 'date', // No I18N
		        options = {
		            timeLabelType: opts.timeLabelType,
		            timeLabel: opts.timeLabel,
		            fixedTimeOptions: opts.fixedTimeOptions,
		            fromTimeLabel: opts.fromTimeLabel,
		            toTimeLabel: opts.toTimeLabel,
		            timeFieldType: opts.timeFieldType,
		            timeMultipleSelectBoxType: opts.timeMultipleSelectBoxType,
		            ...this._getPickerOpts(opts, isDate)
		        },
		        elem;
		    options = $.extend(true, {}, options, opts['dateTime' + (isDate ? '' : 'Range') + 'PickerOptions']); // No i18n
		    elem = this[(isDate ? '_date' : '_range') + 'Picker'] = $(ZC['createDateTime' + (isDate ? '' : 'Range') + 'Picker'](options)); // No i18n
		    elem.removeClass('zdatetimepicker zdatetimepicker--group'); // No i18n
		    this[(isDate ? '_date' : '_range') + 'PickerInstance'] = ZC['datetime' + (isDate ? '' : 'range') + 'picker'](elem);// No i18n
		}
		_changeHandler  (ev, ui){
		    super._changeHandler(ev, ui, this._opts.immediateCommit, this._isSameDate(ev.detail || ui));
		}
		_setAttribute  (optionName, value) {
		    let domChanged = true, 
		        setAttrForTime;
		    this._opts[optionName] = value;
		    if (['dateTimePickerOptions', 'dateTimeRangePickerOptions'].indexOf(optionName) > -1) { // No i18n
		        let instance = this['_'+(optionName.indexOf('Range') ? 'range' : 'date')+ 'PickerInstance'];
		        instance && instance.setAttributes(value); 
		        setAttrForTime = false;
		    } else if (/^(timeFieldType|timeLabelType|timeMultipleSelectBoxType|fixedTimeOptions|timeLabel|disabledTimeList|hourStep|minuteStep)$/.test(optionName)) {
		        setAttrForTime = true;
		    } else if (optionName === 'rtl') { // No i18n
		        let selected = this._selectedData;
		        this._placeholderElem.removeClass('zh-resetlabel');
		        if (selected.fromValue && selected.toValue) {
		            this._setPlaceholder(this._getStringVal(selected.fromValue, selected.toValue))
		            this._placeholderElem[(value ? 'add' : 'remove') + 'Class']('h-resetlabel'); // No i18n
		        }
		        setAttrForTime = true;
		        super._setAttribute(...arguments);
		    } else if ([ 'fromTimeLabel', 'toTimeLabel' ].indexOf(optionName) > -1) { // No i18n
		        this['_' + optionName.replace('TimeLabel', '') + 'Instance'].setAttribute('timeLabel', value); // No i18n
		    } else {
		        domChanged = super._setAttribute(...arguments);
		        if(['immediateCommit', 'hideCancelButton'].indexOf(optionName) > -1){ // No i18n
		           this._buildCBar();
		        }
		    }
		    if (setAttrForTime) {
		        this._fromInstance && this._fromInstance.setAttribute(optionName, value);
		        this._toInstance && this._toInstance.setAttribute(optionName, value);
		        this._opts.dateTimePickerOptions[optionName] = value; // if picker is not yet initialized
		        this._datePickerInstance && this._datePickerInstance.setAttribute(optionName, value);
		        this._opts.dateTimeRangePickerOptions[optionName] = value; // if picker is not yet initialized
		        this._rangePickerInstance && this._rangePickerInstance.setAttribute(optionName, value);
		    }
		    this._domChanged = domChanged;
		}
	}
	ZC.registerComponent('ZDateTimeSelect', ZC.ZDateSelect, ZDateTimeSelect); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zdatetimeselect.Templates, utilities = ZC.Templates.Utilities, timeInput = ZC.createTimeInput; 
template.WCContainer = (data) => ZT.html `<div>${data.children && template.WCChildren(data)}</div>` 
template.WCChildren = (data) => ZT.html `${data.isLeft && utilities.WCIcon(data.calendarIconProps)} <div class="zselectbox__selected"> <span class="zdatetimeselectbox__label zselectbox__text" aria-placeholder="${data.placeholder}"></span> </div> ${data.clearButton && ZC.createButton(data.clearButton)} ${data.isRight && utilities.WCIcon(data.calendarIconProps)} ${data.arrowIconProps && utilities.WCIcon(data.arrowIconProps)} ${data.menu && template.WCMenu(data.menu)}` 
template.WCMenu = (data) => ZT.html `<div ?class="${data.className}"> ${data.prepend && template.WCPickerContainer(data)} <ul class="zdatetimeselectbox__listbox"> ${data.optData.map((item) => ZT.html `<li ?class="${item.class}" ?valueType="${item.valueType}" id="${item.id}" ?style="${item.style}">${item.label}</li>`)} </ul> ${data.append && template.WCPickerContainer(data)} </div>` 
template.WCPickerContainer = (data) => ZT.html `<div class="${data.containerClass}"> <div class="zdatetimeselectbox__datetimecontainer"> ${data.timeClass && ZT.html `<div class="${data.timeClass}"> ${data.timeBarClass && ZT.html `<div class="${data.timeBarClass}"> ${timeInput(data.fromTimeProps)} ${timeInput(data.toTimeProps)} </div>`} ${data.cBar && utilities.WCCommandBar(data.cBar)} </div>`} </div> </div>` }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zdatetimeselect.Templates, utilities = ZC.Templates.Utilities, timeInput = ZC.createTimeInput; 
template.container = (data) => ZT.html `<div>${data.children && template.children(data)}</div>` 
template.children = (data) => ZT.html `${data.isLeft && utilities.icon(data.calendarIconProps)} <div class="zselectbox__selected"> <span class="zdatetimeselectbox__label zselectbox__text" aria-placeholder="${data.placeholder}"></span> </div> ${data.clearButton && ZC.createButton(data.clearButton)} ${data.isRight && utilities.icon(data.calendarIconProps)} ${data.arrowIconProps && utilities.icon(data.arrowIconProps)} ${data.menu && template.menu(data.menu)}` 
template.menu = (data) => ZT.html `<div ?class="${data.className}"> ${data.prepend && template.pickerContainer(data)} <ul class="zdatetimeselectbox__listbox"> ${data.optData.map((item) => ZT.html `<li ?class="${item.class}" ?valueType="${item.valueType}" id="${item.id}" ?style="${item.style}">${item.label}</li>`)} </ul> ${data.append && template.pickerContainer(data)} </div>` 
template.pickerContainer = (data) => ZT.html `<div class="${data.containerClass}"> <div class="zdatetimeselectbox__datetimecontainer"> ${data.timeClass && ZT.html `<div class="${data.timeClass}"> ${data.timeBarClass && ZT.html `<div class="${data.timeBarClass}"> ${timeInput(data.fromTimeProps)} ${timeInput(data.toTimeProps)} </div>`} ${data.cBar && utilities.commandBar(data.cBar)} </div>`} </div> </div>` }(ZComponents)); 
(function(ZC, $){
	class ZSuggestField extends ZC.CoreComponent {
			get name(){
				return "zsuggestfield";
			}
	    get attrs() {
	        return {
	            value: '', // No I18N
	            autoComplete: false,
	            suggestOnFieldFocus: false,
	            lazyLoading: true,
	            viewPerPage: null,
	            sort: true,
	            sortBy: null,
	            sortOrder: null,
	            serverSearch: null,
	            filterByCSSSelector: false,
	            filterBasedOnCurPos: false,
	            disabled: false,
	            placeholder: null,
	            zclassName: null,
	            dataStructure: 'flat', // No I18N
	            cacheData: true
	        }
	    }
	    get props() {
	        return {
	            customSorter: null,
	            customSearch: null,
	            data: [],
	            dataSource: null,
	            dataMapping: {},
	            search: {
	                minKeywordLength: 0,
	                maxKeywordLength: 50,
	                caseSensitive: false,
	                criteria: 'contains', // No I18N
	                delay: 100,
	                by: null,
	                highlightKeyword: false,
	                searchIncrementsInCache: false,
	                showNoResultsMessage: false,
	                moreResultsAction: false,
	                focusFirstResult: true
	            },
	            dropdownList: {
	                contentType: 'text', // No I18N
	                loaderIconClassName: null,
	                loaderSVGIconId: null,
	                virtualization: false,
	                className: null,
	                position: 'auto', // No I18N
	                positionAlterable: true,
	                height: 250,
	                width: null,
	                appendTo: null
	            },
	            messages: {
	                noResults: 'No results found', // No I18N
	                moreAction: 'See more results', // No I18N
	                serverError: 'Server request failed. Please try again later.', // No I18N
	                minKeywordLength: 'Please enter #minKeywordLength# or more characters' // No I18N
	            },
	            headerItems: [],
	            footerItems: []
	        }
	    }
	    get EVENTS() {
	        return [
	            'listitemselect', // No I18N
	            'listitemfocus', // No I18N
	            'dropdownlistbeforefocus', // No I18N 
	            'dropdownlistbeforeopen', // No I18N
	            'dropdownlistopen', // No I18N
	            'dropdownlistbeforeclose', // No I18N
	            'dropdownlistclose', // No I18N
	            'change', // No I18N
	            'beforesearch', // No I18N
	            'searchsuccess', // No I18N
	            'searcherror', // No I18N
	            'moreactionclick', // No I18N
	            'beforedropdownlistupdate', // No I18N
	            'dropdownlistupdate', // No I18N
	            'noresults' // No I18N
	        ];
	    }
	    _init(element, options) {
	        this._id = this._getID(element);
	        this._menuId = this._id + '-menu'; // No I18N
	        if (this.element[0].contenteditable || this.element.is('input, textarea')) { // No I18N
	            this._isRootElementEditable = true;
	        }
	        if (!this.isCE) {
	            [ 'disabled', 'placeholder' ].forEach((prop) => { // No I18N
	                options[prop] = options[prop] || element[0][prop];
	            });
	        }
	    }
	    _render() {
	        let element = this.element;
	        let options = this._opts;
	        let data = this._data;
	        data.disabled = options.disabled;
	        if (this._beforeRender(options, data)) {
	            super._render(...arguments);
	        } else {
	            !data._rendered && this._postRender(element);
	            this._postEachRender(element);
	            data._rendered = true;
	        }
	    }
	    _beforeRender(options, data) {
	        data.inputClass = 'zsuggestfield-element ' + (options.className || options.zclassName || ''); // No I18N
	        return !this._isRootElementEditable;
	    }
	    _initSource() {
	        let listSettings = this._getListSettings();
	        let element = ZC.createDropdownList(listSettings);
	        this._menu = element;
	        this._listInstance = element.data('zdropdownlist'); // No I18N
	        this._listInstance.componentInstance = this;
	    }
	    _postRender(element) {
	        this._input = this._isRootElementEditable ? element : element.find('input'); // No I18N
	        this._initSource();
	    }
	    _postEachRender() {
	        let data = this._data;
	        let options = this._opts;
	        if (this._domChanged || !data.rendered) {
	            let attrs = {
	                disabled: options.disabled || null,
	                role: 'search', // No I18N
	                'aria-owns': this._menuId, // No I18N
	                'aria-haspopup': true, // No I18N
	                placeholder: options.placeholder,
	                autocomplete: 'off' // No I18N
	            }
	            let inputElement, className;
	            let parentClass = (attrs.disabled ? ' is-disabled' : ''); // No I18N
	            if (this._isRootElementEditable) {
	                inputElement = this.element;
	                className = data.inputClass + parentClass;
	            } else {
	                inputElement = this.element.find('input'); // No I18N
	                data.className = parentClass;
	            }
	            inputElement.attr(attrs);
	            data.className = className;
	        }
	    }
	    _bindEvents() {
	        this._addEvents({
	            blur: 'blur' // No I18N
	        }, this._input);
	    }
	    _blurHandler(orgEvent) {
	        clearTimeout(this._blurTimer);
	        let value = this._opts.value;
	        if (value !== this._oldVal) {
	            this._blurTimer = setTimeout(() => {
	                if (this._input[0] !== document.activeElement) {
	                    this._oldVal = value;
	                    this._triggerChange(orgEvent);
	                }
	            });
	        }
	    }
	    _getListSettings() {
	        let options = this._opts;
	        let dropdownList = options.dropdownList;
	        let search = options.search;
	        let autoComplete = options.autoComplete;
	        let focusFirstResult = autoComplete ? false : search.focusFirstResult;
	        let settings = {
	            id: this._menuId,
	            rtl: options.rtl,
	            search: {
	                ...search,
	                ...{
	                    focusFirstResult: focusFirstResult
	                }
	            },
	            focusFirstItemOnOpen: focusFirstResult,
	            focusItemOnItemMouseover: true,
	            selectOnEnterKey: true,
	            // selectOnKeyNavigation: autoComplete,
	            moreResultsAction: search.moreResultsAction,
	            messages: options.messages,
	            searchFieldOptions: {
	                autoComplete: autoComplete,
	                updateOnSelect: true,
	                handleEvents: true,
	                filterBasedOnCurPos: options.filterBasedOnCurPos,
	                suggestOnFieldFocus: options.suggestOnFieldFocus,
	                preventUPDOWNKeysDefault: true
	            }
	        };
	        settings.searchField = settings.forElement = this._input;
	        settings = this._getListCallbacks(settings);
	        // Copied from options
	        [ 'dataStructure', // No I18N
	            'dataSource', // No I18N
	            'dataMapping', // No I18N
	            'cacheData', // No I18N
	            'isResponseFiltered', // No I18N
	            'lazyLoading', // No I18N
	            'viewPerPage', // No I18N
	            'filterByCSSSelector', // No I18N
	            'sort', // No I18N
	            'sortBy', // No I18N
	            'sortOrder', // No I18N
	            'customSorter', // No I18N
	            'serverSearch', // No I18N
	            'customSearch', // No I18N
	            'headerItems', // No I18N
	            'footerItems' // No I18N
	        ].forEach((prop) => settings[prop] = options[prop]);
	        settings.items = options.data;
	        // Copied from dropdownList options
	        $.extend(settings, dropdownList);
	        settings.position = this._getMenuPos(dropdownList.position);
	        return settings;
	    }
	    _getListCallbacks(settings) {
	        [ 'Select', // No I18N
	            'ItemFocus', // No I18N
	            'BeforeOpen', // No I18N
	            'Open', // No I18N
	            'BeforeClose', // No I18N
	            'Close', // No I18N
	            'BeforeSearch', // No I18N
	            'SearchSuccess', // No I18N
	            'SearchError', // No I18N
	            'MoreActionClick', // No I18N
	            'Input', // No I18N
	            'BeforeUpdate', // No I18N
	            'Update', // No I18N
	            'NoResults', // No I18N
	            'BeforeFocus' // No I18N
	        ].forEach((event) => {
	            settings[event.toLowerCase()] = this['_on' + event].bind(this); // No I18N
	        });
	        return settings;
	    }
	    _onBeforeFocus(){   
	        return this._trigger('dropdownlistbeforefocus', ...arguments);// No I18N
	    }
	    _onItemFocus(orgEvent, eventData) {
	        let originalEvent = orgEvent.originalEvent;
	        if (!originalEvent || originalEvent.type !== 'mouseenter') { // No I18N
	            let newEventData = this._getEventData(eventData.itemData);
	            newEventData.listItem = eventData.listItem;
	            this._trigger('listitemfocus', originalEvent, newEventData);// No I18N
	        }
	    }
	    _onSelect(orgEvent) {
	        this._oldVal = this._opts.value = this._input.val();
	        this._input.focus();
	        this._setValue(orgEvent);
	        let newEventData = this._getEventData(orgEvent.detail.itemData);
	        newEventData.listItem = orgEvent.detail.listItem;
	        this._trigger('listitemselect', orgEvent, newEventData);// No I18N
	        this._triggerChange(orgEvent, newEventData);
	    }
	    _triggerChange(orgEvent, eventData) {
	        this._trigger('change', orgEvent, eventData || this._getEventData()); // No I18N
	    }
	    _onInput() {
	        this._actualData = undefined;
	        this._opts.value = this._input.val();
	    }
	    _getMappedData(data) {
	        if (typeof data === 'object') { // No I18N
	            let mappedData = {};
	            this._getDataKeys().forEach((prop) => mappedData[prop] = this._mapJSONToData(data, this._opts.dataMapping[prop]));
	            return mappedData;
	        }
	        return data;
	    }
	    _getDataKeys() {
	        return [ 'image', 'text', 'value', 'groupLabel', 'iconClassName', 'informativeText', 'customValues' ]; // No I18N
	    }
	    _onBeforeOpen(orgEvent) {
	        this._listInstance.deselectAll();
	        return this._trigger('dropdownlistbeforeopen', orgEvent);// No I18N
	    }
	    _onOpen(orgEvent) {
	        this._DDLOpened = true;
	        return this._trigger('dropdownlistopen', orgEvent);// No I18N
	    }
	    _onBeforeUpdate() {
	        return this._trigger('beforedropdownlistupdate', ...arguments);// No I18N
	    }
	    _onUpdate() {
	        return this._trigger('dropdownlistupdate', ...arguments);// No I18N
	    }
	    _onNoResults() {
	        return this._trigger('noresults', ...arguments); // No I18N
	    }
	    _onClose(orgEvent) {
	        this._DDLOpened = false;
	        return this._trigger('dropdownlistclose', orgEvent);// No I18N
	    }
	    _onBeforeClose(orgEvent) {
	        return this._trigger('dropdownlistbeforeclose', orgEvent); // No I18N
	    }
	    _onBeforeSearch(orgEvent, eventData) {
	        return this._trigger('beforesearch', orgEvent, { // No I18N
	            params: orgEvent.detail.params
	        });
	    }
	    _onSearchSuccess() {
	        return this._trigger('searchsuccess', ...arguments); // No I18N
	    }
	    _onSearchError() {
	        return this._trigger('searcherror', ...arguments); // No I18N
	    }
	    _onMoreActionClick(orgEvent, eventData) {
	        let newEventData = this._getEventData(eventData.itemData);
	        newEventData.listItem = eventData.listItem;
	        return this._trigger('moreactionclick', orgEvent, newEventData);// No I18N
	    }
	    _getEventData(actualData) {
	        actualData = actualData || this._actualData;
	        return {
	            data: actualData,
	            mappedData: this._getMappedData(actualData)
	        };
	    }
	    _trigger(customEvent, orgEvent, eventData) {
	        eventData = this._getTriggerData(eventData);
	        return super._dispatchEvent(customEvent, orgEvent, eventData);
	    }
	    _getTriggerData(eventData) {
	        eventData = eventData || {};
	        eventData.value = this._opts.value;
	        eventData.dropdownList = this._menu && this._menu[0];
	        return eventData;
	    }
	    _getMenuPos(position) {
	        let positionObj = {
	            top: 'top-left', // No I18N
	            bottom: 'bottom-left' // No I18N
	        }
	        return positionObj[position] || position;
	    }
	    openDropdownList() {
	        this._listInstance.open();
	    }
	    closeDropdownList() {
	        this._listInstance.close();
	    }
	    getValue() {
	        return this._actualData;
	    }
	    _setValue(orgEvent, fromClose) {
	        let eventDetail = orgEvent.detail;
	        if (eventDetail) {
	            eventDetail = ((eventDetail || {}).value || [])[0];
	            if (eventDetail) {
	                this._actualData = eventDetail;
	            }
	        }
	        return this._actualData;
	    }
	    search(query) {
	        this.element.val(query);
	        this._listInstance.search(query, {}, true);
	    }
	    searchList(query, options) {
	        if (!this._opts.disabled) {
	            this._input.val(query);
	            this._listInstance.search(query, options, true);
	        }
	    }
	    clearCache() {
	        this._listInstance.clearCache();
	    }
	    _destroy() {
	        this._input
	            .val('')// No I18N
	            .off('.' + this.name) // No I18N
	            .removeClass('zsuggestfield-element'); // No I18N
	        clearTimeout(this._blurTimer);
	        this._listInstance.destroy();
	        this._menu.remove();
	    }
	    getDropdownList() {
	        return this._listInstance.getElement()[0];
	    }
	    fetchData() {
	        return this._listInstance.fetchData(...arguments);
	    }
		_disable  (disable = true) {
		    this._stopAttrUpdate = this._domChanged = true;
		    disable && this.closeDropdownList();
		}
		_setAttribute  (optionName, value) {
		    let options = this._opts;
		    if ([ 'placeholder', 'className', 'zclassName' ].indexOf(optionName) > -1) {	// No I18N
		        options[optionName] = value;
		        this._stopAttrUpdate = this._domChanged = true;
		    } else if ([ 'autoComplete',	// No I18N
		        'cacheData',	// No I18N
		        'dataMapping',	// No I18N
		        'data', // No I18N
		        'dataSource',	// No I18N
		        'dropdownList',	// No I18N
		        'isImageSourceSprited',	// No I18N
		        'isResponseFiltered',	// No I18N
		        'lazyLoading',	// No I18N
		        'viewPerPage', // No I18N
		        'messages',	// No I18N
		        'rtl',	// No I18N
		        'search',	// No I18N
		        'customSearch', // No I18N
		        'suggestOnFieldFocus', // No I18N
		        'filterBasedOnCurPos', // No I18N
		        'filterByCSSSelector', // No I18N
		        'headerItems', // No I18N
		        'footerItems', // No I18N
		        'sort', // No I18N
		        'sortBy', // No I18N
		        'sortOrder', // No I18N
		        'customSorter', // No I18N
		        'serverSearch'// No I18N
		    ].indexOf(optionName) > -1) {	// No I18N
		        options[optionName] = value;
		        this._reInit = true;
		    } else if (optionName === 'value') { // No I18N
		        this._input.val(value);
		    }
		}
		_buildData  () {
		    this._listInstance.setAttributes($.extend(true, {}, this._listInstance._DEFAULTS, this._getListSettings()));
		}
	}
	ZC.registerComponent('ZSuggestField', ZSuggestField); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zsuggestfield.Templates; 
template.WCChildren = (data) => ZT.html `<input type=text class="${data.inputClass} ${data.disabled ? 'is-disabled' : ''}">` }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zsuggestfield.Templates; 
template.children = (data) => ZT.html `<input type=text class="${data.inputClass} ${data.disabled ? 'is-disabled' : ''}">` }(ZComponents)); 
(function(ZC, $){
	class ZTokenfield extends ZC.ZSuggestField {
			get name(){
				return "ztokenfield";
			}
	    get attrs() {
	        return {
	            allowDuplicateValues: false,
	            dataValidation: false,
	            delimiter: ',',		// No I18N
	            acceptNewValues: false,
	            maxAllowedValues: null,
	            // Not exposed
	            trimInputedValue: true
	        };
	    }
	    get props() {
	        return {
	            newValuePattern: null,
	            dropdownList: {
	                itemType: 'none', // No I18N
	                closeOnSelect: true
	            },
	            search: {
	                retainKeyword: null
	            },
	            tokens: {
	                contentType: 'text', // No I18N
	                template: null,
	                isDataEncoded: null,
	                sortable: false,
	                editable: false,
	                animateOnRemove: false,
	                showRemoveButtonOnHover: false,
	                editModePattern: '"#value#" <#id#>' // No I18N
	            },
	            values: [],
	            messages: {
	                remove: 'Remove', // No I18N
	                close: 'Close' // No I18N
	            }
	        }
	    }
	    get _messages() {
	        return {
	            limitReach: 'Limit Exceeded', // No I18N
	            denyValue: 'Deny new value' // No I18N
	        }
	    }
	    get EVENTS() {
	        return [
	            'beforetokenadd', // No I18N
	            'beforetokenremove', // No I18N
	            'tokenadd', // No I18N
	            'tokenremove', // No I18N
	            'tokenedit', // No I18N
	            'tokendrag', // No I18N
	            'tokenaddfail', // No I18N
	            'focus', // No I18N
	            'beforeinputfocus', // No I18N
	            'inputfocus' // No I18N
	        ];
	    }
	    get _CONSTANTS() {
	        return {
	            minKeywordLength: 20,
	            maxResults: 10
	        }
	    }
	    _init() {
	        super._init(...arguments);
	        this._dataMapping = this._opts.dataMapping;
	        this._data.tokens = [];
	        this._data.id = this._id;
	        this._data.pasteStyle = ZC.Browser.isIE ? 'width:0;height:0;opacity:0' : 'position:absolute; top: -10000000px'; // No I18N
	        this._prevValues = [];
	        this._didOps = [];
	        this._undidOps = [];
	        this._uniqueIndex = 0;
	        this._updatePreDatas();
	        this._setValues();
	        this._tokensInfo = {};
	    }
	    _updatePreDatas() {
	        let _isCheckboxType = this._opts.dropdownList.itemType === 'checkbox'; // No I18N
	        this._isCheckboxType = _isCheckboxType;
	        this._ignoreChange = false;
	        this._closeOnSelect = !_isCheckboxType && this._opts.dropdownList.closeOnSelect;
	        this._storePatternSettings();
	    }
	    _storePatternSettings() {
	        let displayValuePattern = this._displayPattern = this._opts.tokens.editModePattern.trim();
	        let valuePattern = '#value#';// No I18N
	        let idPattern = '#id#';// No I18N
	        let valueIndex = undefined, idIndex = undefined;
	        let lastIndex = 1;
	        let parsePattern = displayValuePattern
	            .replace(/(\?|\*|\+|\$|\^|\.|\||\\|\(|\)|\[|\])/g, function($0) {
	                return '\\' + $0; // No I18N
	            });
	        parsePattern = parsePattern.replace(new RegExp(`(${valuePattern}|${idPattern})`, 'g'), function($0) { // No I18N
	                if (!valueIndex && $0 === valuePattern) {
	                    valueIndex = lastIndex++;
	                } else if (!idIndex && $0 === idPattern) {
	                    idIndex = lastIndex++;
	                }
	                return '(#prefix#.*#suffix#)'; // No I18N
	            });
	        // let completePattern = parsePattern
	        //     .replace(/#prefix#/g, '?:') // No I18N
	        //     .replace(/#suffix#/g, '?'); // No i18N
	        parsePattern = parsePattern
	            .replace(/#prefix#/g, '') // No I18N
	            .replace(/#suffix#/g, ''); // No I18N
	        this._patternOpts = {
	            parsePattern,
	            // completePattern,
	            idIndex,
	            valueIndex
	        };
	    }
	    /**
	     * TODO: M-- AllowDuplicateValues check is not done here.
	     * TODO: M-- maxAllowedValues check is excluded.
	    */
	    _setValues() {
	        let maxValues = this._opts.maxAllowedValues;
	        let values = this._opts.values;
	        if (maxValues) {
	            this._opts.values = values = values.slice(0, maxValues);
	        }
	        values.forEach((value) => this._data.tokens.push(this._getTokenData(value)));
	    }
	    _getEditInput() {
	        let editInput = $('#' + this._id + '-edit-input'); // No I18N
	        return editInput.length ? editInput : undefined;
	    }
	    _postEachRender(element, data) {
	        let opts = this._opts;
	        let tokenDOMS = this._tokensInfo.DOM = element.children('.ztokenfield__token'); // No I18N
	        this._tokensInfo.DOMArr = tokenDOMS.toArray();
	        this._mainFocussedToken = this._lastSelectedToken = false;
	        this._resetSelectedTokens();
	        this._bindEditHandler();
	        let editInput = this._editField = this._getEditInput();
	        let domChanged = this._domChanged;
	        let selectedTokens = this._getSelected();
	        if (editInput) {
	            editInput.focus();
	            let tokenInEditMode = this._tokenInEditMode;
	            editInput.val(tokenInEditMode.editText);
	            if (!this._CRUDEvent) {
	                editInput.select();
	            }
	            this._resetInputField();
	            this._listInstance.setAttribute('searchField', editInput); // No I18N
	        } else if (selectedTokens.length) {
	            this._mainFocussedToken = selectedTokens[selectedTokens.length - 1];
	        } else {
	            (data.rendered && (!this._focussedOut || this._CRUDEvent)) && this._focusInput({
	                force: true,
	                event: this._data.orgEvent
	            });
	        }
	        if (this._showDrop) {
	            domChanged = true;
	            if (data._queryForList !== undefined) {
	                if (data._queryForList !== this._getQuery()) {
	                    this._search(data._queryForList, this._CRUDEvent);
	                }
	            } else if (opts.dropdownList.position === 'after-cursor') {// No I18N
	                this._positionMenu(true);
	            }
	        }
	        if (domChanged || !data.rendered) {
	            this._data.className = 'ztokenfield ' + (opts.className || opts.zclassName || '') + (opts.rtl ? ' zh-rtl' : '') + (opts.disabled ? ' is-disabled' : '') + (opts.tokens.showRemoveButtonOnHover ? '' : ' ztokenfield--closeshown'); // No I18N
	            data.attrs = {
	                'aria-disabled': opts.disabled, // No I18N
	                id: this._id + '-container' // No I18N
	            }
	            this._adjustHeight();
	            if (opts.tokens.sortable) {
	                this._initSortable();
	            } else {
	                this._destroySortable();
	            }
	            this._fixInput();
	            data.tokens.forEach((tokenData) => {
	                if (tokenData.tokenId && tokenData.removable && !tokenData.removeButton.mainElement) {
	                    let token = $('#' + tokenData.tokenId); // No I18N
	                    tokenData.removeButton.mainElement = token.find('.ztokenfield__close')[0];// No I18N
	                }
	            });
	        } else if (this._CRUDEvent || this._CRUDOper) {
	            this._fixInput();
	        }
	        this._showDrop = this._CRUDEvent = false;
	    }
	    _destroySortable() {
	        this._isSortableSet() && ZC.sortable(this.container).destroy();// No I18N
	    }
	    _isSortableSet() {
	        return this.container.data('zsortable'); // No I18N
	    }
	    _postRender() {
	        let container = this.container;
	        this._cpyHelperField = $('#' + this._id + '-copy-helper'); // No I18N
	        this._input = container.find('.ztokenfield__textbox'); // No I18N
	        this._initSource();
	    }
	    _getTriggerData(eventData) {
	        eventData = eventData || {};
	        eventData.params = this._listInstance.params;
	        eventData.dropdownList = this._menu && this._menu[0];
	        return eventData;
	    }
	    _getListSettings() {
	        let settings = super._getListSettings(),
	            dropdownListOpts = this._opts.dropdownList,
	            inputSettings = settings.searchFieldOptions;
	        if (dropdownListOpts.itemType === 'checkbox') { // No I18N
	            settings.multiSelectInterfacePattern = 'checkbox'; // No I18N
	            settings.checkedIcon = true;
	        }
	        if (this._opts.autoComplete) {
	            settings.focusSelectedItem = false;
	            settings.selectOnKeyNavigation = false;
	        }
	        settings.multiple = settings.hideCheckbox = true;
	        inputSettings.updateOnSelect = false;
	        settings.forElement = this[dropdownListOpts.position === 'after-cursor' ? '_input' : 'container']; // No I18N
	        settings.beforesearchfieldupdate = this._onBeforeFieldUpdate.bind(this);
	        settings.searchfieldupdate = this._onInputFieldUpdate.bind(this);
	        return settings;
	    }
	    _onInputFieldUpdate() {
	        this._fixInput();
	        this._listInstance.updatePosition();
	    }
	    _onInput(orgEvent, eventData) {
	        if (this._opts.delimiter) {
	            let fieldValue = this._input.val();
	            if (this._isDelimiter(fieldValue[fieldValue.length - 1])) {
	                orgEvent.preventDefault();
	                return;
	            }
	        }
	        if (eventData.pasteAction) {
	            orgEvent.preventDefault();
	        }
	        super._onInput(...arguments);
	    }
	    _onBeforeFieldUpdate(orgEvent) {
	        let eventData = orgEvent.detail;
	        if (eventData.autoCompleted) {
	            return this._checkMaxLimit();
	        }
	    }
	    _closeBtnClick(tokenId, orgEvent) {
	        if (!this._opts.disabled) {
	            // To avoid unnecessary check in the clickhandler.
	            this._removeToken($('#' + tokenId), orgEvent); // No I18N
	            orgEvent.stopPropagation();
	            orgEvent.preventDefault();
	            this.closeDropdownList();
	        }
	    }
	    _setRemoveProps(data) {
	        let tokens = this._opts.tokens;
	        data.removeButton = {
	            className: 'ztokenfield__close', // No I18N
	            customAttributes: {
	                tabindex: -1
	            },
	            title: this._getI18NText('remove'), // No I18N
	            defaultSVGIconId: 'zc__svg--close ztokenfield__svg', // No I18N
	            defaultIconClassName: 'ztokenfield__icon', // No I18N
	            defaultClassName: 'ztokenfield__close', // No I18N
	            templateRender: true,
	            iconClassName: tokens.removeSVGIconClassName,
	            SVGIconId: tokens.removeSVGIconId,
	            click: this._closeBtnClick.bind(this, data.tokenId)
	        }
	    }
	    _changeHandler(ev) {
	        let currentTokenList = this._opts.values,
	            curLen = currentTokenList.length,
	            prevTokenList = this._prevValues,
	            prevLen = prevTokenList.length,
	            uniqueKey = this._dataMapping.id;
	        let dispatchChange = curLen !== prevLen;
	        if (!dispatchChange) {
	            for (let i = 0; i < curLen; i++) {
	                let idToBeMatched = this._mapJSONToData(currentTokenList[i], uniqueKey);
	                if (!prevTokenList.find((tokenData) => idToBeMatched === this._mapJSONToData(tokenData, uniqueKey))) {
	                    dispatchChange = true;
	                    break;
	                }
	            }
	        }
	        if (dispatchChange) {
	            this._trigger('change', ev, { // No I18N
	                prevTokenList,
	                currentTokenList
	            });
	            this._prevValues = [ ...currentTokenList ]
	        }
	    }
	    _getObj(mapperName, value, obj) {
	        mapperName = this._dataMapping[mapperName];
	        if (mapperName) {
	            let keys = mapperName.split('.'); // No I18N
	            keys.forEach((key, index) => {
	                if (index === (keys.length - 1)) {
	                    if (value !== undefined) {
	                        obj[key] = value;
	                    }
	                } else {
	                    obj = obj[key] = obj[key] || {};
	                }
	            });
	        }
	    }
	    _getListCallbacks(settings) {
	        /* let callbacks = {
	            menucreation: this._onMenuCreation.bind(this),
	            beforelistupdate: this._onBeforeListUpdate.bind(this),
	            listupdate: this._onListUpdate.bind(this)
	        }
	        if (this._isCheckboxType) {
	            callbacks.beforeitemchecked = this._beforeItemChecked.bind(this);
	        }
	        return {
	            ...super._getListCallbacks(),
	            ...callbacks
	        }; */
	        settings = super._getListCallbacks(settings);
	        settings.selectionLimit = this._opts.maxAllowedValues;
	        settings.value = this._opts.values;
	        settings.deselect = this._onDeselect.bind(this);
	        settings.beforeupdate = this._onBeforeUpdate.bind(this);
	        settings.update = this._onListUpdate.bind(this);
	        return settings;
	    }
	    /* _onMenuCreation(ev, data) {
	        this._menu = data.menu;
	        this._menuInstance = ZC.menu(data.menu);
	        this._addEvents({
	            menuMouseDown: 'mousedown' // No I18N
	        }, data.menu)
	    }
	    _menuMouseDownHandler(orgEvent) {
	        orgEvent.preventDefault();
	    } */
	    _getSelected() {
	        return this._getTokenDOMs().filter('.is-selected') || $([]); // No I18N
	    }
	    _enterKeyHandler(orgEvent) {
	        let opts = this._opts;
	        orgEvent.preventDefault();
	        if (this._isCpyHelperField($(orgEvent.target))) {
	            if (opts.tokens.editable) {
	                let activeToken = this._getSelected();
	                activeToken.length === 1 && this._editHandler(undefined, activeToken[0]);
	            }
	        } else {
	            if (this._editField) {
	                this._focusInput({
	                    event: orgEvent
	                });
	            }
	            this._validateCurrentState(orgEvent);
	        }
	    }
	    _validateCurrentState(orgEvent, validate = true) {
	        this._focussedOut = this._focussedOut || (orgEvent.keyCode === ZC.keyCode.TAB && orgEvent.type === 'keydown'); // No I18N
	        if (this._focussedOut || !this._isCpyHelperField($(orgEvent.target))) {
	            if (this._editField) {
	                this._reformToken(orgEvent);
	            } else if (validate) {
	                let newValue = this._input.val().trim();
	                if (newValue) {
	                    this._processInputText(orgEvent, newValue, this._data.tokens.length);
	                }
	            } else {
	                return;
	            }
	            if (this._closeOnSelect) {
	                this.closeDropdownList();
	            }
	        }
	    }
	    _isDelimiter(inputString) {
	        let delimiter = this._opts.delimiter;
	        if (delimiter) {
	            delimiter = Array.isArray(delimiter) ? delimiter : [ delimiter ];
	            return delimiter.find((match) => inputString === match);
	            // return inputString === delimiter;
	        }
	    }
	    _getFirstDelimiter() {
	        let delimiter = this._opts.delimiter;
	        delimiter = Array.isArray(delimiter) ? delimiter[0] : delimiter;
	        return delimiter;
	    }
	    _getDelimiterRegExp() {
	        let delimiterRegexp = this._opts.delimiter;
	        if (Array.isArray(delimiterRegexp)) {
	            delimiterRegexp = new RegExp(delimiterRegexp.join('|')); // No I18N
	        }
	        return delimiterRegexp;
	    }
	    _processInputText(orgEvent, textContent, tokenIndex, extraData) {
	        let newValues = textContent.split(this._getDelimiterRegExp());
	        let tokensToBeCreated = [];
	        if (newValues.length > 1) {
	            extraData = false;
	        }
	        newValues.forEach((newValue) => {
	            if (newValue) {
	                if (this._opts.trimInputedValue) {
	                    newValue = newValue.trim();
	                }
	                let tokenData = this._processNewValueToken(orgEvent, newValue, extraData);
	                if (tokenData) {
	                    tokensToBeCreated.push(tokenData);
	                }
	            }
	        });
	        let tokensAdded = this._validateAndAddToken(tokensToBeCreated, orgEvent, tokenIndex);
	        if (this._focussedOut || tokensAdded.length) {
	            this._resetInputField();
	        }
	        // !focussedOut && this._focusInput();
	    }
	    _processNewValueToken(orgEvent, newValue, extraData) {
	        let opts = this._opts;
	        let newValueRegex = opts.newValuePattern;
	        let existingToken;
	        let values = this._parsePattern(newValue);
	        let tokenData = {};
	        let valueToMatch = newValue;
	        let ajaxSrc = this._listInstance._ajaxSource;
	        if (values) {
	            tokenData = {
	                ...extraData
	            };
	            valueToMatch = values.id;
	            [ 'id', 'value', 'text', 'titleText' ] // No I18N
	                .forEach((dataMappingKey) => this._getObj(dataMappingKey, dataMappingKey === 'text' ? values.label : values.id, tokenData)); // No I18N
	            if (this._fromEdit) {
	                existingToken = this._tokenInEditMode.id === valueToMatch;
	            }
	            if (!existingToken) {
	                existingToken = this._data.tokens.find((_curTokenData) => {
	                    if (_curTokenData.id === valueToMatch) {
	                        tokenData = {
	                            ..._curTokenData.actualData,
	                            ...tokenData
	                        };
	                        tokenData.removable = true;
	                        return true;
	                    }
	                });
	            }
	            if (!existingToken) {
	                if (!ajaxSrc) {
	                    existingToken = this._opts.data.find((dataOption) => {
	                        if (this._mapJSONToData(dataOption, this._dataMapping.id) === valueToMatch) {
	                            tokenData = {
	                                ...dataOption,
	                                ...tokenData
	                            };
	                            tokenData.removable = true;
	                            return true;
	                        }
	                    });
	                }
	            }
	            if (existingToken) {
	                return tokenData;
	            }
	        }
	        if (opts.acceptNewValues && (orgEvent.type !== 'paste' || values)) { // No I18N
	            if (!newValueRegex || (newValueRegex instanceof RegExp && newValueRegex.test(valueToMatch))) {
	                if (!values) {
	                    this._assignValue(newValue, tokenData, orgEvent);
	                }
	                tokenData.newToken = true;
	                this._addToDS(tokenData);
	                return tokenData;
	            }
	        }
	        /*
	            //Commented because emoty token is getting added
	            else if (orgEvent.type === 'paste' && ajaxSrc) { // No I18N
	            return tokenData;
	        } */
	        if (opts.dataValidation || this._fromEdit) {
	            return this._getErrTokenData(newValue, orgEvent);
	        }
	    }
	    _focusOutHandler(orgEvent) {
	        this._clearAllSelection();
	        this._changeHandler(orgEvent);
	        this._validateCurrentState(orgEvent);
	        this._containerFocussed = this._focussedOut = false;
	        this._updateFocusClass();
	    }
	    _clearAllSelection() {
	        this._mainFocussedToken = this._lastSelectedToken = false;
	        this._deselectToken(this._getSelected());
	    }
	    _getActiveInput() {
	        return this._editField || this._input;
	    }
	    _isCpyHelperField(target) {
	        return target[0] === this._cpyHelperField[0];
	    }
	    _getQuery() {
	        return this._listInstance.params.query;
	    }
	    _arrowNavigation(orgEvent, isLeft) {
	        let allTokens = this._getTokens();
	        let tokensCount = allTokens.length;
	        if (tokensCount) {
	            let lastFocussed = this._lastSelectedToken || this._mainFocussedToken;
	            let targetToken;
	            if (lastFocussed) {
	                let indexToBeFocussed = this._getAjToken(lastFocussed.id, isLeft);
	                targetToken = allTokens[indexToBeFocussed];
	                if (!targetToken) {
	                    if (!isLeft) {
	                        this._focusInput({
	                            event: orgEvent
	                        });
	                    }
	                    return;
	                }
	            } else if (isLeft) {
	                targetToken = allTokens[tokensCount - 1];
	            }
	            this._onTokenClick(orgEvent, targetToken, true);
	            orgEvent.preventDefault();
	        }
	    }
	    _getAjToken(tokenId, isLeft) {
	        let lastFocussedIndex = this._getTokenIndex(tokenId);
	        let indexToBeFocussed;
	        if (isLeft) {
	            indexToBeFocussed = lastFocussedIndex - 1;
	        } else {
	            indexToBeFocussed = lastFocussedIndex + 1;
	        }
	        return indexToBeFocussed;
	    }
	    _isMenuShown() {
	        // return this._menu && this._menu.is(':visible'); // No I18N
	        return this._DDLOpened;
	    }
	    getValues(uniqueKeys) {
	        return uniqueKeys.map((uniqueKey) => this._getValue(uniqueKey));
	    }
	    getValue(uniqueKey) {
	        return this._getValue(uniqueKey);
	    }
	    _getValue(uniqueKey, tokenDatas = this._data.tokens) {
	        let tokenData = tokenDatas.find((tokenData) => tokenData.id === uniqueKey);
	        return tokenData && tokenData.actualData;
	    }
	    getAllValues() {
	        return this._opts.values;
	    }
	    search(query) {
	        this._input[0].value = query;
	        this._fixInput();
	        this._search(query);
	    }
	    _keydownHandler(orgEvent) {
	        this._delToken = false;
	        this._preventInputOnMaxReach(orgEvent);
	        let keyCodes = ZC.keyCode;
	        let dsInstance = this._listInstance;
	        let target = $(orgEvent.target);
	        let isCpyPasteField = this._isCpyHelperField(target);
	        let activeInput = target[0].tagName === 'INPUT' && !isCpyPasteField ? $(target) : undefined; // No I18N
	        let activeInputValue = activeInput && activeInput.val().trim();
	        let keyCode = orgEvent.keyCode;
	        let isMenuVisible = this._isMenuShown();
	        let input = this._input;
	        let mainFieldValue = input.val().trim();
	        let isMainFieldActive = target[0] === input[0];
	        let isLenZero = isMainFieldActive && mainFieldValue.length === 0;
	        let editInput = this._editField;
	        let isLeft = keyCode === keyCodes.LEFT;
	        if (isLeft || keyCode === keyCodes.RIGHT) {
	            if (activeInputValue) {
	                this._search(activeInputValue, orgEvent, null, this._opts.searchOnCurPos);
	            } else {
	                this._arrowNavigation(orgEvent, isLeft);
	            }
	        } else if (keyCode === keyCodes.BACKSPACE || keyCode === keyCodes.DELETE) { // Added to prevent default action for backspace when focus is on token
	            this._delToken = !activeInputValue;
	            if (isCpyPasteField) {
	                // Doubt:
	                orgEvent.preventDefault();
	                return;
	            }
	        } else if (keyCode === keyCodes.TAB) {
	            this._validateCurrentState(orgEvent);
	        } else if (keyCode === keyCodes.ESCAPE) {
	            this.closeDropdownList();
	            if (editInput) {
	                this._validateCurrentState(orgEvent);
	            }
	        } else if (!activeInputValue && this._isCtrl(orgEvent)) {
	            /* ASCII CODE
	                    65 - A
	                    88 - X
	                    89 - Y
	                    90 - Z
	                 */
	            // SPECIAL OPERATIONS
	            let isUndo = keyCode === 90;
	            let isRedo = keyCode === 89;
	            let selectAll = keyCode === 65;
	            let isCutOp = keyCode === 88;
	            if (isUndo || isRedo || selectAll || isCutOp) {
	                this.closeDropdownList();
	                if (selectAll) {
	                    if (isCpyPasteField || isLenZero) { 	// No I18N
	                        orgEvent.preventDefault();
	                        this._selectToken(this._getTokens());
	                    }
	                    return;
	                } else if (isUndo || isRedo) {
	                    orgEvent.preventDefault();
	                    let method = (action) => {
	                        if ((action === 'create')) { // No I18N
	                            return (tokenDatas) => {
	                                this._removeToken(tokenDatas, orgEvent);
	                            }
	                        }
	                        return (tokenDatas) => {
	                            this._validateAndAddToken(tokenDatas.map((tokenData) => tokenData.data), orgEvent);
	                        }
	                    };
	                    if (isUndo) {
	                        this._undoTask = true;
	                        let data = this._didOps.pop();
	                        if (data) {
	                            method(data[0].action).call(this, data);
	                        }
	                    } else if (isRedo) {
	                        this._redoTask = true;
	                        let data = this._undidOps.pop();
	                        if (data) {
	                            method(data[0].action).call(this, data);
	                        }
	                    }
	                    this._undoTask = this._redoTask = false;
	                    return;
	                } else if (isCutOp) {
	                    // Have included setTimeout because even before the content is cut, the input field is focussed.
	                    this._removeTimer = setTimeout(() => {
	                        this._removeToken(this._getSelected(), orgEvent);
	                    }, 2);
	                    return;
	                }
	            }
	        }
	        if (activeInput) {
	            if (isMenuVisible) {
	                if ([ keyCodes.ENTER ].indexOf(keyCode) > -1 && !this._menu.attr('data-noresults')) { // No I18N
	                    if (this._closeOnSelect) {
	                        this.closeDropdownList();
	                    }
	                    return;
	                }
	            } else if (keyCode === keyCodes.DOWN) {
	                if (!dsInstance._ajaxSource) {
	                    this._search(this._input.val(), orgEvent);
	                }
	            }
	            /* if (isMenuVisible) {
	                if ([ keyCodes.UP, keyCodes.DOWN, keyCodes.ENTER ].indexOf(keyCode) > -1) {
	                    dsInstance._menuKeyDownHandler(orgEvent);
	                    return;
	                }
	            } else if (keyCode === keyCodes.DOWN) {
	                if (!dsInstance._ajaxSource) {
	                    this._search(this._input.val(), orgEvent);
	                }
	            } */
	        }
	        if (keyCode === keyCodes.ENTER) {
	            this._enterKeyHandler(orgEvent);
	        }
	    }
	    _preventInputOnMaxReach(orgEvent) {
	        if (this._opts.maxAllowedValues && this._opts.values.length >= this._opts.maxAllowedValues) {
	            let charInput = orgEvent.target.tagName === 'INPUT' && this._isAlphaNumericKey(orgEvent); // No I18N
	            if (charInput) {
	                orgEvent.preventDefault();
	            }
	        }
	    }
	    _isCtrl(orgEvent) {
	        return orgEvent && (orgEvent.metaKey || orgEvent.ctrlKey);
	    }
	    _updateLBSelections() {
	        let values = [];
	        this._data.tokens.forEach((tokenData) => {
	            values.push(tokenData.actualData);
	        });
	        this._listInstance.setValue(values);
	    }
	    _onDelimiterKey(orgEvent) {
	        if (this._isMenuShown() && !this._menu.attr('data-noresults')) { // No I18N
	            let focussedItem = this._menu.find('.zdropdownlist__body > .zdropdownlist__item.has-focus'); // No I18N
	            if (focussedItem.length) {
	                this._listInstance.setValue(focussedItem[0].itemData.originalData, {
	                    event: orgEvent
	                });
	                return;
	            }
	        }
	        this._validateCurrentState(orgEvent);
	    }
	    _resetInputField(field) {
	        (field || this._input).val(''); // No I18N
	        this._fixInput();
	    }
	    _inputHandler(orgEvent) {
	        if (!this._isCpyHelperField($(orgEvent.target))) {
	            this._fixInput();
	        }
	    }
	    _keyUpHandler(orgEvent) {
	        let opts = this._opts;
	        if (!opts.disabled) {
	            let activeField = $(orgEvent.target),
	                delToken = this._delToken,
	                selectPrev;
	            if (delToken || (!this._isCtrl(orgEvent) && this._isAlphaNumericKey(orgEvent))) {
	                let updateInputField;
	                let removeSelectedTokens;
	                if (this._isCpyHelperField(activeField)) {
	                    removeSelectedTokens = delToken;
	                    selectPrev = true;
	                } else {
	                    let query = activeField.val();
	                    if (delToken && (!query || !query.length)) {
	                        this._selectToken(activeField.prev(), true, true);
	                        removeSelectedTokens = true;
	                        this._removeEditInput();
	                        this.closeDropdownList();
	                    } else {
	                        let isDelimiter = this._isDelimiter(query[(query.length - 1)]);
	                        updateInputField = true;
	                        if (isDelimiter) {
	                            this._onDelimiterKey(orgEvent, query);
	                        }/*  else {
	                            this._search(query, orgEvent);
	                        } */
	                    }
	                }
	                if (removeSelectedTokens) {
	                    // If any tokens are in selected state, they are removed.
	                    let selectedTokens = this._getSelected();
	                    if (selectedTokens.length) {
	                        if (selectPrev) {
	                            let nonRemovableTokens = selectedTokens.filter('.is-readonly'); // No I18N
	                            if (!nonRemovableTokens.length) {
	                                let prevToken = $(selectedTokens[0]).prev();
	                                prevToken.length && this._selectToken(prevToken, true, true);
	                            }
	                        }
	                        this._removeToken(selectedTokens, orgEvent);
	                    }
	                    !this._isCheckboxType && this.closeDropdownList();
	                } else if (updateInputField && ZC.Browser.getIEVersion() === 9) {
	                    this._fixInput();
	                }
	            }
	        }
	    }
	    _mousedownHandler(orgEvent) {
	        let target = orgEvent.target;
	        let editFieldInFocus;
	        if (this._editField && !editFieldInFocus) {
	            editFieldInFocus = target === this._editField[0];
	            if (!editFieldInFocus) {
	                this._validateCurrentState(orgEvent);
	            }
	        }
	        if (this._input[0] === target || (!editFieldInFocus && !this._getTokenFromEv(orgEvent))) {
	            this._search(this._input.val(), orgEvent);
	        }
	        this._focussedOut = false;
	        if (orgEvent.target === this.container[0]) {
	            // this._focusInput();
	            orgEvent.preventDefault();
	        }
	    }
	    _onBeforeOpen(orgEvent) {
	        if (!this._isCheckboxType) {
	            this._ignoreChange = true;
	            this._listInstance.deselectAll();
	            this._ignoreChange = false;
	        }
	        let query = this._input.val();
	        if (query.length < this._opts.search.maxKeywordLength && this._checkMaxLimit()) {
	            return this._trigger('dropdownlistbeforeopen', orgEvent);// No I18N
	        }
	        return false;
	    }
	    _rectifyInput(value) {
	        value = value
	            .replace(/[,]?\n+/gim, ',')// No I18N
	            .replace(/\t+/gim, ',');// No I18N
	        return value;
	        // if (this._opts.sanitizeInput) {
	        //     let regex = new RegExp(this._patternOpts.completePattern, 'gim'); // No I18N
	        //     let match = value.match(regex);
	        //     if (match && match.length) {
	        //         value = match.join(','); // No I18N
	        //     }
	        // }
	    }
	    _pasteHandler(orgEvent) {
	        if (this._checkMaxLimit()) {
	            clearTimeout(this._pasteTimer);
	            this._pasteTimer = setTimeout(() => {
	                let inputField = orgEvent.target;
	                let activeFieldValue = this._rectifyInput(inputField.value);
	                // let regex = /(?:".*?") (?:<.*?>)/gm;
	                let eventData = {
	                    inputText: activeFieldValue
	                };
	                this._trigger('paste', orgEvent, eventData);// No I18N
	                if (inputField.value !== eventData.inputText) {
	                    inputField.value = activeFieldValue = eventData.inputText;
	                }
	                this._validateCurrentState(orgEvent);
	                activeFieldValue = inputField.value;
	                if (activeFieldValue) {
	                    this._search(activeFieldValue, orgEvent);
	                }
	            }, 100);
	        } else {
	            orgEvent.preventDefault();
	        }
	    }
	    _contextMenuHandler(orgEvent) {
	        // ev.preventDefault();
	    }
	    _inputFocusHandler(orgEvent) {
	        this._clearAllSelection();
	        // if (!this._containerFocussed) {
	        if (this._opts.suggestOnFieldFocus && this._opts.search.minKeywordLength === 0) {
	            this._search('', orgEvent); // No I18N
	        }
	        // }
	    }
	    _inputBlurHandler(orgEvent) {
	    }
	    _isSpecialKeys(ev) {
	        return (ev.metaKey || ev.ctrlKey || ev.shiftKey)
	    }
	    _isRemovableToken(token) {
	        return !token.hasClass('is-readonly'); // No I18N
	    }
	    _getTokenFromEv(orgEvent) {
	        let target = $(orgEvent.target).closest('.ztokenfield__token')[0]; // No I18N
	        return target;
	    }
	    _isCtrlKey(orgEvent) {
	        return ZC.OS.isMac() ? orgEvent.metaKey : orgEvent.ctrlKey;
	    }
	    _onTokenClick(orgEvent, targetToken, arrowNavigation) {
	        if (targetToken) {
	            this._updateScrollTop(targetToken);
	            let tokensToBeSelected = [ targetToken ];
	            this._skipCpyFieldUpdate = true;
	            let mainFocussedToken = this._mainFocussedToken;
	            let lastFocussedToken = this._lastSelectedToken;
	            if (orgEvent.shiftKey) {
	                let allTokens = this._getTokens();
	                if (!mainFocussedToken) {
	                    mainFocussedToken = targetToken;
	                    // mainFocussedToken = arrowNavigation ? targetToken : allTokens[0];
	                }
	                let endIndex = this._getTokenIndex(targetToken.id);
	                let initialIndex = this._getTokenIndex(mainFocussedToken.id);
	                if (arrowNavigation) {
	                    let selectedTokens = this._getSelected();
	                    this._deselectToken(selectedTokens.filter('.ztemp')); // No I18N
	                } else {
	                    this._clearAllSelection();
	                }
	                if (endIndex !== initialIndex) {
	                    if (endIndex < initialIndex) {
	                        // End and initial index are swapped.
	                        [ initialIndex, endIndex ] = [ endIndex, initialIndex ];
	                    }
	                    for (let index = initialIndex; index <= endIndex; index++) {
	                        tokensToBeSelected.push(allTokens[index]);
	                    }
	                }
	                if (arrowNavigation) {
	                    this._selectToken($(tokensToBeSelected).filter(':not(.is-selected)').addClass('ztemp')); // No I18N
	                } else {
	                    this._selectToken(tokensToBeSelected);
	                }
	                lastFocussedToken = targetToken;
	            } else {
	                if (!arrowNavigation && this._isCtrlKey(orgEvent)) {
	                    if (this._isTokenSelected(targetToken)) {
	                        this._deselectToken(targetToken);
	                    } else {
	                        this._selectToken($(tokensToBeSelected));
	                    }
	                } else {
	                    this._clearAllSelection();
	                    this._selectToken($(tokensToBeSelected));
	                }
	                mainFocussedToken = targetToken;
	                lastFocussedToken = false;
	                this._getSelected().removeClass('ztemp'); // No I18N
	            }
	            this._mainFocussedToken = mainFocussedToken;
	            this._lastSelectedToken = lastFocussedToken;
	            this._skipCpyFieldUpdate = false;
	            this._updateValToBeCopied(orgEvent);
	            this.closeDropdownList();
	        }
	    }
	    _clickHandler(orgEvent) {
	        let targetToken = this._getTokenFromEv(orgEvent);
	        if (targetToken) {
	            this._onTokenClick(orgEvent, targetToken);
	        } else if (orgEvent.target.tagName !== 'INPUT') { // No I18N
	            this._focusInput({
	                event: orgEvent
	            });
	        }
	    }
	    _updateFocusClass() {
	        this.container[this._containerFocussed ? 'addClass' : 'removeClass']('has-focus'); // No I18N
	    }
	    _bindEvents() {
	        if (!this._opts.disabled) {
	            this._addEvents({
	                keydown: 'keydown', // No I18N
	                keyUp: 'keyup', // No I18N
	                input: 'input', // No I18N
	                mousedown: 'mousedown', // No I18N
	                click: 'click', // No I18N
	                paste: 'paste', // No I18N
	                contextMenu: 'contextmenu' // No I18N
	            });
	            this._addEvents({
	                inputFocus: 'focus', // No I18N
	                inputBlur: 'blur' // No I18N
	            }, this._input);
	            this._addEvents({
	                containerBlur: 'focusout', // No I18N
	                containerFocus: 'focusin'// No I18N
	            }, this.container)
	        }
	    }
	    _containerFocusHandler(orgEvent) {
	        let triggerFocus = !this._containerFocussed;
	        this._focussedOut = false;
	        this._containerFocussed = true;
	        this._updateFocusClass();
	        if (triggerFocus) {
	            this._trigger('focus', orgEvent); // No I18N
	        }
	    }
	    _containerBlurHandler(orgEvent) {
	        this._focussedOut = true;
	        clearTimeout(this._blurTimer);
	        if (document.activeElement !== this.container[0]) {
	            this._blurTimer = setTimeout(() => {
	                this._focussedOut && this._focusOutHandler(orgEvent);
	            });
	        }
	    }
	    _getTokenDOMs() {
	        return this._tokensInfo.DOM;
	    }
	    _getTokens() {
	        return this._tokensInfo.DOMArr;
	    }
	    _bindEditHandler() {
	        let tokenDOMs = this._getTokenDOMs();
	        this._removeEvents('dblclick', tokenDOMs);// No I18N
	        if (this._opts.tokens.editable) {
	            this._addEvents({
	                edit: 'dblclick' // No I18N
	            }, tokenDOMs);
	        }
	    }
	    _focusInput(options = {}) {
	        let force = options.force;
	        if (force || document.activeElement !== this._input[0]) {
	            if (this._trigger('beforeinputfocus', options.event)) {
	                this._focussed = this._containerFocussed = true;
	                let scrollTop = this.container[0].scrollTop;
	                this._input.focus();
	                if (this._CRUDEvent) {
	                    this.container[0].scrollTop = scrollTop;
	                }
	                // this._updateScrollTop(this._input);
	                this._trigger('inputfocus'); // No I18N
	            }
	        }
	    }
	    _getToken(tokenDatas) {
	        let tokenDOM;
	        if (tokenDatas) {
	            let tokenFieldClass = 'ztokenfield__token';// No I18N
	            let tokenList = [];
	            if (tokenDatas instanceof $ && tokenDatas.length) {
	                tokenList = tokenDatas.filter('.' + tokenFieldClass).toArray(); // No I18N
	            } else {
	                tokenDatas = Array.isArray(tokenDatas) ? tokenDatas : [ tokenDatas ];
	                tokenDatas.forEach((tokenData) => {
	                    if (typeof tokenData === 'string') {// No I18N
	                        tokenDOM = $('#' + tokenData);// No I18N
	                    } else if (tokenData.tokenId) {
	                        tokenDOM = $('#' + tokenData.tokenId);// No I18N
	                    } else {
	                        tokenDOM = $(tokenData);
	                    }
	                    if (tokenDOM.hasClass(tokenFieldClass)) {
	                        tokenList.push(tokenDOM[0]);
	                    }
	                });
	            }
	            return tokenList.length && tokenList;
	        }
	    }
	    _isTokenSelected(tokenDOM) {
	        return $(tokenDOM).hasClass('is-selected'); // No I18N
	    }
	    _selectToken(tokenDOMs, select = true, updateMainFocussedToken) {
	        let selectionClass = 'is-selected'; // No I18N
	        tokenDOMs = this._getToken(tokenDOMs);
	        if (tokenDOMs) {
	            let $tokenDOMs = $(tokenDOMs);
	            if (select) {
	                $tokenDOMs.addClass(selectionClass);
	                if (updateMainFocussedToken) {
	                    this._mainFocussedToken = tokenDOMs.pop();
	                }
	            } else {
	                $tokenDOMs.removeClass(selectionClass + ' ztemp'); // No I18N
	            }
	            this._updateValToBeCopied();
	        }
	    }
	    _deselectToken(tokenDOMs) {
	        this._selectToken(tokenDOMs, false);
	    }
	    _getTokenIndex(tokenId) {
	        let tokenDatas = this._data.tokens;
	        for (let i = 0; i < tokenDatas.length; i++) {
	            if (tokenDatas[i].tokenId === tokenId) {
	                return i;
	            }
	        }
	        return -1;
	    }
	    _search(query, orgEvent, delay, searchOnCurPos) {
	        if (query.length < this._opts.search.maxKeywordLength && this._checkMaxLimit()) {
	            let searchOpts = this._opts.search;
	            searchOpts.delay = typeof delay === 'number' ? delay : searchOpts.delay; // No I18N
	            searchOpts.event = orgEvent;
	            searchOpts.searchOnCurPos = searchOnCurPos;
	            this._listInstance.search(query, searchOpts, true);
	        }
	    }
	    _removeTokens(values, ev) {
	        this._removeToken(this._getDuplicates(values), ev);
	    }
	    _onSelect(orgEvent, eventData) {
	        if (eventData.fromUI) {
	            eventData = orgEvent.detail;
	            let menuData = eventData.itemMappedData;
	            let menuItem = eventData.item;
	            if (menuData.selectable && !menuData.moreresults) {
	                let actualData = eventData.itemData;
	                let isCheckboxType = this._isCheckboxType;
	                this._lastSelected = menuItem;
	                /* if (this._isCheckboxType && !menuData.checked) {
	                    this._removeTokens(actualData, orgEvent);
	                } else */
	                if (this._trigger('listitemselect', orgEvent, { // No I18N
	                    listItem: menuItem,
	                    listItemData: menuData.originalData
	                })) {
	                    let index;
	                    let editInput = this._editField;
	                    if (editInput) {
	                        let tokenInEditMode = this._tokenInEditMode;
	                        index = tokenInEditMode.index;
	                        if (!isCheckboxType) {
	                            this._removeEditInput();
	                        }
	                    }
	                    this._buildToken(actualData, orgEvent, undefined, index);
	                }
	                if (!this._closeOnSelect) {
	                    orgEvent.preventDefault();
	                }
	            }
	            if (this._closeOnSelect) {
	                this.closeDropdownList();
	            }
	            !this._editField && this._focusInput();
	        }
	    }
	    _getDuplicates(values) {
	        let tokenDatas = this._data.tokens;
	        values = Array.isArray(values) ? values : [ values ];
	        let duplicateTokens = [];
	        values.forEach((value) => {
	            value = typeof value === 'object' ? this._mapJSONToData(value, this._dataMapping.id) : value; // No I18N
	            tokenDatas.forEach((tokenData) => {
	                if (!tokenData.invalidToken && tokenData.id === value) {
	                    duplicateTokens.push($('#' + tokenData.tokenId)[0]); // No I18N
	                }
	            });
	        });
	        return duplicateTokens.length && duplicateTokens;
	    }
	    // _onItemFocus(ev, ui) {
	    //     if (!ui) {
	    //         ui = ev.detail;
	    //     }
	    //     this._focussedItem = null;
	    //     if (this._checkMaxLimit()) {
	    //         this._focussedItem = ui.itemData;
	    //         if (this._opts.autoComplete && this._focussedItem) {
	    //             this._input.val(ui.itemMappedData.text);
	    //             this._fixInput();
	    //         }
	    //     }
	    // }
	    /* _onItemHover(ev, ui) {
	        if (!ui) {
	            ui = ev.detail;
	        }
	        if (this._opts.autoComplete && this._checkMaxLimit()) {
	            let data = ui.listItemData;
	            if (this._isValidItem(ui.listItem) && data) {
	                this._input.val(this._getMappedData(data.originalData).text);
	            }
	            this._fixInput();
	        }
	    }
	    _isValidItem(item) {
	        return item && item.length && !item.is('.zmenu__noresults, .zmenu__title, .zmenu__moreresults, .zmenu__servererror'); // No I18N
	    }
	    _isValidItem(item) {
	        return true; // No I18N
	    } */
	    _beforeRender() {
	        return true;
	    }
	    _onListUpdate() {
	        // this._menu.attr('tabIndex', -1); // No I18N
	        if (this._menu) {
	            this._menu.attr('tabIndex', -1); // No I18N
	            // this._opts.dropdownList.position === 'after-cursor' && this._positionMenu(); // No I18N
	            this._isCheckboxType && this._updateCheckedState();
	        }
	    }
	    _getMatchedData(inputData) {
	        let uniqueKey = this._dataMapping.id;
	        let dataSource = this._opts.data;
	        if (dataSource && dataSource.length) {
	            let id = this._mapJSONToData(inputData, uniqueKey);
	            return dataSource.find((data) => this._mapJSONToData(data, uniqueKey) === id);
	        }
	    }
	    _addToDS(itemData) {
	        if (this._opts.dropdownList.acceptNewValues && this._opts.data instanceof Array) {
	            this._opts.data.push(itemData);
	        }
	    }
	    _buildToken(tokenData, ev, newValue, index) {
	        let opts = this._opts,
	            matchedData,
	            failureType;
	        let tokenToBeCreated;
	        let invalidToken = tokenData.type === 'error'; // No I18N
	        if (invalidToken) {
	            tokenToBeCreated = this._getErrTokenData(tokenData.errorValue, ev, index);
	        } else {
	            if (newValue && !invalidToken) {
	                matchedData = this._getMatchedData(tokenData);
	                if (matchedData) {
	                    tokenData = matchedData;
	                } else if (opts.acceptNewValues || this._listInstance._ajaxSource) {
	                    this._addToDS(tokenData);
	                } else {
	                    failureType = this._messages.denyValue;
	                }
	            }
	            if (!failureType) {
	                if (this._checkMaxLimit()) {
	                    tokenToBeCreated = tokenData;
	                    tokenData.index = index;
	                } else {
	                    failureType = this._messages.limitReach;
	                }
	            }
	            if (failureType) {
	                this._trigger('tokenaddfail', ev, { // No I18N
	                    failureType
	                });
	            } else {
	                this._validateAndAddToken(tokenToBeCreated, ev)
	            }
	        }
	    }
	    _getDataKeys() {
	        let keys = super._getDataKeys();
	        return keys.concat([ 'id', 'titleText' ]); // No I18N
	    }
	    _checkMaxLimit() {
	        let maxAllowed = this._opts.maxAllowedValues;
	        return !maxAllowed || this._opts.values.length < maxAllowed;
	    }
	    _getTokenData(itemData) {
	        let opts = this._opts,
	            mappedData = this._getMappedData(itemData),
	            id = (this._id + '-token-') + this._uniqueIndex++; // No I18N
	        let invalidToken = itemData.invalidToken || itemData.type === 'error'; // No I18N
	        mappedData = {
	            ...mappedData,
	            tokenId: id,
	            invalidToken: invalidToken,
	            errorValue: itemData.errorValue,
	            removable: itemData.removable === undefined || itemData.removable,
	            hidden: itemData.hidden,
	            isSprite: !!opts.dataMapping.iconClassName
	        };
	        if (opts.tokens.contentType === 'custom') { // No I18N
	            mappedData.customHTML = this._getCustomContent(itemData, opts.tokens.template, false, 'text', !opts.tokens.isDataEncoded); // No I18N
	        } else {
	            mappedData.hasImage = !invalidToken && (opts.tokens.contentType === 'image-text' && (!itemData.newToken || mappedData.image || mappedData.iconClassName)); // No I18N
	        }
	        mappedData.actualData = itemData;
	        if (mappedData.removable) {
	            this._setRemoveProps(mappedData);
	        }
	        return mappedData;
	    }
	    _isValidToken(tokenData) {
	        let opts = this._opts;
	        let allowDuplicates = /* !this._isCheckboxType &&  */opts.allowDuplicateValues;
	        if (tokenData.type !== 'error' && !allowDuplicates) { // No I18N
	            if (this._getDuplicates(tokenData)) {
	                return false;
	            }
	        }
	        return true;
	    }
	    _validateAndAddToken(tokenDatas, orgEvent, startIndex) {
	        tokenDatas = Array.isArray(tokenDatas) ? tokenDatas : [ tokenDatas ];
	        this._taskCollector = [];
	        let tokensToBeCreated = [];
	        tokenDatas.forEach((tokenData) => {
	            if (this._isValidToken(tokenData)) {
	                tokensToBeCreated.push(tokenData);
	            } else {
	                tokenData = this._getErrTokenData(this._mapJSONToData(tokenData, this._dataMapping.text), orgEvent, tokenData.index);
	                if (tokenData) {
	                    tokensToBeCreated.push(tokenData);
	                }
	            }
	        });
	        let autoIncrement = startIndex !== undefined;
	        let currentCount = 0;
	        tokensToBeCreated.forEach((tokenData) => {
	            let index = autoIncrement ? (startIndex + currentCount) : tokenData.index;
	            if (this._createToken(tokenData, orgEvent, index)) {
	                currentCount++;
	            }
	        });
	        this._updateUndoRedoOp(orgEvent);
	        return tokensToBeCreated;
	    }
	    // TokenData in _createToken must contain the actual keys (user provided properties)
	    _createToken(tokenData, orgEvent, index) {
	        let opts = this._opts;
	        if (this._checkMaxLimit()) {
	            let tokenRenderData = this._getTokenData(tokenData);
	            let eventData = {
	                tokenData: tokenRenderData,
	                fromEdit: this._fromEdit
	            }
	            if (this._trigger('beforetokenadd', orgEvent, eventData)) { // No I18N
	                let tokens = this._data.tokens;
	                let isValidIndex = typeof index === 'number' && index > -1 && index < tokens.length; // No I18N
	                if (isValidIndex) {
	                    tokens.splice(index, 0, tokenRenderData);
	                    opts.values.splice(index, 0, tokenData);
	                } else {
	                    tokens.push(tokenRenderData);
	                    opts.values.push(tokenData);
	                }
	                this._CRUDEvent = orgEvent;
	                this._CRUDOper = true;
	                this._data.orgEvent = orgEvent;
	                this._render();
	                eventData.token = $('#' + tokenRenderData.tokenId); // No I18N
	                if (!this._fromEdit) {
	                    this._updateScrollTop(eventData.token);
	                }
	                this._trigger('tokenadd', orgEvent, eventData); // No I18N
	                this._addTask(tokenRenderData, isValidIndex ? index : tokens.length - 1);
	                return true;
	            }
	        }
	    }
	    _onDeselect(orgEvent, data) {
	        if (!this._ignoreChange) {
	            this._removeTokens(orgEvent.detail.itemData, orgEvent);
	        }
	    }
	    _onBeforeUpdate(ev, data) {
	        let opts = this._opts;
	        let allowDuplicates = opts.allowDuplicateValues || this._isCheckboxType;
	        this._data.tokens.forEach((tokenData) => {
	            if (!tokenData.editInput) {
	                let selectedVal = tokenData.value;
	                if (selectedVal) {
	                    selectedVal = selectedVal.toString();
	                    data.results = ev.detail.results.filter((result) => {
	                        let val = this._mapJSONToData(result, this._dataMapping.value);
	                        if (val) {
	                            if (selectedVal === val.toString()) {
	                                let nonRemovable = !tokenData.removable;
	                                if (!this._isCheckboxType && nonRemovable) {
	                                    return false;
	                                }
	                                result.disabled = nonRemovable;
	                                return allowDuplicates;
	                            }
	                            return true;
	                        }
	                    });
	                }
	            }
	        });
	    }
	    _removeToken(tokens, orgEvent) {
	        if (!tokens) {
	            return;
	        }
	        tokens = this._getToken(tokens);
	        // let token = ele.closest('.ztokenfield__token'); // No I18N
	        if (tokens && tokens.length) {
	            this._taskCollector = [];
	            let finishCount = 0;
	            let startedCount = 0;
	            tokens.forEach((token) => {
	                token = $(token);
	                let index = this._getTokenIndex(token[0].id),
	                    tokenDatas = this._data.tokens,
	                    tokenData = tokenDatas[index];
	                let eventData = {
	                    token: token[0],
	                    tokenData: {
	                        actualData: tokenData.actualData,
	                        id: tokenData.id,
	                        tokenId: tokenData.tokenId,
	                        invalidToken: tokenData.invalidToken,
	                        text: tokenData.text,
	                        removable: tokenData.removable
	                    }
	                }
	                let canBeRemoved = this._isRemovableToken(token) && this._trigger('beforetokenremove', orgEvent, eventData); // No I18N
	                if (canBeRemoved) {
	                    startedCount++;
	                    /* BUGFIX -- Issue faced when removeAllTokens method is called and animateOnRemove = true */
	                    tokenDatas.splice(index, 1);
	                    this._opts.values.splice(index, 1);
	                    this._skipCpyFieldUpdate = true;
	                    this._isCheckboxType && this._updateCheckedState(tokenData.actualData);
	                    this._deselectToken(token);
	                    this._skipCpyFieldUpdate = false;
	                    if (this._opts.tokens.animateOnRemove) {
	                        let transitionClass = 'ztokenfield--transition'; // No I18N
	                        token
	                            .width(token.width())
	                            .addClass(transitionClass);
	                        /* Width needs to be set if transition for width needs to work. But since width layout is not updated immediately after setting it, we are executing the transition asynchronously. */
	                        setTimeout(() => {
	                            token
	                                .off(ZC._transitionEnd)
	                                .on(ZC._transitionEnd, () => {
	                                    token
	                                        .css({
	                                            opacity: '', // No I18N
	                                            width: ''// No I18N
	                                        })
	                                        .removeClass(transitionClass)
	                                        .off(ZC._transitionEnd);
	                                    finishCount++;
	                                    if (finishCount === startedCount) {
	                                        this._afterTokensRemoval(orgEvent);
	                                    }
	                                    this._trigger('tokenremove', orgEvent, eventData); // No I18N
	                                }).css({
	                                    opacity: 0.01,
	                                    width: 0
	                                });
	                        }, 15);
	                    } else {
	                        finishCount++;
	                        this._trigger('tokenremove', orgEvent, eventData); // No I18N
	                    }
	                    this._addTask(tokenData, index, 'remove'); // No I18N
	                }
	            });
	            if (startedCount === finishCount) {
	                this._afterTokensRemoval(orgEvent);
	            }
	            this._updateUndoRedoOp(orgEvent);
	        }
	    }
	    _afterTokensRemoval(orgEvent) {
	        this._CRUDEvent = orgEvent;
	        this._CRUDOper = true;
	        this._data.orgEvent = orgEvent;
	        this._render();
	        this._updateValToBeCopied(orgEvent);
	        this._updateLBSelections();
	    }
	    _preRender(data) {
	        let editField = this._editField;
	        data._queryForList = undefined;
	        if (this._CRUDEvent) {
	            this._showDrop = true;
	            let activeField = this._getActiveInput();
	            let retainText = this._opts.search.retainKeyword;
	            retainText = (this._opts.search.minKeywordLength && this._isCheckboxType ? (this._isNotNull(retainText) ? retainText : true) : retainText) && !this._opts.autoComplete && this._checkMaxLimit();
	            if (!retainText) {
	                this._resetInputField(activeField);
	            }
	            let activeFieldValue = activeField.val().trim();
	            if (editField) {
	                this._updateEditTokenData(activeFieldValue);
	            }
	            if (!this._closeOnSelect && this._isMenuShown()) {
	                if (!retainText) {
	                    data._queryForList = activeFieldValue;
	                }
	            } else {
	                this._showDrop = false;
	            }
	        }
	        this._data.rendered && this._saveSelectedTokens();
	        return data;
	    }
	    _saveSelectedTokens() {
	        this._selectedTokenIds = this._getSelected()
	            .toArray()
	            .map((token) => token.id);
	    }
	    _resetSelectedTokens() {
	        this._data.rendered && this._getTokenDOMs()
	            .toArray()
	            .forEach((token) => {
	                let selected = this._selectedTokenIds.indexOf(token.id) !== -1;
	                this._selectToken(token, selected);
	            });
	    }
	    _updateUndoRedoOp() {
	        if (this._taskCollector.length) {
	            if (this._undoTask) {
	                this._undidOps.push(this._taskCollector);
	            } else if (!this._redoTask) {
	                this._didOps.push(this._taskCollector);
	            }
	        }
	        this._taskCollector = false;
	    }
	    _addTask(tokenData, index, action) {
	        let data = {
	            data: tokenData.actualData,
	            tokenId: tokenData.tokenId
	        };
	        data.data.index = data.index = index;
	        data.action = action || 'create'; // No I18N
	        this._taskCollector.splice(0, 0, data);
	        // this._taskCollector.push(data);
	    }
	    _getPatternedContent(tokenData, restrictOnlyValidToken) {
	        if (tokenData.invalidToken) {
	            return !restrictOnlyValidToken && tokenData.errorValue;
	        }
	        let pattern = this._displayPattern;
	        return pattern
	            .replace(/#value#/g, this._mapJSONToData(tokenData, this._dataMapping.text))
	            .replace(/#id#/g, this._mapJSONToData(tokenData, this._dataMapping.id));
	    }
	    _parsePattern(text) {
	        let patternOpts = this._patternOpts;
	        let patternMatch = text.match(patternOpts.parsePattern);
	        if (patternMatch) {
	            let id, label;
	            if (patternOpts.idIndex) {
	                id = patternMatch[patternOpts.idIndex];
	            }
	            if (patternOpts.valueIndex) {
	                label = patternMatch[patternOpts.valueIndex];
	            }
	            return {
	                id,
	                label
	            }
	        }
	    }
	    // Function to update the value to be copied to immitate copy paste.
	    _updateValToBeCopied(orgEvent) {
	        if (!this._skipCpyFieldUpdate) {
	            let selectedTokens = this._getSelected().toArray();
	            let valueToBeCopied = [];
	            let lastSelectedToken;
	            if (selectedTokens.length) {
	                this._selected = [];
	                selectedTokens.forEach((token) => {
	                    this._selected.push(token.id);
	                    let tokenData = token.actualData;
	                    valueToBeCopied.push(this._getPatternedContent(tokenData));
	                });
	                if (this._lastSelectedToken && selectedTokens.indexOf(this._lastSelectedToken) > -1) {
	                    lastSelectedToken = this._lastSelectedToken;
	                }
	                this._cpyHelperField
	                    .val(valueToBeCopied.join(this._getFirstDelimiter()))
	                    .select();
	            } else if (!this._editField) {
	                !this._focussedOut && this._focusInput({
	                    event: orgEvent
	                });
	            }
	            this._lastSelectedToken = lastSelectedToken;
	        }
	    }
	    _adjustHeight() {
	        let currentHeight = this.container.css('height');	// No I18N
	        if (this._prevHeight && currentHeight !== this._prevHeight && this._isMenuShown()) {
	            this._listInstance.updatePosition();
	            /* let menuItems = this._menu.find(this._SELECTORS.li);
	            if (this._lastSelected || menuItems.length) {
	                let menuInstance = this._menuInstance;
	                menuInstance.show({
	                    mustBeShown: true,
	                    preventHover: true,
	                    positionAlterable: true
	                });
	                menuInstance.hoverMenuItem(this._lastSelected || $(menuItems[this._dataMapping.groupLabel ? 1 : 0]));
	            } */
	        }
	        this._prevHeight = currentHeight;
	    }
	    _onBeforeSearch(orgEvent, {
	        params
	    }) {
	        params.previousQuery = undefined;
	        this._repositioned = true;
	        return super._onBeforeSearch(...arguments);
	    }
	    _fixInput() {
	        let placeholder = this._data.tokens.length ? '' : this._opts.placeholder; // No I18N
	        this._input[0].placeholder = placeholder || ''; // No I18N
	        let activeInput = this._getActiveInput();
	        let textContent = activeInput === this._input ? (this._input.val() || placeholder) : activeInput.val(); // No I18N
	        let isContainerHidden = this.container.is(':hidden'); // No I18N
	        let insertAfter = this._input;
	        let tempDiv = $('<span>').attr({
	            'class': 'ztokenfield__textbox', // No I18N
	            style: 'position:absolute; visibility:hidden; width:auto;' // No I18N
	        }).text(textContent)
	        let elementToBeRemoved = tempDiv;
	        if (isContainerHidden) {
	            // This fix has been included if the tokenfield is initiated when the main container is hidden where calculating the width always returns 0.
	            elementToBeRemoved = this.container.clone().width('auto').appendTo('body'); // No I18N
	            insertAfter = elementToBeRemoved.find('input'); // No I18N
	        }
	        tempDiv.insertAfter(insertAfter);
	        let width = tempDiv.width() + 30;
	        activeInput[0].style.width = width + 'px'; // No I18N
	        elementToBeRemoved.remove();
	    }
	    _updateScrollTop(targetToken) {
	        targetToken = $(targetToken);
	        if (targetToken && targetToken.length) {
	            let tokenTop = targetToken.position().top;
	            let containerScrollTop = this.container[0].scrollTop;
	            if (tokenTop < 0) {
	                this.container.scrollTop(containerScrollTop + tokenTop);
	            } else {
	                let tokenHeight = targetToken.outerHeight();
	                let fullHt = tokenHeight + tokenTop + containerScrollTop;
	                let containerHeight = this.container.innerHeight() + containerScrollTop;
	                if (fullHt > containerHeight) {
	                    this.container.scrollTop(containerScrollTop + (fullHt - containerHeight));
	                }
	            }
	        }
	    }
	    _destroy() {
	        if (this._opts.tokens.sortable) {
	            this._destroySortable();
	        }
	        this._input.off('.' + this.name); // No I18N
	        this._listInstance.destroy();
	        clearTimeout(this._blurTimer);
	        clearTimeout(this._pasteTimer);
	        clearTimeout(this._removeTimer);
	        this._listInstance = this._input = this._cpyHelperField = undefined;
	    }
		_duplicateElement  (domElement) {
		    let duplicateDiv = $('<div>').css({
		        position: 'absolute', // No I18N
		        left: -9999,
		        top: 0,
		        zIndex: -20000
		    });
		    [ 'borderBottomWidth', // No I18N
		        'borderLeftWidth', // No I18N
		        'borderRightWidth', // No I18N
		        'borderTopStyle', // No I18N
		        'borderRightStyle', // No I18N
		        'borderBottomStyle', // No I18N
		        'borderLeftStyle', // No I18N
		        'borderTopWidth', // No I18N
		        'boxSizing', // No I18N
		        'fontFamily', // No I18N
		        'fontSize', // No I18N
		        'fontWeight', // No I18N
		        'height', // No I18N
		        'letterSpacing', // No I18N
		        'lineHeight', // No I18N
		        'marginBottom', // No I18N
		        'marginLeft', // No I18N
		        'marginRight', // No I18N
		        'marginTop', // No I18N
		        'outlineWidth', // No I18N
		        'overflow', // No I18N
		        'overflowX', // No I18N
		        'overflowY', // No I18N
		        'paddingBottom', // No I18N
		        'paddingLeft', // No I18N
		        'paddingRight', // No I18N
		        'paddingTop', // No I18N
		        'textAlign', // No I18N
		        'textOverflow', // No I18N
		        'textTransform', // No I18N
		        'whiteSpace', // No I18N
		        'wordBreak', // No I18N
		        'wordWrap', // No I18N
		        'height' ].forEach((prop) => duplicateDiv[0].style[prop] = window.getComputedStyle(domElement[0])[prop]);
		    return duplicateDiv;
		}
		_positionMenu  (reposition) {
		    if (this._menu && this._menu.is(':visible')) { // No I18N
		        if (reposition) {
		            this._listInstance.positionList();
		            this._repositioned = true;
		        }
		        if (this._repositioned) {
		            let inputField = this._input;
		            let carretPosition = this._positionInput(inputField);
		            if (carretPosition) {
		                let {
		                    top,
		                    left
		                } = this._menu[0].style;
		                let menuDir = this._menu.data('direction'); // No I18N
		                if (/^(top)/.test(menuDir)) {
		                    top = parseInt(top) + carretPosition.top;
		                } else if (/^(bottom)/.test(menuDir)) {
		                    top = parseInt(top) - inputField.outerHeight() + carretPosition.top + carretPosition.height;
		                }
		                left = parseInt(left) + carretPosition.left;
		                this._menu.css({
		                    top,
		                    left
		                });
		            }
		        }
		        this._repositioned = false;
		    }
		}
		_positionInput  (domElement) {
		    let startPos = domElement[0].value.slice(0, domElement[0].selectionStart),
		        spanElement,
		        spanRelativePosition,
		        elementWithCaret,
		        dimensions,
		        duplicateElement;
		    spanElement = '<span style="position: relative; display: inline-block;vertical-align:middle;">' + this._removeSpecialChar(startPos) + '</span>'; // No I18N
		    spanElement += '<span id=\'caret\' style=\'position: relative; display: inline-block;vertical-align:middle;\'>|</span>'; // No I18N
		    spanElement += '<span style=\'position: relative; display: inline-block;vertical-align:middle;height:100%\'></span>'; // No I18N
		    duplicateElement = this._duplicateElement(domElement);
		    elementWithCaret = duplicateElement
		        .html(spanElement)
		        .insertAfter(domElement)
		        .find('#caret'); // No I18N
		    spanRelativePosition = elementWithCaret.position();
		    dimensions = {
		        left: spanRelativePosition.left,
		        top: spanRelativePosition.top,
		        height: elementWithCaret.height()
		    }
		    duplicateElement.remove();
		    return dimensions;
		}
		_removeSpecialChar  (value) {
		    value = value.replace(/<|>|`|"|&/g, '?').replace(/\r\n|\r|\n/g, '<br/>'); // No I18N
		    if (ZC.Browser.isFirefox) {
		        value = value.replace(/\s/g, '&nbsp;'); // No I18N
		    }
		    return value;
		}
		_updateCheckedState  (tokenData) {
		    if (this._isCheckboxType) {
		        /* let selectedId = [];
		        this._data.tokens.forEach((tokenData) => {
		            if (!tokenData.editInput) {
		                let itemId = this._getItemId(tokenData.actualData, this._menuId);
		                if (selectedId.indexOf(itemId) < 0) {
		                    selectedId.push('#' + itemId); // No I18N
		                }
		            }
		        });
		        selectedId.length && this._menuInstance.setMenuItemsAttribute(selectedId, 'checked', true); // No I18N
		        */
		        this._ignoreChange = true;
		        this._listInstance.deselect(tokenData);
		        this._ignoreChange = false;
		    }
		}
		_beforeItemChecked  (ev, ui) {
		    if (!ui && ev) {
		        ui = ev.detail;
		    }
		    let opts = this._opts,
		        maxAllowed = opts.maxAllowedValues;
		    if (!ui.data.checked && maxAllowed && maxAllowed === opts.values.length) {	// No I18N
		        ev.preventDefault();
		        this._dispatchEvent('tokenaddfail', ev, { // No I18N
		            failureType: this._messages.limitReach
		        });
		    }
		}
		_getErrTokenData  (errorValue, orgEvent, index) {
		    errorValue = errorValue.trim();
		    if (errorValue) {
		        let errTokenData = {
		            invalidToken: true,
		            newToken: true,
		            errorValue: errorValue,
		            type: 'error', // No I18N
		            index
		        }
		        this._assignValue(errorValue, errTokenData, orgEvent, index);
		        this._input.val(''); // No I18N
		        return errTokenData;
		        // this._createToken(errTokenData, orgEvent, index);
		    }
		}
		_assignValue  (value, obj) {
		    [ 'id', 'text', 'titleText' ] // No I18N
		        .forEach((dataMappingKey) => this._getObj(dataMappingKey, value, obj));
		}
		hasInvalidTokens  () {
		    let values = this._opts.values;
		    if (this._opts.dataValidation) {
		        for (let i = 0; i < values.length; i++) {
		            if (values[i].type === 'error') {
		                return true;
		            }
		        }
		    }
		}
		_editHandler  (ev, tokenToBeEdited) {
		    let tokenOptions = this._opts.tokens;
		    tokenToBeEdited = tokenToBeEdited || ev.currentTarget;
		    if (!this._opts.disabled && tokenOptions.editable && this._isRemovableToken($(tokenToBeEdited))) {
		        let data = this._data;
		        let value;
		        let index = this._getTokenIndex(tokenToBeEdited.id);
		        let tokenData = tokenToBeEdited.actualData;
		        let editedData = this._tokenInEditMode = this._data.tokens[index];
		        value = this._getPatternedContent(tokenData);
		        editedData.index = index;
		        editedData.editText = value;
		        this._opts.values.splice(index, 1);
		        data.tokens.splice(index, 1, {
		            editInput: true
		        });
		        this._render();
		        // Removed because it is handled in postEachRender
		        // this._fixInput();
		        // Following is removed because as soon as when a token is doubleclicked, its value need not be copied.
		        // this._setPasteVal();
		        // if (matchFound) {
		        //     this._editInput.off('focus.' + this.name).on('focus.' + this.name, () => this.container.addClass('has-focus'));	// No I18N
		        // }
		    }
		}
		_updateEditTokenData  (editText) {
		    let tokenDatas = this._data.tokens;
		    let tokenInEditMode = this._tokenInEditMode;
		    for (let i = 0; i < tokenDatas.length; i++) {
		        if (tokenDatas[i].editInput) {
		            tokenInEditMode.index = i;
		            tokenInEditMode.editText = editText;
		            break;
		        }
		    }
		}
		// Function to validate edited text - it is validated by the user - not by us.
		_reformToken  (orgEvent) {
		    let editInput = this._editField;
		    if (editInput) {
		        let isESCKey = orgEvent && orgEvent.keyCode === ZC.keyCode.ESCAPE;
		        let editValue = editInput.val().trim();
		        let tokenDataInEditMode = this._tokenInEditMode;
		        let tokenData = tokenDataInEditMode.actualData;
		        let tokenIndex = tokenDataInEditMode.index;
		        this._removeEditInput(); // Respective edit properties are reset in this method.
		        if (isESCKey || tokenDataInEditMode.editText === editValue) {
		            return this._validateAndAddToken(tokenData, orgEvent, tokenIndex);
		        }
		        if (!editValue) {
		            return;
		        }
		        delete tokenData.invalidToken;
		        delete tokenData.type;
		        let data = {
		            textboxValue: editValue,
		            itemData: tokenData
		        };
		        this._dispatchEvent('tokenedit', orgEvent, data); // No I18N
		        this._fromEdit = true;
		        this._tokenInEditMode = tokenDataInEditMode;
		        this._processInputText(orgEvent, data.textboxValue, tokenIndex, tokenData);
		        this._fromEdit = this._tokenInEditMode = false;
		    }
		}
		_removeEditInput  () {
		    this._listInstance.setAttribute('searchField', this._input); // No I18N
		    this._tokenInEditMode = this._editField = false;
		    let tokenDatas = this._data.tokens;
		    for (let i = 0; i < tokenDatas.length; i++) {
		        if (tokenDatas[i].editInput) {
		            tokenDatas.splice(i, 1);
		            this._render();
		            break;
		        }
		    }
		}
		_getEditInputIndex  () {
		    let tokenDatas = this._data.tokens;
		    for (let i = 0; i < tokenDatas; i++) {
		        if (tokenDatas[i].editInput) {
		            return i;
		        }
		    }
		    return -1;
		}
		removeTokens  (value, ev) {
		    this._removeTokens(value, ev);
		}
		removeToken  (value, ev) {
		    this._removeTokens(value, ev);
		}
		removeAllTokens  () {
		    this._removeToken(this._getTokens());
		}
		addTokens  (values) {
		    if (values && values instanceof Array) {
		        values.forEach((value) => this.addToken(value));
		        this._updateLBSelections();
		    }
		}
		addToken  (value) {
		    if (value && !(value instanceof Array)) {
		        this._buildToken(value, undefined, true);
		        this._updateLBSelections();
		    }
		}
		setFocus  () {
		    this._focusInput({
		        from: 'method' // No I18N
		    });
		}
		selectAll  () {
		    if (this._listInstance.staticData) {
		        this.fetchData((response) => {
		            this.setAttribute('values', response.results); // No I18N
		        });
		    }
		}
		_setAttribute  (optionName, value) {
		    let callSuper = false,
		        opts = this._opts;
		    if (optionName === 'values') { // No I18N
		        this._data.tokens = [];
		        opts[optionName] = value;
		        this._setValues();
		        this._updateLBSelections();
		        this._domChanged = true;
		    } else {
		        opts[optionName] = value;
		       if (optionName === 'dataMapping' || optionName === 'rtl') { // No I18N
		            this._dataMapping = opts.dataMapping;
		            callSuper = true;
		        } else if (optionName === 'placeholder') {	// No I18N
		            this._fixInput();
		        } else if (optionName === 'tokens') {	// No I18N
		            this._updatePreDatas();
		            this._reInit = true;
		        } else if (optionName === 'dropdownList') { // No I18N
		            this._updatePreDatas();
		            callSuper = true;
		        } else{
		            callSuper = true;
		        }
		    }
		    if(callSuper) {
		        super._setAttribute(...arguments);
		    }
		}
		_disable  (value) {
		    let opts = this._opts;
		    let container = this.container;
		    let disabledClass = 'is-disabled'; // No I18N
		    if (value) {
		        container
		            .off('.' + this.name) // No I18N
		            .addClass(disabledClass);
		        this._input.off('.' + this.name); // No I18N
		    } else {
		        container.removeClass(disabledClass);
		        this._bindEvents();
		    }
		    this._input.attr('disabled', value); // No I18N
		    if (opts.tokens.sortable) {
		        this._initSortable();
		    }
		}
		_initSortable  () {
		    if (this._opts.tokens.sortable && !this._opts.disabled) {
		        if (this._isSortableSet()) {
		            ZC.sortable(this.container).refresh();
		        } else {
		            ZC.sortable(this.container, {
		                ignoreAsHandle: '.ztokenfield__close', // No I18N
		                region: 'parent', // No I18N
		                items: '> .ztokenfield__token', // No I18N
		                drag: () => this.closeDropdownList()
		            });
		        }
		    } else {
		        this._destroySortable();
		    }
		}
	}
	ZC.registerComponent('ZTokenfield', ZC.ZSuggestField, ZTokenfield); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.ztokenfield.Templates; 
template.WCContainer = (data) => ZT.html `<div>${data.children && template.WCChildren(data)}</div>`; 
template.WCChildren = (data) => { 
let responseHTML = ZT.html `${data.tokens.map((token) => ZT.html ` ${token.editInput ? ZT.html `<input type='text' id='${data.id}-edit-input' autocomplete=off class='ztokenfield__textbox ztokenfield__editinput' tabindex='0'/>` : ZT.html `<div class='ztokenfield__token ${token.removable ? '' : 'is-readonly'} ${token.invalidToken ? ' has-error' : ''}' tabindex='-1' id='${token.tokenId}' .actualData='${token.actualData}' ?style='${token.style}'> ${template.WCTokenContent(token)} ${token.removeButton && ZC.createButton(token.removeButton)} </div>`}`)} <input type='text' aria-haspopup='true' autocomplete=off role='textbox' aria-expanded='false' aria-owns='${data.id}-menu' id='${data.id}-input' autocomplete='off' tabindex='${data.tabindex}' class='ztokenfield__textbox' ?disabled='${data.disabled}'/> <input type='text' style='${data.pasteStyle}' autocomplete=off tabindex='-1' id='${data.id}-copy-helper' />`; return responseHTML; } 
template.WCTokenContent = function(data) { 
let responseHTML = data.customHTML ? ZT.html `${ZT.customHTML(data.customHTML || '')}` : ZT.html `${data.hasImage && (data.isSprite ? ZT.html `<i class='ztokenfield__image ${data.iconClassName}'></i>` : ZT.html `<img src='${data.image}' class='ztokenfield__image' />`)} ${ZT.html `<span class='ztokenfield__text' ?title='${data.titleText}'> ${data.text} </span>`}`; return responseHTML } }(ZComponents)); 
 (function(ZC){ 
let template = ZC.ztokenfield.Templates; 
template.container = (data) => ZT.html `<div>${data.children && template.children(data)}</div>`; 
template.children = (data) => { 
let responseHTML = ZT.html `${data.tokens.map((token) => ZT.html ` ${token.editInput ? ZT.html `<input type='text' id='${data.id}-edit-input' autocomplete=off class='ztokenfield__textbox ztokenfield__editinput' tabindex='0'/>` : ZT.html `<div class='ztokenfield__token ${token.removable ? '' : 'is-readonly'} ${token.invalidToken ? ' has-error' : ''}' tabindex='-1' id='${token.tokenId}' .actualData='${token.actualData}' ?style='${token.style}'> ${template.tokenContent(token)} ${token.removeButton && ZC.createButton(token.removeButton)} </div>`}`)} <input type='text' aria-haspopup='true' autocomplete=off role='textbox' aria-expanded='false' aria-owns='${data.id}-menu' id='${data.id}-input' autocomplete='off' tabindex='${data.tabindex}' class='ztokenfield__textbox' ?disabled='${data.disabled}'/> <input type='text' style='${data.pasteStyle}' autocomplete=off tabindex='-1' id='${data.id}-copy-helper' />`; return responseHTML; } 
template.tokenContent = function(data) { 
let responseHTML = data.customHTML ? ZT.html `${ZT.customHTML(data.customHTML || '')}` : ZT.html `${data.hasImage && (data.isSprite ? ZT.html `<i class='ztokenfield__image ${data.iconClassName}'></i>` : ZT.html `<img src='${data.image}' class='ztokenfield__image' />`)} ${ZT.html `<span class='ztokenfield__text' ?title='${data.titleText}'> ${data.text} </span>`}`; return responseHTML } }(ZComponents)); 
(function(ZC, $){
	class ZInputField extends ZC.CoreComponent {
			get name(){
				return "zinputfield";
			}
	    get attrs() {
	        return {
	            min: null,
	            max: null,
	            spinButtons: 'always', // No I18N
	            locale: null,
	            clearButton: 'focus', // No I18N
	            clearButtonSVGIconId: null,
	            clearButtonIconClass: null,
	            width: null,
	            value: null,
	            spinButtonsType: 'together', // No I18N
	            incrementButtonSVGIconId: null,
	            incrementButtonIconClass: null,
	            decrementButtonIconClass: null,
	            decrementButtonSVGIconId: null,
	            spinEventTriggerDelay: 0,
	            disabled: false,
	            readonly: false
	        }
	    }
	    get props() {
	        return {
	            incrementButtonIconClassName: null,
	            decrementButtonIconClassName: null,
	            clearButtonIconClassName: null,
	            labels: {
	                increment: 'Increment Value', // No I18N
	                decrement: 'Decrement Value', // No I18N
	                clear: 'Clear' // No I18N
	            }
	        }
	    }
	    get EVENTS() {
	        return [ 'focus', 'blur', 'change', 'spin', 'spinstart', 'spinend' ]; // No I18N
	    }
	    _init(element, opts) {
	        let isCE = this.isCE,
	            data = this._data,
	            optWidth = opts.width, // No I18N
	            title = element.attr('title'); // No I18N
	        title && !isCE && (opts.title = title);
	        if (optWidth === 'none') { // No I18N
	            opts.width = null; // needed because opts and data are merged in _render method
	        } else {
	            let width = parseInt(optWidth) || element.outerWidth(); // setting the element's width to the outer container.
	            data.width = width;
	            // if width was given by the user, need to set it to element
	            parseInt(width) && (data.style = 'width:' + data.width + 'px'); // No I18N
	        }
	        // assigning input element attributes
	        data.tabindex = element[0].getAttribute('tabindex') || 0; // No I18N
	        data.attrs = {
	            tabindex: -1 // No I18N
	        };
	        let fVal = 'none'; // No I18N
	        data.spinButtons = opts.spinButtons !== fVal;
	        if (data.spinButtons) {
	            this._getSpinBtnProps();
	        }
	        data.clearButton = opts.clearButton !== fVal;
	        if (data.clearButton) {
	            this._getClearBtnProps();
	        }
	        if (!isCE) {
	            data.id = this._getID(element) + '-container';
	        }
	        this._addedByComponent = this.isCE; // To avoid re-rendering of inner web component elements. But this fix doesn't work.
	    }
	    _postRender() {
	        let data = this._data,
	            opts = this._opts,
	            readonly = opts.readonly,
	            cls = (readonly || opts.disabled ? ' is-disabled' : '') + (readonly ? ' is-readonly' : ''); // No I18N
	        data.className += ' zinputfield ' + cls; // No I18N
	        this._input = this.container.find('.zinputfield__textbox'); // No I18N
	        opts.placeholder && this._input.attr('placeholder', opts.placeholder); // No I18N
	        this._addedByComponent = !this.isCE;
	    }
	    _postEachRender(ele, data = this._data) {
	        let modified = data.modifiedAttr,
	            opts = this._opts,
	            hasSpinBtn = data.spinButtons;
	        if (data.clearButton && (!modified || modified === 'clearButton')) { // No I18N
	            this._updateClearBtn();
	        }
	        if (!modified || [ 'spinButtons', 'spinButtonsOrientation' ].indexOf(modified) > -1) { // No I18N
	            if (hasSpinBtn) {
	                this._updateSpinButtons();
	            } else {
	                this._data.className += ' zinputfield--spinbtnnone'; // No I18N
	            }
	        }
	        if (modified && modified === 'spinButtonsType') { // No I18N
	            this._input = this.container.find('.zinputfield__textbox'); // No I18N
	            this._bindEvents(); // input element's position and events will be lost on this render.
	            this._updateSpinButtons();
	            this._setValue(this._opts.value);
	        }
	        if (hasSpinBtn && !data.isVertical && (!modified || modified.indexOf('spinButtons') === 0)) {
	            this._data.className += ' zinputfield--split'; // No I18N
	        }
	        if (data.clearButton && opts.clearButton === 'always' && (!modified || modified === 'clearButton')) { // No I18N
	            this._data.className += ' zinputfield--withclrbtn'; // No I18N
	            if (!opts.value || opts.readonly || opts.disabled) { // field remains empty or field is disabled
	                this._toggleBtnDisplay(true, true);
	            }
	        }
	        if (data.spinButtons || data.clearButton) {
	            this._bindContainerEvents();
	        }
	        // commenting the below code temporarily.
	        // if (data.modifiedAttr === 'spinButtonsOrientation' && this.isCE && this._buttons) {
	        //     this._buttons[0].$c._addedByComponent = false;
	        //     this._buttons[1].$c._addedByComponent = false;
	        // }
	        data.modifiedAttr = undefined;
	    }
	    // kept as common here because both clearButton and spinButton uses it
	    _toggleBtnDisplay(hide, isClear, both) { // toggle the visibility of the button
	        let elements = both ? this._clearButton.add(this._buttonPane) : (isClear ? this._clearButton : this._buttonPane);
	        elements[hide ? 'addClass' : 'removeClass']('zh-dnone'); // No I18N
	    }
	    _bindContainerEvents() { // ##revisit - Try to reuse in datefield
	        this._addEvents({
	            containerHover: 'mouseenter mouseleave', // No I18N
	            containerFocusIn: 'focusin' // No I18N
	        });
	    }
	    _containerHoverHandler(event) {
	        let opts = this._opts,
	            data = this._data;
	        if (!opts.readonly && !opts.disabled) {
	            let isEnter = event.type === 'mouseenter', // No I18N
	                hasFocus = !isEnter && this.container.hasClass('has-focus'), // No I18N
	                opts = this._opts,
	                hasClearBtn = data.clearButton && opts.clearButton === 'focus', // No I18N
	                hasSpinBtn = data.spinButtons && opts.spinButtons === 'focus', // No I18N
	                clrMod = 'zinputfield--withclrbtn', // No I18N
	                spinMod = 'zinputfield--spinbtnonfocus'; // No I18N
	            if ((hasClearBtn || hasSpinBtn) && this._input.val().length && !hasFocus) {
	                if (isEnter) {
	                    this._data.className += (hasClearBtn ? ' ' + clrMod : '') + (hasSpinBtn ? ' ' + spinMod : ''); // No I18N
	                } else {
	                    this._updateClass('', (hasClearBtn ? clrMod : '') + (hasSpinBtn ? (hasClearBtn ? '|' : '') + spinMod : '')); // No I18N
	                }
	                this._toggleBtnDisplay(!isEnter, hasClearBtn, hasClearBtn && hasSpinBtn, event.type);
	            }
	        }
	    }
	    _containerFocusInHandler(event) {
	        event.stopPropagation();
	    }
	    /* Method is provided because input element's outerWidth will be 0 if it's parent was hidden while initializing the component.
	       This method is applicable to normal JS component alone. */
	    resetWidth() {
	        if (!this.isCE) {
	            this.container.outerWidth(this.element.outerWidth());
	        }
	    }
	    // kept as common here because both clearButton and spinButton uses it
	    _getBtnProps(buttonType, defaultSVGId, clsName, mainEle) {
	        let opts = this._opts,
	            label = this._getI18NText(buttonType);
	        return ZC.ZButton.getBtnProps({
	            className: clsName,
	            templateRender: true,
	            defaultIconClassName: 'zinputfield__icon', // No I18N
	            iconClassName: opts[buttonType + 'ButtonIconClass'] || opts[buttonType + 'ButtonIconClassName'], // No I18N
	            SVGIconId: opts[buttonType + 'ButtonSVGIconId'], // No I18N
	            defaultSVGIconId: defaultSVGId + ' zbutton__svg zinputfield__svg', // No I18N
	            // isCE: this.isCE,
	            // mainElement: mainEle,
	            customAttributes: {
	                tabindex: -1, // tabindex is set to avoid keyboard navigation to those buttons
	                'aria-label': label, // No I18N
	                title: label
	            }
	        });
	    }
	    _destroy() {
	        let cName = this.name;
	        this._input.off(`.${cName}`);
	        this._input = this._clearButton = this._buttons = this._buttonPane = undefined;
	        if (this.isCE) {
	            this.element.removeClass(this._data.className).empty();
	        }
	        ZC.$document.off(`.${cName}`);
	    }
		_getClearBtnProps  () {
		    this._data.clearButtonProps = this._getBtnProps('clear', 'zc__svg--clear', 'zinputfield__clearbutton', this._clearButton && this._clearButton[0]); // No I18N
		}
		_updateClearBtn  () {
		    let clearEle = this._clearButton = this.container.find('.zinputfield__clearbutton'), // No I18N
		        clearProps = this._data.clearButtonProps;
		    if (this._opts.clearButton === 'focus') { // No I18N
		        this._toggleBtnDisplay(true, true);
		    }
		    clearProps.mainElement = clearEle[0];
		    clearEle.attr(clearProps.attrs);
		    this._bindClearBtnEvents();
		}
		_bindClearBtnEvents  () {
		    let clearButton = this._clearButton;
		    this._addEvents({
		        cBtnMouse: 'mousedown mouseup', // No I18N
		        cBtnClick: 'click' // No I18N
		    }, clearButton);
		}
		_cBtnMouseHandler  (event) {
		    this._mouseDown = event.type === 'mousedown'; // No I18N
		}
		_cBtnClickHandler  () {
		    let opts = this._opts;
		    if (opts.disabled || opts.readonly) {
		        return;
		    }
		    // focus is set because in firefox browser, focus is not retained after clearing the value.
		    opts._lastValue = opts.value;
		    this._input.val('').focus(); // No I18N
		    this._toggleBtnDisplay(true, true);
		}
		_handleClearBtn  (optionName, value, opts) { // optionName can be clearButton, clearButtonIconClassName, clearButtonIconClass, clearButtonSVGIconId
		    let data = this._data;
		    opts[optionName] = value;
		    data.clearButton = opts.clearButton !== 'none'; // No I18N
		    if (data.clearButton) {
		        this._getClearBtnProps();
		        if (optionName === 'clearButton') { // No I18N
		            data.modifiedAttr = optionName;
		        }
		    } else { // remove the clear button
		        this._updateClass('', 'zinputfield--withclrbtn'); // No I18N
		        this._clearButton = undefined;
		    }
		}
		_setAttribute  (optionName, value) {
		    let container = this.container,
		        opts = this._opts,
		        inputEle = this._input;
		    if (optionName === 'title') { // No I18N
		        container[0].setAttribute('title', value); // No I18N
		    } else if(optionName === 'placeholder'){ // No I18N
		        inputEle.attr("placeholder", value); // No I18N
		    }else if (optionName === 'width') { // No I18N
		        container.outerWidth(value);
		    } else if (optionName === 'maxLength') { // No I18N
		        inputEle[value ? 'attr' : 'removeAttr']('maxlength', value); // No I18N
		    } else if (optionName.indexOf('clearButton') > -1) { // No I18N
		        this._domChanged = true;
		        this._handleClearBtn(optionName, value, opts);
		    } else if (/incrementButton|decrement|spinButtons/g.test(optionName)) { // if increment alone is used, incrementOnWrapAround also falls into the condition
		        this._domChanged = true;
		        this._handleSpinBtns(optionName, value, opts);
		    } else if (optionName === 'readonly') { // No I18N
		        let rCls ='is-readonly is-disabled'; // No I18N
		        this._updateClass(value ? rCls : '', value ? '' : '(is-readonly'+(opts.disabled ? '' : '|is-disabled')+')'); // No I18N
		        if (value) {
		            inputEle.attr({
		                readonly: true,
		                'aria-readonly': true // No I18N
		            })
		        } else {
		            inputEle.removeAttr('readonly aria-readonly'); // No I18N
		        }
		    } else if(optionName === 'required'){ // No I18N
		        let val = this._opts.value;
		        if(!val){
		            this._setInitialValue();
		        }
		    }
		}
		_disable  (disable) {
		    super._disable(disable, undefined, !disable && this._opts.readonly);
		    let inputEle = this._input;
		    if (disable) {
		        inputEle.attr({
		            disabled: true,
		            'aria-disabled': true // No I18N
		        });
		    } else{
		        inputEle.removeAttr('disabled aria-disabled'); // No I18N
		    }
		}
		_getSpinBtnProps  () {
		    let data = this._data,
		        opts = this._opts,
		        orientation = opts.spinButtonsOrientation || opts.spinButtonsType,
		        UpProps, downProps,
		        getBtnProps = this._getBtnProps.bind(this),
		        getSpinIconInfo = this._getSpinIconInfo.bind(this);
		    data.isVertical = orientation === 'vertical' || orientation === 'together'; // No I18N
		    data.attrs.role = 'spinbutton'; // No I18N
		    UpProps = getSpinIconInfo('increment', data.isVertical); // No I18N
		    downProps = getSpinIconInfo('decrement', data.isVertical); // No I18N
		    data.incrementProps = getBtnProps('increment', UpProps[0], UpProps[1], this._buttons && this._buttons[0]); // No I18N
		    data.decrementProps = getBtnProps('decrement', downProps[0], downProps[1], this._buttons && this._buttons[1]); // No I18N
		}
		_getSpinIconInfo  (button, isVertical) {
		    let svgId = 'zc__svg--' + (isVertical ? '' : 'horizontal') + button + (isVertical ? '' : ' zh-arrowicon'), // No I18N
		        clsName = 'zinputfield__spinbutton' + (button === 'increment' ? ' zh-up' : ' zh-down'); // No I18N
		    return [ svgId, clsName ];
		}
		_updateSpinButtons  () {
		    let opts = this._opts,
		        value = opts.spinButtons,
		        container = this.container, // No I18N
		        isFocus = value === 'focus', // No I18N
		        data = this._data; // No I18N
		    this._buttonPane = container.find('.zinputfield__spinbuttonpane'); // No I18N
		    this._buttons = container.find('.zinputfield__spinbutton'); // No I18N
		    let index = +data.isVertical,
		        elem;
		    elem = data.incrementProps.mainElement = this._buttons[+(!index)];
		    $(elem).attr(data.incrementProps.attrs);
		    elem = data.decrementProps.mainElement = this._buttons[index];
		    $(elem).attr(data.decrementProps.attrs);
		    this._toggleBtnDisplay(isFocus && true);
		    this._bindSpinButtonEvents();
		}
		_handleSpinBtns  (optionName, value, opts) {
		    let data = this._data;
		    opts[optionName] = value;
		    if (optionName === 'spinButtonsType' && opts.spinButtons === 'focus') { // No I18N
		        opts.spinButtons = 'always'; // No I18N
		    }
		    data.spinButtons = value = opts.spinButtons !== 'none'; // No I18N
		    this._updateClass('', 'zinputfield--split|zdatetimefield|zdatetimefield--buttonsonhover|zinputfield--spinbtnonfocus|zinputfield--spinbtnnone'); // No I18N
		    if ([ 'spinButtons', 'spinButtonsType', 'spinButtonsOrientation' ].indexOf(optionName) > -1) { // No I18N
		        data.modifiedAttr = optionName;
		    }
		    if (value) {
		        this._getSpinBtnProps();
		        /* commenting temporarily since z-numberfield will render button tags only instead of z-button
		        let up, down;
		        if (this._buttons) {
		            up = this._buttons[0];
		            down = this._buttons[1];
		        }
		        if (this.isCE && up && down) {
		            up.$c._addedByComponent = true;
		            down.$c._addedByComponent = true;
		        }
		        */
		    } else { // remove the spin buttons
		        this._buttons = this._buttonPane = undefined;
		    }
		}
	}
	ZC.registerComponent('ZInputField', ZInputField); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zinputfield.Templates, button = ZC.zbutton.Templates.WCContainer; 
template.WCContainer = (data) => ZT.html `<div class="zinputfield ${data.className}" ?title=${data.title} tabindex="-1" role="spinbutton" ?style="${data.style}" ?id=${data.id} >${data.children && template.WCChildren(data)}</div>`; 
template.WCChildren = (data) => ZT.html `<input class='zinputfield__textbox' tabindex="${data.tabindex}" ?aria-valuemin=${data.min} ?aria-valuemax=${data.max} ?readonly=${data.readonly} ?aria-readonly=${data.readonly} ?disabled=${data.disabled} ?aria-disabled=${data.disabled} ?maxlength=${data.maxLength}> ${data.clearButton && button(data.clearButtonProps)} ${data.spinButtons && ZT.html `<div class="zinputfield__spinbuttonpane"> ${data.isVertical ? button(data.incrementProps) : button(data.decrementProps)} ${data.isVertical ? button(data.decrementProps) : button(data.incrementProps)} </div>`}`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zinputfield.Templates, button = ZC.zbutton.Templates.container; 
template.container = (data) => ZT.html `<div class="zinputfield ${data.className}" ?title=${data.title} tabindex="-1" role="spinbutton" ?style="${data.style}" ?id=${data.id} >${data.children && template.children(data)}</div>`; 
template.children = (data) => ZT.html `<input class='zinputfield__textbox' tabindex="${data.tabindex}" ?aria-valuemin=${data.min} ?aria-valuemax=${data.max} ?readonly=${data.readonly} ?aria-readonly=${data.readonly} ?disabled=${data.disabled} ?aria-disabled=${data.disabled} ?maxlength=${data.maxLength}> ${data.clearButton && button(data.clearButtonProps)} ${data.spinButtons && ZT.html `<div class="zinputfield__spinbuttonpane"> ${data.isVertical ? button(data.incrementProps) : button(data.decrementProps)} ${data.isVertical ? button(data.decrementProps) : button(data.incrementProps)} </div>`}`; }(ZComponents)); 
(function(ZC, $){
	/*
	_prevKUTime - Previous Key Up Time.
	_currKUTime - Current Key Up Time.
	_currKDTime - Current Key Down Time.
	_prevKDTime - Previous Key Down Time.
	_kuTimer - Key Up Timer
	_muTimer - Mouse Up Timer
	_sTimer - Spin Timer
	_changeDisVal - Change Event dispatched value.
	_mwTimer - Mouse Wheel Timer
	*/
	class ZNumberField extends ZC.ZInputField {
			get name(){
				return "znumberfield";
			}
	    get attrs() {
	        return {
	            step: 1,
	            placeholder: '', // No I18N
	            required: false,
	            spinValues: true,
	            wrapAround: false,
	            thousandSeparator: ',',
	            allowNegativeValue: false,
	            showThousandSeparator: false,
	            decimalPlaces: null,
	            prefix: null, // No I18N
	            suffix: null, // No I18N
	            longStep: null,
	            nullValue: 0,
	            decimalSeparator: '.', // No I18N
	            stepBehavior: 'default', // No I18N
	            suppressThousandSeparatorKey: false,
	            decimalsForWholeNumber: true,
	            innerHTML: null,
	            // below are added for writer spec needs
	            isWriter: false,
	            triggerBlurOnSpinButtonClick: false,
	            spinEventTriggerDelay: 0,
	            bindedSpinAndChange: false,
	            blurEventDelay: 500
	        }
	    }
	    get EVENTS() {
	        return [ 'focus', 'blur', 'change', 'input', 'spin', 'spinstart', 'spinend', 'optionschanged' ]; // No I18N
	    }
	    get escapeSequence() {
	        return /[[\]{}()*+?\\^$|#]/g;
	    }
	    get _mac() {
	        return ZC.OS.isMac();
	    }
	    _init(ele, opts) {
	        super._init(ele, opts);
	        let numericAttrs = [ 'min', 'max', 'step', 'value', 'disabled', 'readonly' ], // No I18N
	            aName, aValue;
	        for (let i = 0; i < 6; i++) {
	            aName = numericAttrs[i]; // attributes present in the elements will be given preference.
	            aValue = ele.attr(aName) || opts[aName];
	            opts[aName] = i < 3 ? parseFloat(aValue) : aValue; // parsefloat to boolean attributes avoided.
	        }
	        this._validateOpts(this._opts);
	        if (opts.decimalPlaces || opts.showThousandSeparator) {
	            this._setSeparatorValues();
	            if (opts.value) {
	                opts.value = this._removeSeparators(opts.value + ''); // No I18N
	            }
	        }
	        opts.value = parseFloat(opts.value);
	        this._factor = opts.stepBehavior === 'w3' ? this._getFactorValue() : 1; // No I18N
	        this._hasAffix = (opts.prefix || opts.suffix || '').trim().length; // No I18N
	        opts.templateName = 'zinputfield'; // No I18N
	        if (this._data.spinButtons) { // No I18N
	            this._validateSBtnOpts(opts);
	        }
	    }
	    _validateOpts(opts = this._opts) {
	        // Revisit - Remove destructuring. It does not have proper browser support.
	        let {
	                min, max, step, decimalPlaces, longStep
	            } = opts,
	            isNotNull = this._isNotNull.bind(this);
	        if (!isNotNull(min)) { // minValue might be zero. So having all the checks.
	            min = opts.allowNegativeValue ? undefined : 0;
	        }
	        if (!isNotNull(max) || max < min) {
	            max = undefined;
	        }
	        if (!step || step <= 0) { // zero or negative value might be provided
	            step = 1;
	        } else if (step > (max - min)) {
	            step = max - min;
	        }
	        // check whether the number is a floating point number or integer.
	        let isMinFloat = Number(min) === min && min % 1 !== 0,
	            isMaxFloat = Number(max) === max && max % 1 !== 0,
	            isStepFloat = Number(step) === step && step % 1 !== 0;
	        if (isMinFloat || isMaxFloat || isStepFloat) {
	            this._hasFloatingNumber = true;
	        }
	        if (decimalPlaces < 0 || decimalPlaces > 20) {
	            decimalPlaces = 0;
	        }
	        if (!longStep && isNotNull(max) && isNotNull(min)) {
	            let dStep = 2 * step;
	            longStep = dStep > max ? (dStep) / (max - min) : (dStep);
	        }
	        opts.min = min;
	        opts.max = max;
	        opts.step = step;
	        opts.decimalPlaces = decimalPlaces;
	        opts.longStep = longStep;
	        let arr = [ 'min', 'max', 'readonly', 'disabled', 'spinButtonsType', 'maxLength' ], // No I18N
	            prop;
	        for (let j = 0; j < 6; j++) {
	            prop = arr[j];
	            this._data[prop] = opts[prop];
	        }
	        this._dispatchEvent('optionschanged', {}); // No I18N
	    }
	    _postEachRender(ele, data) {
	        let modAttr = data.modifiedAttr;
	        super._postEachRender(...arguments);
	        if (data.spinButtons && (modAttr === 'spinButtonsType' || modAttr === 'spinButtons')) { // No I18N
	            this._toggleSpinBtnStates();
	        }
	        if (!this._data.rendered) {
	            this._setInitialValue();
	        }
	    }
	    _toggleBtnDisplay(hide, isClear, both) { // overrided
	        let clrBtn = this._clearButton,
	            spinBtn = (this._opts.spinButtonsType === 'split' ? this._buttons : this._buttonPane), // No I18N
	            elements = both ? clrBtn.add(spinBtn) : (isClear ? clrBtn : spinBtn);
	        elements[hide ? 'addClass' : 'removeClass']('zh-dnone'); // No I18N
	    }
	    _setInitialValue() {
	        let opts = this._opts,
	            inputValue = opts.value,
	            spinBtns = this._data.spinButtons,
	            clrBtn = opts.clearButton === 'always'; // No I18N
	        if (isNaN(inputValue) && !opts.required) {
	            this._input.val(''); // No I18N
	            spinBtns && this._toggleSpinBtnStates();
	            clrBtn && this._toggleBtnDisplay(true, true); // No I18N
	            return;
	        }
	        if (inputValue && !inputValue + ''.match('[0-9]')) { // No I18N
	            inputValue = isNaN(inputValue) ? opts.min : this._checkMinAndMax(inputValue);
	        }
	        this._setValue(inputValue);
	        spinBtns && this._toggleSpinBtnStates(); // No I18N
	        clrBtn && this._toggleBtnDisplay(false, true); // No I18N
	        opts.previousValue = this._changeDisVal = opts.value;
	    }
	    _checkMinAndMax(value) {
	        let opts = this._opts;
	        if (!this._isNotNull(value) || isNaN(value)) {
	            return opts.min || 0;
	        }
	        value = parseFloat(value);
	        value = (value < opts.min) ? opts.min : ((value > opts.max) ? opts.max : value);
	        return value;
	    }
	    _bindEvents() {
	        this._bindSpinEvents();
	        this._addEvents({
	            inputEleFocus: 'focus', // No I18N
	            inputEleBlur: 'blur', // No I18N
	            inputEleClick: 'click', // No I18N
	            inputEleChange: 'change', // No I18N
	            inputEleKey: ZC.Browser.isIE && ZC.Browser.getIEVersion() === 9 ? 'keyup' : 'input' // No I18N
	        }, this._input);
	        if (this.isCE) { /* Native INPUT event is triggered for custom element. So preventing its propagation here since we will throw custom INPUT event on keyup. */
	            this._bindCEInputEvents();
	        }
	        if (ZC.Browser.isSafari) { // safari will not retain focus on buttons. Active element will be container always.
	            this._addEvents({
	                containerBlur: 'blur' // No I18N
	            });
	        }
	    }
	    _containerBlurHandler(event) {
	        let orgEve = event.originalEvent,
	            container = this.container;
	        if (orgEve && $(orgEve.relatedTarget).closest('.zinputfield')[0] !== container[0]) {
	            container.find('.zh-up').trigger('blur'); // No I18N
	        }
	    }
	    _inputEleFocusHandler(event) {
	        let opts = this._opts;
	        if (opts.disabled || opts.readonly) {
	            // Firefox allows placing cursor in read-only text-boxes. Fixing this will disallow selecting the text on double click. So code is commented.
	            // if(ZC.Browser.isFirefox){
	            //     this._input.blur();
	            // }
	            return false;
	        }
	        if (this._hasAffix) { // removing the prefix/suffix will be handled here
	            this._handleInputFocus();
	        }
	        this.container.addClass('has-focus');
	        let fval = 'focus'; // No I18N
	        opts.clearButton === fval && this._toggleBtnDisplay(!this._input.val().length, true); // No I18N
	        if (!this._mouseDown) { // element will be focused on each spin button click also.
	            this._triggerEvent(fval, event); // No I18N
	        }
	        if (opts.spinButtons === fval) { // No I18N
	            this._toggleBtnDisplay();
	        }
	    }
	    _inputEleBlurHandler(event) {
	        let relTarget = event.relatedTarget && $(event.relatedTarget),
	            closestNumField = relTarget && relTarget.closest('.zinputfield'); // No I18N
	        // checking whether blur event is triggered by clicking within the same numberfield or not.
	        if (this._mouseDown || (relTarget && closestNumField.length && closestNumField[0] === this.container[0])) {
	            return;
	        }
	        this.container.removeClass('has-focus');
	        let retVal = this._validateFieldValue();
	        if (retVal === false) {
	            if (this._opts.value !== '') { // No I18N
	                this._triggerEvent('change', event); // No I18N
	            }
	            this._triggerEvent('blur', event); // No I18N
	            return;
	        }
	        let opts = this._opts;
	        // change eve might have triggered on ENTER.
	        if (this._changeDisVal === undefined || parseFloat(this._changeDisVal) !== parseFloat(opts.value)) { // Change event will be triggered from this method.
	            this._triggerEvent('change', event); // No I18N
	            this._changeDisVal = opts.value;
	        }
	        if ((!opts.isWriter || !this._handleInputBlur()) && !this._mouseDown) { // _handleInputBlur - writer spec
	            this._triggerEvent('blur', event); // No I18N
	        }
	        let data = this._data; // hiding spin/clear buttons
	        if (data.spinButtons) {
	            this._toggleSpinBtnStates();
	        }
	        let clrBtn = opts.clearButton,
	            hasClr = clrBtn === 'focus', // No I18N
	            hasSpin = opts.spinButtons === 'focus'; // No I18N
	        if (hasClr || hasSpin) {
	            this._toggleBtnDisplay(true, hasClr, hasClr && hasSpin);
	        } else if (clrBtn === 'always') { // No I18N
	            this._toggleBtnDisplay(false, true);
	        }
	        this._clearTimers();
	    }
	    _validateFieldValue() {
	        let opts = this._opts,
	            value = this._input.val();
	        if (value === '' && !opts.required) { // No I18N
	            return false;
	        }
	        let reg = /^[- . 0-9 e]+$/,
	            valChanged = false;
	        value = this._extractNumericValue(value);
	        let parsedVal = parseFloat(value);
	        if (isNaN(parsedVal) || !reg.test(value)) {
	            valChanged = true;
	            parsedVal = parseFloat(opts._lastValue);
	        } else {
	            let checkedValue = this._checkMinAndMax(value);
	            if (checkedValue !== parsedVal) {
	                valChanged = true;
	                opts._lastValue = parsedVal = checkedValue;
	            }
	        }
	        if (opts.value !== parsedVal) {
	            valChanged = true;
	        }
	        this._setValue(valChanged ? parsedVal : opts.value); // updating the value here since prefix and suffix values might be omitted while editing.
	    }
	    _inputEleClickHandler() {
	        let opts = this._opts;
	        if (!opts.readonly && !opts.disabled && this._hasAffix) {
	            this._input.select();
	        }
	    }
	    _inputEleChangeHandler(event) {
	        event.stopPropagation(); // preventing the change event since we provide custom change event on blur after performing validations.
	    }
	    _inputEleKeyHandler() {
	        // translate the characters while typing itself because if handled in keyup, translation is visible in the UI.
	        this._input.val(this._translateEToA(this._input.val()));
	    }
	    _bindSpinEvents() { // executed only if spinValues is true
	        if (this._opts.spinButtons !== 'none' || this._opts.spinValues) { // No I18N
	            this._addEvents({
	                inputEleMouseWheel: 'mousewheel DOMMouseScroll MozMousePixelScroll' // No I18N
	            }, this._input);
	        }
	        this._addEvents({
	            inputEleKeyDown: 'keydown', // No I18N
	            inputEleKeyUp: 'keyup' // No I18N
	        }, this._input);
	    }
	    _unbindSpinEvents() {
	        this._removeEvents('mousewheel DOMMouseScroll MozMousePixelScroll', this._input); // No I18N
	    }
	    _inputEleKeyDownHandler(event) {
	        let opts = this._opts;
	        if (opts.disabled || opts.readonly) {
	            return false;
	        }
	        let key = ZC.keyCode,
	            code = event.keyCode;
	        if (code !== key.ESCAPE) {
	            window.clearTimeout(this._mwTimer);
	            this._prevKDTime = this._currKDTime;
	            this._currKDTime = new Date().getTime();
	            let longPress = false;
	            if (this._prevKDTime && this._currKDTime && (this._currKDTime - this._prevKDTime) < 600) {
	                longPress = true;
	            }
	            let allowSpinning = this._data.spinButtons || opts.spinValues, // No I18N
	                dontStop = true;
	            switch (code) {
	                case key.UP:
	                case key.DOWN:
	                    dontStop = false;
	                    if (allowSpinning) {
	                        !longPress && (!this._currKUTime || !this._prevKUTime || this._currKUTime - this._prevKUTime > 600) && this._triggerEvent('spinstart', event); // No I18N
	                        this._spinValue(code === key.UP, event.shiftKey, undefined); // event.ctrlKey || event.metaKey
	                    }
	                    break;
	                case key.PAGE_UP: // alternate keys ( Function + Alt + Up)
	                case key.PAGE_DOWN: // alternate keys ( Function + Alt + DOWN)
	                    allowSpinning && this._setValue(opts[code === key.PAGE_UP ? 'max' : 'min']); // No I18N
	                    break;
	                case key.ENTER:
	                    clearTimeout(this._sTimer);
	                    this._changeDisVal = opts.value;
	                    this._setValue(this._input.val()); // invoked this method here inorder to perform min-max validations.
	                    this._triggerEvent('change', {}); // No I18N
	                    opts.isWriter && this._handleEnterKey();
	                    break;
	            }
	            this._shortcutKey = event.ctrlKey || event.metaKey;
	            let eveRes = this._handleKeyDown(event);
	            if (dontStop) {
	                dontStop = eveRes;
	            }
	            return dontStop;
	        }
	    }
	    _inputEleKeyUpHandler(event) {
	        let opts = this._opts;
	        if (opts.disabled || opts.readonly) {
	            return false;
	        }
	        let key = ZC.keyCode,
	            code = event.keyCode,
	            isUpDown = code === key.UP || code === key.DOWN;
	        if (isUpDown) { // Continuous key up and down is tracking inorder to trigger spin-end event at the last keyup.
	            this._prevKUTime = this._currKUTime;
	            this._currKUTime = +(new Date());
	            if (this._prevKUTime !== undefined && ((this._currKUTime - this._prevKUTime) < 600)) {
	                window.clearInterval(this._kuTimer);
	                this._kuTimer = window.setInterval(() => {
	                    this._currKUTime = +(new Date());
	                    if (this._currKUTime - this._prevKUTime > 600) {
	                        (!opts.isWriter || this._canTriggerSEnd(opts)) && this._triggerSpinEndEvent(event);
	                        window.clearInterval(this._kuTimer);
	                        // Revisit - These undefined are done too often. Store in a function and set undefined
	                        this._prevKDTime = this._prevKUTime = this._currKUTime = this._currKDTime = this._kuTimer = undefined;
	                    }
	                }, 200);
	                return;
	            }
	        } else {
	            this._prevKUTime = this._currKUTime = undefined;
	        }
	        if (isUpDown && (!opts.isWriter || this._canTriggerSEnd(opts))) {
	            this._triggerSpinEndEvent(event);
	        }
	        this._prevKDTime = this._currKDTime = undefined;
	        return this._handleKeyUp(event); // selection start and selection end setting removed.
	    }
	    _inputEleMouseWheelHandler(event) {
	        let opts = this._opts;
	        if (opts.disabled || opts.readonly || !this.container.hasClass('has-focus')) {
	            return false;
	        }
	        if (!this._mwTimer) {
	            this._triggerEvent('spinstart', event); // No I18N
	        }
	        let orgEve = event.originalEvent,
	            detail = orgEve.detail;
	        this._spinValue(detail === 0 ? orgEve.wheelDelta < 0 : detail > 0, event.shiftKey); // event.ctrlKey || event.metaKey
	        clearTimeout(this._mwTimer);
	        this._mwTimer = setTimeout(() => {
	            this._triggerSpinEndEvent(event);
	            clearTimeout(this._mwTimer);
	            this._mwTimer = undefined;
	        }, 600);
	        return false;
	    }
	    _extractNumericValue(value, doNotReplaceSeparators) {
	        value = this._translateAToE(value + ''); // No I18N
	        let opts = this._opts;
	        if (this._hasAffix) {
	            value = this._removeAffixes(value);
	        }
	        if (opts.showThousandSeparator || opts.decimalPlaces) {
	            value = this._removeSeparators(value, doNotReplaceSeparators);
	        }
	        return value.trim();
	    }
	    _handleKeyDown(event) {
	        let opts = this._opts;
	        if (this._checkPatternKeys(event)) {
	            let inputEle = this._input,
	                fieldVal = inputEle.val(),
	                val = this._extractNumericValue(fieldVal),
	                selStart = inputEle[0].selectionStart,
	                selEnd = inputEle[0].selectionEnd,
	                code = event.keyCode;
	            if (code === 8) { // delete key
	                val = val.substr(0, selStart - 1);
	            } else {
	                val = val.substr(0, selStart) + String.fromCharCode(event.keyCode) + val.substr(selEnd, fieldVal.length);
	            }
	            val = parseFloat(val);
	            if (!isNaN(val) && val > opts.max && inputEle[0].selectionStart === selEnd) {
	                event.preventDefault(); // prevent entering a value in the field if entered value will be greater than maximum value.
	            } else if (val >= opts.min) {
	                // minimum value check is added since value is updated with wrong value if fieldValue is lesser than min value.
	                opts.value = val;
	            }
	            this._data.spinButtons && this._toggleSpinBtnStates(); // No I18N
	        } else {
	            return this._handleShortcutKeys(event);
	        }
	    }
	    _handleKeyUp(event) {
	        let retValue = true,
	            key = ZC.keyCode;
	        if (this._checkPatternKeys(event)) { // input event should be triggered on keyup only.
	            this._triggerEvent('input', event); // No I18N
	        } else {
	            retValue = this._handleShortcutKeys(event); // shortcut key handling is moved to keyup event since pasted value cannot be retrieved in keydown event.
	            if (!event.ctrlKey && !event.metaKey) {
	                this._shortcutKey = false;
	            }
	        }
	        let inputEle = this._input,
	            val = inputEle.val();
	        if (this._data.clearButton) {
	            this._toggleBtnDisplay(!val.length, true);
	        }
	        if (event.keyCode === key.SPACE && val.trim() === '') { // No I18N
	            inputEle.val(''); // No I18N
	        }
	        return retValue; // value is returned to avoid stopEvent from being called from handleshortcutkeys method.
	    }
	    _triggerSpinEndEvent(event) {
	        this._opts.isWriter && this._handleSpinEnd();
	        this._triggerEvent('spinend', event); // No I18N
	    }
	    _triggerEvent(eventName, originalEvent = {}) {
	        let value = this._input.val(),
	            ui = {
	                value: value === '' ? (this._opts.required ? (this._opts.min || null) : '') : parseFloat(this._extractNumericValue(value)), // No I18N
	                translatedValue: this._translateEToA(value), // No I18N
	                event: originalEvent // No I18N
	            };
	        ui[this.name.replace('z', '')] = this.container; // No I18N
	        return this._dispatchEvent(eventName, originalEvent, ui);
	    }
	    _clearTimers() {
	        clearTimeout(this._sTimer);
	        this._data.spinButtons && this._clearMTimer(undefined, true);
	        clearInterval(this._kuTimer);
	        this._prevMUTime = this._currMUTime = this._prevKUTime = this._prevKDTime = this._currKUTime = this._currKDTime = this._kuTimer = undefined;
	    }
	    _checkPatternKeys(event) {
	        let pattern,
	            opts = this._opts,
	            key = ZC.keyCode,
	            code = event.keyCode;
	        pattern = (!event.shiftKey && ((code >= 48 && code <= 57) || code === 8 || (code >= 96 && code <= 105) || code === 69)); // Numbers and Backspace key
	        // key code: 69 -> letter e [To provide numbers in exponential notation]
	        if (code === key.SPACE && opts.thousandSeparator !== ' ') { // No I18N
	            let inputEle = this._input;
	            if (inputEle[0].selectionStart === 0 && inputEle[0].selectionEnd === inputEle.val().length) {
	                pattern = true;
	            } else { // Return value is needed for other purpose
	                event.preventDefault();
	                event.stopPropagation();
	            }
	        }
	        let min = opts.min;
	        if ((opts.allowNegativeValue && !min) || (this._isNotNull(min) && min.toString().indexOf('-') !== -1)) { // No I18N
	            pattern = (pattern || code === 189 || code === 173); // Hyphen Key
	        }
	        if (!pattern && (opts.decimalPlaces || (opts.showThousandSeparator && !opts.suppressThousandSeparatorKey))) {
	            pattern = this._isSeparator(code);
	        }
	        return pattern;
	    }
	    _handleShortcutKeys(event) {
	        let key = ZC.keyCode,
	            code = event.keyCode,
	            dontStop = true;
	        if (this._shortcutKey) {
	            if (code === 89) { // Key "Y"
	                if (this._mac) {
	                    dontStop = false;
	                }
	            } else if ([ 65, 67, 86, 88, 90, 89, 82, key.LEFT, key.RIGHT ].indexOf(code) < 0) { // Cmd+Shift+Right and Cmd+Shift+Left
	                // Key "A" (65), Key "C" (67), Key "X" (88), Key "Z" (90), Key "R" (82)
	                dontStop = false;
	            }
	            if (code === 86 || code === 91) { // Key "V"
	                this._handlePasteOption();
	            }
	        } else if ([ key.DOWN, key.UP, key.DELETE, key.BACKSPACE, key.LEFT, key.RIGHT, key.TAB, key.ENTER ].indexOf(code) < 0) {
	            dontStop = false;
	        }
	        return dontStop;
	    }
	    _handlePasteOption() {
	        let value = this._extractNumericValue(this._input.val());
	        this._opts.value = this._checkMinAndMax(value);
	    }
	    _spinValue(isUp, longStep, increment = this._opts[longStep ? 'longStep' : 'step']) { // No I18N
	        let opts = this._opts,
	            value = this._input.val(),
	            fieldValue = value,
	            min = opts.min,
	            max = opts.max,
	            isNotNull = this._isNotNull.bind(this);
	        opts.previousValue = opts.value;
	        value = this._extractNumericValue(value); // replace the thousand separator and decimal separator
	        if (isNaN(value) || value.trim() === '') { // No I18N
	            value = isUp ? (isNotNull(min) ? min - opts.step : 0) : (isNotNull(max) ? max + opts.step : 0);
	        }
	        value = parseFloat(value);
	        let step = parseFloat(increment); // No I18N
	        if (opts.stepBehavior === 'w3' && this._checkModuloValue(value, step, min)) { // No I18N
	            // Implementation similar to HTML5 Behavior
	            value = this._getCorrectedVal(value, step, min, isUp ? 1 : 0);
	        } else {
	            let cVal = value + (isUp ? step : -step);
	            // since 0.1+0.2 produces 0.30000000004 as result & 0.4-0.1 produces 0.30000000004 as result, truncating here.
	            value = this._hasFloatingNumber ? parseFloat(cVal).toFixed(12) : cVal;
	        }
	        let end = isUp ? max : min;
	        if (isNotNull(end) && !isNaN(end) && (value > max || value < min)) { // out of boundary
	            if (opts.wrapAround) {
	                value = (isUp ? min : max) || opts.nullValue;
	            } else {
	                value = parseFloat(parseFloat(value > max ? max : min).toFixed(opts.decimalPlaces));
	            }
	        }
	        this._setValue(value);
	        this._data.spinButtons && this._toggleSpinBtnStates(); // No I18N
	        this._triggerSpinEvent();
	        if (!fieldValue && this._data.clearButton && this._clearButton.is(':hidden')) { // No I18N
	            this._toggleBtnDisplay(false, true);
	        }
	    }
	    _triggerSpinEvent() {
	        let opts = this._opts,
	            lastVal = opts._lastValue;
	        if ((lastVal === undefined || (lastVal !== opts.value)) && (!opts.isWriter || this._canTriggerSpin())) {
	            this._triggerEvent('spin'); // No I18N
	            opts._lastValue = opts.value; // last value should be updated after triggering spin events.
	        }
	    }
	    _setValue(val) {
	        let opts = this._opts;
	        opts._lastValue = isNaN(opts.value) ? val : opts.value; // opts.value will be null if field was made empty previously.
	        let formattedVal = opts.value = this._checkMinAndMax(val);
	        if (!isNaN(formattedVal)) {
	            if (opts.decimalPlaces) {
	                // Providing option "decimalsForWholeNumber" since decimal places for whole numbers can be omitted instead of showing .00
	                let valueStr = formattedVal.toString();
	                if (opts.decimalsForWholeNumber || valueStr.indexOf('.') !== -1) { // No I18N
	                    valueStr = formattedVal.toFixed(opts.decimalPlaces);
	                }
	                formattedVal = valueStr.replace('.', opts.decimalSeparator);
	            } else if (!this._hasFloatingNumber) {
	                // Giving values with decimal precision via setValue() method should be corrected here.
	                formattedVal = Math.round(formattedVal);
	            }
	            if (opts.showThousandSeparator) {
	                formattedVal = this._insertSeparators(formattedVal);
	            }
	            if ((opts.prefix || opts.suffix) && !this.container.hasClass('has-focus')) {
	                formattedVal = this._attachAffixes(formattedVal);
	            }
	            formattedVal = this._translateEToA(formattedVal);
	            this._input.val(formattedVal).attr('aria-valuenow', parseFloat(this._extractNumericValue(formattedVal))); // No I18N
	            !this.isCE && this.element.val(formattedVal);
	            return formattedVal;
	        } else if (!opts.required) { // Supporting setValue('')
	            this._input.val('').attr('aria-valuenow', ''); // No I18N
	        }
	    }
	    getValue() {
	        let opts = this._opts,
	            val = opts.value;
	        return isNaN(parseFloat(val)) ? (opts.min || 0) : val;
	    }
	    setValue(value = this._opts.value) {
	        if (!this._muTimer && !this._kuTimer) { // if value change occurs and event is not triggered yet, do not set the value... [ Fix for Getter and Setter Issue ]
	            let opts = this._opts;
	            this._setValue(this._extractNumericValue(value));
	            opts.previousValue = this._changeDisVal = opts.value;
	            this._data.spinButtons && this._toggleSpinBtnStates();
	        }
	    }
	    increment(incrementValue) {
	        // Revisit - Change arguments order.
	        this._spinValue(true, undefined, incrementValue);
	    }
	    decrement(decrementValue) {
	        this._spinValue(false, undefined, decrementValue);
	    }
	    _destroy() {
	        super._destroy();
	        ZC.$window.off('.' + this.name); // No I18N
	    }
		_attachAffixes  (val) {
		    let opts = this._opts;
		    return ((opts.prefix || '') + ' ' + val + ' ' + (opts.suffix || '')).trim(); // No I18N
		}
		_removeAffixes  (val) {
		    let opts = this._opts;
		    val = this._remove(val, opts.prefix);
		    val = this._remove(val, opts.suffix);
		    return val;
		}
		_remove  (val, portion) {
		    let regex = this.escapeSequence;
		    if (portion && portion.trim() !== '') { // No I18N
		        let esc = portion.replace(regex, '');
		        val = val.replace(regex, '').replace(new RegExp(esc, 'g'), ''); // No I18N
		    }
		    return val;
		}
		_handleInputFocus  () {
		    let cName = this.name,
		        key = ZC.keyCode;
		    // determining whether focus is initiated by TAB key.
		    // Use bindEleEvents
		    $(window).on(`keyup.${cName}`, (nestedEvent) => {
		        if (nestedEvent.keyCode === key.TAB) {
		            $(nestedEvent.target).closest('.zinputfield__textbox').select(); // No I18N
		            $(window).off(`keyup.${cName}`);
		        }
		    });
		    this._input.val(this._translateEToA(this._extractNumericValue(this._input.val(), true))); // No I18N
		}
		get _SEPARATORS (){
			return	 {
		    '.': [ 110, 190 ], // No I18N
		    ',': [ 188 ], // No I18N
		    ' ': [ 32 ], // No I18N
		    "'": [ 222 ]// No I18N
		}
		 }
  _setSeparatorValues  () {
		    let opts = this._opts;
		    if (!opts.locale) {
		        opts.locale = ZC.locale || window.navigator.language;
		    }
		    let getSep = this._getSeparatorFromLocale.bind(this);
		    opts.showThousandSeparator && getSep('thousandSeparator', opts.locale); // No I18N
		    opts.decimalPlaces && getSep('decimalSeparator', opts.locale); // No I18N
		}
		_getSeparatorFromLocale  (separatorName, locale) {
		    let localeInfo = ZC.localeInfo;
		    if (localeInfo) {
		        let opts = this._opts,
		            numberFormat = (localeInfo[locale] && localeInfo[locale].numberFormat) || {},
		            value = numberFormat[separatorName] || opts[separatorName]; // If given locale is not present in the data, use default thousand separator and decimal separators.
		        opts[separatorName] = value;
		    }
		}
		_insertSeparators  (value) {
		    value += ''; // No I18N
		    let opts = this._opts,
		        decimalSep = opts.decimalSeparator,
		        splitted = value.split(decimalSep),
		        leftPart = splitted[0],
		        rightPart = splitted[1] ? decimalSep + splitted[1] : '', // No I18N
		        regex = /(\d+)(\d{3})/,
		        portions = [];
		    while (regex.test(leftPart)) {
		        portions = leftPart.split(regex);
		        leftPart = leftPart.replace(regex, portions[1] + opts.thousandSeparator + portions[2]);
		    }
		    return leftPart + rightPart;
		}
		_removeSeparators  (value, dontReplace) {
		    let opts = this._opts,
		        decimalSep = opts.decimalSeparator,
		        thouSep = opts.thousandSeparator;
		    if (!dontReplace && thouSep && opts.showThousandSeparator) {
		        value = value.replace(new RegExp(`\\${thouSep}`, 'g'), '');
		    } else if (!opts.showThousandSeparator && decimalSep !== ',') { // No I18N
		        value = value.replace(/,/g, '');
		    }
		    if (!dontReplace && opts.decimalPlaces && decimalSep !== '.') { // No I18N
		        value = value.replace(new RegExp(`\\${decimalSep}`, 'g'), '.');
		    }
		    return value;
		}
		_isSeparator  (code) {
		    // allow thousand separator. Permitted thousandSeparators are ".", ",", " " and "'".
		    // allow decimal digits. Permitted decimalSeparators are "," and "."
		    // key codes: 188 - Comma, 110 - Numpad dot and 190 - Dot, 59 - Firefox colon
		    let opts = this._opts,
		        allowedSep = this._SEPARATORS;
		    return (opts.decimalPlaces && allowedSep[opts.decimalSeparator].indexOf(code) >= 0) || (!opts.suppressThousandSeparatorKey && allowedSep[opts.thousandSeparator].indexOf(code) >= 0);
		}
		_setAttribute  (optName, value){
		    let valueUpdationProp = ["min","max","value","showThousandSeparator","allowNegativeValue","thousandSeparator","decimalSeparator","decimalPlaces","prefix","suffix","locale"],  // No I18N
		        requiresValidationProp = ["min","max","step","decimalPlaces"], opts = this._opts,  // No I18N
		        data = this._data,
		        toggleBtnFunc = this._toggleSpinBtnStates && this._toggleSpinBtnStates.bind(this);
		    opts[optName] = value;
		    if(optName === "spinValues" && !data.spinButtons){ // No I18N
		        this['_'+(value ? '': 'un')+'bindSpinEvents']();// No I18N
		        value ? this._input.attr("role","spinbutton") : this._input.removeAttr("role"); // No I18N
		    }else if(optName === "spinButtonsType"){ // No I18N
		        opts.templateName = value === 'together' ? 'zinputfield' : 'znumberfield'; // No I18N
		        this._domChanged = true;
		        this._handleSpinBtns(optName, value, opts);
		    }else if(optName === "locale" || optName === "thousandSeparator" || optName === "showThousandSeparator" || optName === "decimalPlaces"){ // No I18N
		        this._getSeparatorFromLocale("decimalSeparator", opts.locale);  // No I18N
		        this._getSeparatorFromLocale("thousandSeparator", opts.locale);  // No I18N
		    }else if(optName === "allowNegativeValue"){ // No I18N
		        let min = opts.min;
		        if(value){
		            min = min >= 0 ? undefined : min;
		        }else{
		            min = (!this._isNotNull(min) || min < 0) ? 0 : min;
		        }
		        opts.min = min;
		    }else if(optName === "wrapAround"){ // No I18N
		        if(value && data.spinButtons){
		            this._buttons.removeClass("is-disabled");
		        }else if(data.spinButtons){ // No I18N
		            toggleBtnFunc();
		        }
		    }else{
		        super._setAttribute(optName, value);
		    }
		    if(requiresValidationProp.indexOf(optName) !== -1){
		        opts[optName] = parseFloat(value);
		        this._validateOpts(opts);
		    }
		    if(valueUpdationProp.indexOf(optName) !== -1){
		        this._setValue(opts.value);
		        data.spinButtons && toggleBtnFunc(); // No I18N
		    }
		    if(optName === "prefix" || optName === "suffix"){ // No I18N
		        this._hasAffix = (opts.prefix && opts.prefix.trim() !== '') || (opts.suffix && opts.suffix.trim() !== ''); // No I18N
		    }
		    if(optName === "min" || optName === "max"){ // No I18N
		        this._input.attr({"aria-valuemax": opts.max, "aria-valuemin": opts.min}); // No I18N
		    }
		}
		/*
		    _prevMUTime - Previous Mouse Up Time
		    _currMUTime - Current Mouse Up Time
		*/
		_getSpinIconInfo  (button, isVertical) { // input field overrided method since plus/minus icons differ.
		    let isUp = button === 'increment', // No I18N
		        svgId = 'zc__svg--' + (isVertical ? button : (isUp ? 'plus' : 'minus')), // No I18N
		        clsName = ('zinputfield__spinbutton zh-' + (isUp ? 'up' : 'down')); // No I18N
		    return [ svgId, clsName ];
		}
		_validateSBtnOpts  (opts) {
		    if (opts.spinButtonsType === 'split') { // No I18N
		        let svalue = opts.spinButtons;
		        opts.spinButtons = svalue === 'focus' ? 'always' : svalue; // No I18N
		        opts.templateName = 'znumberfield'; // No I18N
		    }
		}
		_toggleSpinBtnStates  () {
		    let opts = this._opts;
		    if (!opts.wrapAround) {
		        let val = opts.value,
		            maxReached = val >= opts.max,
		            minReached = isNaN(val) || val <= opts.min;
		        // let data = this._data; // to be removed
		        // data.incrementProps.disabled = !!maxReached;
		        // data.decrementProps.disabled = !!minReached;
		        // calling render here removes the events binded to the spin buttons. Also, this method will be executed for every value change in the field. To be revisited if needed.
		        // this._render();
		        let dCls = 'is-disabled', // No I18N
		            cont = this.container,
		            btns = this._buttons;
		        btns.removeClass(dCls);
		        maxReached && cont.find('.zh-up').addClass(dCls); // No I18N
		        minReached && cont.find('.zh-down').addClass(dCls); // No I18N
		    }
		}
		_bindSpinButtonEvents  () {
		    this._addEvents({
		        spinBtnMouseDown: 'mousedown', // No I18N
		        spinBtnMouseUp: 'mouseup', // No I18N
		        spinBtnKeyDown: 'keydown', // No I18N
		        spinBtnBlur: 'blur' // No I18N
		    }, this._buttons);
		}
		_spinBtnKeyDownHandler  (event) { // Firefox will not support this behavior
		    /* Clicking the up and down arrows whenever spin buttons has focus on it should set focus to the field. */
		    let key = ZC.keyCode,
		        code = event.keyCode,
		        isUp = code === key.UP;
		    if (isUp || code === key.DOWN) { // key denotes ZC.keyCode
		        this._input.focus();
		        this._spinValue(isUp, event.shiftKey, undefined, true);
		    }
		}
		_spinBtnMouseDownHandler  (event) {
		    let spinBtn = $(event.target).closest('.zinputfield__spinbutton'); // No I18N
		    if (this._handleMousedownOnControls(event, spinBtn)) {
		        ZC.currentNumberField = this.container;
		        let isUp = spinBtn.hasClass('zh-up'), // No I18N
		            shft = event.shiftKey;
		        (!this._prevMUTime || !this._currMUTime || this._currMUTime - this._prevMUTime > 600) && this._triggerEvent('spinstart', event); // No I18N
		        this._spinValue(isUp, shft, undefined, false); // event.ctrlKey || event.metaKey
		        if (this._blurEventTimer) {
		            clearTimeout(this._blurEventTimer);
		        }
		        this._mdTimer = setInterval(() => {
		            if (spinBtn.hasClass('is-disabled')) { // No I18N
		                // If minimum or maximum value is reached while pressing the mouse, trigger spin end and exit...
		                this._triggerSpinEndEvent(event);
		                this._clearMTimer();
		            }
		            if (this._mouseDown) {
		                this._spinValue(isUp, shft, undefined, true); // event.ctrlKey || event.metaKey
		            } else {
		                this._clearMTimer();
		            }
		        }, 200);
		    }
		}
		_handleMousedownOnControls  (event, btn) {
		    let opts = this._opts;
		    if (opts.disabled || event.which > 1 || opts.readonly || btn.hasClass('is-disabled')) {
		        return false;
		    }
		    this._mouseDown = true;
		    this._hasFocus = !!this._input.is(':focus'); // No I18N
		    // To decide whether to focus the field or not while pressing the spin buttons.
		    let fCls = 'has-focus', // No I18N
		        currField = ZC.currentNumberField,
		        cont = this.container;
		    if (currField && currField[0] !== cont[0]) {
		        currField.removeClass(fCls);
		    }
		    cont.addClass(fCls);
		    return true;
		}
		_spinBtnMouseUpHandler  (event) {
		    this._spinbuttonsMouseUpHandler(event);
		    ZC.Browser.isFirefox && $(event.target).closest('.zinputfield__spinbutton').focus(); // To retain the focus on the spin button in firefox browser inorder to support focusing the field by pressing up/down arrow keys.
		}
		_spinBtnBlurHandler  (event) {
		    let rTarget = event.relatedTarget,
		        closestField = rTarget && $(rTarget).closest('.zinputfield'), // No I18N
		        sameFieldFocus = false;
		    if (closestField && closestField.length) {
		        // Input field check is added since input field will be focused on spin button click if it already has focus set on them before clicking spin button. While focusing the input field, blur event for spin button will be triggered.
		        sameFieldFocus = closestField[0] === this.container[0];
		    }
		    if (!rTarget || !sameFieldFocus) {
		        this._spinbuttonsMouseUpHandler(event, true);
		        let opts = this._opts;
		        if (opts.triggerBlurOnSpinButtonClick) { // value is updated here since prefix and suffix values are not updated whenever triggerBlurOnSpinButtonClick option is set.
		            this._setValue(opts.value);
		        } else {
		            this._input.trigger('blur'); // No I18N
		        }
		    }
		}
		_spinbuttonsMouseUpHandler  (event, viaBlur) {
		    this._clearMTimer();
		    let opts = this._opts;
		    clearTimeout(this._mwTimer);
		    let isButtonDisabled = $(event.target).closest('.zinputfield__spinbutton').hasClass('is-disabled');
		    if (opts.disabled || opts.readonly || (viaBlur && !this._mouseDown && isButtonDisabled)) {
		        return false;
		    }
		    this._prevMUTime = this._currMUTime || undefined;
		    this._currMUTime = new Date().getTime();
		    if (this._prevMUTime && this._currMUTime - this._prevMUTime < 600) {
		        this._clearMTimer(true);
		        this._muTimer = setInterval(() => {
		            this._currMUTime = new Date().getTime();
		            if (this._currMUTime - this._prevMUTime > 600) {
		                this._canTriggerSpinEnd(opts) && this._triggerSpinEndEvent(event);
		                this._clearMTimer(true);
		                this._prevMUTime = this._currMUTime = this._mouseDown = undefined;
		            }
		        }, 200);
		    }
		    if (this._canTriggerSpinEnd(opts)) {
		        this._mouseDown && this._triggerSpinEndEvent(event);
		    }
		    let _input = this._input;
		    opts.isWriter && this._handleSBtnUp();
		    if (viaBlur && !_input.is(':focus')) { // No I18N
		        this.container.removeClass('has-focus');
		        this._data.clearButton && opts.clearButton === 'focus' && this._toggleBtnDisplay(true, true); // No I18N
		    } else if (this._hasFocus) { // setting focus places the cursor inside the element.
		        _input.attr('tabindex', 0).focus(); // No I18N
		    }
		    this._mouseDown = false;
		}
		_canTriggerSpinEnd  (opts) {
		    let lastValue = this._changeDisVal;
		    return (!opts.bindedSpinAndChange || lastValue === undefined || parseFloat(lastValue) !== parseFloat(opts.value));
		}
		_clearMTimer  (up, both) {
		    if (both) {
		        clearInterval(this._mdTimer);
		        this._mdTimer = undefined;
		        up = true;
		    }
		    let name = '_m' + (up ? 'u' : 'd') + 'Timer'; // No I18N
		    clearInterval(this[name]);
		    this[name] = undefined;
		}
		_getFactorValue  () { // setting the maximum value based on the minimum,maximum and step values - compatible for HTML5 input type=number
		    let opts = this._opts,
		        min = opts.min,
		        max = opts.max,
		        factor = Math.pow(10, opts.decimalPlaces) || 1;
		    if (this._isNotNull(min)) {
		        let reminder = (((max - min) * factor) % (opts.step * factor)) / factor;
		        opts.max = Math.round((max - reminder) * factor) / factor;
		    }
		    return factor;
		}
		_checkModuloValue  (value, step, min) {
		    let factor = this._factor,
		        factoredStep = step * factor,
		        minModStep = (min * factor) % factoredStep,
		        valueModStep = (value * factor) % factoredStep,
		        staticMod = min < 0 ? ((minModStep + factoredStep) % factoredStep) : Math.round(minModStep),
		        modValue = value < 0 ? Math.round((valueModStep + factoredStep) % factoredStep) : Math.round(valueModStep);
		    /*  If value is less than zero, modulo calculation should be
		            since modulo operation produces incorrect result for floating numbers, factorization is needed based on the precision given.
		            ((this % n) + n) % n
		            modValue = ((value%step) + step) % step;
		    */
		    return Math.abs(modValue) !== staticMod;
		}
		_getCorrectedVal  (value, step, min, inc) {
		    // (quotient * step) + min
		    return ((parseInt((value - min) / step) + inc) * step) + min;
		}
		_bindWriterEvents  () {
		    this._addEvents({
		        wInputEleFocus: 'focus' // No I18N
		    }, this._input);
		}
		_wInputEleFocusHandler  () {
		    this._focusedValue = this._opts.value;
		}
		_handleInputBlur  () {
		    let opts = this._opts;
		    if (parseFloat(this._changeDisVal) !== parseFloat(opts.value) && opts.triggerBlurOnSpinButtonClick) {
		        this._triggerBlurEvent(event);
		        return true;
		    }
		}
		_handleEnterKey  (opts) {
		    opts.triggerBlurOnSpinButtonClick && this._triggerBlurEvent(event);
		}
		_canTriggerSEnd  (opts) {
		    return (!opts.bindedSpinAndChange || parseFloat(this._changeDisVal) !== parseFloat(opts.value));
		}
		_handleSpinEnd  () {
		    if (this._opts.bindedSpinAndChange) {
		        this._changeDisVal = this._opts.value;
		    }
		}
		_triggerBlurEvent  (event) {
		    let opts = this._opts,
		        valueOnFocus = this._focusedValue;
		    if (!event) { // triggered from spin button up handler.
		        this._blurEventTimer = setTimeout(() => {
		            this._triggerEvent('blur', event); // No I18N
		        }, opts.blurEventDelay);
		    } else if (!valueOnFocus || parseFloat(valueOnFocus) !== parseFloat(opts.value)) {
		        this._triggerEvent('blur', event); // No I18N
		        this._focusedValue = opts.value;
		    }
		}
		_handleSBtnUp  () {
		    this._opts.triggerBlurOnSpinButtonClick && this._triggerBlurEvent();
		}
		_canTriggerSpin  () {
		    clearTimeout(this._sTimer);
		    let delay = this._opts.spinEventTriggerDelay;
		    if (delay) {
		        if (!this._sEndTimer) { // sEnd -> spin end & sStart -> spin start
		            this._sStartTimer = new Date().getTime();
		        }
		        this._sEndTimer = (new Date().getTime() - this._sStartTimer);
		        delay = parseInt(delay) - this._sEndTimer;
		        if (delay) {
		            this._sTimer = setTimeout(() => {
		                this._triggerEvent('spin'); // No I18N
		                this._sEndTimer = undefined;
		            }, delay);
		            return false;
		        }
		    }
		    return true;
		}
	}
	ZC.registerComponent('ZNumberField', ZC.ZInputField, ZNumberField); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.znumberfield.Templates, button = ZC.zbutton.Templates.WCContainer; 
template.WCContainer = (data) => ZT.html `<div class="zinputfield ${data.className}" ?title=${data.title} tabindex="-1" role="spinbutton" style="width:${data.width}px" ?id=${data.id} >${data.children && template.WCChildren(data)}</div>`; 
template.WCChildren = (data) => ZT.html `${data.spinButtons && button(data.decrementProps)} <input class='zinputfield__textbox' tabindex="${data.tabindex}" ?aria-valuemin=${data.min} ?aria-valuemax=${data.max} ?readonly=${data.readonly} ?aria-readonly=${data.readonly} ?disabled=${data.disabled} ?aria-disabled=${data.disabled} ?maxlength=${data.maxLength}> ${data.clearButton && button(data.clearButtonProps)} ${data.spinButtons && button(data.incrementProps)} 	`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.znumberfield.Templates, button = ZC.zbutton.Templates.container; 
template.container = (data) => ZT.html `<div class="zinputfield ${data.className}" ?title=${data.title} tabindex="-1" role="spinbutton" style="width:${data.width}px" ?id=${data.id} >${data.children && template.children(data)}</div>`; 
template.children = (data) => ZT.html `${data.spinButtons && button(data.decrementProps)} <input class='zinputfield__textbox' tabindex="${data.tabindex}" ?aria-valuemin=${data.min} ?aria-valuemax=${data.max} ?readonly=${data.readonly} ?aria-readonly=${data.readonly} ?disabled=${data.disabled} ?aria-disabled=${data.disabled} ?maxlength=${data.maxLength}> ${data.clearButton && button(data.clearButtonProps)} ${data.spinButtons && button(data.incrementProps)} 	`; }(ZComponents)); 
(function(ZC, $){
		class ZCurrencyField extends ZC.ZNumberField {
			get name(){
				return "zcurrencyfield";
			}
		    get attrs() {
		        return {
		            useCodeAsSymbol: false, // No I18N
		            displaySymbolAs: null, // No I18N
		            currencyCode: null, // No I18N
		            innerHTML: null // No I18N
		        }
		    }
		    _init(ele, opts) {
		        if (!opts.locale) {
		            opts.locale = ZC.locale || window.navigator.language;
		        }
		        if (opts.displaySymbolAs) {
		            this._posOverrided = true;
		        } else {
		            this._getPosFromLocale();
		        }
		        opts.currencyCode = opts.currencyCode || (ZC.localeInfo ? ZC.localeInfo[opts.locale].currency.code : undefined);
		        this._identifyPreSuf();
		        super._init(ele, opts);
		    }
		    _getPosFromLocale() {
		        let localeInfo = ZC.localeInfo,
		            opts = this._opts,
		            locale = opts.locale;
		        opts.displaySymbolAs = 'prefix'; // No I18N
		        if (localeInfo && localeInfo[locale]) {
		            let currency = localeInfo[locale].currency.position; // retrieving the currency symbol position from locale
		            opts.displaySymbolAs = currency === 'left' ? 'prefix' : 'suffix'; // No I18N
		        }
		        if (opts.decimalPlaces || opts.showThousandSeparator) {
		            this._setSeparatorValues();
		        }
		    }
		    _identifyPreSuf() {
		        let opts = this._opts,
		            currCode = opts.currencyCode;
		        if (currCode) {
		            let currencyInfo = ZC.currencyInformation;
		            if (currencyInfo) {
		                let currData = currencyInfo[currCode];
		                opts[opts.displaySymbolAs === 'prefix' ? 'prefix' : 'suffix'] = opts.useCodeAsSymbol ? currCode : currData.symbol; // No I18N
		            }
		        }
		    }
		    _setAttribute(optName, value) {
		        let opts = this._opts;
		        opts[optName] = value;
		        if (optName === 'currencyCode') { // No I18N
		            let validCode = value && value.trim() !== '';// No I18N
		            if (validCode) {
		                this._identifyPreSuf();
		            }
		            // setting empty instead of undefined/null since custom element's attrbChanged produces incorrrect results.
		            this.setAttributes({
		                prefix: validCode ? opts.prefix : '', // No I18N
		                suffix: validCode ? opts.suffix : '' // No I18N
		            });
		            this._setValue(opts.value);
		        } else if ((optName === 'useCodeAsSymbol' || optName === 'displaySymbolAs') || (optName === 'locale' && !this._posOverrided)) { // No I18N
		            opts.prefix = opts.suffix = '';
		            optName === 'locale' && this._getPosFromLocale(); // No I18N
		            if (optName === 'displaySymbolAs') { // No I18N
		                if (value === 'default') { // No I18N
		                    this._getPosFromLocale();
		                } else {
		                    this._posOverrided = true;
		                }
		            }
		            this._identifyPreSuf();
		            this._setValue(opts.value);
		        } else {
		            super._setAttribute(optName, value);
		        }
		    }
		}
	ZC.registerComponent('ZCurrencyField', ZC.ZNumberField, ZCurrencyField); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
	class ZDatePicker extends ZC.CoreComponent {
			get name(){
				return "zdatepicker";
			}
	    get attrs() {
	        return {
	            forElement: null,
	            offset: null,
	            title: null,
	            position: 'auto', // No I18N
	            format: 'dd/MM/yyyy', // No I18N
	            displayType: 'box', // No I18N
	            type: 'popup', // No I18N
	            minDate: null,
	            maxDate: null,
	            displayWeekNumbers: false,
	            weekHeading: null, // No I18N
	            selectionType: 'single', // No I18N
	            todayButtonLabel: null,
	            clearButtonLabel: null,
	            OKButtonLabel: null,
	            closeSVGIconId: null,
	            closeIconClass: null,
	            cancelButtonLabel: null,
	            selectionLimit: null,
	            monthToBeShownOnOpen: null,
	            yearToBeShownOnOpen: null,
	            drilldownLevelOnOpen: null,
	            isTitleHTMLEncoded: false,
	            selectedDateMonthViewIndex: null,
	            todayButtonAction: 'navigate-only', // No I18N
	            displayAdjacentMonthDates: false,
	            allowSelectionOfAdjacentMonthDates: true,
	            hideCancelButton: false,
	            monthsPerView: 1,
	            immediateCommit: true,
	            value: null,
	            draggable: false,
	            height: null,
	            width: null,
	            weekendDays: '0,6', // No I18N
	            closeButton: false,
	            closeOnDateSelect: true,
	            closeOnBodyClick: true,
	            todayButton: false,
	            clearButton: false,
	            locale: 'en-US', // No I18N
	            positionAlterable: true
	        };
	    }
	    get props() {
	        return {
	            closeIconClassName: null,
	            commandBar: {},
	            margin: {},
	            animation: {},
	            customHTMLAboveNavigationBar: null,
	            customHTMLAboveCalendar: null,
	            customHTMLBelowCalendar: null,
	            navigationBar: {
	                monthSwitcher: true,
	                yearSwitcher: true,
	                monthYearHeadingFormat: 'MMM yyyy', // No I18N
	                monthYearSwitcherType: 'drilldown', // No I18N
	                monthFormatInSwitcher: 'MMM', // No I18N
	                navigationButtonsDisplayPattern: 'split', // No I18N
	                togetherTypeNavigationButtonsPosition: 'right', // No I18N
	                monthNavigationStep: 1,
	                yearNavigationStep: 1,
	                yearNavigationButtons: true,
	                monthNavigationButtons: true,
	                previousMonthButtonSVGIconId: null,
	                dropdownStartYear: 'THIS_YEAR-10', // No I18N
	                dropdownEndYear: 'THIS_YEAR+10' // No I18N
	            },
	            otherInputFormats: [],
	            fixedTimeOptions: [],
	            specialDates: [],
	            disabledDates: [],
	            disabledMonths: [],
	            disabledYears: [],
	            specialDaysOfWeek: [],
	            disabledDaysOfWeek: [],
	            disabledDateInformativeText: null,
	            values: [],
	            labels: {
	                weekHeading: 'Week', // No I18N
	                OKButtonLabel: 'OK', // No I18N
	                cancelButtonLabel: 'Cancel', // No I18N
	                todayButtonLabel: 'Today', // No I18N
	                clearButtonLabel: 'Clear', // No I18N
	                days: [
	                    'Sunday', // No I18N
	                    'Monday', // No I18N
	                    'Tuesday', // No I18N
	                    'Wednesday', // No I18N
	                    'Thursday', // No I18N
	                    'Friday', // No I18N
	                    'Saturday' // No I18N
	                ],
	                daysAbbreviated: [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ], // No I18N
	                months: [
	                    'January', // No I18N
	                    'February', // No I18N
	                    'March', // No I18N
	                    'April', // No I18N
	                    'May', // No I18N
	                    'June', // No I18N
	                    'July', // No I18N
	                    'August', // No I18N
	                    'September', // No I18N
	                    'October', // No I18N
	                    'November', // No I18N
	                    'December' // No I18N
	                ],
	                monthsAbbreviated: [
	                    'Jan', // No I18N
	                    'Feb', // No I18N
	                    'Mar', // No I18N
	                    'Apr', // No I18N
	                    'May', // No I18N
	                    'Jun', // No I18N
	                    'Jul', // No I18N
	                    'Aug', // No I18N
	                    'Sep', // No I18N
	                    'Oct', // No I18N
	                    'Nov', // No I18N
	                    'Dec' // No I18N
	                ],
	                close: 'Close', // No I18N
	                nextMonth: 'Next Month', // No I18N
	                nextYear: 'Next Year', // No I18N
	                prevMonth: 'Previous Month', // No I18N
	                prevYear: 'Previous Year', // No I18N
	                nextDecade: 'Next Decade', // No I18N
	                prevDecade: 'Previous Decade', // No I18N
	                nextCentury: 'Next Century', // No I18N
	                prevCentury: 'Previous Century' // No I18N
	            }
	        };
	    }
	    get EVENTS() {
	        return [
	            'beforefocus', // No I18N
	            'beforeopen', // No I18N
	            'open', // No I18N
	            'beforeclose', // No I18N
	            'close', // No I18N
	            'dateselect', // No I18N
	            'todaybuttonclick', // No I18N
	            'change', // No I18N
	            'cancel', // No I18N
	            'clear', // No I18N
	            'beforedrilldown', // No I18N
	            'drilldown', // No I18N
	            'afterdrilldown', // No I18N
	            'datemouseover', // No I18N
	            'monthchange', // No I18N
	            'yearchange', // No I18N
	            'decadechange', // No I18N
	            'beforedatecellrender', // No I18N
	            'dragstart', // No I18N
	            'drag', // No I18N
	            'dragend'// No I18N
	        ];
	    }
	    get SELECTORS() {
	        let isCE = this.isCE;
	        return {
	            option: isCE ? 'z-' : 'option', // No I18N
	            select: `${isCE ? 'z-combobox' : 'select'}` // No I18N
	        };
	    }
	    _setFormat() {
	        this._dateFormat = this._opts.format;
	    }
	    _isBtnsExist() {
	        return this._checkIfButtonsExist() || this._isColumnExists();
	    }
	    _setOKCancelBtns() {
	        let opts = this._opts;
	        opts.OKButton = !opts.immediateCommit;
	        opts.cancelButton = !opts.immediateCommit && !opts.hideCancelButton;
	    }
	    _init(element, options, shouldRender) {
	        this._todayDate = new Date();
	        this._userOptions = $.extend({}, options);
	        let navBar = options.navigationBar,
	            forElement = options.forElement,
	            value = options.value,
	            optVal = [ 'minDate', 'maxDate', 'value' ]; // No I18N
	        this._validateFormat();
	        if (this._invalidFormat) {
	            return;
	        }
	        this._setFormat();
	        options.locale = options.locale || ZC.locale;
	        navBar && (this._yearNavigation = navBar.yearNavigationButtons);
	        options.position && (this._isPositionModified = options.position);
	        this._setSwitcherType(navBar);
	        if (this._yearNavigation === undefined && /^(drilldown|none)$/.test(navBar.monthYearSwitcherType)) {
	            this._yearNavigation = true;
	        }
	        this._rowsCount = [];
	        this._setOKCancelBtns();
	        (this._isBtns = this._isBtnsExist()) && this._setBtnProps();
	        this._getLocaleValues();
	        forElement && (this._forElement = $(forElement));
	        this.element[0].setAttribute('tabindex', 0); //  No I18N
	        this._monthsPerView = options.monthsPerView;
	        this._selectedDates = [];
	        (options.disabledDates.length || options.specialDates.length || (options.disabledTimeList && options.disabledTimeList.length)) && this._convertStringToObject({
	            disabledDates: options.disabledDates,
	            specialDates: options.specialDates,
	            disabledTimeList: options.disabledTimeList
	        });
	        for (let i = 0, len = optVal.length; i < len; i++) {
	            let part = optVal[i],
	                value = options[part],
	                viewDate;
	            if (value) {
	                this._parseValue(part, value);
	                options[part] instanceof Date && !this._checkTime && options[part].setHours(0, 0, 0, 0);
	                if (part === 'value') {
	                    /**  revisit - try to reuse setValue() method
	                         !== 'multiple' added instead of === 'single' to use it commonly for range picker
	                     */
	                    if (this._isNotNull(options.value) && this._dateWithInRange(options.value) && !this._getUniqueClass(options.value) && this._opts.selectionType !== 'multiple') { // No I18N
	                        this._currentSelected = new Date(+options.value);
	                        if (!this._viewDate) {
	                            viewDate = this._viewDate = this._currentSelected;
	                            this._changeMonth(false, viewDate, 1);
	                        }
	                        this._valueUpdate = true;
	                    } else {
	                        options[part] = undefined;
	                    }
	                }
	            }
	            if (part === 'value') {
	                !this._viewDate && this._setHours()
	            } else {
	                this['_' + part] = options[part];
	            }
	        }
	        this._validateOpts();
	        (options.minDate || options.maxDate) && this._processLimits();
	        if (!value && options.values.length === 0) {
	            (options.monthToBeShownOnOpen || options.yearToBeShownOnOpen) && this._setViewOnOpen();
	        }
	        options.selectionType === 'multiple' && this._setValues(); // No I18N
	        options.value && (this._currentSelected = new Date(+options.value));
	        !this._data.month && (this._data.month = []);
	        this._elementId = this._getID(this.element); // No I18N
	        this._buildData(shouldRender);
	        let elem = this.element[0];
	        options.width && (elem.style.width = options.width + 'px'); // No I18N
	        options.height && (elem.style.height = options.height + 'px'); // No I18N
	        return true;
	    }
	    _setSwitcherType(navBar) {
	        let value = navBar.monthYearSwitcherType;
	        this._isDrilldown = value === 'drilldown'; // No I18N
	        this._isDropdown = value === 'dropdown';// No I18N
	    }
	    _getLocaleValues() {
	        let opts = this._opts,
	            labels = opts.labels,
	            locale = ZC.localeInfo[opts.locale];
	        if (locale) {
	            let arr = [ 'days', 'daysAbbreviated', 'monthsAbbreviated', 'months' ]; // No I18N
	            for (let i = 0, len = arr.length; i < len; i++) {
	                labels[arr[i]] = locale[arr[i]] || labels[arr[i]];
	            }
	        }
	        opts.firstDayOfWeek = locale ? locale.firstDayOfWeek || 0 : 0;
	    }
	    _invokeOtherActions() {
	        let opts = this._opts,
	            title = opts.title;
	        if (opts.type === 'inline') { // No I18N
	            this._display();
	            this._isShown = true;
	        } else if (title && title.length && opts.draggable) {
	            this._initDraggable();
	        }
	    }
	    _validateOpts() {
	        let opts = this._opts,
	            displayType = 'monthYearSwitcherType', // No I18N
	            position = opts.position,
	            navBar = opts.navigationBar,
	            type = opts.displatype,
	            yearNavigation = this._yearNavigation;
	        opts.drilldownLevelOnOpen = opts.drilldownLevelOnOpen || 'dates'; // No I18N
	        opts.format = opts.format || 'dd/MM/yyyy'; // No I18N
	        position = opts.position = position === 'auto' ? type === 'callout' ? 'bottom' : 'bottom-left' : position; // No I18N
	        (opts.minDate || opts.maxDate) && this._checkLimits();
	        navBar[displayType] = [ 'dropdown', 'drilldown', 'none' ].indexOf(navBar[displayType]) > -1 ? navBar[displayType] : 'none'; // No I18N
	        if ([ 'top', // No I18N
	            'bottom', // No I18N
	            'right', // No I18N
	            'left', // No I18N
	            'top-left', // No I18N
	            'top-right', // No I18N
	            'bottom-left', // No I18N
	            'bottom-right' // No I18N
	        ].indexOf(position) === -1) {
	            opts.position = 'bottom'; // No I18N
	        }
	        if (!navBar.monthSwitcher && !navBar.yearSwitcher) {
	            opts[displayType] = 'none'; // No I18N
	        }
	        type = opts.displayType;
	        type = [ 'box', 'callout' ].indexOf(type) > -1 ? type : 'box'; // No I18N
	        if (this._data) {
	            this._data.displayType = type;
	        }
	        navBar.yearNavigationButtons = yearNavigation === undefined ? !this._isDropdown : yearNavigation; // No I18N
	        navBar.monthYearHeadingFormat = [ 'MMM yyyy', 'MMMM yyyy', 'yyyy MMM', 'yyyy MMMM' ].indexOf(navBar.monthYearHeadingFormat) > -1 ? navBar.monthYearHeadingFormat : 'MMMM yyyy'; // No I18N
	    }
	    _constructData() {
	        let data = this._data,
	            opts = this._opts,
	            navBar = opts.navigationBar; // No I18N
	        if (opts.title && !data.title) {
	            data.title = this._getTitleData();
	        }
	        this._viewMode === undefined && (this._viewMode = this._isDrilldown ? this._getViewMode() : 0);// No I18N
	        data.dropdownCls = this._isDropdown && navBar.monthNavigationButtons && navBar.yearNavigationButtons; // No I18N
	        this._maxDate && this._monthsPerView > 1 && this._checkViewDateWithMax(this._viewDate);
	        for (let i = 0; i < this._monthsPerView; i++) {
	            let month = data.month[i] = data.month[i] || {},
	                newDate = new Date(+this._viewDate);
	            month.className = '';
	            month.weekTitle = opts.weekHeading || this._getI18NText('weekHeading'); // No I18N
	            newDate = this._moveMonth(this._viewDate, i);
	            this._fillDayOfWeek(month);
	            this._fillDates(month, newDate, opts.monthsPerView > 1 ? i : undefined);
	            month.monthsPerView = opts.monthsPerView;
	            month.displayWeekNumbers = opts.displayWeekNumbers;
	            this._constructNavBar(month, i, newDate);
	            (i === 0 || i === this._monthsPerView - 1) && (month.viewDate = newDate);
	        }
	        let cls = 'zdatetimepicker__month '; // No I18N
	        if (!opts.allowSelectionOfAdjacentMonthDates) {
	            cls += 'zdatetimepicker--adjacentmonthdatereadonly';// No I18N
	        }
	        this._setMonthVal('className', cls);// No I18N
	        opts.drilldownLevelOnOpen !== 'dates' && this._isDrilldown && this._generateContent(this.element); // No I18N
	        if (!this._data.rendered && this._isBtns) {
	            this._createButtons();
	        }
	    }
	    _isColumnExists() {
	        let commandBar = this._opts.commandBar;
	        if (commandBar) {
	            let columns = [ 'leftColumn', 'centerColumn', 'rightColumn' ]; // No I18N
	            for (let i = 0; i < columns.length; i++) {
	                if (commandBar[columns[i]]) {
	                    let commands = commandBar[columns[i]].commands;
	                    for (let i = 0; i < commands.length; i++) {
	                        this._opts[commands[i] + 'Button'] = true; // No I18N
	                    }
	                    return true;
	                }
	            }
	            return false;
	        }
	    }
	    _buildData(shouldRender) {
	        let disabledCls = 'zdatetimepicker--disabledcalendar'; // No I18N
	        this._rowsCount = [];
	        this._viewMode === 0 && this.element.find('.' + disabledCls).removeClass(disabledCls); // No I18N
	        this._constructData();
	        this._data._isRenderedAgain = true;
	        shouldRender && this._render();
	    }
	    _postRender(elem, data) {
	        let pickerCls = ' zdatetimepicker'; // No I18N
	        this._invokeOtherActions();
	        this._data.className += pickerCls + (data.monthsPerView === 1 ? '' : '--group ') + (data.dropdownCls ? pickerCls + '--dropdownyearbutton ' : ''); // No I18N
	        if (data.appendTo) {
	            this._appendEle(data.appendTo);
	        }
	        elem[0].setAttribute('id', this._elementId); // No I18N
	    }
	    _adjustCustomHTMLPos(hide) {
	        let opts = this._opts;
	        (opts.customHTMLAboveCalendar || opts.customHTMLAboveNavigationBar || opts.customHTMLBelowCalendar) && this._handleCustomHTML(hide);
	    }
	    _preRender(data) {
	        /* Since the structure can be changed on render, customHTML has to be inserted after render */
	        this._adjustCustomHTMLPos(false);
	        return data;
	    }
	    _postEachRender(elem, data = this._data) {
	        let firstRender = !this._data.rendered,
	            isRendered = firstRender || data._isRenderedAgain, // No I18N
	            modifiedAttr = data.modifiedAttr,
	            opts = this._opts,
	            isDropdown = this._isDropdown,
	            isNavButtons = opts.navigationBar.monthNavigationButtons || opts.navigationBar.yearNavigationButtons;
	        if (isRendered || modifiedAttr) {
	            if (firstRender || [ 'navBar', 'monthsPerView' ].indexOf(modifiedAttr) > -1) { //  No I18N
	                if (isDropdown) {
	                    this._assignHeaders();
	                    let bindHeaderEvents = this._bindHeaderEvents.bind(this);
	                    bindHeaderEvents('year', 'select'); // No I18N
	                    bindHeaderEvents('month', 'combobox'); // No I18N
	                    this._checkOptions();
	                } else if (this._isDrilldown) {
	                    this._bindDrillDownClickEvent();
	                    // need to do for setAttribute changes
	                    this._monthEventBinded = this._yearEventBinded = this._decadeEventBinded = undefined;
	                }
	            }
	            if (firstRender || [ 'navBar', 'monthsPerView', 'type' ].indexOf(modifiedAttr) > -1) {
	                let className = this._data.className,
	                    cls = ' zdatetimepicker' + (this._monthsPerView === 1 ? '' : ' zdatetimepicker--group') + (data.dropdownCls ? ' zdatetimepicker--dropdownyearbutton' : '') + (opts.type === 'inline' ? ' zdatetimepicker--inline' : '');
	                /* to avoid duplication of classes everytime (for drilldownLevelOnOpen other than dates) */
	                (cls !== className) && (this._data.className = className ? className + cls : cls); // No I18N
	                if (isNavButtons) {
	                    this._bindArrowEvents();
	                    for (let i = 0; i < this._monthsPerView; i++) {
	                        this._setArrowMainElement(data.month[i].navigationBar);
	                    }
	                }
	            }
	            if ((firstRender || [ 'commandBar', 'monthsPerView' ].indexOf(modifiedAttr) > -1) && this._isBtns) {
	                this._updateCommandBar(elem);
	            }
	            if (isRendered || modifiedAttr === 'monthsPerView' || isDropdown) {
	                let calendar = elem.find('.zdatetimepicker__month'); // No I18N
	                if (opts.selectionType === 'multiple') { // No I18N
	                    calendar.attr('aria-multiselectable', true); // No I18N
	                } else {
	                    calendar.removeAttr('aria-multiselectable'); // No I18N
	                }
	            }
	            if (firstRender || modifiedAttr === 'displayType') {
	                this._pointer = this._opts.displayType === 'callout' ? elem.find('.zdatetimepicker__pointer') : undefined; // No I18N
	            }
	            if (opts.title && (firstRender || modifiedAttr === 'title')) {
	                this._enableDrag && this._initDraggable();
	                this._setCloseEle();
	                this._enableDrag = undefined;
	            }
	        }
	        this._adjustCustomHTMLPos();
	        this._doesExist(this._clear) && this._setClearBtnCls(undefined, undefined, true);
	        this._setPosition && this._isShown && this._positionPicker(); // No I18N
	        if (isNavButtons) {
	            for (let i = 0; i < this._monthsPerView; i++) {
	                this._updateArrowState(data.month[i].viewDate, i);
	            }
	        }
	        let viewMode = this._viewMode;
	        if (this._isDrilldown && viewMode && (opts.navigationBar.monthSwitcher || opts.navigationBar.yearSwitcher)) {
	            this._updateYearArrowState(viewMode, viewMode < 3 ? viewMode < 2 ? this._viewDate.getFullYear() : this._yearStart : this._decadeStart);
	        }
	        this._data.modifiedAttr = this._data._isRenderedAgain = this._setPosition = undefined;
	    }
	    _hasClosest(event, toFind, curTarget) {
	        let target = curTarget ? event.currentTarget : event.target;
	        return $(target).closest(toFind).length;
	    }
	    _clearValues(event) {
	        let opts = this._opts,
	            immediateCommit = opts.immediateCommit,
	            arr = [ 'zdatetimepicker__calendar', 'zdatetimepicker__drilldowncell' ]; // No I18N
	        if (immediateCommit) {
	            this._valueUpdate = false;
	            opts.value = undefined;
	            opts.values = [];
	        }
	        this._setHours(true);
	        for (let i = 0; i < 2; i++) {
	            let elems = this.element.find('.' + arr[i]).find(this._getSelector());
	            this._select(false, elems, true);
	            elems.removeAttr('aria-disabled');// No I18N
	        }
	        this._setDateClass('is-disabled', false, this.element.find('.zdatetimepicker__calendar').find(this._getSelector()), true);// No I18N
	        this._selectedDates = [];
	        this._queryString = ''; // No I18N
	        this._currentSelected = undefined;
	        this._render();
	        immediateCommit && this._dispatchEvent('change', event, this._getSelectedValue()); // No I18N
	    }
	    _cancelClickHandler(orgEvent) {
	        if (this._clearClickHandler) { // check is added for rangePickers, where clearValues() is not necessary
	            this._clearClickHandler(orgEvent, true);
	        } else {
	            // Used in case if clearButton is false and values should be cleared
	            this._clearValues(orgEvent);
	        }
	        this._closePicker(orgEvent);
	        this._dispatchEvent('cancel', orgEvent, this._getSelectedValue()); // No I18N
	        this._removeFocus(this._cancel);
	    }
	    _bindEvents() {
	        this._addEvents({
	            mousedown: 'mousedown', // No I18N
	            mouseover: 'mouseover', // No I18N
	            keydown: 'keydown' // No I18N
	        });
	    }
	    _keydownHandler(orgEvent) {
	        if (orgEvent.keyCode === ZC.keyCode.ESCAPE) {
	            this._closePicker(orgEvent);
	        }
	    }
	    _mouseoverHandler(orgEvent) {
	        let arr = [ 'date', 'adjacentmonthdate' ], // No I18N
	            target = $(orgEvent.target),
	            relatedTarget = $(orgEvent.relatedTarget),
	            pickerCls = 'zdatetimepicker__', // No I18N
	            isNotSpan; // No I18N
	        // added because datemouseover is called two times for both span and td
	        isNotSpan = !relatedTarget.hasClass(`${pickerCls}text`) && !target.hasClass(`${pickerCls}text`); // No I18N
	        for (let i = 0; i < arr.length; i++) {
	            if (isNotSpan && this._hasClosest(orgEvent, `.${pickerCls}` + arr[i])) { // No I18N
	                this._dispatchEvent('datemouseover', orgEvent, { // No I18N
	                    cell: target,
	                    date: new Date(+target.attr('data-time')) // No I18N
	                });
	                break;
	            }
	        }
	    }
	    _validateFormat() {
	        this._checkFormat(/h|H|m|t/g); // No I18N
	    }
	    _checkFormat(partsRegex) {
	        this._invalidFormat = partsRegex.test(this._opts.format);
	    }
	    getElement() {
	        return this.element;
	    }
	    _reInitPicker() {
	        this._opts = $.extend(true, {}, this._DEFAULTS, this._userOptions);
	        this._init(this.element, this._opts, true);
	    }
	    open(forElement) {
	        let opts = this._opts;
	        if (!this._isShown && (opts.type === 'inline' || opts.forElement || opts.offset)) {
	            /* Resetting the today date if changed */
	            if (!ZC.Date.areDatesEqual(this._todayDate, new Date())) {
	                this._reInitPicker();
	            }
	            forElement && this._setAttribute('forElement', forElement);// No I18N
	            this._showPicker();
	        }
	    }
	    close() {
	        this._manualClose = true;
	        this._closePicker();
	        this._manualClose = false;
	    }
	    _getBtnsArr() {
	        return [ 'today', 'clear', 'cancel', 'OK' ]; // No I18N
	    }
	    _resetTime(datesObject) {
	        if (datesObject instanceof Date) {
	            let date = new Date(+datesObject);
	            date.setHours(0, 0, 0, 0);
	            return date;
	        }
	    }
	    _dispatchChangeEvent(ev, type, val) {
	        this._dispatchEvent(type + 'change', ev, {// No I18N
	            viewDate: this._viewDate,
	            value: this._opts.value,
	            selectedValue: val === undefined ? this._viewDate.getFullYear() : val
	        });
	    }
	    _arrowEventHandler(ev) {
	        let id = ev.currentTarget.id;
	        if (id.indexOf('month') > -1) { // No I18N
	            let index = parseInt(id.slice(-1)),
	                str = index === 0 ? 'MonthArrow' : index === 1 ? 'Year' : 'DecadeArrow'; // No I18N
	            this['_handle' + str + 'Click'](ev); // No I18N
	        } else {
	            this._opts.navigationBar.yearNavigationButtons && this._handleYearArrowClick(ev);
	        }
	    }
	    _checkIfButtonsExist() {
	        let opts = this._opts;
	        return opts.OKButton || opts.todayButton || opts.cancelButton || opts.clearButton;
	    }
	    _isBig(part, date) {
	        let isTrue = ZC.Date.isGreater(this['_' + part + 'Date'], date); // No I18N
	        return part === 'max' ? !isTrue : isTrue; // No I18N
	    }
	    _moveMonth(date, moveBy) {
	        if (!(date && !isNaN(+date)) || !moveBy) {
	            return moveBy ? this._viewDate : date;
	        }
	        let newDate = new Date(date.valueOf()),
	            day = newDate.getDate(),
	            month = newDate.getMonth(),
	            newMonth,
	            monthVal,
	            isTrue,
	            lessThanZero = moveBy < 0;
	        if (lessThanZero || moveBy >= 1) {
	            newMonth = month + moveBy;
	            newDate.setMonth(newMonth);
	            newMonth = (newMonth + 12) % 12;
	        }
	        monthVal = newDate.getMonth();
	        isTrue = date.getFullYear() === newDate.getFullYear();
	        while (lessThanZero ? monthVal === month && isTrue : monthVal !== newMonth) {
	            isTrue = true;
	            newDate.setDate(--day);
	            newDate.setMonth(newMonth);
	            monthVal = newDate.getMonth();
	        }
	        return newDate;
	    }
	    _showPicker() {
	        let elem = this.element,
	            opts = this._opts;
	        this._dragEnd = false;
	        if (this._dispatchEvent('beforeopen', undefined, this._getObj())) { // No I18N
	            if (opts.type !== 'inline' && ZC.bindDocumentEvents && opts.closeOnBodyClick) { // No I18N
	                ZC.bindDocumentEvents({
	                    element: elem,
	                    forElement: this._forElement,
	                    ctype: this.name,
	                    closeMethodName: 'close', // No I18N
	                    closeEvent: 'close' // No I18N
	                });
	            }
	            if (elem.finish) {
	                elem.finish()
	            } else {
	                elem.stop(true, true);
	            }
	            let animate = Object.keys(opts.animation).length ? opts.animation.open : false;
	            if (animate) {
	                this._setAnimation('open'); // No I18N
	            }
	            /* name check added for effects given. Effect will not be visible if the display is called in the next line itself */
	            if (!animate || !animate.name) {
	                this._display();
	            }
	            this._positionPicker();
	            if (!animate) {
	                this._openHandler();
	            }
	        }
	    }
	    _openHandler() {
	        this._isShown = true;
	        let elem = this.element,
	            dispatchEvent = this._dispatchEvent.bind(this);
	        elem.attr({
	            'aria-hidden': false, // No I18N
	            'aria-expanded': true // No I18N
	        });
	        if (dispatchEvent('beforefocus', {}, elem)) { // No I18N
	            clearTimeout(this._focusTimeout);
	            this._focusTimeout = setTimeout(() => elem.focus(), 100);
	        }
	        dispatchEvent('open', undefined, this._getObj()); // No I18N
	    }
	    _positionPicker() {
	        let $element = this.element,
	            element = $element[0],
	            opts = this._opts,
	            offset = opts.offset;
	        $element.width(opts.width || '');
	        // element.style.width = element.style.width || '';// No I18N
	        if (opts.type === 'popup') { // No I18N
	            if (this._monthsPerView === 3 && ZC._display === 'flex') { // No I18N
	                /* If there is no enough space in the prvious position, then setting width will make the picker shrinken.
	                Hence, top and left values are set for calculating correct width value */
	                $element.css({
	                    top: 0,
	                    left: 0
	                });
	                $element.css('flex-direction', 'column');// No I18N
	                $element.width($element.width());
	                $element.css('flex-direction', ''); // No I18N
	            }
	            if (offset) {
	                $element.css(offset);
	            } else if (opts.forElement) {
	                let position = this._getPosition(),
	                    direction,
	                    pointerElem = this._pointer ? this._pointer[0] : null;
	                if (position) {
	                    direction = position.direction;
	                    this._direction = direction;
	                    opts.displayType !== 'callout' && $element.addClass('zdatetimepicker--' + direction.replace('-', '')); // No I18N
	                    if (opts.margin) {
	                        position.elementPosition = this._retrieveMarginValues(position.elementPosition);
	                    }
	                    let posValue = position.elementPosition;
	                    element.style.top = posValue.top + 'px';// No I18N
	                    element.style.left = posValue.left + 'px';// No I18N
	                    if (pointerElem) {
	                        let arrowPos = position.arrowPosition;
	                        pointerElem.style.top = typeof arrowPos.top === 'number' ? arrowPos.top + 'px' : '';// No I18N
	                        pointerElem.style.left = typeof arrowPos.left === 'number' ? arrowPos.left + 'px' : ''; // No I18N
	                    }
	                }
	            }
	        }
	    }
	    _retrieveMarginValues(position) {
	        let margin = this._opts.margin,
	            arr = [ 'top', 'left' ], // No I18N
	            value;
	        for (let i = 0; i < 2; i++) {
	            value = position[arr[i]];
	            value += typeof margin === 'number' ? margin : margin[arr[i]] || 0; // No I18N
	            position[arr[i]] = value < 0 ? position[arr[i]] : value;
	        }
	        return position;
	    }
	    _arrowCallback(element, direction) {
	        let elem = this.element,
	            pickerCls = 'zdatetimepicker--'; // No I18N
	        elem.removeClass(pickerCls + 'top ' + pickerCls + 'bottom ' + pickerCls + 'left ' + pickerCls + 'right ' + pickerCls + 'topleft ' + pickerCls + 'topright ' + pickerCls + 'bottomleft ' + pickerCls + 'bottomright'); // No I18N
	        elem.addClass(pickerCls + direction); // No I18N
	        this._calloutDirection = direction;
	    }
	    _getPosition() {
	        let opts = this._opts,
	            position = ZC.Position,
	            positionAlterable = opts.positionAlterable;
	        if (position && !this._dragEnd) {
	            let base = this;
	            return position.get(this._forElement, this.element, {
	                direction: this._direction || opts.position,
	                bufferSpace: 6,
	                rtl: opts.rtl,
	                positionAlterable,
	                arrow: {
	                    element: this._pointer,
	                    callback: this._arrowCallback.bind(base),
	                    margin: {
	                        left: -1,
	                        top: -1
	                    }
	                }
	            });
	        }
	    }
	    _getSelector() {
	        return '.is-selected,.is-disabled:not(.zdisabled)'; // No I18N
	    }
	    _isGreater(first, second) {
	        return ZC.Date.isGreater(first, second) && !ZC.Date.areDatesEqual(first, second);
	    }
	    _setHours(notAssign) {
	        !notAssign && (this._viewDate = new Date());
	        this._viewDate.setHours(0, 0, 0, 0);
	    }
	    _updateValues() {
	        if (this._valueUpdate) {
	            let opts = this._opts,
	                value = opts.value,
	                values = opts.values,
	                minTime = this._minTime,
	                date = new Date();
	            if (opts.selectionType === 'multiple') { // No I18N
	                this._handleMultipleSelectOnClose();
	            }
	            let selectedDates = this._selectedDates,
	                selectedLen = selectedDates.length;
	            // Revisit - later
	            date.setHours(minTime ? minTime.getHours() : 0, minTime ? minTime.getMinutes() : 0, 0, 0);
	            this._viewDate = value ? new Date(+value) : values && values.length && selectedLen ? new Date(+selectedDates[selectedLen - 1]) : date;
	            (opts.minDate || opts.maxDate) && this._checkLimits();
	        } else {
	            this._resetValues();
	        }
	    }
	    _resetValues() {
	        let opts = this._opts;
	        this._valueUpdate = false;
	        opts.value = this._currentSelected = this._selectedTime = undefined;
	        opts.values = this._selectedDates = [];
	        this._setDateClass([ 'is-disabled', 'is-selected' ], false, this.element.find('.zdatetimepicker__calendar').find(this._getSelector()), true); // No I18N
	        this.element.find('.zdatetimepicker__drilldowncell').find(this._getSelector()).removeClass('is-disabled', 'is-selected');
	        this._queryString = ''; // No I18N
	        // Added so that on picker close when the view date is modified, viewDate switches back to current date
	        this._setHours();
	        this._doesExist(this._clear) && this._traverseBtns('clearButton', 'is-disabled', true); // No I18N
	        this._render();
	        (this._minDate || this._maxDate) && this._checkViewDate(new Date(+this._viewDate));
	        (opts.monthToBeShownOnOpen || opts.yearToBeShownOnOpen) && this._setViewOnOpen();
	    }
	    _getObj() {
	        return {
	            viewMode: this._viewMode,
	            element: this.element
	        };
	    }
	    _closePickerHandler(orgEvent) {
	        if (this._dispatchEvent('beforeclose', orgEvent, this._getObj())) {// No I18N
	            let animation = this._opts.animation,
	                animate = Object.keys(animation).length ? animation.close : false
	            if (animate) {
	                this._setAnimation('close', orgEvent); // No I18N
	            } else {
	                this._closeHandler();
	            }
	        }
	    }
	    _closeHandler(evObj) {
	        this._display(true);
	        this._isShown = false;
	        this.element.attr({
	            'aria-hidden': true, // No I18N
	            'aria-expanded': false // No I18N
	        });
	        this._dispatchEvent('close', evObj, this._getObj()); // No I18N
	    }
	    _changeMonth(isRender, date, val) {
	        let opts = this._opts,
	            index = opts.selectedDateMonthViewIndex;
	        if (this._monthsPerView > 1 && index >= (val || 0)) {
	            this._viewDate = this._moveMonth(date || opts.value, -index);
	            isRender === undefined && (isRender = true);
	        }
	        isRender && this._buildData(true);
	    }
	    _refreshPicker() {
	        let isDrilldown = this._isDrilldown, // No I18N
	            viewmode,
	            viewdate = this._viewDate,
	            sameYear = this._oldDate.getFullYear() === this._viewDate.getFullYear();
	        viewmode = isDrilldown && this._getViewMode();
	        if (viewmode !== this._viewMode || (this._oldDate.getMonth() !== viewdate.getMonth() && sameYear) || !sameYear) {
	            isDrilldown && this._setViewMode(viewmode, true);
	            this._doNotBuildTime = true;
	            this._buildData(true);
	            isDrilldown && this._addDisabledCls();
	        }
	        isDrilldown && this._removeEffects();
	    }
	    _closePicker(orgEvent) {
	        if (this._isShown) {
	            let viewdate = this._viewDate,
	                opts = this._opts,
	                value = opts.value,
	                closepickerHandler = this._closePickerHandler.bind(this);
	            if (viewdate) {
	                if (opts.selectionType === 'multiple' && opts.values.length === 0 && opts.immediateCommit) { // No I18N
	                    this._valueUpdate = false;
	                }
	                let curSelected = this._currentSelected;
	                if (curSelected && value && !ZC.Date.areDatesEqual(curSelected, value)) {
	                    this._select(false, this._currentSelectedEle, true, true);
	                }
	                this._oldDate = new Date(+viewdate);
	                this._currentSelected = value ? new Date(+value) : undefined;
	                this._updateValues();
	                if (opts.type !== 'inline' || this._manualClose) { // No I18N
	                    closepickerHandler(orgEvent);
	                }
	                this._refreshPicker();
	                opts.selectedDateMonthViewIndex !== undefined && opts.value && this._changeMonth();
	                if (opts.value && this._viewDate) {
	                // It's unary plus
	                    this._doesExist(this._clear) && this._traverseBtns('clearButton', 'is-disabled', false); // No I18N
	                    this._select(true, this.element.find('[data-time="' + +this._resetTime(opts.value) + '"]'), false, true);// No I18N
	                }
	            } else {
	                closepickerHandler(orgEvent);
	            }
	        }
	    }
	    _getBoolVal(part, date) {
	        let optVal = this['_' + part + 'Date'];
	        if (optVal) {
	            optVal = new Date(+optVal);
	            !this._checkTime && optVal.setHours(0, 0, 0);
	            let isEqual = ZC.Date.areDatesEqual(date, optVal)
	            return (part === 'min' ? +date > +optVal : +date < +optVal) || isEqual; // No I18N
	        }
	        return true;
	    }
	    _dateWithInRange(date) {
	        !this._checkTime && date.setHours(0, 0, 0);
	        return this._getBoolVal('min', date) && this._getBoolVal('max', date); // No I18N
	    }
	    _getDateElem(date, elem = this.element) {
	        // it is unary plus
	        return elem.find("[data-time='" + +date + "']");// No I18N
	    }
	    _getFirstDate() {
	        let dates = this._data.month[0].dates[0],
	            i;
	        for (i = 0; i < dates.length; i++) {
	            if (dates[i].text !== '' && dates[i].class.indexOf('zdatetimepicker__date') > -1) {
	                break;
	            }
	        }
	        return dates[i].time;
	    }
	    _mousedownHandler(orgEvent) {
	        let target = $(orgEvent.target),
	            opts = this._opts,
	            disabledCls = 'is-disabled', // No I18N
	            dispatch,
	            selectedVal,
	            time,
	            mode = this._viewMode,
	            arr = [ '.zdatetimepicker__date', '.zdatetimepicker__adjacentmonthdate' ], // No I18N
	            hasMonthCls,
	            adjDates = opts.allowSelectionOfAdjacentMonthDates,
	            hasYearCls,
	            selectedDate, renderDate,
	            allowSpan;
	        if (target.is('.zdatetimepicker__text, .zdatetimepicker__secondaryinfo')) { // No I18N
	            allowSpan = !target.closest('.zdatetimepicker__date, .zdatetimepicker__adjacentmonthdate').hasClass(disabledCls); // No I18N
	        }
	        if (!target.is(`.zdatetimepicker__date:not(.${disabledCls}), .zdatetimepicker__adjacentmonthdate:not(.${disabledCls}), .zdatetimepicker__monthview:not(.${disabledCls}), .zdatetimepicker__year:not(.${disabledCls}), .zdatetimepicker__decade:not(.${disabledCls})`) && !allowSpan) { // No I18N
	            return;
	        }
	        orgEvent.preventDefault();
	        for (let i = 0; i < 2; i++) {
	            if (this._hasClosest(orgEvent, arr[i])) { // No I18N
	                target = target.closest(arr[i]); // No I18N
	                break;
	            }
	        }
	        selectedVal = this._translateAToE(target.text());
	        hasYearCls = target.hasClass('zdatetimepicker__year'); // No I18N
	        hasMonthCls = target.hasClass('zdatetimepicker__monthview'); // No I18N
	        time = target.attr('data-time'); // No I18N
	        time && (selectedDate = new Date(parseInt(time))); // No I18N
	        if (target.hasClass('zdatetimepicker__date') && selectedDate) { // No I18N
	            this._setDate(orgEvent, target, selectedDate);
	        } else if (adjDates && target.hasClass('zdatetimepicker__adjacentmonthdate') && selectedDate) { // No I18N
	            this._setDate(orgEvent, target, selectedDate);
	            this._viewDate = new Date(+selectedDate);
	            this._changeMonth(true, selectedDate);
	            if ([ 'single', 'multiple' ].indexOf(opts.selectionType) > -1 && !target.hasClass('is-selected')) { // No I18N
	                this._select(true, this._getDateElem(selectedDate), true, true); // No I18N
	            }
	        } else if (hasMonthCls || hasYearCls) {
	            /* this event is added for a request by a team (to prevent date rendering after clicking a month with drilldownlevelonopen with months,
	               since they don't need dates and want to show something else while clicking a month */
	            renderDate = this._dispatchEvent('before' + (hasMonthCls ? 'month' : 'year') + 'change', orgEvent, { // No i18n
	                viewDate: this._viewDate,
	                value: opts.value,
	                selectedValue: hasMonthCls ? parseInt(target.attr('data-value')) : parseInt(selectedVal) // No I18N
	            });
	            renderDate = renderDate !== false;
	            renderDate && (dispatch = this._handleMousedownOnDrillDown(orgEvent, hasMonthCls, hasYearCls, selectedVal));
	        } else if (target.hasClass('zdatetimepicker__decade')) { // No I18N
	            this._handleDecadeMousedown(orgEvent, mode, selectedVal);
	            dispatch = 'decade'; // No I18N
	        }
	        renderDate && dispatch && this._dispatchEvent(dispatch + 'change', orgEvent, {// No I18N
	            viewDate: this._viewDate,
	            value: opts.value,
	            selectedValue: hasMonthCls ? parseInt(target.attr('data-value')) : parseInt(selectedVal) // No I18N
	        });
	    }
	    _select(doSelect, elem, doNotRender, addCls) {
	        let type = doSelect ? 'add' : 'remove'; // No I18N
	        for (let i = 0, len = elem.length; i < len; i++) {
	            let ele = $(elem[i]);
	            if (this._doesExist(ele)) {
	                if (doSelect) {
	                    ele.attr('aria-selected', true); // No I18N
	                } else {
	                    ele.removeAttr('aria-selected'); // No I18N
	                }
	                if (ele.hasClass('zdatetimepicker__date') || ele.hasClass('zdatetimepicker__adjacentmonthdate')) { // No I18N
	                    this._setDateClass('is-selected', doSelect, ele, doNotRender)// No I18N
	                } else if (ele.is('.zdatetimepicker__year,.zdatetimepicker__monthview')) {
	                    this._setDrilldownClass(ele);
	                } else {
	                    addCls = true
	                }
	                addCls && ele[type + 'Class']('is-selected'); // No I18N
	            }
	        }
	    }
	    _getDateData(ele) {
	        let monthData = this._data.month,
	            val = this._getDateEleIndex(ele),
	            dateData;
	        monthData[val[0]] && monthData[val[0]].dates[val[1]] && (dateData = monthData[val[0]].dates[val[1]][val[2]]);
	        // (data-time value is checked because, for reinit case on mousedown, dates will be same but the element will be different)
	        return dateData && dateData.time === +ele.attr('data-time') ? dateData : undefined; // No I18N
	    }
	    _getDateEleIndex(ele) {
	        return [ this._monthsPerView === 1 ? 0 : ele.closest('.zdatetimepicker__list').index(), ele.closest('tr').index(), ele.index() ]; // No I18N
	    }
	    _setDateClass(cls, add, elem, doNotRender) {
	        typeof cls !== 'object' && (cls = [ cls ]);
	        for (let i = 0, len = elem.length; i < len; i++) {
	            let ele = $(elem[i]),
	                dateObj = this._getDateData(ele);
	            if (dateObj) { // Trying to change the date object produces issue if the data is rebuilt. (clearSelection)
	                let prevCls = dateObj.class + ' ';
	                prevCls = add ? prevCls + cls.join(' ') : prevCls.replace(new RegExp(cls.join('|'), 'g'), '');
	                dateObj.class = prevCls.trim();
	            }
	        }
	        !doNotRender && this._render();
	    }
	    _setDate(orgEvent, target, date) {
	        let opts = this._opts,
	            obj,
	            immediateCommit = opts.immediateCommit,
	            time = +date;
	        immediateCommit && (this._valueUpdate = false); // Delayed commit doesn't reset value on date select
	        this._limitReached = false;
	        if (this._doesExist(this._clear)) {
	            this._traverseBtns('clearButton', 'is-disabled', false); // No I18N
	            this._disable(false, this._clear);
	        }
	        if (opts.selectionType === 'single') { // No I18N
	            this._select(false, this.element.find('.is-selected')); // No I18N
	            this._currentSelected = new Date(time);
	            this._viewDate = new Date(time);
	            this._currentSelectedEle = target;
	            !target.closest('.zdatetimepicker__adjacentmonthdate').length && this._select(true, target); // No I18N
	            if (immediateCommit) {
	                opts.value = new Date(time);
	                this._OKClickHandler(orgEvent, true);
	            }
	            obj = {
	                valueString: ZC.Date.formatDate(opts.value, opts.format),
	                value: opts.value,
	                selectedDate: this._viewDate
	            };
	        } else {
	            obj = this._setMultipleDate(...arguments);
	        }
	        obj && this._dispatchEvent('dateselect', orgEvent, obj); // No I18N
	    }
	    _fillDates(data, dateVal, index) {
	        data.dates = [];
	        data.weekNumbers = [];
	        let opts = this._opts,
	            element = this.element,
	            value = new Date(dateVal || this._viewDate),
	            year = value.getFullYear(),
	            month = value.getMonth(),
	            prevMonth = new Date(year, month),
	            nextMonth,
	            prevDate = prevMonth.getDate(),
	            firstDay = prevMonth.getDay(),
	            rowCount = 0,
	            adjMonthDates = opts.displayAdjacentMonthDates,
	            frstDayOfWeek = opts.firstDayOfWeek,
	            monthsPerView = this._monthsPerView;
	        // Added since Date Object considers two digit year in 1900's
	        year < 100 && prevMonth.setFullYear(year);
	        prevMonth.setDate(prevDate - (prevMonth.getDay() - frstDayOfWeek + 7) % 7);
	        let list = element.closest('li.zdatetimepicker__list'); // No I18N
	        index = typeof index === 'number' ? index : index === undefined ? list.length ? list.index() : -1 : index; // No I18N
	        nextMonth = new Date(prevMonth);
	        if ([ -1, 1, 2 ].indexOf(index) > -1 || index === 0 && !adjMonthDates) {
	            nextMonth.setDate(nextMonth.getDate() + 42);
	        } else if (monthsPerView > 1 && adjMonthDates && index === 0) {
	            let noOfDaysInPrev = new Date(year, prevMonth.getMonth() + 1, 0).getDate(),
	                noOfDays = new Date(year, month + 1, 0).getDate();
	            nextMonth.setDate((firstDay === frstDayOfWeek ? 0 : noOfDaysInPrev) + noOfDays + 1);
	        }
	        nextMonth.setHours(0, 0, 0, 0);
	        prevMonth.setHours(0, 0, 0, 0);
	        nextMonth = nextMonth.valueOf();
	        let firstThursday,
	            trArray = [];
	        for (let i = prevMonth; i.valueOf() < nextMonth; i.setDate(i.getDate() + 1)) {
	            let weekDay = i.getDay(),
	                iYr = i.getFullYear(),
	                iMonth = i.getMonth();
	            i.setHours(0, 0, 0, 0);
	            let shouldAddElement = adjMonthDates && ([ -1, 0, 2 ].indexOf(index) > -1 || index === 1 && monthsPerView === 2) || iMonth <= month && iYr === year || iYr < year,
	                totDays = new Date(iYr, iMonth + 1, 0).getDate(),
	                lastDate = new Date(nextMonth),
	                isTrue;
	            lastDate.setDate(lastDate.getDate() - 1);
	            isTrue = iMonth === month && i.getDate() === totDays && (!adjMonthDates || adjMonthDates && index === 1 && monthsPerView === 3) || ZC.Date.areDatesEqual(i, lastDate) && adjMonthDates;
	            if (weekDay === frstDayOfWeek && shouldAddElement) {
	                // Week number calculated as per IS0 8601 standard.
	                let weekStart = new Date(+i + (frstDayOfWeek - weekDay - 7) % 7 * 86400000),
	                    thursdayWeek = new Date(+weekStart + (7 + 4 - weekStart.getDay()) % 7 * 86400000);
	                firstThursday = new Date(Number(firstThursday = new Date(thursdayWeek.getFullYear(), 0, 1)) + (7 + 4 - firstThursday.getDay()) % 7 * 86400000);
	                let weekNumber = (thursdayWeek - firstThursday) / 86400000 / 7 + 1;
	                data.weekNumbers.push(this._translateEToA(weekNumber));
	                // length is checked or else extra row will be created
	                if (trArray.length) {
	                    this._pushDateArr(data, trArray);
	                }
	                trArray = [];
	                rowCount++;
	            }
	            if (!adjMonthDates || index === 1 && index !== monthsPerView - 1 || index === monthsPerView - 1) {
	                if (iMonth < month && iYr === year || iYr < year) {
	                    trArray.push({
	                        'class': '', // No I18N
	                        text: '' // No I18N
	                    });
	                    continue;
	                } else if ((iMonth > month && iYr === year || iYr > year) && (index === -1 || adjMonthDates && (index === 0 || index === 1 && index !== monthsPerView - 1) || !adjMonthDates)) {
	                    break;
	                }
	            }
	            let returnVal = this._getClasses(i, value),
	                cellContent = {
	                    'class': (returnVal.class || returnVal).trim(), // No I18N
	                    time: +i,
	                    text: this._translateEToA(i.getDate()),
	                    title: returnVal.title || null,
	                    infoText: returnVal.infoText || null
	                };
	            this._dispatchEvent('beforedatecellrender', undefined, cellContent); // No I18N
	            trArray.push(cellContent);
	            if (isTrue) {
	                this._pushDateArr(data, trArray);
	            }
	        }
	        this._rowsCount.push(rowCount);
	    }
	    _pushDateArr(data, trArray) {
	        /* Included this method for extending the adjacent date behavior for the usecase of projects team */
	        data.dates.push(trArray);
	    }
	    _setMonthVal(name, val, add) {
	        for (let i = 0; i < this._monthsPerView; i++) {
	            let month = this._data.month[i];
	            if (add === undefined) {
	                month[name] = val;
	            } else {
	                month[name] = add ? month[name] + val : month[name].replace(/zdatetimepicker--adjacentmonthdatereadonly/g, '');
	            }
	        }
	    }
	    _constructNavBar(month, i, newDate) {
	        let navBar = this._opts.navigationBar,
	            isDrilldown = this._isDrilldown, // No I18N
	            isButtons = navBar.monthNavigationButtons || navBar.yearNavigationButtons;
	        month.navigationBar = $.extend(true, {}, month.navigationBar || navBar);
	        isButtons && this._getNavBtnProps(month, i, month.navigationBar);
	        let curNav = month.navigationBar;
	        !isButtons && (curNav.class = '');
	        curNav.cursorCls = i === 0 && isDrilldown && (navBar.monthSwitcher || navBar.yearSwitcher) ? 'zh-cursorpointer' : ''; // No I18N
	        if (this._isDropdown && i === 0) {
	            this._constructDropdown(curNav);
	        }
	        /* Commented because it causes issue when reinit happens in daterangepicker. Since anyways bindings will be done in posteachrender */
	        // if (this._data.modifiedAttr === 'navBar') {
	        //     isButtons && this._setArrowMainElement(curNav);// No I18N
	        //     this._isDropdown && this._assignHeaders();
	        // }
	        let monthSwitch = navBar.monthSwitcher,
	            yearSwitch = navBar.yearSwitcher,
	            monthNav = month.navigationBar,
	            isDropdown = this._isDropdown,
	            isTrue = isDropdown && i !== 0;
	        (!isDropdown || isTrue || i === 0 && !monthSwitch) && (monthNav.month = this._translateEToA(this._getI18NText('months' + (navBar.monthYearHeadingFormat.split(' ').indexOf('MMMM') > -1 ? '' : 'Abbreviated'))[newDate.getMonth()])); // No I18N
	        (!isDropdown || isTrue || i === 0 && !yearSwitch) && (monthNav.year = this._translateEToA(newDate.getFullYear()));
	        if (navBar.monthYearHeadingFormat[0] === 'y') {
	            isDropdown && (i === 0) && (monthNav.yrFirst = monthNav.monthSelect && monthNav.yearSelect);
	            if (monthNav.month && monthNav.year) {
	                let temp = monthNav.month;
	                monthNav.month = monthNav.year;
	                monthNav.year = temp;
	            }
	        }
	        this._setConditions(monthNav);
	    }
	    _setConditions(navBar) {
	        navBar.isLMonthYear = navBar.lMonth || navBar.lYear;
	        navBar.isRMonthYear = navBar.rMonth || navBar.rYear;
	        navBar.isMonthYearNav = navBar.month || navBar.year;
	        return navBar;
	    }
	    _OKClickHandler(orgEvent, isNotSubmit, doNotClose) {
	        let shouldClose,
	            opts = this._opts,
	            isZeroViewMode = this._viewMode === 0,
	            currentSelected = this._currentSelected,
	            okBtn = this._OK,
	            isSingle = opts.selectionType === 'single', // No I18N
	            limit = opts.selectionLimit,
	            length = this._selectedDates.length,
	            condtn = currentSelected || length,
	            selectedTime = this._selectedTime;
	        this._valueUpdate = !!condtn;
	        if (isSingle) {
	            let date = new Date();
	            currentSelected && (date = new Date(+currentSelected));
	            this._checkTime && selectedTime && date.setHours(selectedTime.getHours(), selectedTime.getMinutes(), 0, 0);
	            opts.value = currentSelected ? date : undefined;
	        } else {
	            shouldClose = limit && limit === length && isZeroViewMode || this._hasClosest(orgEvent, '.OKButton-' + this.name);// No I18N
	            this._handleOkOnMultiple(opts);
	        }
	        this._dispatchEvent('change', orgEvent, this._getSelectedValue()); // No I18N
	        shouldClose = isSingle ? (isNotSubmit && opts.closeOnDateSelect && isZeroViewMode && !doNotClose || !isNotSubmit) : shouldClose;
	        if (shouldClose) {
	            this._closePicker(orgEvent);
	        }
	        this._valueUpdate = opts.value || opts.values.length;
	        okBtn && this._removeFocus(okBtn);
	    }
	    _getSelectedValue() {
	        return this._opts.selectionType === 'single' ? this._getSingleValue(this._opts.value) : this._getMultipleValues(); // No I18N
	    }
	    _removeFocus(elem) {
	    // To remove the classes added by _handleFocus() in zgeneral-main.
	        elem.removeClass('has-focus has-mfocus');// No I18N
	    }
	    _isWeekend(date) {
	        return (this._opts.weekendDays ? this._opts.weekendDays.split(',') : []).indexOf(date.getDay().toString()) > -1;
	    }
	    _getClasses(date, dateToCompare) {
	        let secondYear,
	            secondMonth,
	            isYrsEqual,
	            isFrstYrBig,
	            opts = this._opts,
	            isEqual = ZC.Date.areDatesEqual.bind(ZC),
	            selectedDates = this._selectedDates,
	            len = selectedDates.length,
	            curSelected = this._currentSelected,
	            cls = ' zdatetimepicker', // No I18N
	            firstYear = date.getFullYear(),
	            firstMonth = date.getMonth(),
	            classes = '';// No I18N
	        if (dateToCompare) {
	            secondYear = dateToCompare.getFullYear();
	            secondMonth = dateToCompare.getMonth();
	            isYrsEqual = firstYear === secondYear;
	            isFrstYrBig = firstYear > secondYear;
	        }
	        if (dateToCompare && !isFrstYrBig && !isYrsEqual || isYrsEqual && firstMonth < secondMonth || (isYrsEqual && firstMonth > secondMonth || isFrstYrBig)) {
	            classes += cls + '__adjacentmonthdate'; // No I18N
	        } else {
	            classes += cls + '__date'; // No I18N
	        }
	        isEqual(date, new Date()) && (classes += cls + '--today'); // No I18N
	        let condtn = curSelected && isEqual(date, curSelected);
	        if (condtn || opts.value && isEqual(date, opts.value) && condtn) {
	            classes += ' is-selected'; // No I18N
	        }
	        if (len && opts.selectionType === 'multiple') { // No I18N
	            let isSelected = false;
	            for (let i = 0; i < len; i++) {
	                if (selectedDates[i] && isEqual(date, selectedDates[i])) {
	                    classes += ' is-selected'; // No I18N
	                    isSelected = true;
	                }
	            }
	            if (!isSelected && opts.selectionLimit === len) {
	                classes += ' is-disabled'; // No I18N
	            }
	        }
	        if (this._isWeekend(date)) {
	            classes += cls + '--weekend'; // No I18N
	        }
	        if (!this._dateWithInRange(date)) {
	            classes += ' is-disabled zdisabled'; // No I18N
	        }
	        return this._getUniqueClass(date, classes, true) || classes;
	    }
	    _getUniqueClass(date, classes, checkBoth) {
	        let arr = [
	            'disabledDaysOfWeek', // No I18N
	            'disabledDates', // No I18N
	            'disabledMonths', // No I18N
	            'disabledYears'// No I18N
	        ];
	        if (classes) {
	            // since for value setting, these two need not to be used, classes check is added
	            arr = [ ...arr, 'specialDates', 'specialDaysOfWeek' ]; // No I18N
	        }
	        arr = arr.map((val) => !!this._opts[val].length);
	        return arr.indexOf(true) > -1 ? this._addUniqueClasses(date, classes, !checkBoth) : undefined;
	    }
	    _parseDateValue(date, pattern) {
	        return ZC.Date._parseDateValue(date, pattern, this._opts.otherInputFormats) || {};
	    }
	    _fillDayOfWeek(month) {
	        month.days = [];
	        let start = this._opts.firstDayOfWeek,
	            classes = '',
	            i18nTxt = this._getI18NText('daysAbbreviated'), // No I18N
	            weekend = this._opts.weekendDays.split(','); // No I18N
	        for (let i = start; i < start + 7; i++) {
	            classes = '';
	            if (i % 7 === parseInt(weekend[0]) || i % 7 === parseInt(weekend[1])) {
	                classes += ' zdatetimepicker--weekend'; // No I18N
	            }
	            month.days.push({
	                value: this._translateEToA(i18nTxt[ i % 7 ]), // No I18N
	                'class': ' zdatetimepicker__day ' + classes // No I18N
	            });
	        }
	    }
	    _doesExist(element) {
	        return element && element.length;
	    }
	    _parseValue(optionName, value, format) {
	        let isModified,
	            opts = this._opts,
	            parseDate = this._parseDateValue.bind(this),
	            date;
	        format = format || opts.format;
	        if (typeof value === 'string') { // No I18N
	            if ([ 'TODAY', 'NOW' ].indexOf(value) > -1) { // No I18N
	                this['_' + optionName + 'HasTime'] = value === 'NOW' && optionName !== 'value'; // No I18N
	                opts[optionName] = new Date();
	            } else {
	                date = parseDate(value, format).date || undefined;
	                if (date) {
	                    opts[optionName] = date;
	                    this['_' + optionName + 'HasTime'] = true; // if datestring is given with time, then the date will be valid and so it is set true
	                } else {
	                    date = parseDate(value, this._dateFormat).date || undefined;
	                    opts[optionName] = date || undefined;
	                }
	            }
	            isModified = true;
	        } else if (value instanceof Date) {
	            opts[optionName] = value;
	            this['_' + optionName + 'HasTime'] = true; // No I18N
	            isModified = true;
	        } else {
	            this._oldValueOption && (isModified = true);
	            opts[optionName] = undefined;
	        }
	        date = opts[optionName];
	        if (date && !this._checkTime) {
	            date.setHours(0, 0, 0, 0);
	        }
	        return isModified;
	    }
	    _setValue(value, shouldRender) {
	        let opts = this._opts,
	            isTrue = true;
	        if (value === '' || !value) {
	            this._setHours();
	            (this._minDate || this._maxDate) && this._checkViewDate(new Date(+this._viewDate));
	            this._clearValues();
	        } else if (value) {
	            this._parseValue('value', value, this._opts.format) && opts.value && !this._checkTime && opts.value.setHours(0, 0, 0, 0); // No I18N
	            if (this._isNotNull(opts.value) && this._dateWithInRange(opts.value) && !this._getUniqueClass(opts.value)) { // No I18N
	                this._currentSelected = new Date(+opts.value);
	                this._viewDate = new Date(+opts.value);
	                this._valueUpdate = true;
	            } else {
	                isTrue = false;
	                opts.value = this._oldValueOption;
	            }
	        }
	        shouldRender && isTrue && this._buildData(true);
	        return isTrue;
	    }
	    _checkViewDateWithMax(date) {
	        /* Checking for the disabled month being shown for monthsperView more than 1 if maxDate is given */
	        let max = new Date(+this._maxDate);
	        date = new Date(+date);
	        max.setMonth(max.getMonth() - (this._monthsPerView - 1));
	        /* Since, all dates will not be available in all months, both dates are kept equal to 1 for checking the month value. Since, month alone is needed for setting the view */
	        date.setDate(1);
	        max.setDate(1);
	        while (+date > +max) {
	            date.setMonth(date.getMonth() - 1);
	        }
	        this._viewDate = date;
	    }
	    getValue() {
	        return this._getSingleValue(this._opts.value);
	    }
	    _getSingleValue(value) {
	        let opts = this._opts,
	            valueString = ZC.Date.formatDate(value, opts.format);
	        return {
	            value,
	            valueString,
	            translatedValue: this._translateEToA(ZC.Date.formatDate(value, opts.format, opts.labels))
	        };
	    }
	    setValue(dateString) {
	        this._opts.selectionType === 'single' && this._setValue(dateString, true); // No I18N
	    }
	    _setAttribute(optionName, value, pickerEle) {
	        let opts = this._opts,
	            isTrue = true,
	            data = this._data,
	            elem = this.element;
	        this._oldValue = opts[optionName];
	        this._oldValueOption = opts.value;
	        if (opts[optionName] instanceof Array) {
	            this._oldOpts = {};
	            this._oldOpts[optionName] = opts[optionName].slice();
	        }
	        opts[optionName] = value;
	        this._userOptions[optionName] = value;
	        if (optionName === 'format') { // No I18N
	            this._validateFormat();
	            if (this._invalidFormat) {
	                isTrue = false;
	            } else {
	                this._setFormat();
	                opts.value && this._setDate(undefined, this._getDateElem(+this._resetTime(opts.value), pickerEle), opts.value); // No I18N
	            }
	        } else if (optionName === 'forElement') { // No I18N
	            this._forElement = value ? $(value) : undefined;
	        } else if ([ 'monthsPerView', 'locale', 'navigationBar', 'drilldownLevelOnOpen', 'value', 'weekendDays' ].indexOf(optionName) > -1) { // No I18N
	            let shouldRender = true;
	            if (optionName === 'value' && opts.selectionType === 'single') {// No I18N
	                shouldRender = this._setValue(opts.value)
	            }
	            if (optionName === 'monthsPerView') {// No I18N
	                data.modifiedAttr = 'monthsPerView';// No I18N
	                this._getBtnsArr().forEach((value) => {
	                    this['_' + value] = null;
	                });
	                if (value > 0 && value <= 3) { // No I18N
	                    this._monthsPerView = value;
	                    this._isBtns && this._createButtons();
	                } else {
	                    shouldRender = false;
	                }
	            }
	            if (optionName === 'drilldownLevelOnOpen') { // No I18N
	                this._viewMode = this._isDrilldown ? this._getViewMode() : 0; // No I18N
	                this._data.modifiedAttr = 'drilldownLevel'; // No I18N
	                if (value === 'dates') {
	                    let drillType = this._oldValue.slice(0, -1);
	                    elem.find('.zdatetimepicker__' + drillType + 'container')[0].style.display = 'none';
	                    elem.find('.zdatetimepicker__days')[0].style.display = 'flex';
	                }
	            }
	            if (optionName === 'navigationBar') { // No I18N
	                if (this._isDrilldown) {
	                    $(elem.find('.zdatetimepicker__monthyearnav')[0]).off('click.' + this.name);
	                } else if (this._isDropdown) {
	                    this._destroyDropdown();
	                }
	                this._setSwitcherType(value);
	                this._data.modifiedAttr = 'navBar'; // No I18N
	                if (this._data.month.length) {
	                    for (let i = 0; i < this._monthsPerView; i++) {
	                        this._data.month[i].navigationBar = null;
	                    }
	                }
	            }
	            this._reInit = shouldRender;
	            isTrue = shouldRender;
	        } else if (optionName === 'position') { // No I18N
	            this._isPositionModified = true;
	            this._validateOpts();
	        } else {
	            isTrue = this._setAttrs(...arguments);
	        }
	        // This line of code is added for calling positionPicker in postEachRender only when it is needed.
	        !this._setPosition && (this._setPosition = [ 'monthsPerView', 'forElement', 'position', 'minDate', 'maxDate', 'displayType', 'customHTML', 'displayWeekNumbers', 'yearToBeShownOnOpen', 'monthToBeShownOnOpen', 'width', 'height', 'rtl' ].indexOf(optionName) > -1 || [ 'commandBar', 'title' ].indexOf(data.modifiedAttr) > -1); // No I18N
	        this._domChanged = isTrue;
	        return isTrue;
	    }
	    _destroy() {
	        let setUndefined = this._setUndefined.bind(this),
	            opts = this._opts;
	        Object.keys(opts.animation).length && ZC.clearAnimationData(this.element);
	        // if focusTimeout called after destroy() called
	        clearTimeout(this._focusTimeout);
	        if (this._isDropdown) {
	            this._destroyDropdown();
	        }
	        this._data.customHTML && this._handleCustomHTML(true);
	        if (opts.draggable && this.element.data('zdraggable')) { // No I18N
	            ZC.draggable(this.element).destroy();
	        }
	        if (this.isCE) {
	            this.element.removeClass(this._data.className).empty();
	        }
	        this._rowsCount = this._selectedDates = [];
	        setUndefined([ 'focusTimeout', 'forElement' ], ''); // No I18N
	        setUndefined([ 'view', 'min', 'max' ], 'Date'); // No I18N
	        setUndefined([ '', 'month', 'year', 'dec ade' ], 'navBar'); // No I18N
	        setUndefined([ 'month', 'year', 'decade' ], 'DrillDownElement'); // No I18N
	        setUndefined([ 'month', 'year' ], 'Header'); // No I18N
	        setUndefined(this._getBtnsArr(), ''); // No I18N
	        setUndefined([ 'monthsPerView', 'currentSelected', 'monthYearNav', 'leftNav', 'rightNav', 'closeButton', 'footer' ], ''); // No I18N
	    }
		_setAnimation  (type) {
		    ZC.animationHandler({
		        action: type,
		        animation: this._opts.animation,
		        element: this.element,
		        ctype: this.name,
		        callback: type === 'close' ? this._closeHandler.bind(this) : this._openHandler.bind(this) // No I18N
		    });
		};
		_clearClickHandler  (orgEvent, doNotTrigger) {
		    let clearBtn = this._clear,
		        doesExist = this._doesExist(clearBtn);
		    if (orgEvent && !$(orgEvent.target).closest(clearBtn).hasClass('is-disabled') || !orgEvent) { // No I18N
		        doesExist && this._removeFocus(clearBtn); /* setting class through traverseBtns() is removed since it is handled in posteachrender */
		        this._clearValues(orgEvent);
		        !doNotTrigger && doesExist && this._dispatchEvent('clear', orgEvent, { // No I18N
		            valuesObject: [],
		            values: []
		        });
		    }
		};
		_setClearBtnCls  (obj, noVal, set) {
		    obj = obj || this._traverseBtns('clearButton', undefined, undefined, true); // No I18N
		    noVal = noVal === undefined ? (this._opts.selectionType === 'single' ? !this._currentSelected : this._selectedDates && this._selectedDates.length === 0) : noVal; // No I18N
		    let clearbtn = this._clear;
		    if (this._doesExist(clearbtn)) {
		        if (noVal) {
		            obj.className.indexOf('is-disabled') === -1 && (obj.className += ' is-disabled'); // No I18N
		        } else {
		            obj.className.replace(/is-disabled/g, '');
		        }
		        set && this._disable(!!noVal, clearbtn);
		    }
		};
		_getCloseProps  (obj) {
		    obj.closeSVGProps = ZC.ZButton.getBtnProps({
		        className: 'zdatetimepicker__close', // No I18N
		        defaultIconClassName: 'zdatetimepicker__icon', // No I18N
		        iconClassName: this._opts.closeIconClassName,
		        SVGIconId: this._opts.closeSVGIconId,
		        defaultSVGIconId: 'zc__svg--close', // No I18N
		        mainElement: this._closeButton ? this._closeButton[0] : null,
		        templateRender: true
		    });
		    return obj;
		}
		_setCloseEle  () {
		    let elem = this.element,
		        opts = this._opts;
		    if (opts.closeButton && opts.type !== 'inline') { // No I18N
		        if (!this._closeButton || !this._closeButton.length) {
		            this._closeButton = elem.find('.zdatetimepicker__close'); // No I18N
		            this._data.title.closeSVGProps.mainElement = this._closeButton[0];
		            this._closeButton && this._addEvents({
		                closeClick: 'click' // No I18N
		            }, this._closeButton);
		        }
		    }
		}
		_closeClickHandler  (orgEvent) {
		    this._closePicker(orgEvent);
		    this._removeFocus(this._closeButton);
		}
		_setBtnProps  () {
		    let btns = this._getBtnsArr(),
		        label,
		        opts = this._opts; // No I18N
		    for (let i = 0; i < btns.length; i++) {
		        label = btns[i] + 'ButtonLabel'; // No I18N
		        this['_' + label] = opts[label] || this._getI18NText(label);
		    }
		    opts.buttonsAlignment = ZC.buttonsAlignment || 'right';// No I18N
		};
		_setBtnVal  () {
		    let btns = this._getBtnsArr(),
		        footer = this._footer;
		    for (let i = 0; i < btns.length; i++) {
		        let btn = '_' + btns[i],
		            handler = btns[i] + 'Click', // No I18N
		            elem = footer.find('.' + btns[i] + 'Button-' + this.name); // No I18N
		        if (elem.length) {
		            this[btn] = elem;
		            this._handleFocus(this[btn]);
		            this._addEvents({
		                [handler]: 'click' + (btn === '_today' ? ' keydown' : '') // No I18N
		            }, elem);
		        }
		    }
		    this._OK && (this._OKButton = !!this._OK.length);
		};
		_createButtons  () {
		    this._data.cBar = {};
		    if (this._isColumnExists()) {
		        this._generateCustomCols();
		    } else {
		        this._autoGenSingleColBtns();
		    }
		    let obj = this._traverseBtns('clearButton', undefined, undefined, true); // No I18N
		    if (this._opts.clearButton && obj) {
		        this._setClearBtnCls(obj);
		    }
		}
		_updateCommandBar  (elem) {
		    (!this._footer || !this._footer.length) && (this._footer = elem.find('.zdatetimepicker__commandbar'));// No I18N
		    this._isBtns && this._setBtnVal();
		    this._traverseBtns();
		}
		_traverseBtns  (name, cls, shoudlAdd, returnObj) {
		    let isGreaterThan1 = this._monthsPerView > 1,
		        cBar = this._data.cBar;
		    for (let pos in cBar) {
		        let posArr = cBar[pos];
		        if (Array.isArray(posArr)) {
		            for (let i = 0, l = posArr.length; i < l; i++) {
		                let arr = posArr[i],
		                    btnObj = isGreaterThan1 ? arr.left || arr.right || arr.center || arr : arr; // No I18N
		                if (btnObj) {
		                    if (isGreaterThan1 && btnObj instanceof Array) {
		                        for (let j = 0, len = btnObj.length; j < len; j++) {
		                            let obj = btnObj[j];
		                            if (returnObj && obj.name && obj.name === name) {
		                                return obj;
		                            } else if (!returnObj) {
		                                this._setBtnMainElement(name, cls, shoudlAdd, obj);
		                            }
		                        }
		                    } else if (returnObj && btnObj.name && btnObj.name === name) {
		                        return btnObj
		                    } else if (!returnObj) {
		                        this._setBtnMainElement(name, cls, shoudlAdd, btnObj);
		                    }
		                }
		            }
		        }
		    }
		}
		_setBtnMainElement  (name, cls, shoudlAdd, obj) {
		    let btn = obj.name ? obj.name.replace('Button', '') : undefined; // No I18N
		    if (btn) {
		        let elem = this['_' + btn]; // No I18N
		        if (shoudlAdd !== undefined && name === obj.name) {
		            let clsName = obj.className + ' ',
		                regExp = new RegExp(cls, 'g');
		            obj.className = shoudlAdd ? clsName + cls : clsName.replace(regExp, '');
		        } else {
		            this._doesExist(elem) && (obj.mainElement = this['_' + btn][0]);
		        }
		    }
		}
		_autoGenSingleColBtns  () {
		    let cBar = this._getCommandBarData.bind(this),
		        opts = this._opts,
		        count = 0,
		        buttons, index,
		        alignment = opts.buttonsAlignment,
		        isToday = opts.todayButton,
		        isOK = opts.OKButton,
		        getIndex = this._getIndex.bind(this);
		    if (this._monthsPerView < 3) {
		        buttons = this._getBtnsArr().map((val) => val + 'Button'); // No I18N
		        for (let i = 0; i < buttons.length; i++) {
		            count += +opts[buttons[i]];
		        }
		        if (count === 1) {
		            index = getIndex(0);
		            let value = buttons[index];
		            cBar(value === 'todayButton' ? 'center' : 'right', value); // No I18N
		        } else if (count === 2) {
		            index = getIndex(1);
		            let value = buttons[index];
		            if (isToday) {
		                cBar('left', 'todayButton'); // No I18N
		                cBar('right', value); // No I18N
		            } else if (isOK && index !== 3) {
		                if (opts.clearButton) {
		                    cBar('left', value); // No I18N
		                    cBar('right', 'OKButton'); // No I18N
		                } else {
		                    cBar('right', [ value, 'OKButton' ]); // No I18N
		                }
		            } else {
		                cBar('left', 'clearButton'); // No I18N
		                cBar('right', 'cancelButton'); // No I18N
		            }
		        } else if (count === 3) {
		            buttons = [ 'today', 'OK', 'clear', 'cancel' ]; // No I18N
		            index = getIndex(2, buttons); // No I18N
		            if (isOK) {
		                cBar('right', 'OKButton'); // No I18N
		                if (isToday) {
		                    cBar('right', buttons[index] + 'Button', 0); // No I18N
		                }
		            }
		            if (isToday) {
		                cBar('left', 'todayButton'); // No I18N
		            } else {
		                cBar('left', 'clearButton'); // No I18N
		                this._data.cBar.right.length && cBar('right', 'cancelButton', 0); // No I18N
		            }
		        } else if (count === 4) {
		            cBar('left', 'clearButton'); // No I18N
		            cBar('center', 'todayButton'); // No I18N
		            cBar('right', [ 'cancelButton', 'OKButton' ]); // No I18N
		        }
		    } else {
		        buttons = [ 'clear', 'today', 'cancel', 'OK' ]; // No I18N
		        alignment !== 'right' && (buttons = buttons.reverse()); // No I18N
		        getIndex(0, buttons, alignment);
		    }
		};
		_getIndex  (start, arr, alignment) {
		    arr = arr || this._getBtnsArr();
		    let buttons = arr.map((val) => val + 'Button'); // No I18N
		    for (let i = start; i < buttons.length; i++) {
		        if (this._opts[buttons[i]]) {
		            if (alignment) {
		                this._getCommandBarData(alignment, buttons[i]);
		            } else {
		                return i;
		            }
		        }
		    }
		}
		_getCommandBarData  (position, button, index, column) {
		    let isCol,
		        cBar = this._data.cBar;
		    isCol = cBar && cBar.cols && cBar.cols.length !== 0;
		    let commandBar = isCol ? column : cBar;
		    if (typeof index === 'number') {
		        commandBar[position].splice(index, 0, this._getbtnAttr(button)); // No I18N
		    } else {
		        if (!(button instanceof Array)) {
		            button = [ button ];
		        }
		        button = button.map((value) => this._getbtnAttr(value)); // No I18N
		        !commandBar[position] && (commandBar[position] = []);
		        commandBar[position].push(...button);
		    }
		};
		_getbtnAttr  (btn) {
		    let btnName = btn.replace('Button', ''),
		        label = this['_' + btn + 'Label'];
		    // ## revisit
		    return ZC.ZButton.getBtnProps({
		        customAttributes: {
		            name: btn,
		            'aria-label': label // No I18N
		        },
		        name: btn,
		        isLink: btnName === 'today', // No I18N
		        className: (btnName === 'today' ? 'zdatetimepicker__todaylink ' : ' ') + btn + '-' + this.name, // No I18N
		        text: label, // No I18N
		        appearance: btn === 'OKButton' ? 'primary' : 'normal', // No I18N
		        size: 'small', // No I18N
		        isCE: this.isCE,
		        tabindex: 0,
		        templateRender: true
		    });
		}
		_generateCustomCols  () {
		    let commandBar = this._data.cBar,
		        opts = this._opts,
		        isGreaterThan1 = this._monthsPerView > 1,
		        layout = opts.commandBar,
		        count = 0,
		        arr = [ 'left', 'center', 'right' ]; // No I18N
		    this._itemsList = [];
		    if (isGreaterThan1) {
		        commandBar.colClass = 'zdatetimepicker--threecolumn'; // No I18N
		        commandBar.cols = [];
		    }
		    for (let i = 0; i < 3; i++) {
		        let column = layout[arr[i] + 'Column'];
		        isGreaterThan1 && (commandBar.cols[i] = {});
		        if (column) {
		            let commands = column.commands;
		            if (isGreaterThan1) {
		                commandBar.cols[i].className = column.className;
		            }
		            for (let j = 0; j < commands.length; j++) {
		                let command = commands[j],
		                    shouldCreate = true;
		                if (command === 'OK' || command === 'cancel') {
		                    shouldCreate = !opts.immediateCommit;
		                    shouldCreate && (this._OKButton = true);
		                }
		                if (shouldCreate && this._itemsList.indexOf(command) === -1) {
		                    this._getCommandBarData(column.halign, command + 'Button', undefined, isGreaterThan1 ? commandBar.cols[i] : undefined);
		                    this._itemsList[count++] = command;
		                }
		            }
		        }
		    }
		};
		_insertHTML  (val, opt) {
		    let elem = $(this._opts[val]);
		    this['_' + opt] = elem.parent();
		    if (elem.length) {
		        elem.show(); // No I18N
		        elem.addClass('zdatetimepicker--custom'); // No I18N
		    }
		    return elem;
		}
		_insertHTMLAboveCalendar  () {
		    let elem = this._insertHTML('customHTMLAboveCalendar', 'aboveCalendarParent') // No I18N
		    elem.length && elem.insertBefore(this.element.find('.zdatetimepicker__month')); // No I18N
		}
		_insertHTMLAboveNavigationBar  () {
		    let elem = this._insertHTML('customHTMLAboveNavigationBar', 'aboveNavbarParent') // No I18N
		    if (elem.length) {
		        if (this._opts.title) {
		            elem.insertAfter(this.element.find('.zdatetimepicker__titlebar')); // No I18N
		        } else {
		            elem.prependTo(this.element);
		        }
		    }
		}
		_insertHTMLBelowCalendar  () {
		    let elem = this._insertHTML('customHTMLBelowCalendar', 'belowCalendarParent'); // No I18N
		    if (elem.length) {
		        elem.insertAfter(this._monthsPerView === 1 ? this.element.find('.zdatetimepicker__monthcontainer').last() : this.element.find('.zdatetimepicker__container')); // No I18N
		    }
		}
		_handleCustomHTML  (hide) {
		    let arr = [ 'BelowCalendar', 'AboveCalendar', 'AboveNavigationBar' ], // No I18N
		        value;// No I18N
		    for (let i = 0; i < 3; i++) {
		        value = this._opts['customHTML' + arr[i]];// No I18N
		        if (value) {
		            if (hide === undefined) {
		                this['_insertHTML' + arr[i]]();// No I18N
		            } else {
		                value = $(value);
		                value.appendTo($('body')); // No I18N
		                if (hide) {
		                    value.hide();
		                }
		            }
		        }
		    }
		}
		_fillDecades  (firstView) {
		    // Revisit - If you have time combine _fillYears & fillDecades in to a single function
		    let element = this.element,
		        orgEvent,
		        yearEle = this._yearDrillDownElement;
		    if (firstView.type !== undefined) {
		        firstView.stopPropagation();
		        firstView.preventDefault();
		        orgEvent = firstView;
		    }
		    !yearEle && this._fillYears(orgEvent);
		    this._fireDrilldownEv(true, orgEvent); // No I18N
		    let yearStart = Math.floor(this._viewDate.getFullYear() / 100) * 100,
		        yearEnd = yearStart + 90;
		    if (this._yearDrillDownElement) {
		        this._buildDrilldownView({
		            view: 'decade', // No I18N
		            year: this._translateEToA(yearStart + ' - ' + yearEnd),
		            fn: [ 'buildYearDecadeBody', yearStart - 10, yearEnd + 20, 10 ] // No I18N
		        }, 3, orgEvent);
		    }
		    this._setViewMode(3, typeof firstView === 'boolean', element); // No I18N
		    this._decadeStart = yearStart;
		    this._fireDrilldownEv(false, orgEvent, this._decadeDrillDownElement);
		};
		_getDecadeClasses  (decade, index) {
		    let cls = ' zdatetimepicker__', // No I18N
		        classes = cls + (index === 1 || index === 12 ? 'drilldownnearlevelcell' : 'monthyeargrid') + cls + 'decade ', // No I18N
		        min = this._minDate,
		        max = this._maxDate; // No I18N
		    if (decade < 10 || min && decade < Math.floor(min.getFullYear() / 10) * 10 || max && decade > Math.floor(max.getFullYear() / 10) * 10) {
		        classes += ' is-disabled zdisabled'; // No I18N
		    }
		    return classes;
		}
		_handleDecadeMousedown  (orgEvent, mode, selectedVal) {
		    this._viewDate.setFullYear(parseInt(selectedVal));
		    if (mode !== 0) {
		        this._setViewMode(mode - 1);
		        // re-assigned because viewmode changes when setViewMode() is called
		        mode = this._viewMode;
		        mode === 2 && this._fillYears(orgEvent);
		    }
		}
		_initDraggable  () {
		    let handler = this._dragHandler.bind(this),
		        pickerCls = '.zdatetimepicker__'; // No I18N
		    if (this._opts.type !== 'inline') { // No I18N
		        ZC.draggable(this.element, {
		            handle: pickerCls + 'titlebar', // No I18N
		            ignore: pickerCls + 'close', // No I18N
		            container: 'window', // No I18N
		            cursor: 'default',  // No I18N
		            start: handler.bind(this, 'start'), // No I18N
		            drag: handler.bind(this, ''), // No I18N
		            end: handler.bind(this, 'end') // No I18N
		        });
		    }
		}
		_dragHandler  (type, orgEvent, ui) {
		    this._dispatchEvent('drag' + type, orgEvent, ui);	 // No I18N
		    type === 'end' && (this._dragEnd = true); // No I18N
		}
		_getViewMode  () {
		    let opts = this._opts,
		        clsName = 'zdatetimepicker--disabledcalendar', // No I18N
		        arr = [ 'dates', 'months', 'years', 'decades' ], // No I18N
		        valueUpdate = this._valueUpdate,
		        index = arr.indexOf(opts.drilldownLevelOnOpen);
		    valueUpdate && this.element.find('.' + clsName).removeClass(clsName); // No I18N
		    return valueUpdate ? 0 : index > -1 ? index : undefined;
		};
		_generateContent  (element) {
		    // used for drilldownLevelOnOpen option
		    if (this._isDrilldown) { // No I18N
		        let arr = [ 'Months', 'Years', 'Decades' ], // No I18N
		            fillType = arr[this._viewMode - 1];
		        fillType && this['_fill' + fillType](true, element);
		    }
		}
		_drilldownClickHandler  (ev) {
		    let target = $(ev.currentTarget),
		        isRendered = false,
		        cls = 'zdatetimepicker__', // No I18N
		        containerCls = '.' + cls + 'monthcontainer', // No I18N
		        len = this.element.find('.' + cls + 'days').length; // No I18N
		    if (this._hasClosest(ev, containerCls, true)) { // No I18N
		        let container = target.closest(containerCls); // No I18N
		        if (target.hasClass(cls + 'monthyearnav')) { // No I18N
		            if (container.hasClass(cls + 'monthdrilldown') && this._opts.navigationBar.yearSwitcher) { // No I18N
		                this._fillYears(ev);
		                isRendered = true;
		            } else if (container.hasClass(cls + 'yeardrilldown')) { // No I18N
		                this._fillDecades(ev);
		                isRendered = true;
		            }
		        }
		    }
		    // Removing len === 1 check since when monthsPerView is 1 len will be 1 by default
		    if (!isRendered && (this._monthsPerView === 1 || (target.closest('li.' + cls + 'list').index() === 0 && (len === 3 || len === 2)))) { // No I18N
		        this._monthYearNavClickHandler(ev);
		    }
		    this._adjustCustomHTMLPos(); /* Since on drilldown, order of DOM elements will be changed */
		};
		_monthYearNavClickHandler  (orgEvent, element) {
		    let arr = [ 'month', 'Months', 'year', 'Years' ],
		        navBar = this._opts.navigationBar; // No I18N
		    for (let i = 0; i < 4; i += 2) {
		        let isTrue = this._viewMode === (arr[i] === 'month' ? 0 : navBar.monthSwitcher ? 1 : 0);
		        if (isTrue && navBar[arr[i] + 'Switcher']) { // No I18N
		            orgEvent.stopPropagation();
		            this['_fill' + arr[i + 1]](orgEvent, element); // No I18N
		            break;
		        }
		    }
		};
		_getDrilldownData  (data, index) {
		    this._viewMode = index;
		    let view = data.view,
		        month = this._data.month[0],
		        fn = data.fn,
		        width = this._opts.drilldownLevelOnOpen === 'dates' ? this._width || this.element.find('.zdatetimepicker__calendar').outerWidth() : null, // No I18N
		        drilldown = {
		            view,
		            cells: this['_' + fn[0]](fn[1], fn[2], fn[3]), // No I18N
		            style: `display:none;width:${width}px`, // No I18N
		            navigationBar: this._getDrilldownNavBar(data, index, view)
		        };
		    month[view + 'Drilldown'] = drilldown; // No I18N
		    return month[view + 'Drilldown'];
		}
		_setMainEle  (navBar) {
		    let lmonth = navBar.lMonthIcon,
		        rMonth = navBar.rMonthIcon;
		    lmonth.mainElement = $('#' + lmonth.id).length ? $('#' + lmonth.id) : null; // No I18N
		    rMonth.mainElement = $('#' + rMonth.id).length ? $('#' + rMonth.id) : null; // No I18N
		}
		_buildDrilldownView  (data, index) {
		    let view = data.view,
		        drilldown = this._getDrilldownData(...arguments),
		        isBinded = this['_' + view + 'EventBinded'],
		        navBar = drilldown.navigationBar;
		    if (!isBinded) {
		        this._setMainEle(navBar);
		    }
		    this._render(); // No I18N
		    if (!isBinded) {
		        this['_' + view + 'EventBinded'] = true;
		        view !== 'decade' && this._bindDrillDownClickEvent(view); // No I18N
		        this._bindDrilldownNavBarEvent(index);
		        this._setMainEle(navBar);
		        this['_' + view + 'DrillDownElement'] = this.element.find('.zdatetimepicker__' + view + 'drilldown'); // No I18N
		    }
		};
		_bindDrilldownNavBarEvent  (index) {
		    let arrowId = [ '-left-month-', '-right-month-' ];// No I18N
		    for (let i = 0; i < 2; i++) {
		        this._addEvents({// No I18N
		            arrowEvent: 'click'// No I18N
		        }, $('#' + this._elementId + arrowId[i] + index)); // No I18N
		    }
		}
		_bindDrillDownClickEvent  (view, elem = this.element) {
		    elem = view ? elem.find('.zdatetimepicker__' + view + 'drilldown') : elem; // No I18N
		    this._addEvents({ // No I18N
		        drilldownClick: 'click' // No I18N
		    }, $(elem.find('.zdatetimepicker__monthyearnav')[0])); // No I18N
		}
		_getDrilldownNavBar  (data, index, view) {
		    let navBar = this._data.month[0][view + 'Drilldown'] ? this._data.month[0][view + 'Drilldown'].navigationBar : null,
		        defaultNavBar = this._opts.navigationBar,
		        lMonthIcon = navBar ? navBar.lMonthIcon : this._lMonthIcon,
		        rMonthIcon = navBar ? navBar.rMonthIcon : this._rMonthIcon,
		        isSplit = this._opts.navigationBar.navigationButtonsDisplayPattern === 'split', // No I18N
		        labels = [ 'month', 'Year', 'Decade', 'Century' ], // No I18N
		        label;
		    if (!lMonthIcon || !rMonthIcon) { /* When monthNavigationButtons or yearNavigationButtons is set false */
		        navBar = this._getMonthNavBtnProps(null, defaultNavBar)
		    }
		    lMonthIcon = $.extend(true, {}, lMonthIcon || navBar.lMonthIcon);
		    rMonthIcon = $.extend(true, {}, rMonthIcon || navBar.rMonthIcon);
		    label = this._getI18NText('prev' + labels[index]);
		    lMonthIcon = {
		        ...lMonthIcon,
		        id: this._elementId + '-left-month-' + index, // No I18N
		        customAttributes: {
		            'aria-label': label, // No I18N
		            title: label
		        }
		    }
		    label = this._getI18NText('next' + labels[index]);
		    rMonthIcon = {
		        ...rMonthIcon,
		        id: this._elementId + '-right-month-' + index, // No I18N
		        customAttributes: {
		            'aria-label': label, // No I18N
		            title: label
		        }
		    }
		    return this._setConditions({
		        year: this._translateEToA(data.year || this._viewDate.getFullYear()),
		        monthYearSwitcherType: 'drilldown', // No I18N
		        isSplit, // No I18N
		        lMonth: true,
		        rMonth: true,
		        cursorCls: view !== 'decade' && defaultNavBar.yearSwitcher ? 'zh-cursorpointer' : '', // No I18N
		        'class': isSplit ? '' : ' zdatetimepicker__navbaractionsonright', // No I18N
		        navBtnCls: 'zdatetimepicker__navbutton', // No I18N
		        lMonthIcon,
		        rMonthIcon
		    });
		};
		_updateYearArrowState  (viewMode, year) {
		    year = typeof year === 'number' ? year : this._viewDate.getFullYear(); // No I18N
		    let factor,
		        id = this._elementId;
		    viewMode && (factor = Math.pow(10, viewMode - 1));
		    let right = this._maxDate && year + factor > Math.floor(this._maxDate.getFullYear() / factor) * factor || false;
		    $('#' + id + '-right-month-' + viewMode).toggleClass('is-disabled', right); // No I18N
		    let left = year <= 1 || this._minDate && year - factor < Math.floor(this._minDate.getFullYear() / factor) * factor || false;
		    $('#' + id + '-left-month-' + viewMode).toggleClass('is-disabled', left);	 // No I18N
		}
		_buildYearDecadeBody  (yearStart, yearEnd, incrementer) {
		    let j = 1,
		        cells = [];
		    for (let i = yearStart; i < yearEnd; i = i + incrementer, j++) {
		        cells.push({
		            'class': this['_get' + (incrementer === 10 ? 'Decade' : 'Year') + 'Classes'](i, j), // No I18N
		            value: i >= 1 ? this._translateEToA(i) : '',
		            attr: i >= 1 ? i : ''
		        });
		        if (j !== 12 && j % 4 === 0) {
		            cells.push({
		                isTr: true
		            });
		        }
		    }
		    return cells;
		};
		_setViewMode  (viewMode, preventAnimation, element) {
		    let viewmode = this._prevViewMode,
		        cls = 'zdatetimepicker', // No I18N
		        elem = this.element,
		        eleToAnimate,
		        currentClass = this._getClass(viewmode);
		    element = element || elem;
		    let calendar = $(element.find('.' + cls + '__calendar')[0]);
		    if (viewmode === 0 && this._isShown && calendar.is(':visible')) { // No I18N
		        this._width = calendar.outerWidth(); // No I18N
		    }
		    if (viewmode === 0) {
		        eleToAnimate = $(calendar[0]).find('table'); // No I18N
		    } else {
		        eleToAnimate = element.find('.' + cls + '__' + currentClass).find('.' + cls + '__drilldowncell'); // No I18N
		    }
		    eleToAnimate.removeClass('zeffects--zoomin'); // No I18N
		    !preventAnimation && eleToAnimate.addClass('zeffects--zoomout'); // No I18N
		    this._viewMode = viewMode;
		    this._monthsPerView > 1 && elem.find('.zdatetimepicker__list').nextAll().find('.' + cls + '__month,.' + cls + '__weeknumbers,.' + cls + '__navbar').addClass(cls + '--disabledcalendar'); // No I18N
		    clearTimeout(this._animationTimeout);
		    if (preventAnimation) {
		        this._animationHandler(element, preventAnimation);
		    } else {
		        this._animationTimeout = setTimeout(this._animationHandler.bind(this, element, preventAnimation), 300);
		    }
		};
		_updateMonthClasses  () {
		    let monthCells = this._data.month[0].monthDrilldown.cells;
		    for (let i = 0, j = 0, len = monthCells.length; i < len; i++) {
		        if (monthCells[i].class && monthCells[i].class.indexOf('zdatetimepicker__monthview') > -1) { // No I18N
		            monthCells[i].class = this._getMonthClasses(j);
		            j++;
		        }
		    }
		    this._render(); // revisit
		    this._updateYearArrowState(1);
		}
		_updateMonthDDNav  () {
		    this._data.month[0].monthDrilldown.navigationBar.year = this._translateEToA(this._viewDate.getFullYear());
		}
		_getClass  (viewmode) {
		    let currentClass,
		        arr = [ 'days', 'month', 'year', 'decade' ]; // No I18N
		    if (viewmode <= 4) {
		        currentClass = arr[viewmode];
		        viewmode === 0 && (this._rowsCount = []);
		    }
		    return currentClass + (viewmode === 0 ? '' : 'drilldown'); // No I18N
		};
		_animationHandler  (element, preventAnimation) {
		    let viewmode = this._viewMode,
		        className = this._getClass(viewmode),
		        elementToAnimate,
		        children = this._monthsPerView === 1 ? element.children('div:not(.zdatetimepicker__commandbar):not(.zdatetimepicker__titlebar):not(.zdatetimepicker__pointer):not(.zdatetimepicker__timebar):not(.zdatetimepicker--custom)') // No I18N
		            : $(this.element.find('.zdatetimepicker__container').find('.zdatetimepicker__list')[0]).find('.zdatetimepicker').children(); // No I18N
		    element = this._display(true, children).filter('.zdatetimepicker__' + className); // No I18N
		    elementToAnimate = viewmode === 0 ? $(element.find('.zdatetimepicker__calendar')[0]).find('table') // No I18N
		        : element.find('.zdatetimepicker__drilldowncell'); // No I18N
		    elementToAnimate.removeClass('zeffects--zoomout'); // No I18N
		    !preventAnimation && elementToAnimate.addClass('zeffects--zoomin'); // No I18N
		    this._display(undefined, element);
		    this._positionPicker();
		    this._fireDrilldownEv(undefined, undefined, undefined, true)
		};
		_addDisabledCls  () {
		    let pickerCls = 'zdatetimepicker'; // No I18N
		    if (this._opts.drilldownLevelOnOpen !== 'dates' && this._viewMode !== 0) { // No I18N
		        this.element.find('.zdatetimepicker__list').nextAll().find('.' + pickerCls + '__month,.' + pickerCls + '__weeknumbers,.' + pickerCls + '__navbar').addClass(pickerCls + '--disabledcalendar'); // No I18N
		    }
		}
		_removeEffects  () {
		    this.element.find('.zeffects--zoomin').removeClass('zeffects--zoomin'); // No I18N
		    this.element.find('.zeffects--zoomout').removeClass('zeffects--zoomout'); // No I18N
		}
		_handleMousedownOnDrillDown  (orgEvent, hasMonthCls, hasYearCls, selectedVal) {
		    let opts = this._opts,
		        navBar = opts.navigationBar,
		        viewDate = this._viewDate,
		        target = $(orgEvent.target),
		        mode = this._viewMode;
		    hasMonthCls && viewDate.setMonth(parseInt(target.attr('data-value'))); // No I18N
		    hasYearCls && viewDate.setFullYear(parseInt(selectedVal));
		    navBar.updateDateOnMonthYearSwitch && opts.immediateCommit && this._OKClickHandler(orgEvent, true);
		    if (mode !== 0) {
		        let viewMode = mode - 1;
		        hasYearCls && !navBar.monthSwitcher && (viewMode = 0);
		        this._prevViewMode = this._viewMode;
		        this._setViewMode(viewMode);
		        mode = this._viewMode;
		        this._doNotBuildTime = true;
		        mode === 0 && this._buildData(true);
		        if (mode === 1) {
		            this._updateMonthDDNav();
		            this._updateMonthClasses();
		        }
		    }
		    return hasMonthCls ? 'month' : 'year'; // No I18N
		}
		_fireDrilldownEv  (before, ev, viewElement, after) {
		    this._prevViewMode = this._viewMode;
		    let obj = this._getObj();
		    this._dispatchEvent((before ? 'before' : after ? 'after' : '') + 'drilldown', ev, { // No I18N
		        ...obj,
		        viewElement
		    })
		}
		_setDrilldownClass  (elem) {
		    let month = this._data.month[0],
		        type = elem.is('.zdatetimepicker__year') ? 'year' : 'month', // No I18N
		        obj = month[type + 'Drilldown'].cells[elem.index()]; // No I18N
		    obj.class = obj.class.replace(/is-selected/g, ''); // No I18N
		}
		_generateDropdown  (valueChange, isMonth) {
		    let type = isMonth ? [ 'month', 'Month' ] : [ 'year', 'Year' ], // No I18N
		        navBar = this._data.month[0].navigationBar,
		        selectJSON = navBar[type[0] + 'Select'];
		    if (this._opts.navigationBar[type[0] + 'Switcher']) {
		        if (selectJSON.mainElement) { // No I18N
		            typeof valueChange === 'number' && ZC[isMonth ? 'select' : 'combobox'](this['_' + type[0] + 'Header']).setAttributes({ // No I18N
		                selectedValue: isMonth ? selectJSON.options[valueChange].value : valueChange
		            });
		        } else {
		            this['_generate' + type[1] + 'Dropdown'](navBar); // No I18N
		        }
		    }
		}
		_constructDropdown  (curNav) {
		    curNav.yearSwitcher && !curNav.yearSelect && this._generateYearDropdown(curNav);
		    curNav.monthSwitcher && !curNav.monthSelect && this._generateMonthDropdown(curNav);
		    this._checkOptions();
		}
		_stopSelectEvents  (element) {
		    let events = ZC.ZSelect.prototype._EVENTS;
		    for (let i = 0; i < events.length; i++) {
		        element.on('z' + events[i], (ev) => ev.stopPropagation());
		    }
		}
		_assignHeaders  () {
		    this._assignElement('month'); // No I18N
		    this._assignElement('year');// No I18N
		}
		_assignElement  (type) {
		    if (this._opts.navigationBar[type + 'Switcher']) {// No I18N
		        let element = this['_' + type + 'Header'];
		        if (!element || element && !element.length) {
		            let elem = $('#' + this._elementId + '-' + type + '-header');// No I18N
		            elem = elem ? elem[0] : null;
		            if (elem) {
		                this['_' + type + 'Header'] = $(elem);// No I18N
		            }
		            this._data.month[0].navigationBar[type + 'Select'].mainElement = elem;// No I18N
		        }
		    }
		}
		_buildDropdownNavElement  (monthChanged, yearChanged) {
		    (this._opts.disabledMonths || this._opts.disabledYears) && this._validateDisabledMonthYear();
		    this._generateDropdown(monthChanged, true);
		    this._generateDropdown(yearChanged);
		}
		_validateDisabledMonthYear  () {
		    let arr = [ 'months', 'month', 'Years', 'year' ], // No I18N
		        disabledVal;
		    for (let j = 0; j < arr.length; j += 2) {
		        disabledVal = this._opts['disabled' + arr[j]]; // No I18N
		        let header = this['_' + arr[j + 1] + 'Header'], // No I18N
		            viewVal = this._viewDate[arr[j] === 'months' ? 'getMonth' : 'getFullYear']();// No I18N
		        if (header && disabledVal) {
		            for (let i = 0; i < disabledVal.length; i++) {
		                let type = arr[j] === 'months' ? 'select' : 'combobox'; // No I18N
		                viewVal !== disabledVal[i] && ZC[type](header).setOptionAttributes(disabledVal[i], 'disabled', true); // No I18N
		            }
		        }
		    }
		}
		_setDropdownVal  () {
		    let max = this._maxDate,
		        min = this._minDate,
		        navBar = this._data.month[0].navigationBar,
		        minYr, minMonth, maxYr, maxMonth;
		    if (max) {
		        maxYr = max.getFullYear();
		        maxMonth = max.getMonth();
		    }
		    if (min) {
		        minMonth = min.getMonth();
		        minYr = min.getFullYear();
		    }
		    let arr = [ 'month', 'year' ];// No I18N
		    for (let i = 0; i < 2; i++) {
		        let isYear = arr[i] === 'year';
		        if (this._opts.navigationBar[isYear ? 'yearSwitcher' : 'monthSwitcher']) {// No I18N
		            this[ isYear ? '_setYearDropdownVal' : '_setMonthDropdownVal'](minYr, minMonth, maxYr, maxMonth, navBar);// No I18N
		        }
		    }
		}
		_checkOptions  () {
		    (this._monthHeader || this._yearHeader) && this._setDropdownVal();
		}
		_bindHeaderEvents  (type) {
		    type = $('#' + this._elementId + '-' + type + '-header');
		    if (type.length && this.isCE) {
		        this._stopSelectEvents(type);
		    }
		}
		_destroyDropdown  () {
		    this._monthHeader && ZC.select(this._monthHeader).destroy();
		    this._yearHeader && ZC.combobox(this._yearHeader).destroy();
		    this._monthHeader = this._yearHeader = undefined;
		}
		_selectClickHandler  (orgEvent, ui, element) {
		    ui = !ui && orgEvent ? orgEvent.detail : ui;
		    let viewDate = this._viewDate,
		        isMonth,
		        viewYr = viewDate.getFullYear();
		    if (ui.fromUI) {
		        let selectedVal = ui.selectedValue;
		        // Setting the date as 1 because this resets the limit if max / min date is set
		        viewDate.setDate(1);
		        if (ui.dropdownList) {
		            isMonth = $(ui.dropdownList).attr('id').indexOf('month-header') > -1; // No I18N
		            if (isMonth) {
		                viewDate.setMonth(this._getMonthVal(selectedVal));
		            } else {
		                viewDate.setFullYear(+selectedVal || viewYr);
		            }
		        }
		        (this._minDate || this._maxDate) && this._checkLimitOnDropDown();
		        this._buildData(true);
		        this._checkOptions(selectedVal, element);
		        (this._opts.disabledMonths || this._opts.disabledYears) && this._validateDisabledMonthYear();
		        if (isMonth !== undefined) {
		            this._dispatchChangeEvent(orgEvent, isMonth ? 'month' : 'year', this._viewDate[isMonth ? 'getMonth' : 'getFullYear']()); // No I18N
		        }
		    }
		}
		_checkLimitOnDropDown  () {
		    let arr = [ 'min', 'max' ], // No I18N
		        viewDate = this._viewDate,
		        minDate = this._minDate,
		        yrHeader = this._yearHeader;
		    for (let i = 0; i < 2; i++) {
		        let date = this['_' + arr[i] + 'Date']; // No I18N
		        if (date && this._isBig(arr[i], viewDate)) {
		            viewDate.setFullYear(date.getFullYear());
		            if (arr[i] === 'min') {
		                while (this._isGreater(minDate, viewDate)) {
		                    if (viewDate.getMonth() === minDate.getMonth() && viewDate.getFullYear() === minDate.getFullYear()) {
		                        viewDate.setDate(minDate.getDate());
		                    } else {
		                        viewDate.setFullYear(viewDate.getFullYear() + 1);
		                    }
		                }
		            } else {
		                while (this._isGreater(viewDate, this._maxDate)) {
		                    viewDate.setFullYear(viewDate.getFullYear() - 1);
		                }
		            }
		            yrHeader && ZC.combobox(yrHeader).setAttributes({
		                selectedValue: viewDate.getFullYear()
		            });
		        }
		    }
		}
		_processLimits  () {
		    let parts = [ '_min', '_max' ]; // No I18N
		    for (let i = 0, len = parts.length; i < len; i++) {
		        let part = parts[i];
		        if (this[part + 'DateHasTime']) { // No I18N
		            this[part + 'Time'] = new Date(+this._opts[part.slice(1) + 'Date']); // No I18N
		        }
		        part = part + 'Date'; // No I18N
		        !this._checkTime && this[part] && this[part].setHours(0, 0, 0, 0);
		    }
		}
		_checkMax  (value, opt) {
		    let optVal = this['_' + opt + 'Date'];
		    return opt === 'min' ? this._isGreater(optVal, value) : this._isGreater(value, optVal); // No I18N
		}
		_checkLimits  () {
		    let min = this._minDate,
		        max = this._maxDate,
		        opts = this._opts,
		        value = opts.value,
		        valueChanged,
		        todayDate = new Date();
		    todayDate.setHours(0, 0, 0, 0);
		    if (min && max && ZC.Date.isGreater(min, max) && !ZC.Date.areDatesEqual(min, max)) {
		        opts.maxDate = this._maxDate = undefined;
		    }
		    let arr = [ 'min', 'max' ]; // No I18N
		    for (let i = 0; i < 2; i++) {
		        let part = arr[i],
		            optVal = this['_' + part + 'Date'];
		        if (optVal) {
		            let tempMin = new Date(+min);
		            tempMin.setHours(0, 0, 0, 0);
		            // Revisit
		            if (value) {
		                if (this._checkMax(value, part)) {
		                    this._currentSelected = opts.value = undefined;
		                    valueChanged = true;
		                }
		            } else if (opts.selectionType === 'multiple' && this._selectedDates.length) {
		                valueChanged = this._checkDates(part, tempMin);
		            }
		            if (valueChanged) {
		                this._dispatchEvent('change', undefined, this._getSelectedValue()); // No I18N
		            }
		            if (this._checkMax(this._viewDate, part)) {
		                this._viewDate = new Date(this._isBig(part, todayDate) ? +optVal : +todayDate);
		            } else if (part === 'min') { // No I18N
		                this._setViewDateIfNoVal(part);
		            }
		        }
		    }
		}
		_checkViewDate  (date) {
		    let maxDate = this._maxDate,
		        minDate = this._minDate,
		        opt;
		    maxDate && this._isGreater(this._viewDate, maxDate) && (opt = 'max'); // No I18N
		    minDate && this._isGreater(minDate, this._viewDate) && (opt = 'min');// No I18N
		    if (opt === undefined) {
		        this._setViewDateIfNoVal();// No I18N
		    } else {
		        this._viewDate = new Date(this._isBig(opt, date) ? (minDate ? +minDate : opt === 'max' ? +maxDate : +date) : +date); // No I18N
		    }
		}
		_setViewDateIfNoVal  () {
		    let opts = this._opts,
		        min = this._minDate,
		        max = this._maxDate;
		    if (!opts.value && !opts.values.length && min && (!max || this._isGreater(max, min)) && this._isGreater(min, new Date())) {
		        this._viewDate = new Date(+min);
		    }
		}
		_fillMonths  (firstView) {
		    let orgEvent,
		        element = this.element;
		    firstView && firstView.type !== undefined && (orgEvent = firstView);
		    this._fireDrilldownEv(true, orgEvent);
		    this._buildDrilldownView({
		        view: 'month', // No I18N
		        fn: [ 'buildMonthNavBarBody' ] // No I18N
		    }, 1, orgEvent);
		    // revisit - check if it works for option drilldownLevelOnOpen: 'months'
		    this._setViewMode(1, typeof firstView === 'boolean', element); // No I18N
		    this._fireDrilldownEv(false, orgEvent, this._monthDrillDownElement);
		}
		_buildMonthNavBarBody  () {
		    let monthCells = [];
		    let months = this._opts.navigationBar.monthFormatInSwitcher.indexOf('MMMM') > -1 ? this._getI18NText('months') : this._getI18NText('monthsAbbreviated'); // No I18N
		    for (let i = 0; i < 12; i++) {
		        monthCells.push({
		            'class': this._getMonthClasses(i), // No I18N
		            value: this._translateEToA(months[i]),
		            isTr: false,
		            attr: i + ''
		        });
		        if (i + 1 !== 12 && (i + 1) % 4 === 0) {
		            monthCells.push({
		                isTr: true
		            });
		        }
		    }
		    return monthCells;
		}
		_getMonthClasses  (month) {
		    let pickerCls = 'zdatetimepicker', // No I18N
		        isDisabled = this._checkDisabled.bind(this),
		        classes = pickerCls + '__monthview ' + pickerCls + '__monthyeargrid', // No I18N
		        today = new Date(),
		        viewDate = this._viewDate,
		        viewYear = viewDate.getFullYear(),
		        min = this._minDate,
		        currentSelected = this._currentSelected,
		        max = this._maxDate,
		        isSelect = currentSelected && currentSelected.getMonth() === month && currentSelected.getFullYear() === viewYear,
		        opts = this._opts,
		        value = opts.value;
		    if (value && value.getMonth() === month && value.getFullYear() === viewYear && isSelect || isSelect) {
		        classes += ' is-selected'; // No I18N
		    }
		    opts.selectionType === 'multiple' && (classes += this._addSelectClass('Month', month, viewYear)); // No I18N
		    if (today.getMonth() === month && today.getFullYear() === viewYear) {
		        classes += ' ' + pickerCls + '--currentcell'; // No I18N
		    }
		    if (min && (viewYear === min.getFullYear() && month < min.getMonth() || viewYear < min.getFullYear())
		        || max && (viewYear === max.getFullYear() && month > max.getMonth() || viewYear > max.getFullYear())
		        || isDisabled('Years', viewYear) || isDisabled('Months', month)) { // No I18N
		        classes += ' is-disabled zdisabled'; // No I18N
		    }
		    return classes;
		}
		_checkDisabled  (type, val) {
		    let arr = this._opts['disabled' + type];
		    return arr instanceof Array && arr.indexOf(val) > -1;
		}
		_handleYearClick  (orgEvent, viewElement, viewDate) {
		    this._rowsCount = [];
		    let target = $(orgEvent.target),
		        elemId = this._elementId,
		        step = this._opts.navigationBar.yearNavigationStep,
		        id = orgEvent.currentTarget.getAttribute('id'); // No I18N
		    if (!target.closest('.zdatetimepicker__navbutton').hasClass('is-disabled')) { // No I18N
		        let moveBy = step * (id.indexOf(elemId + '-right-year') > -1 || id.indexOf(elemId + '-right-month') > -1 && this._viewMode > 0 ? 1 : -1); // No I18N
		        viewDate = viewDate || this._viewDate;
		        viewDate.setFullYear(viewDate.getFullYear() + moveBy);
		        this._viewDate = new Date(+viewDate);
		        this._updateMonthDDNav();
		        this._updateMonthClasses(viewElement || this.element);
		        this._dispatchChangeEvent(orgEvent, 'year', this._viewDate.getFullYear()); // No I18N
		    }
		};
		_generateMonthDropdown  (data) {
		    let opts = this._opts,
		        year = this._viewDate.getFullYear(),
		        month = this._viewDate.getMonth(),
		        min = opts.minDate,
		        selectedValue,
		        max = opts.maxDate,
		        isMinYear, isMaxYear,
		        disabledMonths = opts.disabledMonths,
		        monthJSON = [],
		        months = this._getMonthVal();
		    min && (isMinYear = min.getFullYear() === year);
		    max && (isMaxYear = max.getFullYear() === year);
		    for (let i = 0; i < months.length; i++) {
		        month === i && (selectedValue = months[i]);
		        monthJSON[i] = {
		            value: months[i],
		            selected: month === i,
		            disabled: (isMinYear && min && i < min.getMonth() || isMaxYear && max && i > max.getMonth()) || disabledMonths && disabledMonths.indexOf(i) > -1 && month !== i,
		            label: months[i]
		        };
		    }
		    let elem = this._monthHeader;
		    // Revisit - Create a function and pass the values for month and year. They have similar values.
		    data.monthSelect = {
		        id: this._elementId + '-month-header', // No I18N
		        width: '107px', // No I18N
		        dropdownList: {
		            width: 99,
		            height: 330,
		            className: 'zdatetimepicker--menu' // No I18N
		        },
		        mainElement: elem ? elem[0] : null,
		        isCE: this.isCE,
		        selectedValue,
		        rtl: opts.rtl,
		        templateRender: true,
		        options: monthJSON,
		        allowDisabledOptionsForSelection: true,
		        optionclick: this._selectClickHandler.bind(this)
		    }
		}
		_getMonthVal  (monthval) {
		    let type = 'months' + (this._opts.navigationBar.monthYearHeadingFormat.split(' ').indexOf('MMMM') > -1 ? '' : 'Abbreviated'), // No I18N
		        months = this._getI18NText(type);
		    return monthval ? months.indexOf(monthval) : months;
		}
		_setMonthDropdownVal  (minYr, minMonth, maxYr, maxMonth, navBar) {
		    let monthInstance = ZC.select(this._monthHeader),
		        disabledMonths = this._opts.disabledMonths,
		        viewYr = this._viewDate.getFullYear(),
		        viewMonth = this._viewDate.getMonth();
		    if (minYr || minMonth || maxYr || maxMonth || this._data.modifiedAttr === 'minOrMax') { // No I18N
		        let trueVal = [],
		            falseVal = [],
		            isTrue,
		            months = navBar.monthSelect.options;
		        for (let i = 0; i < 12; i++) {
		            isTrue = minYr === viewYr && i < minMonth || maxYr === viewYr && i > maxMonth || disabledMonths && disabledMonths.indexOf(i) > -1 && viewMonth !== i;
		            (isTrue ? trueVal : falseVal).push(months[i].value);
		        }
		        monthInstance.setOptionAttributes(trueVal, 'disabled', true); // No I18N
		        monthInstance.setOptionAttributes(falseVal, 'disabled', false); // No I18N
		    }
		    monthInstance.setAttributes({
		        selectedValue: navBar.monthSelect.options[viewMonth].value
		    });
		}
		_getMonthNavBtnProps  (curNav, navBar) {
		    let lMonthIcon = this._getIconProps(navBar, 'backward', 'previousMonth', '-left-month-0', 'prevMonth'), // No I18N
		        rMonthIcon = this._getIconProps(navBar, 'forward', 'nextMonth', '-right-month-0', 'nextMonth'); // No I18N
		    if (!curNav) {
		        return {
		            lMonthIcon,
		            rMonthIcon
		        }
		    }
		    if (!curNav.lMonthIcon) {
		        this._lMonthIcon = curNav.lMonthIcon = lMonthIcon;
		    }
		    if (!curNav.rMonthIcon) {
		        this._rMonthIcon = curNav.rMonthIcon = rMonthIcon
		    }
		}
		_handleMonthArrowClick  (orgEvent) {
		    // console.time("Month arrow click");
		    let target = $(orgEvent.target),
		        opts = this._opts,
		        pickerCls = '.zdatetimepicker__', // No I18N
		        id = orgEvent.currentTarget.getAttribute('id'), // No I18N
		        monthStep = opts.navigationBar.monthNavigationStep; // No I18N
		    this._rowsCount = [];
		    if (!target.closest(pickerCls + 'navbutton').hasClass('is-disabled')) { // No I18N
		        if (this._monthsPerView > 1 && this._currentSelected) {
		            this._viewDate = new Date(+this._getFirstDate());
		        }
		        this._arrowClickHandler(monthStep * (id.indexOf(this._elementId + '-right-month') > -1 ? 1 : -1), true); // No I18N
		    }
		    this._dispatchChangeEvent(orgEvent, 'month', this._viewDate.getMonth()); // No I18N
		    // console.timeEnd("Month arrow click");
		}
		_setViewdate  (isMonth, val, isTrue) {
		    let viewDate = this._viewDate;
		    if (isMonth) {
		        this._viewDate = this._moveMonth(viewDate, val);
		    } else if (isTrue) {
		        this._viewDate.setFullYear(viewDate.getFullYear() + val);
		    }
		}
		_setView  (part, isMonth) {
		    let value = this._opts[part + 'ToBeShownOnOpen']; // No I18N
		    if (isMonth && !this._isNotNull(value)) {
		        return;
		    }
		    if (typeof value === 'number' && (isMonth && value >= 0 && value <= 11 || !isMonth)) { // No I18N
		        this._viewDate['set' + (isMonth ? 'Month' : 'FullYear')](value); // No I18N
		    } else if (typeof value === 'string') { // No I18N
		        let i,
		            arr = [ 'LAST', 'THIS', 'NEXT' ]; // No I18N
		        for (i = 0; i < 3; i++) {
		            if (value.indexOf(arr[i] + '_') > -1) {
		                let isThis = arr[i] === 'THIS', // No I18N
		                    val = isThis ? ZC.Date.convertOffsetToValue(value.substring(9 + +isMonth)) : i - 1;
		                this._setViewdate(isMonth, val, isThis ? true : value.length === 9);
		            }
		        }
		    }
		}
		_setViewOnOpen  () {
		    let opts = this._opts,
		        setView = this._setView.bind(this),
		        monthToBeShownOnOpen = opts.monthToBeShownOnOpen,
		        yearToBeShownOnOpen = opts.yearToBeShownOnOpen;
		    monthToBeShownOnOpen && setView('month', true); // No I18N
		    yearToBeShownOnOpen && setView('year'); // No I18N
		    if (monthToBeShownOnOpen || yearToBeShownOnOpen) {
		        this._checkViewDate(new Date(+this._viewDate));
		    }
		}
		_handleMultipleSelectOnClose  () {
		    let opts = this._opts,
		        values = opts.values,
		        selectedDates = this._selectedDates,
		        valLen = values.length,
		        selectedLen = selectedDates.length,
		        extraElements = [],
		        isTrue,
		        limit = opts.selectionLimit; // No I18N
		    if (selectedLen !== valLen) {
		        if (selectedLen > valLen) {
		            extraElements = this._selectedDates.splice(valLen);
		            this._selectedDates.length = valLen;
		            this._setSelectClass(false, extraElements);
		        } else {
		            this._selectedDates = [];
		            for (let i = 0; i < valLen; i++) {
		                this._selectedDates[i] = this._parseDateValue(values[i], opts.format).date;
		            }
		            this._setSelectClass(true, this._selectedDates);
		        }
		        if (limit !== valLen && this._limitReached) {
		            this._limitReached = false;
		            isTrue = false;
		            this._queryString = ''; // No I18N
		        } else if (limit === valLen) {
		            this._queryString = ':not('; // No I18N
		            this._getQueryString();
		            isTrue = true;
		        }
		    }
		    selectedDates = this._selectedDates;
		    let clrBtn = this._clear;
		    if (selectedDates && selectedDates.length && this._doesExist(clrBtn)) {
		        this._traverseBtns('clearButton', 'is-disabled', false); // No I18N
		        this._disable(false, clrBtn);
		    }
		    isTrue !== undefined && this._setDateClass('is-disabled', isTrue, this.element.find('.zdatetimepicker__date,.zdatetimepicker__adjacentmonthdate').filter(this._queryString));// No I18N
		}
		_setSelectClass  (bool, arr) {
		    for (let i = 0; i < arr.length; i++) {
		        this._select(bool, this._getDateElem(this._resetTime(arr[i]))); // No I18N
		    }
		}
		_setValues  () {
		    let opts = this._opts,
		        values = opts.values,
		        len = values.length;
		    for (let i = 0; i < len; i++) {
		        let date,
		            value = values[i];
		        if (typeof value === 'string') { // No I18N
		            date = value === 'TODAY' ? new Date() : this._parseDateValue(values[i], opts.format).date; // No I18N
		        } else if (value instanceof Date) {
		            date = value;
		        } else {
		            values.splice(i, 1);
		        }
		        let isTrue = (opts.selectionLimit ? opts.selectionLimit > i : true) && this._dateWithInRange(date);
		        if (isTrue) {
		            this._valueUpdate = true;
		            if (date && this._dateWithInRange(date)) {
		                date.setHours(0, 0, 0, 0);
		                this._selectedDates.push(date);
		                if (i === len - 1) {
		                    this._viewDate = new Date(+date);
		                }
		            }
		        } else {
		            opts.values.splice(i, len);
		            break;
		        }
		    }
		}
		_handleOkOnMultiple  (opts) {
		    opts.values = [];
		    let selectedDates = this._selectedDates,
		        len = selectedDates.length;
		    for (let i = 0; i < len; i++) {
		        let newDate = new Date(selectedDates[i]);
		        this._checkTime && newDate.setHours(this._selectedTime.getHours(), this._selectedTime.getMinutes(), 0, 0);
		        opts.values.push(ZC.Date.formatDate(newDate, opts.format));
		    }
		}
		_getMultipleValues  () {
		    return {
		        values: this._opts.values,
		        valuesObject: this._selectedDates,
		        translatedValues: this._getTranslatedValues()
		    }
		}
		_getTranslatedValues  () {
		    let arr = [],
		        opts = this._opts,
		        values = this._selectedDates;
		    for (let i = 0; i < values.length; i++) {
		        arr.push(this._translateEToA(ZC.Date.formatDate(values[i], opts.format, opts.labels)));
		    }
		    return arr;
		}
		_getQueryString  () {
		    let selectedDates = this._selectedDates;
		    for (let i = 0, len = selectedDates.length; i < len; i++) {
		        // it is unary plus
		        this._queryString += "[data-time='" + +this._resetTime(selectedDates[i]) + "']"; // No I18N
		        this._queryString += ',' + (i === len - 1 ? ' .zdisabled)' : ''); // No I18N
		    }
		}
		_addSelectClass  (getVal, val, viewYr) {
		    let selectedDates = this._selectedDates,
		        i, len,
		        classes = '';
		    for (i = 0, len = selectedDates.length; i < len; i++) {
		        let isTrue = getVal === 'Month' ? viewYr === selectedDates[i].getFullYear() : true;
		        if (isTrue && selectedDates[i]['get' + getVal]() === val) {
		            classes += ' is-selected'; // No I18N
		        }
		    }
		    return classes;
		}
		_setMultipleDate  (orgEvent, target, date) {
		    let opts = this._opts,
		        clrBtn = this._clear,
		        selectedDates = this._selectedDates,
		        cls = '.zdatetimepicker__', // No I18N
		        immediateCommit = opts.immediateCommit,
		        time = +date,
		        len = selectedDates.length,
		        ele = this.element;
		    if (target.hasClass('is-selected')) { // No I18N
		        if (!orgEvent || orgEvent && $(orgEvent.target).closest(cls + 'todaylink').length === 0) { // No I18N
		            this._select(false, target);
		            let index = this._getDateIndex(date);
		            if (index !== -1) {
		                if (len === opts.selectionLimit) {
		                    this._limitReached = true;
		                    this._queryString = ':not('; // No I18N
		                    this._getQueryString();
		                    this._queryString && this._setDateClass('is-disabled', false, ele.find(cls + 'date,' + cls + 'adjacentmonthdate').filter(this._queryString));// No I18N
		                    this._disable(false, ele.find('.is-selected')); // No I18N
		                }
		                selectedDates.splice(index, 1);
		                immediateCommit && opts.values.splice(index, 1);
		            }
		            if (len > 0 && immediateCommit) {
		                this._valueUpdate = true;
		                this._OKClickHandler(orgEvent, true)
		            }
		        }
		    } else {
		        this._select(true, target);
		        // Assign this._selectedTime to a variable and use it.
		        this._selectedTime && date.setHours(this._selectedTime.getHours(), this._selectedTime.getMinutes(), 0, 0);
		        selectedDates.push(new Date(time));
		        len = selectedDates.length;
		        if (opts.type !== 'inline' && immediateCommit) {
		            this._valueUpdate = true;
		            this._OKClickHandler(orgEvent, true);
		        }
		        this._queryString = ''; // No I18N
		        if (len === opts.selectionLimit) {
		            if (!this._queryString) {
		                this._queryString = ':not('; // No I18N
		                this._getQueryString();
		            }
		            this._setDateClass('is-disabled', true, ele.find(cls + 'date,' + cls + 'adjacentmonthdate').filter(this._queryString));// No I18N
		            this._limitReached = true;
		        }
		    }
		    this._doesExist(clrBtn) && this._traverseBtns('clearButton', 'is-disabled', !selectedDates.length); // No I18N
		    this._disable(!selectedDates.length, clrBtn);
		    return {
		        values: opts.values,
		        valuesObject: selectedDates
		    }; // No I18N
		}
		_getDateIndex  (date) {
		    let selectedDates = this._selectedDates;
		    for (let i = 0, len = selectedDates.length; i < len; i++) {
		        if (ZC.Date.areDatesEqual(date, selectedDates[i])) {
		            return i;
		        }
		    }
		    return -1;
		}
		_checkDates  (opt, tempMin) {
		    let selectedDates = this._selectedDates,
		        valueChanged,
		        isTrue,
		        opts = this._opts;
		    for (let i = 0; i < selectedDates.length; i++) {
		        isTrue = opt === 'max' ? this._checkMax(selectedDates[i], opt) : this._isGreater(tempMin, selectedDates[i]); // No I18N
		        if (isTrue) {
		            valueChanged = true;
		            opts.values.splice(i, 1);
		            this._selectedDates.splice(i, 1);
		            i--;
		        }
		    }
		    return valueChanged;
		}
		getValues  () {
		    let selectedDates = [],
		        opts = this._opts,
		        values = opts.values;
		    for (let i = 0, len = values.length; i < len; i++) {
		        selectedDates[i] = ZC.Date.formatDate(values[i], opts.format);
		    }
		    return {
		        values: values,
		        valuesString: selectedDates
		    };
		}
		setValues  (datesArray) {
		    let opts = this._opts,
		        oldDate = this._oldDate;
		    if (opts.selectionType === 'multiple') { // No I18N
		        this._rowsCount = [];
		        opts.values = datesArray;
		        this._setValues();
		        this._validateOpts();
		        if (oldDate && !ZC.Date.areDatesEqual(oldDate, this._viewDate) || !oldDate) {
		            this._buildData(true);
		        }
		    }
		}
		clearAll  () {
		    let opts = this._opts;
		    if (opts.selectionType === 'multiple' && (opts.values.length || this._selectedDates.length)) { // If values set to undefined through setAttribute, then length will be zero
		        this._clearValues();
		        opts.values = [];
		        this._selectedDates = [];
		    }
		}
		clear  (date) {
		    let opts = this._opts
		    if (opts.selectionType === 'multiple' && date) { // No I18N
		        let index, isTrue,
		            selectedDates = this._selectedDates,
		            values = opts.values;
		        if (typeof date === 'string') { // No I18N
		            isTrue = true;
		        } else if (date instanceof Date) {
		            date.setHours(0, 0, 0, 0);
		            date = ZC.Date.formatDate(date, opts.format);
		            isTrue = true
		        }
		        isTrue && (index = values.indexOf(date));
		        if (index > -1) {
		            let elem = this._getDateElem(this._resetTime(selectedDates[index]));
		            elem.removeClass('is-selected').removeAttr('aria-selected'); // No I18N
		            this._select(false, elem, true);
		            values.splice(index, 1);
		            selectedDates.splice(index, 1);
		            if (values.length === 0) {
		                this._setHours();
		                this._doesExist(this._clear) && this._traverseBtns('clearButton', 'is-disabled', true); // No I18N
		            }
		            this._buildData(true);
		        }
		    }
		}
		_bindArrowEvents  () {
		    let id = this._elementId,
		        elems = ('#' + id + '-left-year,#' + id + '-right-year,#' + id + '-left-month-0,#' + id + '-right-month-0').split(',');
		    for (let i = 0, len = elems.length; i < len; i++) {
		        let elem = $(elems[i]);
		        elem.length && this._addEvents({
		            arrowEvent: 'click' // No I18N
		        }, elem);
		    }
		}
		_getIconProps  (navBar, svgId, btn, id, label) {
		    label = this._getI18NText(label);
		    return ZC.ZButton.getBtnProps({
		        className: 'zdatetimepicker__navbutton', // No I18N
		        isCE: this.isCE,
		        customAttributes: {
		            'aria-label': label, // No I18N
		            title: label
		        },
		        defaultIconClassName: 'zdatetimepicker__icon', // No I18N
		        SVGIconId: navBar[btn + 'ButtonSVGIconId'], // No I18N
		        defaultSVGIconId: '#zc__svg--' + svgId + ' zh-arrowicon', // No I18N
		        iconClassName: navBar[btn + 'ButtonIconClassName'], // No I18N
		        templateRender: true,
		        id: this._elementId + id
		    });
		}
		_getNavBtnProps  (month, i, curNav) {
		    let navBar = this._opts.navigationBar,
		        isLast = i === this._monthsPerView - 1,
		        monthButtons = navBar.monthNavigationButtons,
		        yearButtons = navBar.yearNavigationButtons;
		    curNav.isSplit = navBar.navigationButtonsDisplayPattern === 'split'; // No I18N
		    curNav.class = curNav.isSplit ? '' : ' zdatetimepicker__navbaractionsonright';// No I18N
		    monthButtons && this._getMonthNavBtnProps(curNav, navBar);
		    yearButtons && this._getYrNavBtnProps(curNav, navBar);
		    if (curNav.isSplit) {
		        month.navigationBar = {
		            ...curNav,
		            lMonth: monthButtons && !i,
		            lYear: yearButtons && !i,
		            rMonth: monthButtons && isLast,
		            rYear: yearButtons && isLast
		        };
		    } else {
		        curNav.lMonth = curNav.rMonth = monthButtons && isLast;
		        curNav.lYear = curNav.rYear = yearButtons && isLast;
		    }
		}
		_setArrowMainElement  (curNav) {
		    let arr = [];
		    curNav.monthNavigationButtons && (arr = [
		        '-left-month-0', // No I18N
		        'lMonthIcon', // No I18N
		        '-right-month-0', // No I18N
		        'rMonthIcon' // No I18N
		    ]);
		    curNav.yearNavigationButtons && (arr = [ ...arr,
		        '-left-year', // No I18N
		        'lYearIcon', // No I18N
		        '-right-year', // No I18N
		        'rYearIcon' // No I18N
		    ]);
		    for (let i = 0, len = arr.length; i < len; i += 2) {
		        let elem = $('#' + this._elementId + arr[i]);
		        if (elem.length) {
		            let btnData = curNav[arr[i + 1]];
		            btnData.mainElement = elem[0];
		            /* Updating the button attrs. Since it is not added when using ZC.Button.getBtnProps() */
		            elem.attr(btnData.attrs);
		        }
		    }
		}
		_arrowClickHandler  (moveBy, monthsChanged, yearChanged) {
		    let newDate,
		        count = this._monthsPerView,
		        navBar = this._opts.navigationBar,
		        viewDate = this._viewDate,
		        oldDate;
		    oldDate = new Date(+viewDate);
		    let elem = this.element;
		    for (let i = 1; i <= count; i++) {
		        let isOne = i === 1;
		        if (monthsChanged) {
		            if (moveBy > 1) {
		                newDate = this._moveMonth(oldDate, isOne ? moveBy : 1);
		            } else {
		                newDate = this._moveMonth(viewDate, isOne ? moveBy : i - 1);
		            }
		        }
		        if (yearChanged) {
		            if (count > 1) {
		                newDate = new Date(this._getFirstDate()); // No I18N
		            } else {
		                !newDate && (newDate = new Date(viewDate));
		            }
		            newDate.setFullYear(newDate.getFullYear() + moveBy);
		        }
		        if (navBar.monthNavigationStep > 1 || navBar.yearNavigationStep > 1) {
		            let arr = [ 'min', 'max' ], // No I18N
		                isTrue;
		            for (let i = 0; i < 2; i++) {
		                isTrue = this._isBig(arr[i], newDate);
		                this['_' + arr[i] + 'Date'] && isTrue && (newDate = new Date(+this['_' + arr[i] + 'Date'])); // No I18N
		            }
		        }
		        isOne && newDate && (viewDate = this._viewDate = new Date(+newDate));
		    }
		    this._doNotBuildTime = true;
		    this._setPosition = true;
		    this._buildData(true);
		    if (this._isDropdown) { // No I18N
		        this._checkOptions();
		        this._buildDropdownNavElement(viewDate.getMonth(), viewDate.getFullYear());
		    } else if (yearChanged && this._viewMode === 1) {
		        this._updateMonthClasses(elem);
		    }
		}
		_updateArrowState  (date, index) {
		    let updateInBatch = this._monthsPerView > 1,
		        disable = this._disable.bind(this);
		    date = date || this._viewDate;
		    let id = this._elementId,
		        minDate = this._minDate,
		        maxDate = this._maxDate,
		        year = date.getFullYear(),
		        month = date.getMonth(),
		        minMonth,
		        minYear,
		        maxMonth,
		        maxYear,
		        isValidValue,
		        prev,
		        next,
		        yearPrev,
		        yearNext;
		    if (minDate) {
		        minYear = minDate.getFullYear();
		        minMonth = minDate.getMonth();
		    }
		    if (maxDate) {
		        maxYear = maxDate.getFullYear();
		        maxMonth = maxDate.getMonth();
		    }
		    let isFirstMonth = year === 1;
		    isValidValue = isFirstMonth || minMonth || minYear || maxMonth || maxYear;
		    prev = isFirstMonth && month === 0 || year < minYear || year === minYear && month - 1 < minMonth;
		    next = year > maxYear || year === maxYear && month + 1 > maxMonth;
		    yearPrev = year === 1 || year - 1 < minYear || year - 1 === minYear && month < minMonth;
		    yearNext = year + 1 > maxYear || year + 1 === maxYear && month > maxMonth;
		    let condtn = isValidValue && !updateInBatch;
		    if (condtn || updateInBatch && index === 0) {
		        disable(prev, $('#' + id + '-left-month-0')); // No I18N
		        disable(yearPrev, $('#' + id + '-left-year')); // No I18N
		    }
		    if (condtn || updateInBatch && index === this._monthsPerView - 1) {
		        disable(next, $('#' + id + '-right-month-0')); // No I18N
		        disable(yearNext, $('#' + id + '-right-year')); // No I18N
		    }
		    if (!isValidValue && !(prev && isFirstMonth && month === 0)) {
		        $('#' + id + '-left-month-0,#' + id + '-left-year,#' + id + '-right-month-0,#' + id + '-right-year').removeClass('is-disabled').removeAttr('aria-disabled disabled'); // No I18N
		    }
		}
		_getQueryString  () {
		    let selectedDates = this._selectedDates;
		    for (let i = 0, len = selectedDates.length; i < len; i++) {
		        // it is unary plus
		        this._queryString += "[data-time='" + +this._resetTime(selectedDates[i]) + "']"; // No I18N
		        this._queryString += ',' + (i === len - 1 ? ' .zdisabled)' : ''); // No I18N
		    }
		}
		_setAttrs  (optionName, value, pickerEle) {
		    let data = this._data,
		        opts = this._opts,
		        navBar = opts.navigationBar,
		        isTrue = true,
		        isDropdown = this._isDropdown,
		        shouldRender,
		        buttonOptions = [ 'todayButton', 'clearButton', 'hideCancelButton', 'immediateCommit', 'commandBar' ], // No I18N
		        labels = [ 'todayButtonLabel', 'cancelButtonLabel', 'clearButtonLabel', 'OKButtonLabel' ], // No I18N
		        specialDays = [ 'disabledDaysOfWeek', 'specialDaysOfWeek', 'specialDates', 'disabledDates' ]; // No I18N
		    pickerEle = pickerEle || this.element;
		    [ 'minDate', 'maxDate' ].indexOf(optionName) < -1 && (opts[optionName] = value);
		    if (this._yearNavigation === undefined) {
		        this._yearNavigation = navBar.yearNavigationButtons = !isDropdown;
		    }
		    if (optionName === 'values') { // No I18N
		        let values = opts.values;
		        if (!values || values instanceof Array && values.length === 0) {
		            this.clearAll();
		        } else {
		            this.setValues(values);
		        }
		        isTrue = false;
		    } else if ([ 'minDate', 'maxDate' ].indexOf(optionName) > -1) { // No I18N
		        this['_' + optionName + 'HasTime'] = false;
		        this._parseValue(optionName, value);
		        if (value) {
		            this['_' + optionName] = new Date(opts[optionName].getTime()); // No I18N
		        } else {
		            this['_' + optionName] = null;
		            this['_' + optionName + 'HasTime'] = false; // No I18N
		        }
		        let isNotValid = !opts.value && opts.values.length === 0;
		        isNotValid && this._setHours();
		        this._processLimits();
		        this._checkLimits();
		        if (isNotValid) {
		            opts.monthToBeShownOnOpen && this._setView('month', true); // No I18N
		            opts.yearToBeShownOnOpen && this._setView('year'); // No I18N
		        }
		        if (this._isDropdown) {
		            data.modifiedAttr = 'minOrMax'; // No I18N
		            this._checkOptions();
		        }
		        // this._resetValues();
		        shouldRender = true;
		    } else if ([ 'closeButton', 'closeSVGIconId', 'closeIconClassName', 'title' ].indexOf(optionName) > -1) { // No I18N
		        this._closeButton = undefined;
		        data.title = this._getTitleData();
		        if (optionName === 'title') {
		            if (opts.title) {
		                this._enableDrag = opts.draggable;
		            } else if (opts.draggable) {
		                this.element.data('zdraggable') && ZC.draggable(this.element).destroy(); // No I18N
		            }
		        }
		        data.modifiedAttr = 'title';// No I18N
		    } else if (optionName === 'displayType') { // No I18N
		        this._validateOpts();
		        if (value === 'box' && this._pointer) { // No I18N
		            !this._isPositionModified && (opts.position = 'bottom-left'); // No I18N
		        }
		        data.modifiedAttr = 'displayType'; // No I18N
		    } else if (optionName.indexOf('customHTML') > -1) { // No I18N
		        this._handleCustomHTML();
		        isTrue = false;
		    } else if (optionName === 'displayWeekNumbers') { // No I18N
		        this._setMonthVal(optionName, value);
		    } else if (optionName === 'weekHeading' && opts.displayWeekNumbers) { // No I18N
		        this._setMonthVal('weekTitle', value); // No I18N
		    } else if (optionName === 'type') { // No I18N
		        data.modifiedAttr = 'type'; // No I18N
		        if (opts.type === 'popup') { // No I18N
		            // updated again if changed through setAttribute
		            data.title.closeButton = opts.closeButton;
		            (opts.forElement || opts.offset) && this._showPicker();
		        } else if (this._closeButton) {
		            data.title.closeButton = false;
		        }
		        if (opts.type === 'inline') { // No I18N
		            this._display();
		            this._isShown = true;
		        }
		    } else if (optionName === 'selectionType') { // No I18N
		        this._resetValues();
		        shouldRender = true;
		    } else if (buttonOptions.indexOf(optionName) > -1) { // No I18N
		        this._setOKCancelBtns();
		        this._isBtns = this._isBtnsExist();
		        if (this._isBtns) {
		            this._setBtnProps();
		            this._createButtons();
		        } else {
		            this._data.cBar = null;
		        }
		        this._getBtnsArr().forEach((value) => {
		            if (!opts[value + 'Button']) { // No I18N
		                this['_' + value] = null; // No I18N
		            }
		        });
		        data.modifiedAttr = 'commandBar'; // No I18N
		    } else if (labels.indexOf(optionName) > -1) {
		        let name = optionName.replace('Label', ''),
		            btnObj = this._traverseBtns(name, undefined, undefined, true),
		            btn = this['_' + name.replace('Button', '')];
		        btnObj.text = btnObj.customAttributes['aria-label'] = value // No I18N
		        btnObj.mainElement = btn && btn.length ? btn[0] : undefined;
		        if (name === 'todayButton') { // No I18N
		            this._domChanged = true;
		        } else {
		            this._setBtnValue({
		                text: value
		            }, btnObj); // No I18N
		        }
		        this['_' + optionName] = value || this._getI18NText(optionName);
		    } else if (optionName === 'draggable') { // No I18N
		        if (opts.title && opts.draggable) {
		            this._enableDrag = true;
		            data.modifiedAttr = 'title';// No I18N
		        } else {
		            this.element.data('zdraggable') && ZC.draggable(this.element).destroy(); // No I18N
		        }
		    } else if (optionName === 'monthToBeShownOnOpen' || optionName === 'yearToBeShownOnOpen') { // No I18N
		        let isTrue = optionName.indexOf('month') > -1; // No I18N
		        this._setView(isTrue ? 'month' : 'year', isTrue); // No I18N
		        (this._minDate || this._maxDate) && this._checkViewDate(this._viewDate);
		        shouldRender = true;
		    } else if (specialDays.indexOf(optionName) > -1) {
		        if ([ 'disabledDates', 'specialDates' ].indexOf(optionName) > -1) { // No I18N
		            this._convertStringToObject({
		                [optionName]: opts[optionName]
		            });
		        }
		        let isSpecial = optionName.indexOf('special') > -1;
		        // refreshClassNames can be called only for the option which is changed. Hence, the check is added.
		        this._refreshClassNames(isSpecial ? 'zdatetimepicker--special' : 'is-disabled zdisabled', isSpecial ? [ 'specialDaysOfWeek', 'specialDates' ] : [ 'disabledDaysOfWeek', 'disabledDates' ]); // No I18N
		    } else if (optionName === 'disabledMonths') { // No I18N
		        if (opts.disabledMonths.indexOf(this._viewDate.getMonth()) > -1) {
		            pickerEle.find('td').addClass('is-disabled zdisabled').attr('aria-disabled', true); // No I18N
		        } else if (isDropdown) { // No I18N
		            if (this._monthHeader) {
		                let monthInstance = ZC.select(this._monthHeader);
		                monthInstance.setOptionAttributes(this._oldValue, 'disabled', false); // No I18N
		                monthInstance.setOptionAttributes(opts.disabledMonths, 'disabled', true); // No I18N
		            }
		        } else {
		            this._monthDrillDownElement && this._monthDrillDownElement.find('td').addClass('is-disabled').attr('aria-disabled', true); // No I18N
		        }
		    } else if (optionName === 'selectionLimit' && opts.selectionType === 'multiple') {// No I18N
		        let selectedDates = this._selectedDates,
		            values = this._opts.values,
		            len = selectedDates.length;
		        if (value === len || len > value) {
		            this._limitReached = true;
		            values.splice(value, values.length);
		            let extraElems = selectedDates.splice(value, selectedDates.length);
		            for (let i = 0, len = extraElems.length; i < len; i++) {
		                this._setDateClass('is-selected', false, this._getDateElem(extraElems[i]), true);// No I18N
		            }
		            if (selectedDates.length) {
		                this._queryString = ':not('; // No I18N
		                this._getQueryString();
		                this._setDateClass('is-disabled', true, this.element.find('.zdatetimepicker__date,.zdatetimepicker__adjacentmonthdate').filter(this._queryString), true);// No I18N
		            } else {
		                /* Issue fix added if the selectionLimit is given as zero. (It can be used to remove the selectionLimit) */
		                this._queryString = '';
		                shouldRender = true;
		            }
		            this._dispatchEvent('change', undefined, this._getSelectedValue()); // No I18N
		        } else {
		            shouldRender = true;
		        }
		    } else if (optionName === 'disabledYears') { // No I18N
		        if (opts.disabledYears.indexOf(this._viewDate.getFullYear()) > -1) {
		            shouldRender = true;
		        } else if (isDropdown) { // No I18N
		            if (this._yearHeader) {
		                let yearInstance = ZC.combobox(this._yearHeader);
		                yearInstance.setOptionAttributes(this._oldValue, 'disabled', false); // No I18N
		                yearInstance.setOptionAttributes(opts.disabledYears, 'disabled', true); // No I18N
		            }
		        } else {
		            this._yearDrillDownElement && this._yearDrillDownElement.find('td').addClass('is-disabled').attr('aria-disabled', true); // No I18N
		        }
		    } else if (optionName === 'displayAdjacentMonthDates') { // No I18N
		        shouldRender = true;
		        data.modifiedAttr = 'adjacentMonthDates';// No I18N
		    } else if (optionName === 'selectedDateMonthViewIndex' && opts.value) { // No I18N
		        this._viewDate = new Date(opts.value.getTime());
		        this._changeMonth(false);
		        shouldRender = true;
		    } else if (optionName === 'allowSelectionOfAdjacentMonthDates') { // No I18N
		        this._setMonthVal('className', ' zdatetimepicker--adjacentmonthdatereadonly', !value);// No I18N
		        this._domChanged = true;
		        data.modifiedAttr = 'adjacentMonthDates';// No I18N
		    } else if (optionName === 'width') { // No I18N
		        value && this.element.width(value);
		    } else if (optionName === 'height') { // No I18N
		        value && this.element.height(value);
		    } else if (optionName === 'className') { // No I18N
		        this.element.removeClass(this._oldValue);
		        value && this.element.addClass(value);
		    } else if (optionName === 'offset') { // No I18N
		        this.element.css(value);
		        isTrue = false;
		    } else if (optionName === 'margin' && this._isShown) { // No I18N
		        let position = {
		            left: parseInt(this.element.css('left')), // No I18N
		            top: parseInt(this.element.css('top'))// No I18N
		        };
		        position = this._retrieveMarginValues(position);
		        this.element.css(position);
		    } else if (optionName === 'zclassName' && this.isCE) { // No I18N
		        this._oldValue && this.element.removeClass(this._oldValue);
		        this.element.addClass(value);
		    } else if (optionName === 'rtl' && (this._monthHeader || this._yearHeader)) { // No I18N
		        let val = {
		            rtl: value
		        };
		        this._monthHeader && ZC.select(this._monthHeader).setAttributes(val);
		        this._yearHeader && ZC.combobox(this._yearHeader).setAttributes(val);
		    }
		    !this._reInit && (this._reInit = shouldRender);
		    return isTrue;
		};
		_refreshClassNames  (className, optionsArray) {
		    let base = this,
		        isDisabled = className.indexOf('disabled') > -1,
		        opts = this._opts, // No I18N
		        classes = className.split(' ');
		    for (let i = 0; i < this._monthsPerView; i++) {
		        let monthData = this._data.month[i].dates;
		        for (let week = 0, len = monthData.length; week < len; week++) {
		            let weekData = monthData[week];
		            for (let d = 0, l = weekData.length; d < l; d++) {
		                let dateObj = weekData[d],
		                    prevCls = dateObj.class;
		                dateObj.class = prevCls.replace(classes[0], '').replace(classes[1], ''); // No I18N
		                dateObj.title = dateObj.infoText = '';
		                let returnValue,
		                    date = new Date(parseInt(dateObj.time)),
		                    addDisabled = isDisabled ? !base._dateWithInRange(date) : false;
		                if (dateObj.text && (addDisabled || (returnValue = this._shouldAddClass(date, optionsArray)) || this._shouldAddClass(date, optionsArray, opts.selectionType === 'multiple' && this._limitReached))) { // No I18N
		                    if (typeof returnValue === 'object') { // No I18N
		                        dateObj.class += returnValue.className ? ' ' + returnValue.className : '';
		                        dateObj.title = returnValue.title || null;
		                        dateObj.infoText = returnValue.informativeText || opts.specialDatesInformativeText || opts.disabledDateInformativeText || null;
		                    }
		                    dateObj.class += ' ' + className;
		                    // When selection limit is reached and if disabledDates are removed, disabled classes were not included properly.
		                    if (!returnValue && !addDisabled) {
		                        dateObj.class = dateObj.class.replace('zdisabled', ''); // No I18N
		                        dateObj.class.indexOf('is-selected') > -1 && (dateObj.class = dateObj.class.replace('is-disabled', '')); // No I18N
		                    }
		                }
		            }
		        }
		    }
		};
		_shouldAddClass  (date, options, takeOldVal) {
		    let areDatesEqual = ZC.Date.areDatesEqual.bind(ZC);
		    for (let i = 0, len = options.length; i < len; i++) {
		        let optionVal = takeOldVal ? this._oldOpts[options[i]] : this._opts[options[i]];
		        if (optionVal) {
		            if (optionVal.indexOf(date.getDay()) > -1) {
		                return true;
		            }
		            for (let j = 0, size = optionVal.length; j < size; j++) {
		                let value = optionVal[j],
		                    dateVal = value.date;
		                if (typeof value === 'object') { // No I18N
		                    if (dateVal instanceof Date && areDatesEqual(dateVal, date)) {
		                        return true;
		                    } else if (dateVal) {
		                        let dateToCheck = new Date(+dateVal.date);
		                        this._setYearAndMonth(dateToCheck, date, value);
		                        if (areDatesEqual(dateToCheck, date)) {
		                            return value;
		                        }
		                    } else if (value.startDate && value.endDate) {
		                        let arr = [ 'startDate', 'endDate' ]; // No I18N
		                        for (let i = 0; i < 2; i++) {
		                            arr[i] = new Date(+value[arr[i]].date);
		                            this._setYearAndMonth(arr[i], date, value);
		                        }
		                        if ((ZC.Date.isGreater(date, arr[0]) || areDatesEqual(arr[0], date)) && ZC.Date.isGreater(arr[1], date)) {
		                            return value;
		                        }
		                    }
		                }
		            }
		        }
		    }
		}
		_setYearAndMonth  (dateToCheck, date, value) {
		    value.repeatEveryYear && dateToCheck.setFullYear(date.getFullYear());
		    value.repeatEveryMonth && dateToCheck.setMonth(date.getMonth());
		}
		_convertStringToObject  (datesObject) {
		    for (let option in datesObject) {
		        let optVal = datesObject[option],
		            opts = this._opts,
		            format = this._dateFormat;
		        if (this._isNotNull(optVal)) {
		            if (typeof optVal === 'string') { // No I18N
		                datesObject[option] = opts[option] = this._parseDateValue(optVal, format)
		            } else if (optVal instanceof Array) {
		                datesObject[option] = opts[option] = optVal.map((d) => {
		                    if (typeof d === 'object' && !(d instanceof Date)) { // No I18N
		                        let dateVal = d.date,
		                            checkDate = this._checkDate.bind(this),
		                            parseVal = this._parseVal.bind(this);
		                        if (checkDate(dateVal, d) || checkDate(dateVal) || checkDate(d.startDate) || checkDate(d.endDate)) { // No I18N
		                            return d;
		                        }
		                        if (dateVal) {
		                            d.date = parseVal(dateVal);
		                        } else if (d.startDate && d.endDate) {
		                            d.startDate = parseVal(d.startDate);
		                            d.endDate = parseVal(d.endDate);
		                        }
		                        return d;
		                    }
		                    let isTimeList = option === 'disabledTimeList', // No I18N
		                        date = this._parseDateValue(d, isTimeList ? this._timeFormat : format); // No I18N
		                    if (isTimeList) {
		                        date.date.setSeconds(0, 0);
		                    } else {
		                        date.date.setHours(0, 0, 0, 0)
		                    }
		                    return date;
		                });
		            }
		        }
		    }
		}
		_checkDate  (date, obj) {
		    date = obj ? date : date ? date.date : undefined;
		    obj = obj || date;
		    return date && date instanceof Date && obj.hasOwnProperty('isValid'); // No I18N
		}
		_parseVal  (dateVal) {
		    // hasOwnProperty is used to avoid getting error when accessed from a date object
		    dateVal = this._parseDateValue(dateVal && dateVal.hasOwnProperty('isValid') && dateVal.isValid && dateVal.date || dateVal, this._dateFormat); // No I18N
		    dateVal.date.setHours(0, 0, 0, 0);
		    return dateVal;
		}
		_addUniqueClasses  (date, cls, onlyDisabled) {
		    let opts = this._opts,
		        classes = cls ? (cls + ' ') : '',
		        monthsDis = opts.disabledMonths,
		        yearsDis = opts.disabledYears,
		        returnObj,
		        returnValue = true;
		    returnObj = this._shouldAddClass(date, [ 'disabledDaysOfWeek', 'disabledDates' ]); // No I18N
		    if (returnObj || monthsDis && monthsDis.indexOf(date.getMonth()) > -1 || yearsDis && yearsDis.indexOf(date.getFullYear()) > -1) {
		        classes += 'is-disabled zdisabled'; // No I18N
		    } else if (!returnObj && !onlyDisabled) {
		        returnObj = this._shouldAddClass(date, [ 'specialDaysOfWeek', 'specialDates' ]); // No I18N
		        if (returnObj) {
		            classes += 'zdatetimepicker--special'; // No I18N
		        }
		    } else {
		        returnValue = false;
		    }
		    returnValue = returnObj || returnValue;
		    return returnValue && this._getCustomProps(returnValue, classes);
		}
		_getCustomProps  (returnValue, classes) {
		    let infoText,
		        cls = classes + ' ',
		        obj, title;
		    if (typeof returnValue === 'object') { // No I18N
		        cls += returnValue.className ? ' ' + returnValue.className : '';
		        title = returnValue.title || null;
		        let disabledInfo = this._opts.disabledDateInformativeText,
		            highlightInfo = this._opts.specialDatesInformativeText;
		        if (returnValue && returnValue.informativeText || typeof returnValue === 'boolean' && disabledInfo || highlightInfo) { // No I18N
		            if (classes.indexOf('is-disabled') > -1 && disabledInfo) { // No I18N
		                infoText = disabledInfo;
		            } else if (classes.indexOf('zdatetimepicker--special') > -1 && highlightInfo) { // No I18N
		                infoText = highlightInfo;
		            } else if (returnValue && returnValue.informativeText) {
		                infoText = returnValue.informativeText;
		            }
		            infoText = infoText || undefined;
		        }
		    }
		    obj = {
		        'class': cls, // No I18N
		        infoText: infoText,
		        title: title
		    };
		    return obj;
		}
		_getTitleData  (isModified) {
		    let opts = this._opts,
		        title = opts.title,
		        closeButton = opts.closeButton && opts.type !== 'inline', // No I18N
		        obj = {
		            value: title && opts.isTitleHTMLEncoded ? title : ZC.encodeHTML(title),
		            closeButton,
		            modifiedAttr: isModified ? 'title' : null // No I18N
		        };
		    return closeButton ? this._getCloseProps(obj) : obj;
		}
		_todayClickHandler  (orgEvent, doNotTrigger) {
		    let zkeycode = ZC.keyCode;
		    if (orgEvent.type === 'click' || (orgEvent.type === 'keydown' && [ zkeycode.ENTER, zkeycode.SPACE ].indexOf(orgEvent.keyCode) > -1)) {
		        this._today.removeClass('has-focus has-kfocus'); // No I18N
		        let oldViewDate = new Date(+this._viewDate),
		            opts = this._opts,
		            isViewModeZero = this._viewMode === 0,
		            viewDate, date;
		        date = new Date();
		        this._setHours();
		        viewDate = this._viewDate;
		        date.setHours(0, 0, 0, 0);
		        if (isViewModeZero && !ZC.Date.areDatesEqual(viewDate, oldViewDate) || !isViewModeZero) {
		            this._isDrilldown && this._setViewMode(0, true);
		            this._buildData(true);
		        }
		        !doNotTrigger && this._dispatchEvent('todaybuttonclick', orgEvent, this._getSingleValue(viewDate)); // No I18N
		        if (opts.todayButtonAction === 'navigate-and-select') { // No I18N
		            let todayElement = this._getDateElem(date); // No I18N
		            if (!todayElement.hasClass('is-disabled')) { // No I18N
		                this._setDate(orgEvent, todayElement, date);
		                isViewModeZero && opts.closeOnDateSelect && opts.immediateCommit && opts.selectionType === 'single' && this._closePicker(); // No I18N
		            }
		        }
		    }
		};
		_fillYears  (firstView) {
		    let orgEvent,
		        element = this.element,
		        viewMode = this._viewMode;
		    if (firstView && firstView.type !== undefined) {
		        firstView.stopPropagation();
		        firstView.preventDefault();
		        orgEvent = firstView;
		    }
		    !(this._monthDrillDownElement && viewMode === 1) && this._fillMonths(orgEvent);
		    this._fireDrilldownEv(true, orgEvent); // No I18N
		    let yrStart = Math.floor(this._viewDate.getFullYear() / 10) * 10,
		        yrEnd = yrStart + 9;
		    this._yearStart = yrStart;
		    if (this._monthDrillDownElement) {
		        this._buildDrilldownView({
		            view: 'year',
		            year: this._translateEToA(yrStart + ' - ' + yrEnd),
		            fn: [ 'buildYearDecadeBody', yrStart - 1, yrEnd + 2, 1 ] // No I18N
		        }, 2, orgEvent);
		    }
		    this._setViewMode(2, typeof firstView === 'boolean', element); // No I18N
		    this._fireDrilldownEv(false, orgEvent, this._yearDrillDownElement);
		}
		_getYearClasses  (year, index) {
		    let clsName = ' zdatetimepicker', // No I18N
		        opts = this._opts,
		        disabledYrs = opts.disabledYears,
		        classes = clsName + '__year ' + clsName + (index === 1 || index === 12 ? '__drilldownnearlevelcell' : '__monthyeargrid'), // No I18N
		        min = this._minDate,
		        max = this._maxDate,
		        isSelect = this._currentSelected && this._currentSelected.getFullYear() === year,
		        value = opts.value;
		    if (value && value.getFullYear() === year && isSelect || isSelect) {
		        classes += ' is-selected'; // No I18N
		    }
		    opts.selectionType === 'multiple' && (opts.values.length || this._selectedDates.length) && (classes += this._addSelectClass('FullYear', year)); // No I18N
		    if (new Date().getFullYear() === year) {
		        classes += clsName + '--currentcell'; // No I18N
		    }
		    if (year < 1 || min && year < min.getFullYear() || max && year > max.getFullYear() || disabledYrs && disabledYrs.indexOf(year) > -1) {
		        classes += ' is-disabled zdisabled'; // No I18N
		    }
		    return classes;
		}
		_handleDecadeArrowClick  (orgEvent) {
		    orgEvent.stopPropagation();
		    let target = $(orgEvent.target),
		        viewDate = this._viewDate,
		        id = orgEvent.currentTarget.getAttribute('id'),
		        viewMode = this._viewMode,
		        isViewMode2 = viewMode === 2;
		    if (!target.closest('.zdatetimepicker__navbutton').hasClass('is-disabled')) { // No I18N
		        let moveBy,
		            view = isViewMode2 ? 'year' : 'decade', // No I18N
		            startFactor = 10,
		            year, curYear, yearStart,
		            endFactor = 9,
		            yearEnd,
		            incrementer = isViewMode2 ? 1 : 10; // No I18N
		        moveBy = (id.indexOf(this._elementId + '-right-month') > -1 ? 1 : -1) * incrementer; // No I18N
		        year = isViewMode2 ? this._yearStart : this._decadeStart;
		        year = typeof year === 'number' ? year : viewDate.getFullYear(); // No I18N
		        let yearVal = year + startFactor * moveBy;
		        curYear = typeof yearVal === 'number' ? yearVal : this._viewDate.getFullYear(); // No I18N
		        this._data.month[0][view + 'Drilldown'].cells = null;
		        yearStart = Math.floor(curYear / (startFactor * incrementer)) * (startFactor * incrementer);
		        yearEnd = yearStart + endFactor * incrementer;
		        this._buildDrilldownView({
		            view,
		            year: this._translateEToA(yearStart + ' - ' + yearEnd),
		            fn: [ 'buildYearDecadeBody', yearStart - incrementer, yearEnd + 2 * incrementer, incrementer ], // No I18N
		            placeholder: isViewMode2 ? 'month' : 'year' // No I18N
		        }, viewMode, orgEvent); // No I18N
		        this._display(undefined, this['_' + view + 'DrillDownElement']);
		        this['_' + (isViewMode2 ? 'year' : 'decade') + 'Start'] = yearStart; // No I18N
		        this._updateYearArrowState(viewMode, yearStart);
		    }
		    this._dispatchEvent((isViewMode2 ? 'decade' : 'century') + 'change', orgEvent, { // No I18N
		        viewDate: this._viewDate,
		        value: this._opts.value
		    });
		}
		_generateYearDropdown  (data) {
		    let elem = this._yearDropdown,
		        yearOpts = this._getYearDropdownOpts();
		    data.yearSelect = {
		        id: this._elementId + '-year-header', // No I18N
		        acceptNewValues: true,
		        width: '82px', // No I18N
		        templateRender: true,
		        isCE: this.isCE,
		        dropdownList: {
		            width: 99,
		            height: 330,
		            className: 'zdatetimepicker--menu' // No I18N
		        },
		        selectedValue: yearOpts.selectedValue,
		        mainElement: elem ? elem[0] : null,
		        options: yearOpts.yearJSON,
		        rtl: this._opts.rtl,
		        change: this._selectClickHandler.bind(this),
		        allowDisabledOptionsForSelection: true,
		        search: {
		            showNoResultsMessage: false
		        }
		    };
		}
		_getYearDropdownOpts  () {
		    let opts = this._opts,
		        navBar = opts.navigationBar,
		        defaultNavBar = this._DEFAULTS.navigationBar,
		        viewDate = this._viewDate,
		        curYear = new Date().getFullYear(),
		        year = viewDate.getFullYear(),
		        min = this._minDate,
		        max = this._maxDate,
		        value = opts.value,
		        selectedValue,
		        startValue,
		        endValue,
		        startOffset = navBar.dropdownStartYear,
		        endOffset = navBar.dropdownEndYear,
		        disabledYears = opts.disabledYears,
		        convertOffset = ZC.Date.convertOffsetToValue.bind(ZC),
		        yearVal = value ? value.getFullYear() : undefined;
		    startValue = startOffset;
		    endValue = endOffset;
		    startOffset = convertOffset((+startOffset ? defaultNavBar.dropdownStartYear : startOffset).substring(9));
		    startValue = +startValue || (curYear + startOffset);
		    endOffset = convertOffset((+endOffset ? defaultNavBar.dropdownEndYear : endOffset).substring(9));
		    endValue = +endValue || (curYear + endOffset);
		    if (endValue < startValue) {
		        let start = startValue;
		        startValue = endValue;
		        endValue = start;
		    }
		    if (value) {
		        endValue = yearVal + endOffset;
		        startValue = yearVal + startOffset;
		    }
		    if (min) {
		        let oldStart = startValue,
		            minYr = min.getFullYear();
		        if (minYr > oldStart) {
		            startValue = minYr
		            endValue < minYr && (endValue = minYr + endOffset);
		        }
		    } else if (value && startValue > yearVal) {
		        startValue = yearVal;
		        endValue = yearVal + endOffset;
		    }
		    if (max) {
		        endValue = max.getFullYear();
		        startValue = endValue <= startValue ? (min || max).getFullYear() : startValue;
		    }
		    let yearJSON = [];
		    for (let i = startValue; i <= endValue; i++) {
		        year === i && (selectedValue = i)
		        yearJSON.push({
		            value: i,
		            selected: year === i,
		            disabled: (max && max.getFullYear() === i && viewDate.getMonth() > max.getMonth()) || year !== i && disabledYears && disabledYears.indexOf(i) > -1,
		            label: i
		        })
		    }
		    return {
		        selectedValue,
		        yearJSON
		    }
		}
		_setYearDropdownVal  (minYr, minMonth, maxYr, maxMonth) {
		    let yearInstance = ZC.combobox(this._yearHeader),
		        viewDate = this._viewDate;
		    if (this._data.modifiedAttr === 'minOrMax') {
		        let yearJSON = this._getYearDropdownOpts().yearJSON;
		        yearInstance.setAttribute('options', yearJSON);
		    }
		    maxYr && yearInstance.setOptionAttributes(maxYr, 'disabled', viewDate.getMonth() > maxMonth); // No I18N
		    minYr && yearInstance.setOptionAttributes(minYr, 'disabled', viewDate.getMonth() < minMonth); // No I18N
		    yearInstance.setAttributes({
		        selectedValue: viewDate.getFullYear()
		    });
		}
		_getYrNavBtnProps  (curNav, navBar) {
		    !curNav.lYearIcon && (curNav.lYearIcon = this._getIconProps(navBar, 'fastbackward', 'previousYear', '-left-year', 'prevYear')); // No I18N
		    !curNav.rYearIcon && (curNav.rYearIcon = this._getIconProps(navBar, 'fastforward', 'nextYear', '-right-year', 'nextYear')); // No I18N
		}
		_handleYearArrowClick  (orgEvent) {
		    this._rowsCount = [];
		    let opts = this._opts,
		        target = $(orgEvent.target),
		        id = orgEvent.currentTarget.getAttribute('id'), // No I18N
		        yearStep = opts.navigationBar.yearNavigationStep,
		        str;
		    if (!target.closest('.zdatetimepicker__navbutton').hasClass('is-disabled')) { // No I18N
		        str = this._elementId + '-right-'; // No I18N
		        this._arrowClickHandler(id.indexOf(str + 'year') > -1 || id.indexOf(str + 'month') > -1 && this._viewMode > 0 ? yearStep : -yearStep, // No I18N
		            undefined,
		            true);
		    }
		    this._dispatchChangeEvent(orgEvent, 'year', this._viewDate.getFullYear()); // No I18N
		}
	}
	ZC.registerComponent('ZDatePicker', ZDatePicker); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zdatepicker.Templates, utilities = ZC.Templates.Utilities; 
template.WCChildren = (data) => ZT.html `${data.displayType === 'callout' && ZT.html `<div class='zdatetimepicker__pointer'></div>`} ${data.title && template.WCTitle(data.title)} ${data.monthsPerView > 1 ? ZT.html `<ul class='zdatetimepicker__container'> ${ZC.iterateData(data.monthsPerView, (item, i) => ZT.html `<li class='zdatetimepicker__list'> <div class='zdatetimepicker'> ${template.WCMonth(data.month[i])} ${template.WCDrilldownView(data.month[i])} </div> </li>`)} </ul>` : ZT.html `${template.WCMonth(data.month[0])} ${template.WCDrilldownView(data.month[0])} ` } ${data.cBar && !data.isCBar && utilities.WCCommandBar(data.cBar)}`; 
template.WCDrilldownView = (data) => ZT.html `${data.monthDrilldown && template.WCDrilldown(data.monthDrilldown)} ${data.yearDrilldown && template.WCDrilldown(data.yearDrilldown)} ${data.decadeDrilldown && template.WCDrilldown(data.decadeDrilldown)} `; 
template.WCMonth = (data) => ZT.html `<div class="zdatetimepicker__monthcontainer zdatetimepicker__days" ?style='${data.style}'> ${template.WCNavBar(data.navigationBar)} <div class="zdatetimepicker__calendar"> ${data.displayWeekNumbers && template.WCWeekNumbers(data)} <table role="grid" class=${data.className}> <thead> <tr role='row' class='zdatetimepicker__week'> ${data.days.map((day) => ZT.html `<th class=${day.class}>${day.value}</th>`)} </tr> </thead> <tbody> ${data.dates.map((row) => ZT.html `<tr> ${row.map((cell) => ZT.html `<td role='gridcell' ?class='${cell.class}' ?data-time='${cell.time}' ?title='${cell.title}'> <span class='zdatetimepicker__text'>${cell.text} </span> ${cell.infoText && ZT.html `<span class='zdatetimepicker__secondaryinfo'>${cell.infoText}</span>`} </td>`)}`)} </tbody> </table> </div> </div>`; 
let icon = ZC.zbutton.Templates.WCContainer; 
template.WCNavBar = (data) => ZT.html `<div class="zdatetimepicker__navbar ${data.class}"> ${data.isLMonthYear && data.isSplit ? ZT.html `<div class="zdatetimepicker__leftnav"> ${data.lYear && icon(data.lYearIcon)} ${data.lMonth && icon(data.lMonthIcon)} </div>` : ''} ${data.monthSelect && !data.month && (data.yrFirst ? ZC.createComboBox(data.yearSelect) : ZC.createSelect(data.monthSelect))} ${data.isMonthYearNav && ZT.html `<div class="zdatetimepicker__monthyearnav ${data.cursorCls}"> ${data.month && ZT.html `<span class='zdatetimepicker__monthnav'> ${data.month} </span>`} ${data.year && ZT.html `<span class='zdatetimepicker__yearnav'> ${data.year} </span>`} </div>`} ${data.yearSelect && !data.year && (data.yrFirst ? ZC.createSelect(data.monthSelect) : ZC.createComboBox(data.yearSelect))} ${data.isRMonthYear ? ZT.html `<div class="zdatetimepicker__rightnav"> ${!data.isSplit && data.lYear && icon(data.lYearIcon)} ${!data.isSplit && data.lMonth && icon(data.lMonthIcon)} ${data.rMonth && icon(data.rMonthIcon)} ${data.rYear && icon(data.rYearIcon)} </div>` : ''} </div > `; 
template.WCDrilldown = (data) => ZT.html `<div class='zdatetimepicker__${data.view}drilldown zdatetimepicker__monthcontainer' ?style='${data.style}'> ${template.WCNavBar(data.navigationBar)} ${data.cells && ZT.html `<div class="zdatetimepicker__drilldownview"> <table role="grid" class="zdatetimepicker__drilldowncell"> <tbody> ${data.cells.map((cell) => cell.isTr ? ZT.html `<tr role='row'>` : ZT.html `<td role='gridcell' class='${cell.class}' data-value="${cell.attr}">${cell.value}</td>`)} </tbody> </table> </div> </div>`}`; 
template.WCTitle = (data) => ZT.html `${data.value && ZT.html `<div class='zdatetimepicker__titlebar' role='heading'> <span class='zdatetimepicker__title'>${ZT.customHTML(data.value)}</span> ${data.closeButton && ZC.zbutton.Templates.WCContainer(data.closeSVGProps)} </div>`}`; 
template.WCWeekNumbers = (data) => ZT.html `<table role='grid' class='zdatetimepicker__weeknumbers'> <thead> <tr role="row"> <th class="zdatetimepicker__weeknumber">${data.weekTitle}</th> </tr> </thead> <tbody> ${data.weekNumbers.map((value) => ZT.html `<tr role="row"><td role="gridcell" class="zdatetimepicker__weeknumber">${value}</td></tr>`)} </tbody> </table>`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zdatepicker.Templates, utilities = ZC.Templates.Utilities; 
template.children = (data) => ZT.html `${data.displayType === 'callout' && ZT.html `<div class='zdatetimepicker__pointer'></div>`} ${data.title && template.title(data.title)} ${data.monthsPerView > 1 ? ZT.html `<ul class='zdatetimepicker__container'> ${ZC.iterateData(data.monthsPerView, (item, i) => ZT.html `<li class='zdatetimepicker__list'> <div class='zdatetimepicker'> ${template.month(data.month[i])} ${template.drilldownView(data.month[i])} </div> </li>`)} </ul>` : ZT.html `${template.month(data.month[0])} ${template.drilldownView(data.month[0])} ` } ${data.cBar && !data.isCBar && utilities.commandBar(data.cBar)}`; 
template.drilldownView = (data) => ZT.html `${data.monthDrilldown && template.drilldown(data.monthDrilldown)} ${data.yearDrilldown && template.drilldown(data.yearDrilldown)} ${data.decadeDrilldown && template.drilldown(data.decadeDrilldown)} `; 
template.month = (data) => ZT.html `<div class="zdatetimepicker__monthcontainer zdatetimepicker__days" ?style='${data.style}'> ${template.navBar(data.navigationBar)} <div class="zdatetimepicker__calendar"> ${data.displayWeekNumbers && template.weekNumbers(data)} <table role="grid" class=${data.className}> <thead> <tr role='row' class='zdatetimepicker__week'> ${data.days.map((day) => ZT.html `<th class=${day.class}>${day.value}</th>`)} </tr> </thead> <tbody> ${data.dates.map((row) => ZT.html `<tr> ${row.map((cell) => ZT.html `<td role='gridcell' ?class='${cell.class}' ?data-time='${cell.time}' ?title='${cell.title}'> <span class='zdatetimepicker__text'>${cell.text} </span> ${cell.infoText && ZT.html `<span class='zdatetimepicker__secondaryinfo'>${cell.infoText}</span>`} </td>`)}`)} </tbody> </table> </div> </div>`; 
let icon = ZC.zbutton.Templates.container; 
template.navBar = (data) => ZT.html `<div class="zdatetimepicker__navbar ${data.class}"> ${data.isLMonthYear && data.isSplit ? ZT.html `<div class="zdatetimepicker__leftnav"> ${data.lYear && icon(data.lYearIcon)} ${data.lMonth && icon(data.lMonthIcon)} </div>` : ''} ${data.monthSelect && !data.month && (data.yrFirst ? ZC.createComboBox(data.yearSelect) : ZC.createSelect(data.monthSelect))} ${data.isMonthYearNav && ZT.html `<div class="zdatetimepicker__monthyearnav ${data.cursorCls}"> ${data.month && ZT.html `<span class='zdatetimepicker__monthnav'> ${data.month} </span>`} ${data.year && ZT.html `<span class='zdatetimepicker__yearnav'> ${data.year} </span>`} </div>`} ${data.yearSelect && !data.year && (data.yrFirst ? ZC.createSelect(data.monthSelect) : ZC.createComboBox(data.yearSelect))} ${data.isRMonthYear ? ZT.html `<div class="zdatetimepicker__rightnav"> ${!data.isSplit && data.lYear && icon(data.lYearIcon)} ${!data.isSplit && data.lMonth && icon(data.lMonthIcon)} ${data.rMonth && icon(data.rMonthIcon)} ${data.rYear && icon(data.rYearIcon)} </div>` : ''} </div > `; 
template.drilldown = (data) => ZT.html `<div class='zdatetimepicker__${data.view}drilldown zdatetimepicker__monthcontainer' ?style='${data.style}'> ${template.navBar(data.navigationBar)} ${data.cells && ZT.html `<div class="zdatetimepicker__drilldownview"> <table role="grid" class="zdatetimepicker__drilldowncell"> <tbody> ${data.cells.map((cell) => cell.isTr ? ZT.html `<tr role='row'>` : ZT.html `<td role='gridcell' class='${cell.class}' data-value="${cell.attr}">${cell.value}</td>`)} </tbody> </table> </div> </div>`}`; 
template.title = (data) => ZT.html `${data.value && ZT.html `<div class='zdatetimepicker__titlebar' role='heading'> <span class='zdatetimepicker__title'>${ZT.customHTML(data.value)}</span> ${data.closeButton && ZC.zbutton.Templates.container(data.closeSVGProps)} </div>`}`; 
template.weekNumbers = (data) => ZT.html `<table role='grid' class='zdatetimepicker__weeknumbers'> <thead> <tr role="row"> <th class="zdatetimepicker__weeknumber">${data.weekTitle}</th> </tr> </thead> <tbody> ${data.weekNumbers.map((value) => ZT.html `<tr role="row"><td role="gridcell" class="zdatetimepicker__weeknumber">${value}</td></tr>`)} </tbody> </table>`; }(ZComponents)); 
(function(ZC, $){
	class ZDateTimePicker extends ZC.ZDatePicker {
			get name(){
				return "zdatetimepicker";
			}
	    get props() {
	        return {
	            timeLabelIconClassName: null,
	            fixedTimeOptions: [],
	            disabledTimeList: [],
	            labels: {
	                timeLabel: 'Time' // No I18N
	            },
	            closeOnDateSelect: false
	        }
	    }
	    get attrs() {
	        return {
	            timeMultipleSelectBoxType: 'h-m-t', // No I18N
	            timeFieldType: 'input', // No I18N
	            timeLabelType: 'icon', // No I18N
	            timeLabel: null,
	            timeLabelIconClass: null,
	            timeLabelSVGIconId: null,
	            hourStep: 1,
	            minTime: null,
	            maxTime: null,
	            format: 'dd/MM/yyyy, hh:mm tt', // No I18N
	            minuteStep: 5,
	            className: '',
	            /* Options included after requirements */
	            defaultTime: null
	        };
	    }
	    get EVENTS() {
	        return [ 'hourchange', 'minutechange', 'periodchange', 'timechange' ]; // No I18N
	    }
	    _init() {
	        this._checkTime = true;
	        super._init(...arguments);
	        return true;
	    }
	    _validateFormat() {
	        let format = this._opts.format;
	        this._invalidFormat = !((format.indexOf('d') > -1) && (format.indexOf('h') > -1 || format.indexOf('H') > -1));
	    }
	    _getTimeSettings() {
	        let timeOpts = [ 'timeFieldType', 'timeMultipleSelectBoxType', 'minTime', 'maxTime', 'hourStep', 'minuteStep', 'timeLabelType', 'fixedTimeOptions', 'disabledTimeList', 'rtl' ], // No I18N
	            finalOpts = {},
	            opts = this._opts;
	        timeOpts.forEach((opt) => finalOpts[opt] = opts[opt]);
	        finalOpts.timeLabel = opts.timeLabel || this._getI18NText('timeLabel'); // No I18N
	        finalOpts.isCE = this.isCE;
	        finalOpts.templateRender = true;
	        finalOpts.format = this._timeFormat;
	        finalOpts.viewDate = this._viewDate;
	        finalOpts.id = this._elementId + '-timeinput'; // No I18N
	        finalOpts.timechange = this._changeHandler.bind(this);
	        let timeEv = [ 'period', 'hour', 'minute' ], // No I18N
	            base = this;
	        timeEv.forEach((ev) => {
	            ev = ev + 'change';// No I18N
	            finalOpts[ev] = function(evObj) {
	                base._dispatchEvent(ev, evObj, evObj.detail)
	            }
	        })
	        finalOpts.className = ' zdatetimepicker__timebar zh-align' + (this._monthsPerView === 3 && this._isBtnsExist() ? (opts.buttonsAlignment === 'left' ? 'right' : 'left') : 'center');// No I18N
	        let selectedTime = opts.value || opts.defaultTime;
	        if (selectedTime) {
	            finalOpts.selectedTime = new Date(+selectedTime);
	        }
	        this._data.timeProps = finalOpts;
	    }
	    _changeHandler(ev) {
	        let ui = ev.detail,
	            selectedTime = ui.selectedTime;
	        if (ui.fromUI) {
	            this._selectedTime = selectedTime;
	            this._opts.selectionType === 'multiple' && this._setTimeForMultiple(selectedTime); // No I18N
	            this._triggerChange(ev);
	            this._dispatchEvent('timechange', ev, { // No I18N
	                ...this._getSelectedValue(),
	                selectedTime,
	                selectedTimeString: ZC.Date.formatDate(selectedTime, this._timeFormat)
	            });
	        }
	    }
	    _validateOpts() {
	        super._validateOpts();
	        let opts = this._opts;
	        [ 'hourStep', 'minuteStep' ].forEach((value) => { // No I18N
	            opts[value] = +opts[value] > 0 ? opts[value] : 1;
	        });
	        if (!(opts.minTime || opts.value || opts.values.length) && opts.defaultTime) {
	            let defaultTime = this._getDateVal(opts.defaultTime);
	            opts.defaultTime = defaultTime;
	            this._viewDate.setHours(defaultTime.getHours(), defaultTime.getMinutes(), 0, 0)
	        } else {
	            opts.defaultTime = null;
	        }
	    }
	    _setFormat() {
	        let format = this._opts.format,
	            hourIndex = Math.max(format.indexOf('h'), format.indexOf('H')), // No I18N
	            dateIndex = Math.min(Math.min(format.indexOf('d'), format.indexOf('M')), format.indexOf('y')), // No I18N
	            lastIndex, first;
	        this._is12HourFormat = format.indexOf('h') > -1;
	        if (hourIndex > dateIndex) {
	            this._timeFormat = format.substring(hourIndex); // No I18N
	            format = format.replace(this._timeFormat, '');// No I18N
	            lastIndex = Math.max(Math.max(format.lastIndexOf('d'), format.lastIndexOf('M')), format.lastIndexOf('y'));// No I18N
	            first = '_date';// No I18N
	        } else {
	            // if timeFormat comes before dateFormat
	            this._dateFormat = format.substring(dateIndex);
	            format = format.replace(this._dateFormat, '');// No I18N
	            lastIndex = Math.max(format.lastIndexOf('m'), format.lastIndexOf('t'));// No I18N
	            first = '_time';// No I18N
	        }
	        this[first + 'Format'] = format.substring(0, lastIndex + 1); // No I18N
	    }
	    _buildData(shouldRender) {
	        super._buildData();
	        !this._doNotBuildTime && this._buildTimeElem();
	        this._data.isCBar = true;
	        shouldRender && this._render();
	        this._doNotBuildTime = undefined;
	    }
	    _buildTimeElem() {
	        let min, max;
	        if (this._minDateHasTime || this._maxDateHasTime) {
	            min = this._checkToUnSetVal('_minTime'); // No I18N
	            max = this._checkToUnSetVal('_maxTime');// No I18N
	        }
	        this._getTimeSettings();
	        (min || max) && this._setMinMaxVal(min, max);
	    }
	    _addTripleCls() {
	        let clsName = 'zdatetimepicker--triplecalendar', // No I18N
	            data = this._data;
	        if (this._monthsPerView === 3 && Object.keys(data.cBar).length) {
	            data.className.indexOf(clsName) < 0 && (data.className += ' ' + clsName);// No I18N
	        } else {
	            data.className = data.className.replace(/zdatetimepicker--triplecalendar/g, '');
	        }
	    }
	    _postRender() {
	        super._postRender(...arguments);
	        this._timeInstance = ZC.timeinput($('#' + this._elementId + '-timeinput'));
	        this._selectedTime = this._timeInstance.getAttribute('value');
	    }
	    _postEachRender(elem, data) {
	        let firstRender = !data.rendered,
	            modifiedAttr = data.modifiedAttr;
	        if (firstRender || [ 'commandBar, monthsPerView' ].indexOf(modifiedAttr) > -1) { // No I18N
	            this._isBtnsExist() && this._addTripleCls();
	        }
	        super._postEachRender(...arguments);
	        // if (this._timeElemRendered || this._valueReset) { // No I18N
	        //     if (this._timeElemRendered) {
	        //         if (opts.timeFieldType === 'input') { // No I18N
	        //             let elem = this.element.find('.zinputfield'); // No I18N
	        //             this._input = this.isCE ? elem : elem.prev();// No I18N
	        //             timeProps.inputProps.mainElement = this._input[0];
	        //         } else {
	        //             this._setSelectElement(...arguments);
	        //         }
	        //     }
	        //     if (opts.timeFieldType === 'multiple-select-box' && modifiedAttr !== 'singleSelect') { // No I18N
	        //         this._checkForTime();
	        //     }
	        //     this._updateSelectedTime(opts.timeFieldType, this._timeElemRendered);
	        //     this._time._postEachRender(...arguments);
	        // }
	        // this._timeElemRendered = this._valueReset = undefined;
	    }
	    _setSelectedTime() {
	        let minTime = this._minTime,
	            value = this._selectedTime = minTime ? new Date(+minTime) : undefined;
	        this._timeInstance.setAttribute('viewDate', new Date(+value));
	        return value;
	    }
	    _setValue(dateString) {
	        let shouldRender = super._setValue(dateString, false);
	        this._setTimeValues(undefined, true);
	        this._doNotBuildTime = true;
	        shouldRender && this._buildData(true);
	    }
	    _triggerChange(orgEvent) {
	        /* When closeOnDateSelect is true, picker should not be closed on time change, if it is false, default handling will be done */
	        let opts = this._opts;
	        opts.immediateCommit && (this._currentSelected || this._selectedDates.length) && this._OKClickHandler(orgEvent, true, opts.closeOnDateSelect);
	    }
	    _OKClickHandler() {
	        if (!this._selectedTime) {
	            let date = this._timeInstance.getAttribute('value');
	            if (!date) {
	                date = new Date(this._minTime || new Date().setHours(0, 0, 0, 0));
	                this._timeInstance.setTime(date);
	            }
	            this._viewDate.setHours(date.getHours(), date.getMinutes(), 0, 0);
	            this._selectedTime = new Date(+date);
	        }
	        !(this._currentSelected || this._selectedDates.length) && this._setSelectedTime();
	        super._OKClickHandler(...arguments);
	    }
	    _updateValues() {
	        super._updateValues();
	        let opts = this._opts,
	            setTimeVal = this._setTimeValues.bind(this);
	        this._timeInstance.setAttribute('valueUpdate', this._valueUpdate); // No I18N
	        if (!this._valueUpdate) {
	            if (opts.timeFieldType === 'multiple-select-box') { // No I18N
	                this._timeInstance.update();
	                setTimeVal(true, true);
	            } else {
	                setTimeVal();
	            }
	        } else if (this._valueUpdate && !opts.immediateCommit) {
	            setTimeVal();
	        }
	    }
	    _clearValues(orgEvent, doNotCallSuper) {
	        !doNotCallSuper && super._clearValues(orgEvent); // Since, if clearButton clicked, clearClickHandler will call clearValues of datepicker twice.
	        this._timeInstance.clearTime();
	        this._timeInstance.refresh();
	    }
	    _setDate(orgEvent, target, date) {
	        let opts = this._opts;
	        if (opts.selectionType === 'single') { // No I18N
	            this._viewDate = new Date(+date);
	        }
	        if (this._minDateHasTime || this._maxDateHasTime) {
	            this._setBoundaryValuesForTimeInput(); // No I18N
	        }
	        this._selectedTime = ZC.timeinput($('#' + this._elementId + '-timeinput')).getAttribute('selectedTime');
	        // this._valueReset && this._updateSelectedTime(opts.timeFieldType);
	        // let selected = this._selectedTime;
	        // this._viewDate.setHours(selected.getHours(), selected.getMinutes(), selected.getSeconds());
	        super._setDate(orgEvent, target, opts.selectionType === 'single' ? this._viewDate : date); // No I18N
	        if (this._selectedDates.length === 0 && opts.selectionType === 'multiple') { // No I18N
	            this._setTimeValues();
	        }
	    }
	    _resetValues() {
	        this._valueReset = true;
	        super._resetValues(true);
	        let min, max;
	        if (this._minDateHasTime || this._maxDateHasTime) {
	            min = this._checkToUnSetVal('_minTime'); // No I18N
	            max = this._checkToUnSetVal('_maxTime');// No I18N
	        }
	        if (this._minTime) {
	            this._viewDate.setHours(this._minTime.getHours(), this._minTime.getMinutes(), 0, 0);
	        }
	        (min || max) && this._setMinMaxVal(min);
	    }
	    _setTimeValues(forceReset, valueCheck, doNotReset) {
	        let opts = this._opts,
	            minTime, maxTime,
	            viewDate = this._viewDate;
	        if (!doNotReset && (this._minDateHasTime || this._maxDateHasTime)) {
	            minTime = this._checkToUnSetVal('_minTime'); // No I18N
	            maxTime = this._checkToUnSetVal('_maxTime'); // No I18N
	        }
	        let value = valueCheck === false ? undefined : (opts.selectionType === 'single' || opts.value ? viewDate : (opts.values.length ? this._getDateVal(opts.values[0], opts.format) : undefined)), // No I18N
	            date;
	        if (value && !forceReset) {
	            date = new Date(viewDate.getTime());
	            date.setHours(viewDate.getHours(), viewDate.getMinutes(), 0, 0);
	        }
	        this._timeInstance.setAttribute('valueUpdate', this._valueUpdate); // No I18N
	        this._timeInstance.setTime(date);
	        (minTime || maxTime) && this._setMinMaxVal(minTime, maxTime);
	    }
	    _getDateVal(value) {
	        return ZC.Date.parseDate(value, this._timeFormat).date;
	    }
	    _destroy() {
	        let inputElem = this._input;
	        if (inputElem && inputElem.length && this.isCE) {
	            inputElem.remove();
	        }
	        this._timeInstance.destroy();
	        super._destroy();
	        this._timeInstance = undefined;
	        this._footer = this._input = undefined;
	    }
		_clearClickHandler   (orgEvent, doNotTrigger) {
		    if (orgEvent && !$(orgEvent.target).closest(this._clear).hasClass('is-disabled') || !orgEvent) { // No I18N
		        super._clearClickHandler(orgEvent, true);
		        this._clearValues(orgEvent, true);
		        !doNotTrigger && this._dispatchEvent('clear', orgEvent, { // No I18N
		            valuesObject: [],
		            values: [],
		            options: this._opts
		        });
		    }
		}
		_setBoundaryValuesForTimeInput  () {
		    let setMin = this._checkToUnSetVal('_minTime'), // No I18N
		        setMax = this._checkToUnSetVal('_maxTime'), // No I18N
		        shouldSetVal = this._checkLimitValues();
		    /* Commenting the below code temporarily. Since if the time value is not in range, it will be reset in timeinput and the below code might not be required. */
		    // if (timeFieldType === 'input') { // No I18N
		    //     let date;
		    //     if (shouldSetVal.setMin) {
		    //         date = this._timeInstance.getAttribute('value');
		    //         date.setDate(viewDate.getDate());
		    //         date.setMonth(viewDate.getMonth());
		    //         date.setFullYear(viewDate.getFullYear());
		    //     } else {
		    //         date = this._minTime;
		    //     }
		    //     this._opts.selectedTime = new Date(+date);
		    //     this._timeInstance.setTime(date);
		    // } else if (timeFieldType === 'multiple-select-box') { // No I18N
		    this._viewDate.setHours(this._selectedTime.getHours(), this._selectedTime.getMinutes(), 0, 0);
		    this._resetTimeVal();
		    // }
		    if (shouldSetVal.setMin) {
		        this._timeInstance.setAttribute('minTime', undefined); // No I18N
		        this._timeInstance.refresh();
		    } else if (shouldSetVal.setMax) {
		        this._timeInstance.setAttribute('maxTime', undefined); // No I18N
		        this._timeInstance.refresh();
		    } else {
		        this._timeInstance.setAttribute('minTime', this._minTime); // No I18N
		        this._timeInstance.setAttribute('maxTime', this._maxTime);
		    }
		    (setMin || setMax) && this._setMinMaxVal(setMin, setMax);
		}
		_resetTimeVal  () {
		    let resetToToday = this._resetToToday.bind(this),
		        viewDate = resetToToday(new Date(+this._viewDate)),
		        min = resetToToday(this._minTime ? new Date(+this._minTime) : undefined),
		        max = resetToToday(this._maxTime ? new Date(+this._maxTime) : undefined);
		    if (min && viewDate && +viewDate < +min) {
		        viewDate = new Date(+min);
		    }
		    if (max && viewDate && +viewDate > +max) {
		        viewDate = new Date(+max);
		    }
		    this._viewDate.setHours(viewDate.getHours(), viewDate.getMinutes(), 0, 0);
		    this._selectedTime = new Date(+this._viewDate);
		    this._timeInstance.setAttribute('viewDate', this._viewDate);
		}
		_resetToToday  (value) {
		    if (value) {
		        let today = new Date();
		        value.setDate(today.getDate());
		        value.setMonth(today.getMonth());
		        value.setFullYear(today.getFullYear());
		    }
		    return value;
		}
		_checkLimitValues  () {
		    let viewDate = new Date(this._viewDate.getTime()),
		        min = this._minDate,
		        max = this._maxDate,
		        isEqual = ZC.Date.areDatesEqual.bind(ZC);
		    viewDate.setHours(0, 0, 0, 0);
		    return (this._minDateHasTime || this._maxDateHasTime) ? {
		        setMin: min && !isEqual(min, viewDate),
		        setMax: max && !isEqual(max, viewDate)
		    } : {};
		}
		_checkToUnSetVal  (opt) {
		    let optVal = this[opt],
		        checkVal = 'set' + (opt === '_minTime' ? 'Min' : 'Max'), // No I18N
		        timeVal = optVal ? new Date(optVal.getTime()) : undefined,
		        shouldSetValue = this._checkLimitValues();
		    if (shouldSetValue[checkVal] && optVal) {
		        this['_' + checkVal] = true;// No I18N
		        this[opt] = undefined;
		    }
		    return timeVal;
		}
		_setMinMaxVal  (min, max) {
		    this._setMin && min && (this._minTime = new Date(min.getTime()));
		    this._setMax && max && (this._maxTime = new Date(max.getTime()));
		    this._setMin = this._setMax = undefined;
		}
		_setTimeForMultiple  (value) {
		    let selectedDates = this._selectedDates;
		    if (this._opts.selectionType === 'multiple') {// No I18N
		        for (let i = 0; i < selectedDates.length; i++) {
		            selectedDates[i].setHours(value.getHours(), value.getMinutes(), 0, 0);
		        }
		    }
		}
		_setAttribute  (optionName, value, pickerEle = this.element) {
		    let timeOptions = [ 'timeFieldType', 'timeLabelType', 'timeLabel', 'timeMultipleSelectBoxType', 'minTime', 'maxTime', 'hourStep', 'minuteStep', 'disabledTimeList', 'fixedTimeOptions' ], // No I18N
		        opts = this._opts,
		        domChange = true;
		   [ 'minTime', 'maxTime', 'timeFieldType'].indexOf(optionName) < 0 && (opts[optionName] = value);// No I18N       
		   if (timeOptions.indexOf(optionName) > -1) {
		        let isDate = value instanceof Date;
		        if ([ 'minTime', 'maxTime' ].indexOf(optionName) > -1) { // No I18N
		            if(value){
		                this['_'+optionName] = isDate ? new Date(+value) : this._getDateVal(value);
		            }else {
		                this['_'+optionName] = null;
		            }
		        }
		        this._opts[optionName] = value;
		        this._buildTimeElem();
		        if(this.isCE){
		            let oldValue = this._timeInstance._opts[optionName];
		            this._timeInstance._opts = this._data.timeProps;
		            this._timeInstance._opts[optionName] = oldValue;
		        }
		        this._timeInstance.setAttribute(optionName, value);
		    } else {
		       domChange = super._setAttribute(optionName, value, pickerEle);
		    }
		    if ([ 'monthsPerView', 'commandBar', 'immediateCommit' ].indexOf(optionName) > -1) { // No I18N
		        this._isBtnsExist() && this._addTripleCls();
		    }else if(optionName === 'format'){ // No I18N
		        this._validateFormat();
		        if(!this._invalidFormat){
		            this._timeInstance.setAttribute('format', value);  // No I18N
		        }
		    }else if(optionName === 'rtl'){  // No I18N
		        this._timeInstance.setAttribute(optionName, value);
		    }
		    this._domChanged = domChange;
		}
		// Revisit
		// _addAprropriateClasses  () {
		//     if (this._doesExist(this._footer)) {
		//         if (this._doesExist(this._timeElement)) {
		//             this.element.addClass(this._CLASSES.triple);
		//         } else {
		//             this.element.removeClass(this._CLASSES.triple);
		//         }
		//     } else if (this._doesExist(this._timeElement)) {
		//         this.element.removeClass(this._CLASSES.triple);
		//     }
		// }
		// _undefineTimeElems  () {
		//     this._singleSelect = this._input = this._combinedEle = this._hourEle = this._minuteEle = this._periodEle = undefined;
		// }
	}
	ZC.registerComponent('ZDateTimePicker', ZC.ZDatePicker, ZDateTimePicker); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zdatetimepicker.Templates, datepickerTemplate = ZC.zdatepicker.Templates, utilities = ZC.Templates.Utilities; 
template.WCChildren = (data) => ZT.html `${datepickerTemplate.WCChildren(data)} ${ZC.createTimeInput(data.timeProps)} ${data.cBar && utilities.WCCommandBar(data.cBar)}` }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zdatetimepicker.Templates, datepickerTemplate = ZC.zdatepicker.Templates, utilities = ZC.Templates.Utilities; 
template.children = (data) => ZT.html `${datepickerTemplate.children(data)} ${ZC.createTimeInput(data.timeProps)} ${data.cBar && utilities.commandBar(data.cBar)}` }(ZComponents)); 
(function(ZC, $){
	class ZDateInput extends ZC.ZInputField {
			get name(){
				return "zdateinput";
			}
	    get attrs() {
	        return {
	            placeholderType: 'date-format', // No I18N
	            jumpOnComplete: true,
	            locale: 'en-US', // No I18N
	            spinButtonsOrientation: 'vertical', // No I18N
	            incrementOnWrapAround: true
	        }
	    }
	    get props() {
	        return {
	            otherInputFormats: []
	        }
	    }
	    _postRender() {
	        if (this._invalidFormat) {
	            return;
	        }
	        super._postRender(...arguments);
	        let opts = this._opts,
	            value = opts.value,
	            optionType = [ 'value', 'min', 'max' ], // No I18N
	            inputElem = this._input; // No I18N
	        // Added since the text values were constantly rotating if direction is rtl
	        // if (opts.rtl) {
	        //     inputElem.css({
	        //         direction: 'ltr' // No I18N
	        //     }); // No I18N
	        // }
	        if (opts.locale === 'ar') { // No I18N
	            inputElem.addClass('zh-bidioverride'); // No I18N
	        }
	        value && (this._viewDate = new Date(value.getTime()));
	        for (let i = 0; i < optionType.length; i++) {
	            let optn = optionType[i];
	            if (opts[optn]) {
	                inputElem.attr('aria-value' + (optn === 'value' ? 'now' : optn), ZC.Date.formatDate(opts[optn], opts.format)); // No I18N
	            }
	        }
	        this._updateElementValue();
	    }
	    _postEachRender(elem, data) {
	        let modified = this._data.modifiedAttr;
	        if (!data.isVertical && (!modified || modified.indexOf('spinButtons') > -1)) {
	            this._data.className += ' zdatetimefield'; // No I18N
	        }
	        super._postEachRender();
	        !this._data.rendered && this._disableSpinBtns();
	    }
	    _init(element, options) {
	        let opts = this._opts;
	        this._format = opts.format;
	        this._setFormat();
	        super._init(element, options);
	        this._performValidations();
	        this._oldDateValue = new Date(this._viewDate.getTime());
	        this._isInit = undefined;
	        /* Updating the locale values */
	        let labels = opts.labels,
	            locale = ZC.localeInfo[opts.locale];
	        if (locale) {
	            let arr = [ 'days', 'daysAbbreviated', 'monthsAbbreviated', 'months' ]; // No I18N
	            for (let i = 0, len = arr.length; i < len; i++) {
	                labels[arr[i]] = locale[arr[i]] || labels[arr[i]];
	            }
	        }
	    }
	    _disableSpinBtns() {
	        let opts = this._opts,
	            cls = 'is-disabled', // No I18N
	            btnPane = this._buttonPane;
	        if (opts.spinButtons !== 'none') { // No I18N
	            btnPane.find('.zh-down')[(opts.min && (+opts.value === +opts.min) ? 'add' : 'remove') + 'Class'](cls);// No I18N
	            btnPane.find('.zh-up')[(opts.max && (+opts.value === +opts.max) ? 'add' : 'remove') + 'Class'](cls); // No I18N
	        }
	    }
	    _setFormatVal(regExp, part, defaultFormat) {
	        let format = this._format,
	            opts = this._opts,
	            isFormatSpecifier = regExp.test(format),
	            labels = opts.labels,
	            locale = opts.locale,
	            ZLocale = ZC.localeInfo[locale];
	        if (isFormatSpecifier) {
	            let props = [ 'days', 'daysAbbreviated', 'months', 'monthsAbbreviated' ]; // No I18N
	            for (let i = 0; i < props.length; i++) {
	                labels[props[i]] = ZLocale[props[i]];
	            }
	            if (part.indexOf('time') > -1) {
	                let arr = [ 'AM', 'PM' ]; // No I18N
	                for (let i = 0; i < arr.length; i++) {
	                    labels[arr[i]] = ZLocale[arr[i]] || this._DEFAULTS.labels[arr[i]];
	                }
	            }
	            let parts = format.split('-'); // No I18N
	            if (parts[0] === part) {
	                format = format.replace(part, (part === 'datetime' ? 'dateTime' : part) + 'Format'); // No I18N
	            }
	            parts = format.split('-'); // No I18N
	            let type = ZLocale[parts[0]];
	            format = type[parts[1]];
	            opts.format = ZLocale && type && format ? format : defaultFormat; // No I18N
	        }
	    }
	    _performValidations(stepValues, parts) {
	        let opts = this._opts; // No I18N
	        this._validateStep(stepValues); // No I18N
	        this._validateFormat();
	        this._validateOptions();
	        let compareDates = this._compareDates.bind(this);
	        compareDates(opts.max, opts.min) && (opts.max = undefined);
	        compareDates(opts.max, opts.value) && (opts.value = opts.max);
	        compareDates(opts.value, opts.min) && (opts.value = opts.min);
	        this._setBoolValue(parts, true, 'Modified'); // No I18N
	        this._checkForModification(opts.value);
	    }
	    _validateOptions() {
	        let opts = this._opts,
	            value,
	            options = [ 'min', 'max', 'value' ]; // No I18N
	        for (let i = 0, len = options.length; i < len; i++) {
	            let optn = options[i];
	            value = opts[optn];
	            value && (opts[optn] = typeof value === 'string' ? this._getStringValue(value, opts) : value instanceof Date ? value : undefined); // No I18N
	            optn === 'value' && (this._viewDate = opts[optn] ? new Date(opts[optn].getTime()) : this._resetViewDate()); // No I18N
	        }
	    }
	    _getStringValue(value, opts) {
	        let format = opts.format;
	        if (value === 'TODAY' || value === 'NOW') { // No I18N
	            return new Date();
	        }
	        let dateInfo = this._parseDateValue(value, format);
	        if (format.indexOf('h') < 0 && format.indexOf('H') < 0 && dateInfo && dateInfo.isValid) {
	            dateInfo.date.setHours(0, 0, 0, 0);
	        }
	        return dateInfo && dateInfo.isValid ? dateInfo.date : undefined;
	    }
	    _resetViewDate() {
	        let date = new Date(new Date().getFullYear(), 0, 1, 0, 0, 0),
	            compareDates = this._compareDates.bind(this),
	            opts = this._opts,
	            min = opts.min,
	            max = opts.max;
	        if (min && compareDates(date, min)) {
	            return new Date(+min);
	        }
	        if (max && compareDates(max, date)) {
	            return new Date(+max);
	        }
	        return date;
	    }
	    _selectText(character) {
	        let format = this._dateFormat;
	        this._oldSegment = this._currentSegment;
	        let end = format.lastIndexOf(character) + 1,
	            start = format.indexOf(character);
	        if (start < 0) {
	            start = 0;
	        }
	        this._currentSegment = character;
	        this._opts.spinButtons !== 'none' && this._addDisabledClass(character); // No I18N
	        this._selectCaretPosition(this._input[0], start, end);
	    }
	    _compareDates(firstDate, secondDate) {
	        if (firstDate && secondDate) {
	            return firstDate.getTime() < secondDate.getTime();
	        }
	    }
	    // call directly if not reused
	    _parseDateValue(date, pattern) {
	        return ZC.Date._parseDateValue(date, pattern, this._opts.otherInputFormats);
	    }
	    _selectCaretPosition(element, start, end) {
	        let isPositioned = start !== undefined;
	        end === undefined && (end = start);
	        if (isPositioned && element.disabled) {
	            return;
	        }
	        try {
	            if (element.selectionStart !== undefined) {
	                if (isPositioned) {
	                    !this._isInit && !this._bodyClick && element.focus();
	                    element.setSelectionRange(start, end);
	                } else {
	                    start = [ element.selectionStart, element.selectionEnd ];
	                }
	            }
	        } catch (e) {
	            throw e;
	        }
	        return start;
	    }
	    _bindEvents() {
	        if (this._invalidFormat) {
	            return;
	        }
	        this._bindButtonEvents();
	        let isIE9 = ZC.Browser.isIE && ZC.Browser.getIEVersion() === 9,
	            clickEvent = ZC.Browser.isFirefox ? 'click' : 'mouseup'; // No I18N
	        this._addEvents({
	            containerMouseUp: clickEvent
	        }, this.container);
	        let keyUp = isIE9 ? 'keyup' : 'input', // No I18N
	            focusOut = isIE9 ? 'blur' : 'focusout', // No I18N
	            eventsObj = {
	                focus: 'focus', // No I18N
	                mouseup: clickEvent, // No I18N
	                keyUp, // No I18N
	                change: 'change', // No I18N
	                keydown: 'keydown', // No I18N
	                spinKeyup: 'keyup', // No I18N
	                focusOut, // No I18N
	                paste: 'paste' // No I18N
	            };
	        // if (this._opts.spinViaMousewheel) {
	        eventsObj.mouseWheel = 'mousewheel DOMMouseScroll MozMousePixelScroll' // No I18N
	        // }
	        this._addEvents(eventsObj, this._input);
	        this._input.on('contextmenu.' + this.name, (event) => event.preventDefault());
	    }
	    _bindButtonEvents() {
	        if (this._opts.clearButton === 'focus' || this._opts.spinButtons === 'focus') { // No I18N
	            this._addEvents({
	                mouseEnter: 'mouseenter', // No I18N
	                mouseLeave: 'mouseleave'// No I18N
	            }, this.container)
	        }
	    }
	    _checkFormat(partsRegex) {
	        this._invalidFormat = partsRegex.test(this._opts.format);
	    }
	    _destroy() {
	        let clearButton = this._clearButton,
	            componentName = this.name;
	        ZC.$window.off(`keyup.${componentName} keydown.${componentName}`); // No I18N
	        this.container.find('.zh-up,.zh-down').off(`mousedown.${componentName} mouseup.${componentName}`); // No I18N
	        clearButton && clearButton.off(`mousedown.${componentName} mouseup.${componentName}`); // No I18N
	        super._destroy();
	        this._buttonPane = this._keyUp = this._keyUpTime = this._isFastInput = undefined;
	    }
	    getValue() {
	        return {
	            dateObject: this._opts.value,
	            dateString: this._opts.value ? this._input[0].value : undefined
	        };
	    }
	    _checkForModification(value) {
	        let format = this._opts.format;
	        for (let i = 0; i < format.length; i++) {
	            this._isPartModified(format[i], !!value);
	        }
	    }
	    setValue(dateString) {
	        if (dateString) {
	            this._validateValue('value', dateString); // No I18N
	            this._viewDate = this._checkMinMaxLimit(this._viewDate);
	            this._checkForModification(this._viewDate);
	            this._updateElementValue();
	        } else {
	            this._clearActionHandler();
	            this._input[0].setSelectionRange(0, 0);
	        }
	        !this.container.hasClass('has-focus') && this._input.trigger('change'); // No I18N
	    }
	    formatDate(dateObject, dateFormat) {
	        return ZC.Date.formatDate(dateObject, dateFormat || this._opts.format)
	    }
	    parseDate(dateString, dateFormat) {
	        return this._parseDateValue(dateString, dateFormat || this._opts.format);
	    }
	    _resetValues(character, value) {
	        if (!isNaN(value) && [ 'y', 'H', 'm', 's' ].indexOf(character) > -1) {
	            let chars = {
	                y: 'FullYear', // No I18N
	                H: 'Hours', // No I18N
	                m: 'Minutes', // No I18N
	                s: 'Seconds' // No I18N
	            };
	            this._viewDate[`set${chars[character]}`](0); // No I18N
	        }
	    }
	    _validateValue(optionName, value) {
	        let isModified = true,
	            opts = this._opts,
	            format = opts.format;
	        if (typeof value === 'string') { // No I18N
	            opts[optionName] = this._getStringValue(value, opts);
	        } else if (value instanceof Date) {
	            opts[optionName] = value;
	        } else {
	            isModified = !!this._oldValueOption;
	            opts[optionName] = undefined;
	        }
	        value = opts.value;
	        if (format.indexOf('h') < 0 && format.indexOf('H') < 0 && value) {
	            value.setHours(0, 0, 0, 0);
	        } else if (value) {
	            value.setHours(value.getHours(), value.getMinutes(), format.indexOf('s') < 0 ? 0 : value.getSeconds(), 0);
	        }
	        if (optionName === 'value') { // No I18N
	            if (value) {
	                this._viewDate = new Date(value.getTime());
	            }
	            if (this._hasPicker) {
	                ZC[this._pickerMethods.instance](this._picker).setValue(value);
	            }
	        }
	        return isModified;
	    }
	    _windowKeyupHandler(orgEvent) {
	        if ((orgEvent.keyCode === ZC.keyCode.TAB && orgEvent.shiftKey || this._reverseShiftKey) && !this._reverseFocusset) {
	            this._reverseFocusset = this._focusout = true;
	            this._selectText(this._dateFormat.slice(-1));
	        } else if ((orgEvent.keyCode === ZC.keyCode.TAB || this._tabKey) && !this._focusset) {
	            this._focusset = this._focusout = true;
	            ZC.OS.isLinux() && this._input[0].setSelectionRange(0, 0);
	            this._mouseupHandler();
	        }
	        ZC.$window.off(`keyup.${this.name} keydown.${this.name}`); // No I18N
	    }
	    _updateElementValue() {
	        let dateFormatRegExp = this._getRegEx();
	        let format = this._opts.format;
	        this._retursFormat = false;
	        let newValue = format.replace(dateFormatRegExp, this._replaceMatchedText.bind(this));
	        this._retursFormat = true;
	        this._dateFormat = format.replace(dateFormatRegExp, this._replaceMatchedText.bind(this));
	        this._oldValue = this._input[0].value = newValue;
	        this._opts.value = this._getDateValue() ? new Date(this._viewDate.getTime()) : undefined;
	    }
	    _windowKeydownHandler(orgEvent) {
	        let tabKeyCode = ZC.keyCode.TAB,
	            keyCode = orgEvent.keyCode;
	        this._reverseShiftKey = keyCode === tabKeyCode && orgEvent.shiftKey;
	        this._tabKey = keyCode === tabKeyCode;
	    }
	    _focusTimeoutHandler() {
	        this._addEvents({
	            windowKeydown: 'keydown', // No I18N
	            windowKeyup: 'keyup'// No I18N
	        }, ZC.$window);
	    }
	    _toggleBtnDisplay(hide, isClear, both, eventType) {
	        let clearHide = hide,
	            showOrHide = this._showOrHideBtn.bind(this);
	        if (isClear) {
	            (clearHide === null || eventType) && (clearHide = this._checkForPartModification());
	            (eventType === 'mouseleave' || !eventType && this._opts.clearButton === 'focus') && !this.container.hasClass('has-focus') && (clearHide = true); // No I18N
	            this._clearBtnShown = !clearHide;
	        }
	        if (clearHide === hide) {
	            showOrHide(...arguments);
	        } else {
	            isClear && showOrHide(clearHide, true);
	            both && showOrHide(hide);
	        }
	    }
	    _showOrHideBtn(hide, isClear, both) {
	        let className = (isClear ? 'zinputfield--withclrbtn' : '') + ((both || !isClear) ? (isClear ? hide ? '|' : ' ' : '') + 'zinputfield--spinbtnonfocus' : ''); // No I18N
	        if (hide) {
	            this._updateClass('', className);
	        } else {
	            this._data.className += ' ' + className;
	        }
	        super._toggleBtnDisplay(...arguments);
	    }
	    _spinTimeoutHandler(orgEvent) {
	        this._changeHandler(orgEvent, 'spin'); // No I18N
	    }
	    _setBoolValue(array, value, txt) {
	        let len = array.length;
	        while (--len >= 0) {
	            this['_' + array[len] + (txt || '')] = value;
	        }
	    }
	    _focusOutHandler(orgEvent) {
	        if (this._hasPicker) {
	            let relTarget = $(orgEvent.relatedTarget);
	            if (relTarget && relTarget.is('.zselectbox')) {
	                return;
	            }
	        }
	        let opts = this._opts;
	        this._setBoolValue([ 'focusset', 'longPress', 'reverseFocusset', 'reverseShiftKey', 'tabKey' ], false); // No I18N
	        this._focusout = true;
	        window.getSelection().removeAllRanges();
	        this._viewDate = this._checkMinMaxLimit(this._viewDate, undefined, undefined, false);
	        this.container.removeClass('has-focus'); // No I18N
	        this._disableSpinBtns();
	        this._updateElementValue();
	        // Setting selectionStart sets focus on the element in the below browsers. So preventing it.
	        if (!(ZC.Browser.isIE || ZC.Browser.isSafari || ZC.OS.isLinux)) {
	            this._input[0].selectionStart = 0;
	        }
	        this._checkForChange(orgEvent, 'change'); // No I18N
	        this._checkButtonsOptn(opts.clearButton === 'focus', opts.spinButtons === 'focus', 'hide', 'add', 'focusOut'); // No I18N
	        this._changeHandler(orgEvent, 'blur'); // No I18N
	        this._isCleared = false;
	    }
	    _validateStep(stepOptions) {
	        for (let i = 0, len = stepOptions.length; i < len; i++) {
	            if (Number(this._opts[stepOptions[i]]) <= 0) {
	                this._opts[stepOptions[i]] = 1;
	            }
	        }
	    }
	    _focusHandler(orgEvent) {
	        let opts = this._opts;
	        if (opts.disabled) {
	            return false;
	        }
	        this.container.addClass('has-focus'); // No I18N
	        this._input[0].setSelectionRange(0, 0);
	        this._focusTimeout = setTimeout(this._focusTimeoutHandler.bind(this), 10);
	        // if (ZC.Browser.isFirefox || ZC.Browser.isSafari || ZC.OS.isLinux()) {
	        //     setTimeout(this._selectionFocusHandler.bind(this), 0);
	        // } else {
	        //     this._input[0].setSelectionRange(0, 0);
	        // }
	        if (!opts.readonly) {
	            this._checkButtonsOptn(opts.clearButton === 'focus', opts.spinButtons !== 'none'); // No I18N
	        }
	        this._clearBtnShown = false;
	        clearTimeout(this._clearButtonTimeout);
	        this._clearButtonTimeout = setTimeout(this._isClearVisible.bind(this), 1000);
	        this._changeHandler(orgEvent, 'focus'); // No I18N
	    }
	    _checkButtonsOptn(isClearButton, isSpinButtons, effect, clsFn, event) {
	        let clrBtn = this._clearButton;
	        clsFn = (clsFn || 'remove') + 'Class'; // No I18N
	        if (isClearButton) { // No I18N
	            event !== 'focusOut' && clrBtn && this._toggleBtnDisplay(null, true, null, event); // No I18N
	            effect && this._toggleBtnDisplay(effect === 'hide', true); // No I18N
	        }
	        if (isSpinButtons) { // No I18N
	            if (this._buttonPane) {
	                this._toggleBtnDisplay(effect === 'hide', false); // No I18N
	                this._opts.calendarIcon && this.container[clsFn]('zdatetimefield--buttonsonhover');
	                clrBtn && clrBtn[clsFn]('zh-right'); // No I18N
	            }
	        }
	    }
	    _mouseEnterHandler() {
	        let opts = this._opts;
	        if (document.activeElement !== this._input[0] && !opts.readonly && !opts.disabled) {
	            this._checkButtonsOptn(opts.clearButton === 'focus', opts.spinButtons === 'focus', null, null, 'mouseenter'); // No I18N
	        }
	    }
	    _addEffect() {
	        this._input.addClass('zeffects--skew'); // No I18N
	        clearTimeout(this._effectTimeout);
	        this._effectTimeout = setTimeout(this._effectTimeoutHandler.bind(this), 1000);
	    }
	    _effectTimeoutHandler() {
	        this._input.removeClass('zeffects--skew'); // No I18N
	    }
	    _getSegment() {
	        let inputElem = this._input[0];
	        this._segment = this._checkForSegment(inputElem.selectionStart, inputElem.selectionEnd - 1);
	    }
	    _getPlaceholder(match) {
	        switch (this._opts.placeholderType) {
	            case 'date-format': // No I18N
	                return match;
	            case 'date-format-in-upper': // No I18N
	                return match.toUpperCase();
	            case 'date-format-in-lower': // No I18N
	                return match.toLowerCase();
	            case 'underscore': // No I18N
	                return new Array(match.length + 1).join('_ ');
	            case 'custom': // No I18N
	                return this._getCustomMatch(match);
	        }
	    }
	    _addDisabledClass(character) {
	        let opts = this._opts,
	            btn = [ 'down', 'up' ], // No I18N
	            offset = [ -1, 1 ]; // No I18N
	        if (opts.value) {
	            for (let i = 0; i < btn.length; i++) {
	                let newDate = this._modifyPartValue(character, offset[i], true);
	                !this._getDisabledValue(opts.min, opts.max, offset[i], newDate) && this.container.find(`.zh-${btn[i]}`).removeClass('is-disabled'); // No I18N
	            }
	        }
	    }
	    _getDisabledValue(min, max, offset, newDate) {
	        let value,
	            updateDisabledState = this._updateDisabledState.bind(this);
	        value = min && offset === -1 ? updateDisabledState(min, newDate, undefined, offset) : undefined;
	        !value && (value = max && offset === 1 ? updateDisabledState(max, newDate, true, offset, value) : undefined);
	        return value;
	    }
	    _checkPart(part) {
	        let parts = this['_get' + (this.name.indexOf('date') > -1 ? 'Date' : 'Time') + 'Parts'](); // No I18N
	        return parts[part] && this[`_${parts[part]}Modified`]; // No I18N
	    }
	    _checkForPartModification() {
	        let values = [],
	            j = 0,
	            format = this._opts.format,
	            valModified = false;
	        for (let i = 0; i < format.length; i++) {
	            values[j++] = this._checkPart(format[i]);
	        }
	        while (--j >= 0) {
	            if (values[j]) {
	                valModified = true;
	                break;
	            }
	        }
	        this._isClearVisible();
	        return !valModified;
	    }
	    // _selectionFocusHandler() {
	    //     this._input[0].setSelectionRange(0, 0);
	    // }
	    _parseValue(character, currentChar) {
	        if (!currentChar) {
	            this._isPartModified(character, false);
	            return true;
	        }
	        let newDate = new Date(this._viewDate.getTime());
	        this._parseSegment(character, currentChar, newDate);
	        // this._oldDateValue = new Date(this._viewDate.getTime());
	        this._viewDate = newDate;
	        return true;
	    }
	    _updateDisabledState(value, newDate, isMax, offset, isDisabled) {
	        let element = this.container.find(`.zh-${offset === 1 ? 'up' : 'down'}`),
	            newDateTime = newDate.getTime(),
	            time, isMore; // No I18N
	        if (value) {
	            !this._checkTime && value.setHours(0, 0, 0, 0);
	            time = value.getTime();
	        }
	        isMore = isMax && value ? newDateTime >= time : newDateTime <= time;
	        if (value && isMore) {
	            element.addClass('is-disabled');
	            return true;
	        }
	        return isDisabled;
	    }
	    _containerMouseUpHandler(orgEvent) {
	        let target = $(orgEvent.target);
	        if (target.closest('.zdatetimefield__icon').length || target.closest('.zdatetimefield__iconbutton').length) { // No I18N
	            orgEvent.preventDefault();
	            if (this._currentSegment) {
	                this._selectText(this._currentSegment);
	            } else {
	                this._selectCaretPosition(this._input[0], 0, 0);
	                this._mouseupHandler();
	            }
	        }
	    }
	    _mouseLeaveHandler() {
	        let opts = this._opts,
	            clrBtn = this._clearButton,
	            buttonPane = this._buttonPane;
	        if (document.activeElement !== this._input[0]) {
	            if (opts.spinButtons === 'focus') { // No I18N
	                buttonPane && this._toggleBtnDisplay(true);
	                clrBtn && clrBtn.addClass('zh-right'); // No I18N
	                opts.calendarIcon && this.container.addClass('zdatetimefield--buttonsonhover');
	            }
	            if (opts.clearButton === 'focus') { // No I18N
	                clrBtn && this._toggleBtnDisplay(true, true, undefined, 'mouseleave'); // No I18N
	            }
	        }
	    }
	    _spinKeyupHandler(orgEvent) {
	        this._keyUp = true
	        let evKeyCode = orgEvent.keyCode;
	        evKeyCode !== ZC.keyCode.LEFT && evKeyCode !== ZC.keyCode.RIGHT && this._checkForChange(orgEvent, 'spinend'); // No I18N
	    }
	    _replaceMatchedText(match) {
	        let result = this._replaceText(match);
	        result = result === undefined ? match.slice(1, match.length - 1) : result;
	        if (this._retursFormat) {
	            let formattedResult = '',
	                i = result.length; // No I18N
	            match = this._getMatch(match);
	            while (i--) {
	                formattedResult += match[0];
	            }
	            return formattedResult;
	        }
	        return result;
	    }
	    _pasteTimeoutHandler(pastedText, orgEvent) {
	        let dateInfo = this._parseDateValue(pastedText, this._opts.format);
	        dateInfo && dateInfo.isValid && (this._viewDate = dateInfo.date);
	        this._checkForModification(dateInfo.isValid);
	        this._updateElementValue();
	        this._selectCaretPosition(this._input[0], 0, 0);
	        this._mouseupHandler(orgEvent);
	        this._pasteAction = false;
	    }
	    _mouseWheelHandler(orgEvent) {
	        let inputElem = this._input,
	            originalEvent = orgEvent.originalEvent;
	        if (document.activeElement === inputElem[0]) {
	            let newEvent = {
	                preventDefault: function() { },
	                type: 'mousewheel' // No I18N
	            }; // No I18N
	            if (!this._keyUp && !this._mousewheelTriggered) {
	                this._keyUp = true;
	            }
	            if (!this._mWheelTimer) {
	                this._mWheelSpinStart = this._checkForChange(orgEvent, 'spinstart'); // No I18N
	            }
	            if (this._mWheelSpinStart) {
	                this._mousewheelTriggered = true;
	                let base = this;
	                clearTimeout(this._mWheelTimer);
	                this._mWheelTimer = setTimeout(() => {
	                    base._checkForChange(orgEvent, 'spinend'); // No I18N
	                    base._mWheelTimer = base._mWheelSpinStart = undefined;
	                }, 250); // No I18N
	                orgEvent.preventDefault();
	                orgEvent.stopPropagation();
	                newEvent.keyCode = (originalEvent.detail === 0 ? originalEvent.wheelDelta < 0 : originalEvent.detail > 0) ? 38 : 40;
	                this._keydownHandler(newEvent);
	            }
	        }
	    }
	    _pasteHandler(orgEvent) {
	        this._pasteAction = false;
	        let pastedText = orgEvent.originalEvent.clipboardData.getData('Text'), // No I18N
	            caretPosition = this._selectCaretPosition(this._input[0]),
	            selectedTextLen; // No I18N
	        // as it can take its value as zero, checked with undefined
	        caretPosition[0] !== undefined && caretPosition[1] !== undefined && (selectedTextLen = caretPosition[1] - caretPosition[0]);
	        if (selectedTextLen && selectedTextLen === this._input[0].value.length) {
	            this._pasteAction = true;
	            orgEvent.stopPropagation();
	            orgEvent.preventDefault();
	            this._input[0].value = pastedText;
	            clearTimeout(this._pasteTimeout);
	            this._pasteTimeout = setTimeout(this._pasteTimeoutHandler.bind(this, pastedText, orgEvent), 500);
	        } else {
	            orgEvent.preventDefault();
	        }
	    }
	    _modifyPartValue(character, offset, disabledCheck) {
	        let newDate = new Date(this._viewDate.getTime()),
	            part = this._modifyValue(newDate, character, offset, this._getDateValue());
	        if (!disabledCheck) {
	            newDate = this._checkMinMaxLimit(newDate, part, offset);
	            this._isPartModified(character, true);
	            this._oldDateValue && this._setOldDate();
	            this._viewDate = newDate;
	            !this._oldDateValue && this._setOldDate();
	        }
	        if (this._hasPicker && (this._opts.pickerOptions.disabledDaysOfWeek || this._opts.pickerOptions.disabledDates)) {
	            this._oldDateValue && this._setOldDate();
	            this._viewDate = this._checkForDisabledDates(this._viewDate, offset);
	            !this._oldDateValue && this._setOldDate();
	        }
	        return newDate;
	    }
	    _setOldDate() {
	        let oldValue = this._oldDateValue;
	        if (!oldValue || (!ZC.Date.areDatesEqual(oldValue, this._viewDate) && !ZC.Date.areTimesEqual(oldValue, this._viewDate))) {
	            this._oldDateValue = new Date(+this._viewDate);
	        }
	    }
	    _mouseupHandler(orgEvent) {
	        this._isClearVisible();
	        let caretPosition = this._selectCaretPosition(this._input[0]);
	        // selecting the text based on the caretPosition
	        if (caretPosition[0] === caretPosition[1]) {
	            this._selectText(this._checkForSegment(caretPosition[0], caretPosition[0] - 1));
	        } else {
	            orgEvent && orgEvent.type === 'mouseup' && window.getSelection().removeAllRanges(); // No I18N
	        }
	    }
	    _checkForSegment(i, j) {
	        let allowedChars = this._allowedChars,
	            format = this._dateFormat;
	        for (let len = format.length; i < len || j >= 0; i++, j--) {
	            if (allowedChars.indexOf(format[i]) !== -1) {
	                return format[i];
	            }
	            if (j >= 0 && allowedChars.indexOf(format[j]) !== -1) {
	                return format[j];
	            }
	        }
	    }
	    _getStringDiff(oldText, oldFormat, newText, caretPosition) {
	        this._isNewValue = false;
	        let txtLen = caretPosition + oldText.length - newText.length,
	            i,
	            diff = [];
	        oldText = oldText.substring(0, txtLen);
	        newText = newText.substring(0, caretPosition);
	        let newTxtLen = newText.length,
	            formatPart = oldFormat[caretPosition - 1];
	        if (oldText === newText && caretPosition > 0) {
	            return [
	                [ formatPart, newText[caretPosition - 1] ]
	            ];
	        }
	        // checks whether the letter is removed
	        if (oldText.indexOf(newText) === 0 && (newTxtLen === 0 || oldFormat[newTxtLen - 1] !== oldFormat[newTxtLen])) {
	            let removedChar = ''; // No I18N
	            for (i = newTxtLen; i < oldText.length; i++) {
	                if (oldText[i] !== removedChar && this._allowedChars.indexOf(oldFormat[i]) >= 0) {
	                    removedChar = oldFormat[i];
	                    diff.push([ removedChar, '' ]); // No I18N
	                }
	                this._resetToFirst(removedChar);
	            }
	            return diff;
	        }
	        let navigationChar = newText[newTxtLen - 1];
	        if (/[ |/|.|-|;]/.test(navigationChar) || navigationChar === oldText[txtLen]) {
	            return [
	                [ oldFormat[caretPosition - 1], navigationChar ]
	            ];
	        }
	        if (this._focusout) {
	            this._resetOnBlur(formatPart);
	            this._focusout = false;
	        }
	        this._isNewValue = true;
	        return [
	            [ formatPart, newText[caretPosition - 1] ]
	        ];
	    }
	    _checkForChange(orgEvent, eventName) {
	        let notFullyModified = this._getDateValue() === undefined,
	            changed,
	            viewDate = this._viewDate,
	            oldDate = this._oldDateValue,
	            triggerEv;
	        if (!notFullyModified) {
	            if (viewDate.getDate() === 1 && viewDate.getMonth() === 0 && viewDate.getFullYear() === new Date().getFullYear() && viewDate.getHours() === 0 && viewDate.getMinutes() === 0 && viewDate.getSeconds() === 0) {
	                changed = true;
	            }
	        }
	        if (eventName.indexOf('spin') > -1) {
	            if (eventName === 'spin') { // No I18N
	                clearTimeout(this._spinTimeout);
	                this._spinTimeout = setTimeout(this._spinTimeoutHandler.bind(this, orgEvent), this._opts.spinEventTriggerDelay);
	            } else {
	                triggerEv = true;
	            }
	        } else if (this._isCleared || (!notFullyModified && (changed || viewDate && oldDate && +oldDate !== +viewDate))) {
	            triggerEv = true;
	        }
	        if (triggerEv) {
	            return this._changeHandler(orgEvent, eventName);
	        }
	    }
	    _changeHandler(orgEvent, eventName) {
	        (eventName || orgEvent.type) === 'change' && this._setOldDate(); // No I18N
	        return this._dispatchEvent(eventName || 'change', orgEvent, this._getCurrentValue()); // No I18N
	    }
	    _getCurrentValue() {
	        return {
	            value: this._opts.value ? this._input[0].value : '', // No I18N
	            dateValue: this._opts.value
	        }
	    }
	    _keydownHandler(orgEvent) {
	        if (this._opts.disabled || this._opts.readonly) {
	            return false;
	        }
	        let selection,
	            keyCodes = ZC.keyCode,
	            tabKeyCode = keyCodes.TAB,
	            eventKeyCode = orgEvent.keyCode,
	            isShiftPressed = orgEvent.shiftKey,
	            selectCaretPosition = this._selectCaretPosition.bind(this),
	            inputElem = this._input[0],
	            dateFormat = this._dateFormat;
	        if (eventKeyCode === tabKeyCode && !(inputElem.selectionStart === 0 && isShiftPressed || inputElem.selectionEnd === inputElem.value.length && !isShiftPressed)) {
	            orgEvent.stopImmediatePropagation();
	        }
	        if ([ keyCodes.RIGHT, keyCodes.LEFT, tabKeyCode ].indexOf(eventKeyCode) > -1) {
	            eventKeyCode !== tabKeyCode && orgEvent.preventDefault();
	            selection = selectCaretPosition(inputElem);
	            this._viewDate = this._checkMinMaxLimit(this._viewDate);
	            if (this._isModified) {
	                this._updateElementValue();
	                selectCaretPosition(inputElem, selection[0], selection[1]);
	            }
	            if (selection[0] !== selection[1]) {
	                this._mouseupHandler();
	            }
	            let direction = eventKeyCode === keyCodes.LEFT ? -1 : 1;
	            if (eventKeyCode === tabKeyCode && isShiftPressed) {
	                this._focusout = true;
	                direction = -1;
	            }
	            selection = selectCaretPosition(inputElem);
	            let currentIndex = direction === -1 ? selection[0] - 1 : selection[1] + 1,
	                format = this._opts.format;
	            while (currentIndex >= 0 && currentIndex < dateFormat.length) {
	                let character = dateFormat[currentIndex],
	                    lastIndex = format.lastIndexOf(character);
	                if (this._allowedChars.indexOf(character) >= 0) {
	                    if (eventKeyCode === tabKeyCode && (lastIndex !== format.length || lastIndex + 1 !== format.length)) {
	                        orgEvent.preventDefault();
	                        this._focusout = true;
	                    }
	                    this._reverseFocusset = direction === -1;
	                    this._selectText(dateFormat[currentIndex]);
	                    break;
	                }
	                currentIndex += direction;
	            }
	        }
	        if (eventKeyCode === keyCodes.UP || eventKeyCode === keyCodes.DOWN) {
	            orgEvent.preventDefault();
	            selection = selectCaretPosition(inputElem);
	            let character = dateFormat[selection[0]];
	            if (this._allowedChars.indexOf(character) >= 0) {
	                this._modifyPartValue(character, eventKeyCode === keyCodes.UP ? 1 : -1);
	                this._updateElementValue();
	                this._clearButton && this._toggleBtnDisplay(null, true);
	                this._selectText(character);
	            }
	            this._checkForChange(orgEvent, this._keyUp ? 'spinstart' : 'spin'); // No I18N
	            this._keyUp = false;
	        }
	        if (orgEvent.metaKey || orgEvent.ctrlKey) {
	            let caretPosition = selectCaretPosition(inputElem),
	                length;
	            caretPosition[0] !== undefined && caretPosition[1] !== undefined && (length = caretPosition[1] - caretPosition[0]);
	            if (eventKeyCode === 88 && length !== inputElem.value.length || eventKeyCode === 90) {
	                orgEvent.preventDefault();
	            }
	        }
	    }
	    _checkMinMaxLimit(newDate, part, offset, shouldAddClass) {
	        let min = this._opts.min,
	            max = this._opts.max;
	        shouldAddClass = shouldAddClass === undefined || shouldAddClass;
	        this._isModified = false;
	        max && (newDate = this._validateValues(max, newDate, part, offset, shouldAddClass, true));
	        min && (newDate = this._validateValues(min, newDate, part, offset, shouldAddClass));
	        return newDate;
	    }
	    _validateValues(value, newDate, part, offset, shouldAddClass, isMax) {
	        if (value) {
	            let currentTime = new Date().getTime(),
	                time, newDateTime, isMore, isValueMore,
	                opts = this._opts,
	                classfn;
	            time = value.getTime();
	            newDateTime = newDate.getTime();
	            isMore = isMax ? time < currentTime : time > currentTime;
	            isValueMore = isMax ? newDateTime >= time : newDateTime <= time;
	            if (isValueMore || part && !this[part] && isMore && !offset) {
	                classfn = opts.value ? 'add' : undefined; // No I18N
	                this._isModified = true;
	                newDate = new Date(((offset && newDateTime !== time) ? this._viewDate : value).getTime());
	            } else {
	                classfn = isValueMore ? undefined : 'remove'; // No I18N
	            }
	            classfn && shouldAddClass && opts.spinButtons !== 'none' && this.container.find(`.zh-${isMax ? 'up' : 'down'}`)[`${classfn}Class`]('is-disabled'); // No I18N
	        }
	        return newDate;
	    }
	    _keyUpHandler(orgEvent, doNotTrigger) {
	        // Check for IE9
	        let keyCodes = [ 32, 8, 46 ],
	            keycode = orgEvent.keyCode;
	        if (orgEvent.type === 'input' || orgEvent.type === 'keyup' && (keycode >= 186 && keycode <= 192 || keycode >= 219 && keycode <= 222 || keycode >= 48 && keycode <= 57 || keycode >= 65 && keycode <= 90 || keyCodes.indexOf(keycode) > -1)) { // No I18N
	            let currentTime = new Date().getTime(),
	                dateFormat = this._dateFormat;
	            this._isFastInput = !!(this._keyUpTime && currentTime - this._keyUpTime < 500);
	            this._keyUpTime = currentTime;
	            if (document.activeElement !== this._input[0]) {
	                return;
	            }
	            let i,
	                diff = this._getStringDiff(this._oldValue, dateFormat, this._input[0].value, this._selectCaretPosition(this._input[0])[0]),
	                diffLen = diff.length,
	                separatorMatch = diffLen && /[ |/|.|-|;]/.test(diff[0][1]),
	                isNavigation = diffLen === 1 && separatorMatch;
	            if (this._isNewValue && this._allowedChars.indexOf(diff[0][0]) > -1 && this._currentSegment !== this._oldSegment) {
	                this._resetValues(diff[0][0], diff[0][1]);
	            }
	            if (isNavigation) {
	                this._viewDate = this._checkMinMaxLimit(this._viewDate);
	            } else {
	                for (i = 0; i < diffLen; i++) {
	                    let char1 = this._translateAToE(diff[i][0]),
	                        char2 = this._translateAToE(diff[i][1]);
	                    this._parseValue(char1, char2);
	                }
	            } !this._pasteAction && this._updateElementValue();
	            separatorMatch = diffLen && /[ |/|.|-|;]/.test(diff[0][0]);
	            if (diffLen && !separatorMatch) {
	                this._selectText(diff[0][0])
	                if (this._isNextSegment) {
	                    let index = dateFormat.lastIndexOf(diff[0][0]) + 1;
	                    if (index < dateFormat.length) {
	                        while (this._allowedChars.indexOf(dateFormat[index]) === -1 && index < dateFormat.length) {
	                            index += 1;
	                        }
	                        this._isNextSegment = false;
	                        this._viewDate = this._checkMinMaxLimit(this._viewDate);
	                        !this._pasteAction && this._updateElementValue();
	                        this._selectText(dateFormat[index]);
	                    }
	                }
	            }
	            if (isNavigation) {
	                this._keydownHandler({
	                    keyCode: ZC.keyCode.RIGHT,
	                    preventDefault: function() { }
	                })
	            } else if (!doNotTrigger) {
	                this._checkForChange(orgEvent, 'spin'); // No I18N
	            }
	            if (this._opts.clearButton !== 'none') { // No I18N
	                this._toggleBtnDisplay(null, true);
	            }
	        }
	    }
		_updateClearBtn  () {
		    super._updateClearBtn();
		    if (this._opts.value) {
		        this._clearBtnShown = true;
		        this._opts.spinButtons === 'focus' && this._clearButton.addClass('zh-right'); // No I18N
		    }
		    this._toggleBtnDisplay(null, true);
		}
		_bindClearBtnEvents  () {
		    this._addEvents({
		        clearButtonClick: 'mouseup', // No I18N
		        clearButtonMousedown: 'mousedown' // No I18N
		    }, this._clearButton);
		}
		_clearButtonMousedownHandler  (orgEvent) {
		    orgEvent.stopPropagation();
		    orgEvent.preventDefault();
		    clearInterval(this._mouseDownTimer);
		    this._mouseDown = false;
		    this._getSegment();
		}
		_clearActionHandler  () {
		    this._opts.value = null;
		    this._isCleared = true;
		    if (this._immediateCommit) {
		        this._lastValue = undefined;
		    }
		    let inputElem = this._input;
		    inputElem[0].value = ''; // No I18N
		    if (document.activeElement !== inputElem[0]) {
		        inputElem.focus();
		    }
		    this._keyUpHandler({
		        type: 'input', // No I18N
		        keyCode: ZC.keyCode.BACKSPACE,
		        preventDefault: function() { }
		    }, true);
		    this._selectText(this._segment);
		    this._mouseupHandler();
		    this._data.spinButtons && this._buttonPane.find('.zh-up,.zh-down').removeClass('is-disabled'); // No I18N
		}
		_isClearVisible  () {
		    this._clearBtnShown = this._opts.clearButton !== 'none' && this._clearButton && this._clearButton.is(':visible'); // No I18N
		}
		_clearButtonClickHandler  (orgEvent) {
		    if (this._clearBtnShown) {
		        orgEvent.preventDefault();
		        clearInterval(this._mouseDownTimer);
		        this._mouseDown = false;
		        this._clearActionHandler();
		        return false;
		    }
		    this._mouseupHandler();
		}
		_setAttribute   (optionName, value) {
		    let componentName = this.name,  // No I18N
		        opts = this._opts, updateElementValue = this._updateElementValue.bind(this), // No I18N
		        inputElem = this._input, isFormat = (optionName === "format"), isValue = (optionName === "value"),  // No I18N
		        placeHolder = ["date-format", "underscore", "date-format-in-upper", "date-format-in-lower", "custom"],    // No I18N
		        setAttribute = super._setAttribute.bind(this),
		        shouldCheck, oldFormat = this._format;
		    this._opts[optionName] = value;
		    if (isFormat || isValue) {
		        isValue && this._setValue(value);
		        this._setBoolValue(["month", "year", "minutes", "seconds", "hours"], true, "Modified");  // No I18N
		        if (isFormat) {  // No I18N
		            this._format = value;
		            this._setFormat();
		            this._validateFormat();
		            if (this._invalidFormat) {
		               this._format = opts.format = oldFormat;
		                return;
		            }
		            this._picker && this._getPicker()._setAttribute("format", opts.format);  // No I18N
		        }
		        let dateValue = opts.value;
		        this._checkForModification(dateValue);
		        this._viewDate = this._checkMinMaxLimit(dateValue ? new Date(dateValue.getTime()) : this._resetViewDate());
		        shouldCheck = true;
		        updateElementValue();
		        isValue && !this.container.hasClass('has-focus') && this._input.trigger('change'); // No I18N
		        isValue && !value && (this._isCleared = true);
		    } else if (optionName === "min" || optionName === "max") {	// No I18N
		        this._validateValue(optionName, value);
		        this._performValidations();
		        this._viewDate = this._checkMinMaxLimit(this._viewDate);
		        shouldCheck = true;
		        if(this._picker){
		           let pickerInstance = ZC[this._pickerMethods.instance](this._picker), 
		               optValue = opts[optionName],
		               name = optionName+"Date";// No I18N
		           pickerInstance.setAttribute(name,  optValue);
		           opts.pickerOptions[name] = optValue;
		        }
		        updateElementValue();
		    } else if (/increment|decrement|spinButtons/g.test(optionName)) {
		        optionName === "spinButtonsOrientation" && this._updateClass("zinputfield--split", value === 'vertical');  // No I18N
		        setAttribute(optionName, value);
		        value && this._reConstructSpinButtons(value);
		    } else if (optionName === "placeholderType") {     // No I18N
		        opts.placeholerType = (placeHolder.indexOf(value) === -1) ? "date-format" : value;  // No I18N
		        !opts.value && updateElementValue();
		    } else if (optionName === "locale") {  // No I18N
		        this._setFormat();
		        updateElementValue();
		        inputElem[(value === "ar" ? "add" : "remove") + "Class"]("zh-bidioverride"); // No I18N
		    } else if (optionName === "disabled") {  // No I18N
		        setAttribute(optionName, value);
		        // inputElem[(value ? "remove" : "add") + "Class"]("zh-hidecursor");        // No I18N
		        opts.clearButton !== "none" && (value ? this._clearButton.off(`mouseup.${componentName} mousedown.${componentName}`) : this._bindClearBtnEvents());   // No I18N
		    } else if (optionName === "rtl") {  // No I18N
		        inputElem[(opts.locale === "ar" ? "add" : "remove") + "Class"]("zh-bidioverride");  // No I18N
		        // inputElem.css("direction", "ltr"); // No I18N
		    } else {
		        setAttribute(optionName, value);
		    }
		    if (shouldCheck) {
		        this._disableSpinBtns();
		        this._domChanged = true;
		    }
		}
		_setValue   (value) {
		    let opts = this._opts, inputElem = this._input, // No I18N
		        isModified = this._validateValue("value", value);   // No I18N
		    value = opts.value;
		    this._performValidations();
		    if (isModified && value) {
		        this._setOldDate();
		        this._viewDate = new Date(value.getTime());
		        inputElem.attr("aria-valuenow", ZC.Date.formatDate(value, opts.format));  // No I18N
		    }
		    !value && inputElem.removeAttr("aria-valuenow"); // No I18N
		    this._clearButton && this._toggleBtnDisplay(null, true);
		    return isModified;
		}
		_spinButtonsMousedownHandler  (orgEvent) {
		    orgEvent.preventDefault();
		    if (this._opts.disabled || orgEvent.which > 1 || this._opts.readonly || $(orgEvent.target).closest('.zinputfield__spinbutton').hasClass('is-disabled')) {
		        return;
		    }
		    this._mouseDown = true;
		    this.container.addClass('has-focus'); // No I18N
		    this._checkForChange(orgEvent, 'spinstart'); // No I18N
		    if (this._input[0].selectionStart === (0 || this._input[0].value.length) && this._input[0].selectionEnd === this._input[0].value.length) {
		        this._selectCaretPosition(this._input[0], 0, 0);
		        this._mouseupHandler(orgEvent);
		    }
		    let ev = this._assignEventProps(orgEvent);
		    this._keyUp = true;
		    this._keydownHandler(ev);
		    clearInterval(this._mouseDownTimer);
		    this._mouseDownTimer = setInterval(this._repetitiveMouseDownHandler.bind(this, orgEvent), 220);
		    ZC.$document.off(`mouseup.${this.name}`).on(`mouseup.${this.name}`, this._documentMouseUpHandler.bind(this));
		}
		_repetitiveMouseDownHandler  (orgEvent) {
		    if (this._mouseDown) {
		        this._keydownHandler(this._assignEventProps(orgEvent))
		    } else {
		        clearInterval(this._mouseDownTimer);
		    }
		}
		_assignEventProps  (event) {
		    return {
		        keyCode: $(event.target).closest('.zh-up').length ? ZC.keyCode.UP : ZC.keyCode.DOWN,
		        preventDefault: function() { }
		    };
		}
		_documentMouseUpHandler  () {
		    clearInterval(this._mouseDownTimer);
		    ZC.$document.off(`mouseup.${this.name}`);
		    this._mouseDown = false;
		}
		_updateSpinButtons  () {
		    let data = this._data;
		    if (this._opts.spinButtons === 'focus') { // No I18N
		        data.className += ' zdatetimefield--buttonsonhover'; // No I18N
		    }
		    super._updateSpinButtons();
		}
		_bindSpinButtonEvents  () {
		    this._addEvents({ // No I18N
		        spinButtonsMouseup: 'mouseup', // No I18N
		        spinButtonsMousedown: 'mousedown' // No I18N
		    }, this.container.find('.zh-up,.zh-down'));
		}
		_spinButtonsMouseupHandler  (orgEvent) {
		    this._mouseUp = true;
		    this._checkForChange(orgEvent, 'spinend'); // No I18N
		}
		_reConstructSpinButtons  (value) {
		    let containerCls = ' zdatetimefield', // No I18N
		        opts = this._opts,
		        data = this._data;
		    if (data.spinButtons) {
		        if (value === 'focus') { // No I18N
		            this._addEvents({
		                mouseEnter: 'mouseenter', // No I18N
		                mouseLeave: 'mouseleave'// No I18N
		            }, this.container)
		        }
		        this.container.attr('role', 'spinbutton'); // No I18N
		        data.isVertical && !opts.calendarIcon && this._updateClass(containerCls, true);
		        opts.spinButtons === 'always' && this._updateClass('zdatetimefield--buttonsonhover', true); // No I18N
		    }
		    // else{
		    //     this._opts.calendarIcon && this.container.removeClass(containerCls);
		    // }
		}
	}
	ZC.registerComponent('ZDateInput', ZC.ZInputField, ZDateInput); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
	class ZDateField extends ZC.ZDateInput {
			get name(){
				return "zdatefield";
			}
	    get attrs() {
	        return {
	            format: 'dd/MM/yyyy', // No I18N
	            dateStep: 1,
	            monthStep: 1,
	            yearStep: 1,
	            picker: false,
	            pickerId: null,
	            century: 21,
	            calendarIcon: false,
	            calendarIconClass: null,
	            calendarSVGIconId: null,
	            calendarIconAlignment: 'right', // No I18N
	            calendarIconUIType: 'label', // No I18N
	            showPickerOnFocus: false
	        };
	    }
	    get props() {
	        return {
	            calendarIconClassName: null,
	            placeholder: {
	                year: 'year', // No I18N
	                month: 'month', // No I18N
	                date: 'date' // No I18N
	            },
	            pickerOptions: {
	                timeFieldType: 'multiple-select-box' // No I18N
	            },
	            labels: {
	                days: [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ], // No I18N
	                daysAbbreviated: [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ], // No I18N
	                months: [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December' ], // No I18N
	                monthsAbbreviated: [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ], // No I18N
	                invalidInput: 'Invalid date/time provided. Please provide correct input', // No I18N
	                invalidNumber: 'Not a number' // No I18N
	            }
	        };
	    }
	    get EVENTS() {
	        return [ 'pickerbeforeopen', 'pickeropen', 'pickerbeforeclose', 'pickerclose', 'pickerbeforedatecellrender', 'pickerdatecellrender', 'pickerbeforemonthopen', 'pickerbeforedrilldown', 'pickerdrilldown', 'pickerdatemouseover', 'pickerdateselect', 'pickermonthchange', 'pickeryearchange', 'pickerdecadechange', 'pickertodaybuttonclick', 'pickercancel', 'pickerclear' ]; // No I18N
	    }
	    get monthChars() {
	        return [ 'f', 's', 'o', 'n', 'd', 'ja', 'may', 'mar', 'ap', 'au', 'jun', 'jul' ]; // No I18N
	    }
	    _create() {
	        super._create(...arguments);
	    }
	    _getDateParts() {
	        return {
	            d: 'date', // No I18N
	            M: 'month', // No I18N
	            y: 'year' // No I18N
	        }; // No I18N
	    }
	    _replaceText(match) {
	        return this._replaceDate(match);
	    }
	    _getRegEx() {
	        return /dd{0,3}|MM{0,3}|yyyy|yy|"[^"]*"|'[^']*'/g;
	    }
	    _getMatch(match) {
	        let arr = [ 'ddd', 'dddd', 'z', 'zz', 'zzz' ]; // No I18N
	        return arr.indexOf(match) > -1 ? match.replace('d', 'E').replace('z', 'f') : match; // No I18N
	    }
	    _replaceDate(match) {
	        let result,
	            viewDate = this._viewDate,
	            value,
	            monthModified = this._monthModified,
	            dateModified = this._dateModified,
	            yearModified = this._yearModified,
	            isModified,
	            isDate = [ 'd', 'dd', 'ddd', 'dddd' ].indexOf(match) > -1; // No I18N
	        if ([ 'd', 'dd', 'M', 'MM' ].indexOf(match) !== -1) { // No I18N
	            viewDate = isDate ? viewDate.getDate() : viewDate.getMonth() + 1;
	            result = (isDate ? dateModified : monthModified) ? match.length === 1 ? viewDate.toString() : (viewDate < 10 ? '0' : '') + viewDate : this._getPlaceholder(match); // No I18N
	        } else if ([ 'ddd', 'dddd', 'MMM', 'MMMM' ].indexOf(match) !== -1) { // No I18N
	            viewDate = isDate ? viewDate.getDay() : viewDate.getMonth();
	            isModified = isDate ? dateModified && monthModified && yearModified : monthModified;
	            value = match.indexOf('d') > -1 ? 'days' : 'months'; // No I18N
	            result = isModified ? this._getI18NText(match.length === 3 ? `${value}Abbreviated` : value)[viewDate] : this._getPlaceholder(match);
	        } else if ([ 'yy', 'yyyy' ].indexOf(match) !== -1) { // No I18N
	            this._isYear2Digit = match === 'yy'; // No I18N
	            viewDate = viewDate.getFullYear();
	            result = yearModified ? this._appendZeros(match === 'yy' ? viewDate % 100 : viewDate, match.length) : this._getPlaceholder(match); // No I18N
	        }
	        return this._translateEToA(result);
	    }
	    _focusOutHandler(orgEvent) {
	        let relTarget = $(orgEvent.relatedTarget);
	        if (!this._hasPicker || !(this._hasPicker && relTarget.closest('.zdatetimepicker,.zdatetimepicker--group').length)) {
	            super._focusOutHandler(orgEvent);
	        }
	    }
	    _appendZeros(number, chars) {
	        let zeroes = [ '', '0', '00', '000', '0000' ], // No I18N
	            last;
	        number = number.toString();
	        last = chars - number.length;
	        return last ? zeroes[chars].substring(0, last) + number : number;
	    }
	    _init() {
	        this._allowedChars = 'dMyz'; // No I18N
	        !this._pickerMethods && (this._pickerMethods = {
	            create: 'createDatePicker', // No I18N
	            instance: 'datepicker' // No I18N
	        });
	        super._init(...arguments);
	        this._opts.calendarIcon && this._getCalendarIconProps();
	    }
	    _performValidations() {
	        let opts = this._opts,
	            arr = [ 'date', 'month', 'year' ]; // No I18N
	        if (opts.calendarIcon) {
	            [ 'right', 'left' ].indexOf(opts.calendarIconAlignment) === -1 && (opts.calendarIconAlignment = 'right'); // No I18N
	        }
	        super._performValidations(arr.map((str) => str + 'Step'), arr); // No I18N
	    }
	    _validateFormat() {
	        this._checkFormat(/h|H|m|t/g); // No I18N
	    }
	    _postRender() {
	        super._postRender(...arguments);
	        this._opts.picker && this._createPicker();
	    }
	    _postEachRender(elem, data) {
	        let modified = data.modifiedAttr;
	        if (data.calendarIcon && (!modified || modified === 'calendarIcon')) { // No I18N
	            this._updateCalendarIcon();
	        }
	        super._postEachRender(...arguments);
	    }
	    _getCustomMatch(match) {
	        return this._getDateMatch(match);
	    }
	    _getDateMatch(match) {
	        let placeholder = this._opts.placeholder;
	        if ([ 'd', 'dd', 'ddd', 'dddd' ].indexOf(match) > -1) { // No I18N
	            return placeholder[match.length > 2 ? 'weekDay' : 'date']; // No I18N
	        } else if ([ 'M', 'MM', 'MMM', 'MMMM' ].indexOf(match) > -1) { // No I18N
	            return placeholder.month;
	        } else if ([ 'yy', 'yyyy' ].indexOf(match) > -1) { // No I18N
	            return placeholder.year;
	        }
	    }
	    _getDateValue() {
	        return this._dateModified && this._monthModified && this._yearModified ? new Date(+this._viewDate) : undefined;
	    }
	    _modifyValue(newDate, character, offset, isValueComplete) {
	        return this._modifyDate(newDate, character, offset, isValueComplete);
	    }
	    _getDateSegment(value, part) {
	        let parts = {
	            y: 'FullYear', // No I18N
	            M: 'Month', // No I18N
	            d: 'Date' // No I18N
	        };
	        return value[`get${parts[part]}`]();
	    }
	    _checkValue(min, max, minAdd, maxAdd, value) {
	        if (value < min) {
	            value += max + minAdd;
	        } else if (value > max) {
	            value %= max + maxAdd;
	        }
	        return value;
	    }
	    _changeDateValue(newDate, condition, newValue) {
	        if (condition) {
	            newDate.setDate(1);
	            newDate.setMonth(newValue);
	        }
	    }
	    _modifyDate(newDate, character, offset, isValueComplete) {
	        let char = this._getDateParts()[character],
	            part = '_' + char + 'Modified',
	            opts = this._opts,
	            newValue = this._getDateSegment(newDate, character),
	            checkValue = this._checkValue.bind(this);
	        offset && (offset *= opts[char + 'Step']);
	        newValue = newValue + offset;
	        if (character === 'y') { // No I18N
	            newValue = checkValue(0, 9999, 0, 1, newValue);
	            newValue === 0 && (newValue = 1);
	            this._yearModified && newDate.setFullYear(newValue);
	        } else if (character === 'M') {
	            if (this[part]) {
	                if (opts.incrementOnWrapAround && isValueComplete !== undefined) {
	                    newDate.setMonth(newValue);
	                    this._changeDateValue(newDate, newDate.getMonth() % 12 !== (newValue + 12) % 12, newValue);
	                } else {
	                    newValue = checkValue(0, 11, 1, 1, newValue);
	                    let numberOfDays = new Date(newDate.getFullYear(), newValue + 1, 0).getDate();
	                    newDate.getDate() > numberOfDays && newDate.setDate(numberOfDays);
	                    newDate.setMonth(newValue);
	                }
	            } else {
	                offset < 0 && newDate.setMonth(11);
	            }
	        } else if (character === 'd') {
	            if (!opts.incrementOnWrapAround || !isValueComplete) {
	                newValue = checkValue(1, this._getDaysInAMonth(newDate), -newValue, 0, newValue);
	            }
	            if (this[part]) {
	                newDate.setDate(newValue)
	            } else if (offset < 0) {
	                newDate.setDate(31);
	            }
	        }
	        return part;
	    }
	    _getDaysInAMonth(dateValue) {
	        return new Date(dateValue.getFullYear(), dateValue.getMonth() + 1, 0).getDate();
	    }
	    _parseSegment(character, currentChar, newDate) {
	        return this._parseDate(character, currentChar, newDate);
	    }
	    _getNewValue(newDate, currentChar, part, jumpOnComplete, maxLen) {
	        let getValue = 'get' + (part === 'date' ? 'Date' : 'Month'); // No I18N
	        let value = newDate[getValue]() + +(part === 'month'); // No I18N
	        let newValue = this._isNewValue && this._oldSegment !== this._currentSegment ? 0 : this[`_${part}Modified`] ? value * 10 : 0;
	        newValue += parseInt(currentChar);
	        this._isNextSegment = !isNaN(newValue) && jumpOnComplete && newValue >= maxLen;
	        return newValue;
	    }
	    _sliceValue(max, newValue, str) {
	        while (newValue > max) {
	            newValue = parseInt(str.slice(1));
	        }
	        return newValue;
	    }
	    _parseDate(character, currentChar, newDate) {
	        let jumpOnComplete = this._opts.jumpOnComplete,
	            newValue,
	            getNewValue = this._getNewValue.bind(this),
	            sliceValue = this._sliceValue.bind(this),
	            viewDate = this._viewDate;
	        if (character === 'd') { // No I18N
	            let numberOfDays = this._getDaysInAMonth(newDate);
	            newValue = getNewValue(newDate, currentChar, 'date', jumpOnComplete, 4); // No I18N
	            if (isNaN(newValue)) {
	                return;
	            }
	            let str = newValue.toString();
	            if (!jumpOnComplete && newValue > numberOfDays && this._isFastInput) {
	                if (str.length === 2) {
	                    newValue = viewDate.getDate();
	                } else if (str.length >= 3) {
	                    newValue = sliceValue(31, newValue, str);
	                }
	            } else {
	                newValue = newValue > numberOfDays ? jumpOnComplete ? parseInt(str[0]) : parseInt(str.slice(-1)) : newValue;
	            }
	            this._dateModified = newValue >= 1;
	            if (this._dateModified) {
	                newDate.setDate(newValue);
	                if (newDate.getMonth() !== viewDate.getMonth()) {
	                    return;
	                }
	            }
	        } else if (character === 'M') { // No I18N
	            newValue = getNewValue(newDate, currentChar, 'month', jumpOnComplete, 2); // No I18N
	            if (isNaN(newValue)) {
	                let months = this._getI18NText('months'); // No I18N
	                let typedMonthChar = this._typedMonthChar += currentChar.toLowerCase();
	                while (typedMonthChar.length > 0) {
	                    for (let i = 0; i < months.length; i++) {
	                        if (months[i].toLowerCase().indexOf(typedMonthChar) === 0) {
	                            newDate.setMonth(i);
	                            this._isNextSegment = jumpOnComplete && this.monthChars.indexOf(typedMonthChar) > -1; // No I18N
	                            this._monthModified = true;
	                            this._oldDateValue = new Date(+viewDate);
	                            this._viewDate = newDate;
	                            return true;
	                        }
	                    }
	                    this._typedMonthChar = typedMonthChar.substring(1, typedMonthChar.length);
	                }
	                return false;
	            }
	            let str = newValue.toString();
	            if (!jumpOnComplete && newValue > 12 && this._isFastInput) {
	                let value = parseInt(str.slice(1));
	                newValue = value > 12 ? parseInt(value.toString()[0]) : viewDate.getMonth() + 1;
	            } else if (jumpOnComplete) {
	                newValue = newValue > 12 && newValue < 20 ? 12 : newValue > 20 ? str[0] : newValue;
	            } else if (newValue === 111 || newValue === 112) {
	                newValue = parseInt(str.slice(-1));
	            } else {
	                newValue = sliceValue(12, newValue, str);
	            }
	            this._monthModified = newValue >= 1;
	            if (this._monthModified) {
	                newDate.setMonth(newValue - 1);
	                this._changeDateValue(newDate, newDate.getMonth() !== newValue - 1, --newValue);
	            }
	        } else if (character === 'y') { // No I18N
	            let is2Digit = this._isYear2Digit;
	            newValue = this._yearModified ? is2Digit ? newDate.getFullYear().toString().slice(2) : newDate.getFullYear() * 10 : 0;
	            newValue = is2Digit ? parseInt(newValue + currentChar) : newValue + parseInt(currentChar);
	            if (isNaN(newValue)) {
	                return;
	            }
	            let yearString = newValue.toString();
	            if (is2Digit) {
	                if (jumpOnComplete && newValue > 10 && (yearString.length === 2 && yearString[1] !== '0')) {
	                    this._isNextSegment = true;
	                }
	                newValue = sliceValue(99, newValue, yearString);
	                this._yearModified = newValue >= 1;
	                if (this._yearModified) {
	                    let century = this._opts.century - 1;
	                    newValue = parseInt(century.toString() + newValue.toString());
	                    newDate.setFullYear(newValue);
	                }
	            } else {
	                if (jumpOnComplete && newValue > 1001 && (yearString.length === 4 && yearString[3] !== '0')) { // No I18N
	                    this._isNextSegment = true;
	                }
	                newValue = sliceValue(9999, newValue, yearString);
	                this._yearModified = newValue >= 1;
	                if (this._yearModified) {
	                    newDate.setFullYear(newValue);
	                }
	            }
	        }
	        return newDate;
	    }
	    _isPartModified(character, value) {
	        this._isDateModified(character, value);
	    }
	    _isDateModified(character, value) {
	        if ([ 'd', 'y', 'M' ].indexOf(character) > -1) {
	            let chars = this._getDateParts();
	            this['_' + chars[character] + 'Modified'] = value; // No I18N
	            !value && character === 'M' && (this._typedMonthChar = ''); // No I18N
	        }
	    }
	    _setFormat() {
	        this._setFormatVal(/^(date-short|date-long|date-medium)$/, 'date', 'dd/MM/yyyy'); // No I18N
	    }
	    _getNumberOfDays(year, month) {
	        return new Date(year, month, 0).getDate();
	    }
	    _parseValue(character, currentChar) {
	        super._parseValue(character, currentChar);
	        this._hasPicker && (this._opts.pickerOptions.disabledDaysOfWeek || this._opts.pickerOptions.disabledDates) && (this._viewDate = this._checkForDisabledDates(this._viewDate));
	        return true;
	    }
	    _bindEvents() {
	        super._bindEvents();
	        this._opts.picker && this._bindPickerEvents();
	    }
	    _keydownHandler(orgEvent) {
	        let pickerElem = this._picker;
	        let eventKeycode = orgEvent.keyCode;
	        let keyCode = ZC.keyCode;
	        if (this._hasPicker) {
	            if (pickerElem.is(':visible')) {
	                if ([ keyCode.ESCAPE, keyCode.ENTER ].indexOf(eventKeycode) > -1) {
	                    ZC[this._pickerMethods.instance](pickerElem).close();
	                }
	            }
	            if (orgEvent.metaKey || orgEvent.ctrlKey) {
	                if (keyCode.DOWN === eventKeycode) {
	                    if (!pickerElem.is(':visible')) { // No I18N
	                        ZC[this._pickerMethods.instance](pickerElem).open();
	                        return;
	                    }
	                }
	            }
	        }
	        super._keydownHandler(orgEvent);
	    }
	    _isDateInstance(value) {
	        return value instanceof Date ? new Date(+value) : value;
	    }
	    _updateElementValue() {
	        super._updateElementValue();
	        let opts = this._opts,
	            value = opts.value,
	            lastValue = this._lastValue,
	            pickerElem = this._picker;
	        if (this._hasPicker && value) {
	            if (!lastValue || lastValue && +(ZC.Date.parseDate(lastValue, opts.format).date) !== +value) {
	                ZC[this._pickerMethods.instance](pickerElem).setAttribute('value', new Date(+value));
	            }
	        }
	        if (value) {
	            this._lastValue = this._isDateInstance(value);
	            (opts.format.indexOf('h') < 0 || opts.indexOf('H') < 0) && value.setHours(0, 0, 0, 0);
	        }
	    }
	    _clearActionHandler() {
	        super._clearActionHandler();
	        this._picker && ZC[this._pickerMethods.instance](this._picker).setAttribute('value', null); // No I18N
	    }
	    /* resetValues in dateinput handles both year and time values. Calling this method for datetimefield not updating the time values */
	    // _resetValues(character, value) {
	    //     if (!isNaN(value) && character === 'y') {
	    //         this._viewDate.setFullYear(0);
	    //     }
	    // }
	    _resetToFirst(removedChar) {
	        this._resetDateToFirst(removedChar);
	    }
	    _resetDateToFirst(removedChar) {
	        let obj = {
	            M: 'Month', // No I18N
	            d: 'Date', // No I18N
	            y: 'FullYear' // No I18N
	        };
	        if (removedChar && 'Mdy'.indexOf(removedChar > -1)) {
	            this._viewDate[`set${obj[removedChar]}`](removedChar === 'y' ? new Date().getFullYear() : 'Mdy'.indexOf(removedChar)); // No I18N
	        }
	    }
	    _resetOnBlur(char) {
	        this._resetDateOnBlur(char);
	    }
	    _resetDateOnBlur(char) {
	        char === 'y' && this._viewDate.setFullYear(0); // No I18N
	    }
	    _destroy() {
	        this._picker && this._destroyPicker();
	        super._destroy();
	    }
		_getCalendarIconProps  () {
		    let data = this._data,
		        opts = this._opts,
		        icon = this._calendarIcon;
		    data.calendarPosition = ''; // No I18N
		    let UItype = opts.calendarIconUIType;
		    let clsName = 'zdatetimefield__icon' + UItype; // No I18N
		    data.calIconClassName = clsName;
		    let calProp = {
		        className: clsName,
		        defaultIconClassName: 'zdatetimefield__icon', // No I18N
		        iconClassName: opts.calendarIconClassName,
		        SVGIconId: opts.calendarSVGIconId,
		        defaultSVGIconId: 'zc__svg--calendaricon zbutton__svg', // No I18N
		        isCE: this.isCE,
		        customAttributes: {
		            tabindex: -1 // tabindex is set to avoid keyboard navigation to those buttons
		        },
		        templateRender: true,
		        mainElement: icon ? icon[0] : null
		    };
		    data.calendarIconProps = UItype === 'label' ? ZC._getIconInfo(calProp.iconClassName, calProp.SVGIconId, 'zc__svg--calendaricon zbutton__svg', 'zdatetimefield__icon', calProp) : ZC.ZButton.getBtnProps(calProp); // No I18N
		    data.calendarPosition = this._getCalendarPosition(UItype, opts.calendarIconAlignment);
		}
		_getCalendarPosition  (UItype, alignment) {
		    if ([ 'right', 'left' ].indexOf(alignment) > -1) {// No I18N
		        return alignment === 'left' ? 'beforeInput' : (UItype === 'button' ? 'after' : 'before') + 'SpinBtn'; // No I18N
		    }
		}
		_updateCalendarIcon  () {
		    let UItype = this._opts.calendarIconUIType,
		        container = this.container;
		    this._calendarIcon = container.find('.zdatetimefield__icon' + (UItype === 'label' ? 'label' : 'button')); // No I18N
		    this._data.calendarIconProps.mainElement = this._calendarIcon[0];
		    container.addClass('zdatetimefield zinputfield--withcalendaricon');// No I18N
		    if (UItype === 'button') {// No I18N
		        container.addClass('zh-hasiconbutton'); // No I18N
		        this._addEvents({
		            calendarIconClick: 'mousedown' // No I18N
		        }, this._calendarIcon);
		    }
		}
		_calendarIconClickHandler  (orgEvent) {
		    orgEvent.preventDefault();
		    if (this._picker && this._picker.is(':visible')) { // No I18N
		        this._picker.zdatepicker('close'); // No I18N
		    } else {
		        this._pickerOpenHandler(orgEvent);
		    }
		    if (this._currentSegment) {
		        this._selectText(this._currentSegment);
		    } else {
		        this._selectCaretPosition(this._input[0], 0, 0);
		    }
		    this._mouseupHandler(orgEvent);
		    this.container.addClass('has-focus'); // No I18N
		}
		_handleCalendarIcon  (optionName, value) {
		    let componentName = this.name,
		        data = this._data,
		        opts = this._opts,
		        container = this.container,
		        UItype = opts.calendarIconUIType,
		        calendarCls = 'zinputfield--withcalendaricon'; // No I18N
		    if (data.modifiedAttr === 'calendarIcon' && this._calendarIcon) {
		        value !== 'button' && this._hasPicker && this._calendarIcon.off('click.' + this.name); // No I18N
		        data.calendarPosition = '';
		        data.calendarIconProps = null;
		        this._calendarIcon = undefined;
		        container.removeClass('zh-hasiconbutton ' + calendarCls);// No I18N
		    }
		    if (value && opts.calendarIcon) { // to check if value becomes false, calendarIcon should not be created
		        this._getCalendarIconProps();
		        container.addClass(calendarCls + (opts.spinButtons === 'focus' ? ' zdatetimefield--buttonsonhover' : ''));
		        if (UItype === 'button') { // No I18N
		            !opts.showPickerOnFocus && container.off(`click.${componentName}`);
		        } else {
		            this._addEvents({
		                pickerOpen: 'click'// No I18N
		            }, container)
		        }
		    }
		    this._domChanged = true;
		}
		_checkForDisabledDates  (newDate, offset) {
		    offset = offset || 1;
		    let disabled, pickerInstance, disabledWeek,
		        preserveDate = new Date(newDate.getTime()),
		        opts = this._opts,
		        isGreater = this._isGreater.bind(this);
		        // checking whether the date is within range
		    if (this._hasPicker && isGreater(newDate, opts.min) && isGreater(opts.max, newDate)) {
		        pickerInstance = ZC[this._pickerMethods.instance](this._picker);
		        disabledWeek = pickerInstance.getAttribute('disabledDaysOfWeek');
		        disabled = pickerInstance.getAttribute('disabledDates'); // No I18N
		        let newDateVal = new Date(newDate.getTime());
		        !this._checkTime && newDateVal.setHours(0, 0, 0, 0);
		        let step = opts.dateStep * (offset === 1 ? 1 : -1),
		            date = new Date(newDate.getTime());
		        !this._checkTime && date.setHours(0, 0, 0, 0);
		        while (this._picker.find(`[data-time='${date.getTime()}']`).hasClass('is-disabled')) { // No I18N
		            if (disabledWeek && disabledWeek.length) {
		                for (let i = 0; i < disabledWeek.length; i++) {
		                    if (newDateVal.getDay() === disabledWeek[i]) {
		                        newDateVal.setDate(newDateVal.getDate() + step);
		                        newDate = new Date(newDateVal.getTime());
		                        i = -1;
		                    }
		                }
		                newDate.setHours(preserveDate.getHours(), preserveDate.getMinutes(), preserveDate.getSeconds(), 0);
		            }
		            if (disabled && disabled.length) {
		                for (let i = 0, len = disabled.length; i < len; i++) {
		                    let dateToCheck,
		                        disabledObj = disabled[i],
		                        changeValue;
		                    if (disabledObj.date instanceof Date) {
		                        dateToCheck = disabledObj.date;
		                    } else if (disabledObj.date) {
		                        changeValue = false;
		                        dateToCheck = disabledObj.date.date;
		                        disabledObj.repeatEveryYear && dateToCheck.setFullYear(newDate.getFullYear());
		                        disabledObj.repeatEveryMonth && dateToCheck.setMonth(newDate.getMonth());
		                    } else if (disabledObj.startDate && disabledObj.endDate) {
		                        let startDate = disabledObj.startDate.date,
		                            endDate = disabledObj.endDate.date;
		                        if (disabledObj.repeatEveryYear) {
		                            startDate.setFullYear(newDate.getFullYear());
		                            endDate.setFullYear(newDate.getFullYear());
		                        }
		                        if (disabledObj.repeatEveryMonth) {
		                            startDate.setMonth(newDate.getMonth());
		                            endDate.setMonth(newDate.getMonth());
		                        }
		                        if (ZC.Date.isGreater(newDateVal, startDate) || ZC.Date.areDatesEqual(startDate, newDateVal)) {
		                            changeValue = !!ZC.Date.isGreater(endDate, newDateVal);
		                        } else {
		                            changeValue = false;
		                        }
		                    }
		                    if (dateToCheck && ZC.Date.areDatesEqual(dateToCheck, newDateVal) || changeValue) {
		                        let dateValue = newDate.getDate() + step;
		                        if (!opts.incrementOnWrapAround) {
		                            let numberOfDays = new Date(newDateVal.getFullYear(), newDateVal.getMonth() + 1, 0).getDate();
		                            if (dateValue < 1) {
		                                dateValue = numberOfDays;
		                            } else if (dateValue > numberOfDays) {
		                                dateValue %= numberOfDays;
		                            }
		                        }
		                        newDateVal.setDate(dateValue);
		                        let time = newDateVal.getTime();
		                        newDate = new Date(time);
		                        i = -1;
		                    }
		                }
		            }
		            newDate.setHours(preserveDate.getHours(), preserveDate.getMinutes(), preserveDate.getSeconds(), 0);
		            date = new Date(newDate.getTime());
		            !this._checkTime && date.setHours(0, 0, 0, 0);
		        }
		    }
		    return newDate;
		}
		_isGreater  (first, second) {
		    return ZC.Date.isGreater(first, second) && !ZC.Date.areDatesEqual(first, second);
		}
		_createPicker  () {
		    let opts = this._opts,
		        pickerMethods = this._pickerMethods;
		    this._hasPicker = opts.picker;
		    if (opts.picker && !opts.pickerId) {
		        this._initPicker();
		    }
		    if (opts.pickerId) {
		        let picker = $('#' + opts.pickerId);
		        if (picker.length) {
		            let data = picker.data('z' + pickerMethods.instance); // No I18N
		            if (Object.keys(data).length) {
		                this._hasPicker = true;
		                this._picker = picker;
		                ZC[pickerMethods.instance](this._picker).setAttribute('forElement', this.container); // No I18N
		            }
		        }
		    }
		    if (this._hasPicker) {
		        this._immediateCommit = ZC[pickerMethods.instance](this._picker).getAttribute('immediateCommit'); // No I18N
		        this.container.attr({
		            'aria-owns': $(this._picker).attr('id'), // No I18N
		            'aria-expanded': false // No I18N
		        });
		    }
		}
		_initPicker  () {
		    let min, max,
		        opts = this._opts,
		        pickerOptions = opts.pickerOptions;
		    if (opts.min) {
		        min = new Date(opts.min.getTime());
		    }
		    if (opts.max) {
		        max = new Date(opts.max.getTime());
		    }
		    if (!this._checkTime) {
		        min && min.setHours(0, 0, 0, 0);
		        max && max.setHours(0, 0, 0, 0);
		    }
		    pickerOptions = $.extend(true, {}, pickerOptions, {
		        id: `${this._getID(this.container)}-picker`,
		        appendTo: $('body'), // No I18N
		        isCE: this.isCE,
		        rtl: this._opts.rtl, // No I18N
		        locale: this._opts.locale,
		        forElement: this.container,
		        minDate: pickerOptions.minDate || min,
		        maxDate: pickerOptions.maxDate || max,
		        value: opts.value,
		        format: opts.format.replace('s', ''), // dateTimePicker does not support seconds value
		        beforedatecellrender: this._dispatchPickerEventsHandler.bind(this, 'pickerbeforedatecellrender')
		    });
		    this._picker = ZC[this._pickerMethods.create](pickerOptions);
		}
		_bindPickerEvents  () {
		    let componentName = this.name,
		        baseComp = this.isCE ? 'z' : `z${this._pickerMethods.instance}`, // No I18N
		        opts = this._opts;
		    this._hasPicker && (opts.calendarIconUIType === 'label' || opts.calendarIconUIType === 'button' && opts.showPickerOnFocus) && this._addEvents({ // No I18N
		        pickerOpen: 'click' // No I18N
		    }, this.container);
		    let pickerElem = this._picker = $(this._picker);
		    pickerElem.off(this._getPicker()._EVENTS.map((val) => `z${this._pickerMethods.instance}${val}.${this.name}`).join(' ')); // No I18N
		    this._addEvents({
		        pickerMouseup: 'mouseup', // No I18N
		        focusInput: 'mousedown', // No I18N
		        apply: `${baseComp}change`, // No I18N
		        clear: `${baseComp}clear`, // No I18N
		        close: `${baseComp}close`, // No I18N
		        open: `${baseComp}open`, // No I18N
		        beforeClose: `${baseComp}beforeclose`, // No I18N
		        beforeOpen: `${baseComp}beforeopen`, // No I18N
		        beforeFocus: `${baseComp}beforefocus`// No I18N
		    }, pickerElem);
		    let eventList = [ 'beforedrilldown', 'drilldown', 'datemouseover', 'dateselect', 'monthchange', 'yearchange', 'hourchange', 'minutechange', 'periodchange', 'timechange', 'todaybuttonclick', 'cancel', 'clear' ]; // No I18N
		    for (let i = 0, len = eventList.length; i < len; i++) {
		        pickerElem.off(baseComp + eventList[i] + '.' + componentName).on(`${baseComp}${eventList[i]}.${componentName}`, this._dispatchPickerEventsHandler.bind(this, 'picker' + eventList[i])); // No I18N
		    }
		}
		_beforeFocusHandler  (ev) {
		    ev.preventDefault();
		}
		_focusInputHandler  () {
		    this._pickerMouseDown = true;
		    this.container.addClass('has-focus').trigger('focusin'); // No I18N
		}
		_pickerMouseupHandler  () {
		    this._pickerMouseDown = false;
		}
		_clearHandler  () {
		    if (this._opts.immediateCommit) {
		        this.setAttribute('value', null); // No I18N
		        this._clearActionHandler();
		    }
		}
		_dispatchPickerEventsHandler  (eventKey, orgEvent, ui) {
		    if (!ui) {
		        ui = orgEvent.detail;
		    }
		    this._dispatchEvent(eventKey, orgEvent, ui);
		}
		_openHandler  (orgEvent) {
		    this.container.attr('aria-expanded', true); // No I18N
		    this._dispatchEvent('pickeropen', orgEvent, { // No I18N
		        value: this._input[0].value,
		        dateValue: this._opts.value
		    });
		    let base = this;
		    /* When mousedown happens over picker and clicked somewhere else, focussing the input field causes a scroll to it.
		       To avoid this, only when mousedown happens within the component, the field has to be focussed. (Team box team faced this issue) */
		    ZC.$document.on('mousedown.' + this.name, (evObj) => {// No I18N
		        if (!base._pickerMouseDown) {
		            let target = $(evObj.target);
		            if (target && target.length && !target.closest(this._picker).length) {
		                base._bodyClick = true;
		            }
		        }
		    });
		}
		_beforeOpenHandler  (orgEvent) {
		    let returnValue = this._dispatchEvent('pickerbeforeopen', orgEvent, { // No I18N
		        value: this._input[0].value,
		        dateValue: this._opts.value
		    });
		    return returnValue;
		}
		_beforeCloseHandler  (orgEvent) {
		    this._dispatchEvent('pickerbeforeclose', orgEvent, { // No I18N
		        value: this._input[0].value,
		        dateValue: this._opts.value
		    });
		}
		_closeHandler  (orgEvent) {
		    this.container.attr('aria-expanded', false); // No I18N
		    this._getSegmentValue();
		    let value = this._opts.value;
		    if (!this._immediateCommit) {
		        this.setAttribute('value', this._applyClicked ? this._isDateInstance(value) : this._isDateInstance(this._lastValue)); // No I18N
		    }
		    this._selectText(this._segment);
		    this._mouseupHandler();
		    this._applyClicked = false;
		    this._dispatchEvent('pickerclose', orgEvent, { // No I18N
		        value: this._input[0].value,
		        dateValue: value
		    });
		    if (this._bodyClick) {
		        /* When focus setting is prevented, focusout is not triggered for this case. Hence, focusout is triggered. */
		        this._input.trigger('focusout'); // No I18N
		    }
		    ZC.$document.off('mousedown.' + this.name); // No I18N
		    this._bodyClick = false;
		}
		_applyHandler  (orgEvent, ui) {
		    if (!ui) {
		        ui = orgEvent.detail;
		    }
		    this._applyClicked = true;
		    this._lastValue = ui.valueString;
		    this._getSegmentValue();
		    let format = this._opts.format,
		        dateUtil = ZC.Date;
		    if (dateUtil.formatDate(this._opts.value, format) !== dateUtil.formatDate(ui.value, format)) { // check is included since field value might be already updated via setValue method.
		        this.setAttribute('value', ui.value ? ui.valueString : null); // No I18N
		        let pickerOptions = ZC[this._pickerMethods.instance](this._picker).getAttributes();
		        if (pickerOptions.monthsPerView > 1) {
		            let index = parseInt(this._picker.find('.is-selected').closest('li').index()); // No I18N
		            this.setAttribute('pickerOptions', { // No I18N
		                selectedDateMonthViewIndex: index
		            });
		        }
		    }
		    this._selectText(this._segment);
		    this._mouseupHandler();
		    // this._input.addClass('has-focus'); // No I18N (added for Ok Click)
		}
		clearHandler  () {
		    if (this._opts.immediateCommit) {
		        this.setAttribute('value', null); // No I18N
		        this._clearActionHandler();
		    }
		}
		_pickerOpenHandler  (orgEvent) {
		    let picker = this._picker,
		        opts = this._opts;
		    this._getSegment();
		    orgEvent.preventDefault();
		    if (picker && !picker.is(':visible') && !opts.readonly && !opts.disabled && $(orgEvent.target).closest('.zinputfield__clearbutton,.zinputfield__spinbutton').length === 0) { // No I18N
		        opts.pickerId && this._bindPickerEvents();
		        let pickerInstance = ZC[this._pickerMethods.instance](picker);
		        pickerInstance.setAttributes({
		            forElement: this.container,
		            value: this._isDateInstance(opts.value)
		        });
		        pickerInstance.open();
		    }
		}
		_getSegmentValue  () {
		    this._getSegment();
		    if (!this._segment) {
		        this._selectCaretPosition(this._input[0], 0, 0);
		        this._getSegment();
		    }
		}
		_isPickerOpenValid  () {
		    let opts = this._opts;
		    return opts.calendarIconUIType !== 'button' || opts.calendarIconUIType === 'button' && opts.showPickerOnFocus; // No I18N
		}
		_setPickerAttributes  (optionName, value) {
		    let opts = this._opts,
		        componentName = this.name,
		        pickerInstance,
		        pickerOptions = $.extend(true, {}, opts.pickerOptions);
		    if (this._picker) {
		        pickerInstance = ZC[this._pickerMethods.instance](this._picker);
		    }
		    switch (optionName) {
		        case 'picker':
		            if (value) {
		                this._hasPicker = true;
		                this._createPicker();
		                this._bindPickerEvents();
		                this._isPickerOpenValid() && this._addEvents({
		                    pickerOpen: 'click'// No I18N
		                }, this.container);
		                opts.calendarIconUIType === 'button' && this._addEvents({ // No I18N
		                    calendarIconClick: 'mousedown' // No I18N
		                }, this._calendarIcon);
		                pickerInstance = ZC[this._pickerMethods.instance](this._picker);
		                this._immediateCommit = pickerInstance.getAttribute('immediateCommit'); // No I18N
		            } else if (this._picker) {
		                opts.pickerOptions = null;
		                this._render();
		                opts.pickerOptions = pickerOptions;
		                this._picker = undefined;
		                this._hasPicker = false;
		                this.container.off('click.' + componentName); // No I18N
		            }
		            break;
		        case 'pickerOptions': // No I18N
		            // pickerInstance && pickerInstance.destroy();
		            opts.value = this._isDateInstance(opts.value);
		            pickerInstance && pickerInstance.setAttributes(pickerOptions);
		            break;
		        case 'showPickerOnFocus': // No I18N
		            if (opts.calendarIconUIType === 'button') { // No I18N
		                this.container.off(`click.${componentName}`);
		                if (value) {
		                    this._addEvents({
		                        pickerOpen: 'click'// No I18N
		                    }, this.container)
		                }
		            }
		            break;
		    }
		}
		_getPicker  () {
		    return ZC[this._pickerMethods.instance](this._picker);
		}
		_destroyPicker  () {
		    let pickerInstance = this._getPicker();
		    this._picker.off(pickerInstance._EVENTS.map((val) => `z${this._pickerMethods.instance}${val}.${this.name}`).join(' ')); // No I18N
		    pickerInstance.destroy();
		    this._picker.remove();
		    this._picker = undefined;
		}
		openPicker  () {
		    ZC[this._pickerMethods.instance](this._picker).open();
		}
		closePicker  () {
		    ZC[this._pickerMethods.instance](this._picker).close();
		}
		getPickerElement  () {
		    return this._picker;
		}
		_setAttribute   (optionName, value) {
		    let calendarIconOptions = ["calendarIcon", "calendarIconClassName", "calendarSVGIconId", "calendarIconUIType", "calendarIconAlignment"], // No I18N
		        data = this._data, opts = this._opts, hasPicker = this._hasPicker, setAttribute = super._setAttribute.bind(this),
		        dateValue = opts.value, pickerElem = this._picker, pickerInstance;
		    opts[optionName] = value;
		    if (hasPicker) {
		        pickerInstance = ZC[this._pickerMethods.instance](pickerElem);
		    }
		    if (optionName === "century") { // No I18N 
		        value = value - 1;
		        let viewDate = this._viewDate;
		        if (!isNaN(value) && value.toString().length === 2) {
		            viewDate.setFullYear(parseInt(value.toString() + viewDate.getFullYear().toString().slice(2)));
		            dateValue && (opts.value = new Date(viewDate.getTime()));
		            opts.century = value + 1;
		        } else {
		            throw new Error(opts.labels.invalidNumber);
		        }
		    } else if (optionName === "format" || optionName === "value") { // No I18N
		        this._lastValue = null;
		        setAttribute(optionName, value);
		        // revisit - following set of code is commented since it is unnecessary and also produces issue
		        // let calendarIcon = this._calendarIcon, clickEvent = "click." + this.name, isPickerOpenValid = this._isPickerOpenValid(), // No I18N 
		        //     container = this.container;   // No I18N 
		        // isPickerOpenValid && container.off(clickEvent);
		        // calendarIcon && opts.calendarIconUIType === "button" && calendarIcon.off(clickEvent);  // No I18N 
		        // if (hasPicker) {
		        //    calendarIcon && this._addEvents({
		        //         calendarIconClick: 'click' // No I18N 
		        //     }, calendarIcon)
		        //     isPickerOpenValid && this._addEvents({
		        //         pickerOpen: 'click' // No I18N
		        //     }, container);
		        // }
		    } else if (optionName === "min" || optionName === "max") { // No I18N
		        setAttribute(optionName, value);
		    } else if (optionName.indexOf("picker") > -1 || optionName === "showPickerOnFocus") {  // No I18N
		        opts.value = this._isDateInstance(dateValue);
		        this._setPickerAttributes(optionName, value);
		    } else if (calendarIconOptions.indexOf(optionName) > -1) {
		        if(optionName === 'calendarIconUIType' && opts.calendarIcon || optionName === 'calendarIcon'){ // No I18N 
		            data.modifiedAttr = 'calendarIcon'; // No I18N 
		        }
		        if (optionName === "calendarIconAlignment") {  // No I18N
		            value = ["right", "left"].indexOf(value) > -1 ? value : "right"; // No I18N
		            this._domChanged = true;
		        }
		        this._handleCalendarIcon(optionName, value);
		    } else if (optionName === "rtl" && hasPicker) { // No I18N
		        pickerElem && pickerInstance.setAttribute("rtl", value); // No I18N
		    } else if (optionName === "locale") { // No I18N
		        setAttribute(optionName, value);
		        pickerElem && pickerInstance.setAttribute("locale", value); // No I18N
		    } else {
		        setAttribute(optionName, value);
		    }
		}
	}
	ZC.registerComponent('ZDateField', ZC.ZDateInput, ZDateField); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zdatefield.Templates, button = ZC.zbutton.Templates.WCContainer; 
template.WCContainer = (data) => ZT.html `<div class="zinputfield ${data.className}" ?title=${data.title} tabindex="-1" role="spinbutton" style="width:${data.width}px" ?id=${data.id} >${data.children && template.WCChildren(data)}</div>`; 
template.WCChildren = (data) => ZT.html `${data.calendarPosition === 'beforeInput' && template.WCCalendarIcon(data)} ${ZT.html `<input class='zinputfield__textbox' tabindex="${data.tabindex}" ?aria-valuemin=${data.min} ?aria-valuemax=${data.max} ?readonly=${data.readonly} ?aria-readonly=${data.readonly} ?disabled=${data.disabled} ?aria-disabled=${data.disabled} ?maxlength=${data.maxLength}>`} ${data.clearButton && button(data.clearButtonProps)} ${data.calendarPosition === 'beforeSpinBtn' && template.WCCalendarIcon(data)} ${data.spinButtons && ZT.html `<div class="zinputfield__spinbuttonpane"> ${data.isVertical ? button(data.incrementProps) : button(data.decrementProps)} ${data.isVertical ? button(data.decrementProps) : button(data.incrementProps)} </div>`} ${data.calendarPosition === 'afterSpinBtn' && template.WCCalendarIcon(data)}`; 
let utilities = ZC.Templates.Utilities; 
template.WCCalendarIcon = (data) => ZT.html `${data.calendarIconUIType === 'label' ? ZT.html `<div class="${data.calIconClassName}">${utilities.WCIcon(data.calendarIconProps)}</div>` : ZC.zbutton.Templates.WCContainer(data.calendarIconProps)}`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zdatefield.Templates, button = ZC.zbutton.Templates.container; 
template.container = (data) => ZT.html `<div class="zinputfield ${data.className}" ?title=${data.title} tabindex="-1" role="spinbutton" style="width:${data.width}px" ?id=${data.id} >${data.children && template.children(data)}</div>`; 
template.children = (data) => ZT.html `${data.calendarPosition === 'beforeInput' && template.calendarIcon(data)} ${ZT.html `<input class='zinputfield__textbox' tabindex="${data.tabindex}" ?aria-valuemin=${data.min} ?aria-valuemax=${data.max} ?readonly=${data.readonly} ?aria-readonly=${data.readonly} ?disabled=${data.disabled} ?aria-disabled=${data.disabled} ?maxlength=${data.maxLength}>`} ${data.clearButton && button(data.clearButtonProps)} ${data.calendarPosition === 'beforeSpinBtn' && template.calendarIcon(data)} ${data.spinButtons && ZT.html `<div class="zinputfield__spinbuttonpane"> ${data.isVertical ? button(data.incrementProps) : button(data.decrementProps)} ${data.isVertical ? button(data.decrementProps) : button(data.incrementProps)} </div>`} ${data.calendarPosition === 'afterSpinBtn' && template.calendarIcon(data)}`; 
let utilities = ZC.Templates.Utilities; 
template.calendarIcon = (data) => ZT.html `${data.calendarIconUIType === 'label' ? ZT.html `<div class="${data.calIconClassName}">${utilities.icon(data.calendarIconProps)}</div>` : ZC.zbutton.Templates.container(data.calendarIconProps)}`; }(ZComponents)); 
(function(ZC, $){
		class ZTimeField extends ZC.ZDateInput {
			get name(){
				return "ztimefield";
			}
		    get attrs() {
		        return {
		            format: 'hh:mm tt', // No I18N
		            hourStep: 1,
		            minuteStep: 1,
		            secondStep: 1,
		            placeholder: {
		                hour: 'hour', // No I18N
		                minute: 'minute', // No I18N
		                second: 'second', // No I18N
		                period: 'AM/PM'	// No I18N
		            },
		            labels: {
		                period: 'AM/PM',	// No I18N
		                AM: 'AM',	// No I18N
		                PM: 'PM'	// No I18N
		            }
		        }
		    }
		    _validateFormat() {
		        this._checkFormat(/d|M|y/g); // No I18N
		    }
		    _init() {
		        this._allowedChars = 'Hhmstz';	// No I18N
		        super._init(...arguments);
		        this._opts.templateName = 'zinputfield'; // No I18N
		        this._opts.incrementOnWrapAround = false;
		    }
		    _setFormat() {
		        this._setFormatVal(/^(time-short|time-long|time-medium)$/, 'time', 'hh:mm tt'); // No I18N
		    }
		    _getDateValue() {
		        return this._hoursModified && this._minutesModified && this._secondsModified ? new Date(this._viewDate.getTime()) : undefined;
		    }
		    _getMatch(match) {
		        return match;
		    }
		    _getRegEx() {
		        return /HH|H|hh|h|mm|m|ss|s|tt|zz{0,2}|"[^"]*"|'[^']*'/g;
		    }
		    _resetToFirst(removedChar) {
		        this._resetTimeToFirst(removedChar);
		    }
		    _resetTimeToFirst(removedChar) {
		        let obj = {
		            H: 'Hours', // No I18N
		            m: 'Minutes', // No I18N
		            s: 'Seconds' // No I18N
		        };
		        if (removedChar && 'Hms'.indexOf(removedChar) > -1) {
		            this._viewDate[`set${obj[removedChar]}`](0);
		        }
		    }
		    _resetOnBlur(char) {
		        this._resetTimeOnBlur(char);
		    }
		    _resetTimeOnBlur(char) {
		        char === 'm' && this._viewDate.setMinutes(0); // No I18N
		    }
		    _parseSegment(character, currentChar, newDate) {
		        return this._parseTime(character, currentChar, newDate);
		    }
		    _replaceTime(match) {
		        let result,
		            viewDate = this._viewDate,
		            hoursModified = this._hoursModified,
		            minutesModified = this._minutesModified,
		            secondsModified = this._secondsModified,
		            getPlaceholder = this._getPlaceholder.bind(this);
		        if ([ 'h', 'hh', 'H', 'HH' ].indexOf(match) > -1) { // No I18N
		            result = hoursModified ? viewDate.getHours() : getPlaceholder(match);
		            if (hoursModified) {
		                [ 'h', 'hh' ].indexOf(match) > -1 && (result = result % 12 || 12); // No I18N
		                result = [ 'h', 'H' ].indexOf(match) > -1 ? result.toString() : (result < 10 ? '0' : '') + result; // No I18N
		            }
		        } else if ([ 'm', 'mm', 's', 'ss' ].indexOf(match) > -1) { // No I18N
		            let parts = match.indexOf('m') > -1 ? [ 'Minutes', minutesModified ] : [ 'Seconds', secondsModified ]; // No I18N
		            result = parts[1] ? viewDate[`get${parts[0]}`]() : getPlaceholder(match);
		            parts[1] && (result = match.length === 1 ? result.toString() : (result < 10 ? '0' : '') + result); // No I18N
		        } else if ([ 'tt' ].indexOf(match) > -1) {
		            result = hoursModified ? viewDate.getHours() < 12 ? this._getI18NText('AM') : this._getI18NText('PM') : this._opts.placeholder.period; // No I18N
		            if (this._opts.placeholderType !== 'underscore') { // No I18N
		                result = getPlaceholder(result);
		            }
		        } else if ([ 'z', 'zz', 'zzz' ].indexOf(match) > -1) { // No I18N
		            result = viewDate.toString().split(' ')[5]; // No I18N
		        }
		        return this._translateEToA(result);
		    }
		    _replaceText(match) {
		        return this._replaceTime(match);
		    }
		    _validateOptions() {
		        super._validateOptions();
		        let opts = this._opts;
		        [ 'value', 'min', 'max' ].forEach((value) => { // No I18N
		            if (opts[value]) {
		                opts[value] = this._changeToViewDate(opts[value]);
		            }
		        });
		    }
		    _performValidations() {
		        super._performValidations([ 'hourStep', 'minuteStep', 'secondStep' ], [ 'hours', 'minutes', 'seconds' ]); // No I18N
		    }
		    _getCustomMatch(match) {
		        return this._getTimeMatch(match);
		    }
		    _getTimeMatch(match) {
		        let part = this._getTimeParts()[match[0]];
		        part = [ 'h', 'hh', 'H', 'HH', 'm', 'mm', 's', 'ss' ].indexOf(match) > -1 ? this._opts.placeholder[part.slice(0, -1)] : ''; // No I18N
		        return part || (!this._hoursModified && this._opts.placeholder.period || match);
		    }
		    _getTimeParts() {
		        return {
		            H: 'hours', // No I18N
		            h: 'hours', // No I18N
		            m: 'minutes', // No I18N
		            s: 'seconds' // No I18N
		        };
		    }
		    _modifyValue(newDate, character, offset, isValueComplete) {
		        return this._modifyTime(newDate, character, offset, isValueComplete);
		    }
		    _modifyTime(newDate, character, offset, isValueComplete) {
		        let part;
		        if ([ 'h', 'H' ].indexOf(character) > -1) { // No I18N
		            part = '_hoursModified'; // No I18N
		            offset *= this._opts.hourStep;
		            let hourValue = newDate.getHours() + offset;
		            if (!this._opts.incrementOnWrapAround || !isValueComplete) {
		                hourValue > 23 && (hourValue %= 24);
		                hourValue < 0 && (hourValue += 24);
		            }
		            (this._hoursModified || offset < 0) && newDate.setHours(hourValue);
		        } else if ([ 'm', 's' ].indexOf(character) > -1) { // No I18N
		            part = this._minuteSecondUpdate(character, offset, newDate, isValueComplete);
		        } else if (character === 't') { // No I18N
		            newDate.setHours((newDate.getHours() + 12) % 24);
		        }
		        return part;
		    }
		    _disableSpinBtns() {
		        let opts = this._opts,
		            cls = 'is-disabled', // No I18N
		            value = opts.value,
		            min = opts.min,
		            max = opts.max,
		            btnPane = this._buttonPane;
		        if (opts.spinButtons !== 'none') { // No I18N
		            if (value) {
		                let tempVal = new Date(+value),
		                    clsFn;
		                this._modifyTime(tempVal, this._currentSegment || 'h', -1); // No I18N
		                clsFn = ((min && +tempVal < +min) || (max && +tempVal > +max)) ? 'addClass' : 'removeClass'; // No I18N
		                btnPane.find('.zh-down')[clsFn](cls);// No I18N
		                tempVal = new Date(+value);
		                this._modifyTime(tempVal, this._currentSegment || 'h', 1); // No I18N
		                clsFn = ((min && +tempVal < +min) || (max && +tempVal > +max)) ? 'addClass' : 'removeClass'; // No I18N
		                btnPane.find('.zh-up')[clsFn](cls); // No I18N
		            }
		        }
		    }
		    _getDisabledValue(min, max, offset, newDate) {
		        let disable = super._getDisabledValue(...arguments);
		        if (!disable && ((min && +newDate < +min) || (max && +newDate > +max))) {
		            disable = true;
		            this.container.find(`.zh-${offset === 1 ? 'up' : 'down'}`).addClass('is-disabled')
		        }
		        return disable;
		    }
		    _updateDisabledState(limit, newDate, isMax) {
		        let element = this.container.find(`.zh-${isMax ? 'up' : 'down'}`), // No I18N
		            disabled,
		            notInRange;
		        limit = +limit;
		        newDate = +newDate;
		        notInRange = isMax ? newDate > limit : newDate < limit;
		        if (limit && notInRange) {
		            element.addClass('is-disabled');// No I18N
		            disabled = true;
		        }
		        !disabled && element.removeClass('is-disabled');// No I18N
		        return disabled;
		    }
		    _parseTime(character, currentChar, newDate) {
		        let jumpOnComplete = this._opts.jumpOnComplete,
		            viewDate = this._viewDate,
		            hourString,
		            hoursModified = this._hoursModified,
		            newValue;
		        if (character === 'h') { // No I18N
		            newValue = (hoursModified ? newDate.getHours() % 12 * 10 : 0) + parseInt(currentChar);
		            if (isNaN(newValue)) {
		                return;
		            }
		            hourString = newValue.toString();
		            if (!jumpOnComplete && newValue > 12) {
		                newValue = this._isFastInput ? parseInt(hourString[0]) : parseInt(hourString.slice(-1));
		            } else if (jumpOnComplete) {
		                while (newValue > 12) {
		                    newValue = parseInt(newValue.toString().slice(1));
		                }
		            }
		            newValue = viewDate.getHours() >= 12 ? newValue + 12 : newValue % 12 === 0 ? 0 : newValue;
		            if (jumpOnComplete && hoursModified && currentChar !== '1') { // No I18N
		                this._isNextSegment = true;
		            }
		            newValue > 23 && (newValue = 12);
		        } else if (character === 'H') { // No I18N
		            newValue = (this._isNewValue && this._oldSegment !== this._currentSegment ? 0 : hoursModified ? newDate.getHours() * 10 : 0) + parseInt(currentChar);
		            if (isNaN(newValue)) {
		                return;
		            }
		            hourString = newValue.toString();
		            let strLen = hourString.length;
		            if (jumpOnComplete && (newValue >= 23 || strLen === 2 && hourString[1] !== '0')) { // No I18N
		                this._isNextSegment = true;
		            }
		            if (!jumpOnComplete && newValue > 23 && this._isFastInput) {
		                if (strLen === 2) {
		                    newValue = viewDate.getHours();
		                } else if (strLen >= 3) {
		                    newValue = parseInt(newValue.toString().slice(1));
		                    if (newValue > 23) {
		                        newValue = parseInt(newValue.toString()[0]);
		                    }
		                }
		            } else {
		                newValue > 23 && (newValue = jumpOnComplete ? parseInt(hourString[0]) : parseInt(hourString.slice(-1)))
		            }
		        } else if ([ 'm', 's' ].indexOf(character) > -1) { // No I18N
		            this._parseMinuteSecond(character, currentChar, newDate);
		        } else if (character === 't') { // No I18N
		            if (hoursModified) {
		                this._typedPeriodChar += currentChar.toLowerCase();
		                while (this._typedPeriodChar.length > 0) {
		                    let AMKey = this._getI18NText('AM'), // No I18N
		                        PMKey = this._getI18NText('PM'), // No I18N
		                        typedChar = this._typedPeriodChar; // No I18N
		                    if (AMKey.toLowerCase().indexOf(typedChar) === 0 && newDate.getHours() >= 12 || PMKey.toLowerCase().indexOf(typedChar) === 0 && newDate.getHours() < 12) {
		                        newDate.setHours((newDate.getHours() + 12) % 24);
		                        this._oldDateValue = new Date(viewDate.getTime());
		                        this._viewDate = newDate;
		                        return true;
		                    }
		                    this._typedPeriodChar = typedChar.substring(1, typedChar.length);
		                }
		                this._hoursModified = true;
		                return true;
		            }
		        }
		        [ 'H', 'h' ].indexOf(character) > -1 && newDate.setHours(newValue); // No I18N
		        [ 'm', 's' ].indexOf(character) === -1 && (this._hoursModified = true); // No I18N
		        return newDate;
		    }
		    _parseMinuteSecond(character, currentChar, newDate) {
		        let suffix = character === 'm' ? 'Minutes' : 'Seconds', // No I18N
		            part = `_${this._getTimeParts()[character]}Modified`, // No I18N
		            newValue = (this[`${part}`] ? newDate[`get${suffix}`]() * 10 : 0) + parseInt(currentChar), // No I18N
		            jumpOnComplete = this._opts.jumpOnComplete;
		        if (!isNaN(newValue)) {
		            let str = newValue.toString();
		            if (jumpOnComplete && (newValue >= 59 || str.length === 2 && str[1] !== '0')) { // No I18N
		                this._isNextSegment = true;
		            }
		            if (!jumpOnComplete && newValue > 59 && this._isFastInput) {
		                if (str.length === 2) {
		                    newValue = this._viewDate[`get${suffix}`](); // No I18N
		                } else if (str.length >= 3) {
		                    newValue > 59 && (newValue = parseInt(newValue.toString().slice(1)));
		                    if (newValue > 59) {
		                        newValue = parseInt(newValue.toString()[0]);
		                    }
		                }
		            } else {
		                newValue > 59 && (newValue = jumpOnComplete ? parseInt(str[0]) : parseInt(str.slice(-1)));
		            }
		            newDate[`set${suffix}`](newValue); // No I18N
		            this[part] = true;
		        }
		    }
		    _minuteSecondUpdate(character, offset, newDate, isValueComplete) {
		        let part = `_${this._getTimeParts()[character]}Modified`, // No I18N
		            step = `${part.slice(1, 7)}Step`, // No I18N
		            methodSuffix = character === 'm' ? 'Minutes' : 'Seconds'; // No I18N
		        offset *= this._opts[step];
		        let value = newDate[`get${methodSuffix}`]() + offset; // No I18N
		        if (!this._opts.incrementOnWrapAround || !isValueComplete) {
		            value > 59 && (value %= 60);
		            value < 0 && (value += 60);
		        }
		        (this[part] || offset < 0) && newDate[`set${methodSuffix}`](value); // No I18N
		        return part;
		    }
		    _isPartModified(character, value) {
		        this._isTimeModified(character, value);
		    }
		    _isTimeModified(character, value) {
		        let obj = this._getTimeParts(); // No I18N
		        this[`_${obj[character]}Modified`] = value; // No I18N
		        [ 'h', 'H' ].indexOf(character) > -1 && !value && (this._typedPeriodChar = ''); // No I18N
		    }
		    _changeToViewDate(value) {
		        value = ZC.Date.parseDate(value, this._format);
		        value = (value && value.isValid) ? value.date : undefined;
		        if (value) {
		            let viewDate = this._viewDate;
		            value.setDate(viewDate.getDate());
		            value.setMonth(viewDate.getMonth());
		            value.setFullYear(viewDate.getFullYear());
		        }
		        return value;
		    }
		    setValue(value) {
		        /* Viewdate might be changed if the value is set */
		        value = this._changeToViewDate(value);
		        super.setValue(value);
		    }
		    _setAttribute(name, value) {
		        if ([ 'value', 'min', 'max' ].indexOf(name) > -1 && value) { // No I18N
		            value = this._changeToViewDate(value);
		        }
		        super._setAttribute(name, value);
		    }
		}
	ZC.registerComponent('ZTimeField', ZC.ZDateInput, ZTimeField); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
		ZC.dateTimePrototype = class dateTimePrototype { };
		ZC.getPrototype(ZC.ZDateField, ZC.dateTimePrototype);
		ZC.getPrototype(ZC.ZTimeField, ZC.dateTimePrototype);
		class ZDateTimeField extends ZC.dateTimePrototype {
			get name(){
				return "zdatetimefield";
			}
		    get attrs() {
		        return {
		            format: 'dd/MM/yyyy, hh:mm tt' // No I18N
		        }
		    }
		    // CoreComponent's constructor code is included here since the prototype is the resultant of two different class prototypes which are merged manually to support multiple inheritance
		    constructor(element, options) {
		        super(element, options);
		        // Commented since it is producting issue in vue and react component. Also the below statement is achieved by using a getter
		        // this.name = this.constructor.name.toLowerCase();
		        options = options || {};
		        this.element = $(element);
		        this._opts = $.extend(true, {}, this._DEFAULTS, ZC[this.name] ? ZC[this.name].DEFAULTS : {}, ZC._getOpts(element), options);
		        this._create($(element), this._opts);
		        this._defineGetterSetter();
		    }
		    _checkForTime() {
		        let format = this._opts.format;
		        return format.indexOf('H') > -1 || format.indexOf('h') > -1 || format.indexOf('m') > -1; // No I18N
		    }
		    _checkForDate() {
		        let format = this._opts.format;
		        return format.indexOf('d') > -1 || format.indexOf('dd') > -1; // No I18N
		    }
		    _validateFormat() {
		        this._invalidFormat = !(this._checkForDate() && this._checkForTime());
		    }
		    _getDateValue() {
		        return this._dateModified && this._monthModified && this._yearModified && this._hoursModified && this._minutesModified && this._secondsModified ? new Date(this._viewDate.getTime()) : undefined;
		    }
		    _getRegEx() {
		        return /dd{0,3}|MM{0,3}|yyyy|yy|HH|H|hh|h|mm|m|ss|s|tt|zz{0,2}|"[^"]*"|'[^']*'/g;
		    }
		    _initPicker() {
		        let opts = this._opts,
		            pickerOptions = opts.pickerOptions,
		            min = opts.min,
		            max = opts.max;
		        min && (min = new Date(+opts.min));
		        max && (max = new Date(+opts.max));
		        pickerOptions.minuteStep = opts.minuteStep;
		        pickerOptions.hourStep = opts.hourStep;
		        pickerOptions.minDate = pickerOptions.minDate || min;
		        pickerOptions.maxDate = pickerOptions.maxDate || max;
		        super._initPicker();
		    }
		    _init() {
		        this._checkTime = true;
		        this._isInit = true;
		        super._init(...arguments);
		        this._opts.templateName = 'zdatefield'; // No I18N
		        this._allowedChars = 'dMyHhmstz';	// No I18N
		    }
		    _postRender() {
		        this._pickerMethods = {
		            create: 'createDateTimePicker', // No I18N
		            instance: 'datetimepicker'// No I18N
		        };
		        super._postRender();
		    }
		    _getSuffix(character) {
		        return 'dMy'.indexOf(character[0]) > -1 ? 'Date' : 'Time'; // No I18N
		    }
		    _modifyValue(newDate, character, offset, isValueComplete) {
		        return this[`_modify${this._getSuffix(character)}`](newDate, character, offset, isValueComplete);
		    }
		    _replaceText(match) {
		        return this[`_replace${this._getSuffix(match)}`](match);
		    }
		    _resetOnBlur(char) {
		        this[`_reset${this._getSuffix(char)}OnBlur`](char);
		    }
		    _resetToFirst(removedChar) {
		        this[`_reset${this._getSuffix(removedChar)}ToFirst`](removedChar);
		    }
		    _getCustomMatch(match) {
		        return this[`_get${this._getSuffix(match)}Match`](match);
		    }
		    _isPartModified(character, value) {
		        this[`_is${this._getSuffix(character)}Modified`](character, value);
		    }
		    _parseSegment(character, currentChar, newDate) {
		        this[`_parse${this._getSuffix(character)}`](character, currentChar, newDate);
		    }
		    _performValidations() {
		        this._validateStep([ 'dateStep', 'monthStep', 'yearStep', 'hourStep', 'minuteStep', 'secondStep' ]); // No I18N
		        super._performValidations();
		        let min = this._opts.min,
		            format = this._opts.format,
		            max = this._opts.max;
		        min && min.setHours(min.getHours(), min.getMinutes(), format.indexOf('s') < 0 ? 0 : min.getSeconds(), 0);
		        max && max.setHours(max.getHours(), max.getMinutes(), format.indexOf('s') < 0 ? 0 : max.getSeconds(), 0);
		        this._dateModified = this._monthModified = this._yearModified = this._hoursModified = this._minutesModified = this._secondsModified = true;
		        this._checkForModification(this._opts.value);
		    }
		    _isDateInstance(value) {
		        if (value instanceof Date) {
		            value = new Date(value.getTime());
		            value.setSeconds(0, 0);
		        }
		        return value;
		    }
		    _updateElementValue() {
		        let dateFormatRegExp = this._getRegEx();
		        let opts = this._opts,
		            format = opts.format;
		        this._retursFormat = false;
		        let newValue = format.replace(dateFormatRegExp, this._replaceMatchedText.bind(this));
		        this._retursFormat = true;
		        this._dateFormat = format.replace(dateFormatRegExp, this._replaceMatchedText.bind(this));
		        this._input[0].value = newValue;
		        opts.value = this._getDateValue() ? new Date(this._viewDate.getTime()) : undefined;
		        this._oldValue = newValue;
		        if (this._hasPicker && opts.value) {
		            let value = new Date(opts.value.getTime());
		            value.setSeconds(0, 0);
		            if (!this._lastValue || this._lastValue && ZC.Date.parseDate(this._lastValue, opts.format).date.getTime() !== value.getTime()) {
		                ZC[this._pickerMethods.instance](this._picker).setAttribute('value', new Date(value.getTime()));
		            }
		        }
		        if (opts.value) {
		            this._lastValue = this._isDateInstance(opts.value);
		        }
		    }
		    _setFormat() {
		        this._setFormatVal(/^(datetime-short|datetime-long|datetime-medium|datetime-full)$/, 'datetime', 'dd/MM/yyyy, hh:mm tt'); // No I18N
		    }
		}
	ZC.registerComponent('ZDateTimeField', ZC.dateTimePrototype, ZDateTimeField); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
	class ZSlider extends ZC.CoreComponent {
			get name(){
				return "zslider";
			}
	    get attrs() {
	        return {
	            orientation: 'horizontal', // No I18N
	            locale: null,
	            thumbIconStyle: 'circle', // No I18N
	            thumbIconClass: null,
	            thumbSVGIconId: null,
	            min: 0,
	            max: 100,
	            step: 1,
	            valuesType: 'range', // No I18N
	            value: 0,
	            minValueAllowed: null,
	            maxValueAllowed: null,
	            values: [],
	            showTooltip: 'never', // No I18N
	            showTicks: false,
	            snapToTicks: true,
	            stepBehavior: 'w3', // No I18N
	            selectionStartValue: null,
	            blurOnMouseRelease: false,
	            disabled: false
	        }
	    }
	    get props() {
	        return {
	            thumbIconClassName: null,
	            tooltip: {
	                position: 'top', // No I18N
	                displayType: 'callout', // No I18N
	                text: '#value#', // No I18N
	                isHTMLEncoded: false
	            },
	            ticks: {
	                splitBy: 'count', // No I18N
	                count: 4,
	                step: null,
	                randomValues: null,
	                position: 'bottom', // No I18N
	                showLabels: true,
	                showLabelsFor: null,
	                labelPattern: '#value#', // No I18N
	                customLabels: null,
	                isLabelHTMLEncoded: false
	            },
	            valueDisplayFormat: {
	                type: 'number', // No I18N
	                currencyCode: null,
	                prefix: null,
	                suffix: null,
	                decimalPlaces: null,
	                thousandSeparator: false
	            },
	            rangeGroups: {
	                groups: [],
	                isLabelHTMLEncoded: false,
	                labelPosition: 'top' // No I18N
	            }
	        }
	    }
	    get EVENTS() {
	        return [
	            'init', // No I18N
	            'focus', // No I18N
	            'blur', // No I18N
	            'change', // No I18N
	            'slidestart', // No I18N
	            'slide', // No I18N
	            'slideend' // No I18N
	        ]
	    }
	    get _MEASUREMENTS() {
	        return [ 'minValueAllowed', 'maxValueAllowed' ]; // No I18N
	    }
	    _init(element, options) {
	        this._frominit = true;
	        [ 'min', 'max', 'step', 'value', 'title', 'tabIndex' ].forEach((attr) => { // No I18N
	            let value = element[0][attr]
	            if (value || value === 0) {
	                options[attr] = value;
	            }
	        });
	        /* Property check */
	        if (element[0].disabled) {
	            options.disabled = true;
	        }
	        this._cacheMeasurements();
	        this._buildData();
	    }
	    _buildData() { // No I18N
	        let options = this._opts;
	        let data = this._data;
	        data.rangeLabels = undefined;
	        this.vertical = (options.orientation === 'vertical'); // No I18N
	        let _isFixed = (options.valuesType === 'fixed'); // No I18N
	        this._tip = (options.showTooltip !== 'never' && !_isFixed); // No I18N
	        this._isRange = (options.valuesType === 'range'); // No I18N
	        this._hasRangeGroups = this._isRange && options.rangeGroups.groups.length;
	        options.locale = options.locale || ZC.locale;
	        this._ticks = (options.showTicks || _isFixed);
	        data.ticksList = [];
	        data.labels = [];
	        this._isFixed = _isFixed;
	        if (_isFixed) {
	            this._setFixedValues();
	        }
	        this._validateProperty();
	        if (!this.isCE) {
	            this.element.addClass('zh-dnone'); // No I18N
	            data.style = this.element.attr('style'); // No I18N
	            data.title = this._opts.title;
	        }
	        data.thumbs = [ this._setThumb() ];
	        this._ticks && this._handleTicks();
	        this._hasRangeGroups && this._setRangeLabels();
	        this._tip && this._setTooltip();
	        this._setSelectedLimit();
	    }
	    _getFromLocale(prop, currency) {
	        let localeInfo = ZC.localeInfo
	        if (localeInfo) {
	            let locale = this._opts.locale || ZC.locale
	            localeInfo = localeInfo[locale][currency ? 'currency' : 'numberFormat']; // No I18N
	            return localeInfo[prop] || '';
	        }
	    }
	    _postEachRender() {
	        if (!this._reStoreRef) {
	            this._setDim(this.vertical ? 'height' : 'width'); // No I18N
	            this._showParent()
	            this._storeRef(...arguments);
	            this._hideParent();
	        }
	    }
	    _setDim(param) {
	        let dimension = this._opts[param] || (!this._useParent && this.element[0].style[param]);
	        if (dimension) {
	            this.container[0].style[param] = isNaN(dimension) ? dimension : (dimension + 'px'); // No I18N
	        }
	    }
	    _storeRef(element) {
	        element = this.container;
	        this._shadowTrack = element.find('.zslider__shadowtrack'); // No I18N
	        this._innerSlider = element.find('.zslider__track'); // No I18N
	        this._range = this._innerSlider.find('.zslider__selection'); // No I18N
	        this._setClassName();
	        this._setDimensions();
	        this.container.find('.zslider__thumb').removeAttr('style'); // No I18N
	        this._opts.disabled && this._disable(true, false);
	        // let childselector = '.' + this.vertical ? "zslider__text" : "zslider__rangelabel";  // No I18N
	        /* if (this.vertical) {For range Label Htmls
	            //let labelStyle = "max-" + this.innerDim + ":" + (this.sliderDim[this.outerDim] * (curPer - lastPer) / 100) + "px"; //No I18N
	        }
	        */
	        this._tip && this._handleTip();
	        this._setHandlePosition();
	        this._ticks && this._setTicksPosition();
	        this._ticksLabel && this._setLabelsPosition();
	        this._hasRangeGroups && this._setRangeLabelsPosition();
	        this._setCurrentValues();
	        this._handleSelectedLimit();
	    }
	    _setClassName() {
	        let options = this._opts;
	        let className = 'zslider ' + (options.className || options.zclassName || ''); // No I18N
	        if (options.rtl) {
	            className += ' zh-rtl'; // No I18N
	        }
	        if (options.disabled) {
	            className += ' is-disabled'; // No I18N
	        }
	        if (this.vertical) {
	            className += ' zslider--vertical'; // No I18N
	        }
	        this.container.attr('class', className); // No I18N
	    }
	    _setThumb() {
	        let o = this._opts,
	            iconHTML = '',
	            tabIndex,
	            iconClass = '', // No I18N
	            thumbIconClassName = o.thumbIconClassName;
	        if (o.disabled) {
	            iconClass = ' is-disabled'; // No I18N
	        } else {
	            tabIndex = o.tabIndex || 0;
	        }
	        if (o.thumbSVGIconId) {
	            let thumbIconInfo = ZC._getIconInfo(thumbIconClassName, o.thumbSVGIconId);
	        } else if (thumbIconClassName) {
	            iconClass += thumbIconClassName;
	        } else if (o.thumbIconStyle === 'pointer') { // No I18N
	            iconClass += ' zslider__pointerthumb '; // No I18N
	            // Here RTL is not considered as it is handled in CSS.
	            let thumbDir = this._getRTLBasedDir(this._getCorrectDir(o.ticks.position));
	            if ((this._opts.rtl ? /^(right|top)$/ : /^(left|top)$/).test(thumbDir)) { // No I18N
	                iconClass += ' zh-inverted'; // No I18N
	            }
	            let width = 21,
	                height = 32;
	            if (/^(right|left)$/.test(thumbDir)) {
	                width = 32;
	                height = 21;
	            }
	            iconHTML = '<svg class="zslider__pointerthumbsvg" viewBox="0 0 ' + width + ' ' + height + '" width="' + width + '" height="' + height + '">' + this['_pointer' + thumbDir[0].toUpperCase() + thumbDir.substr(1)]() + '</svg>'; // No I18N
	        } else {
	            iconClass += ' zslider__circlethumb'; // No I18N
	        }
	        return {
	            iconClass: iconClass,
	            tabIndex: tabIndex,
	            iconHTML: iconHTML
	        }
	    }
	    _getCorrectDir(dir) {
	        if (dir === 'left' || dir === 'top') { // No I18N
	            dir = this.vertical ? 'left' : 'top'; // No I18N
	        } else {
	            dir = this.vertical ? 'right' : 'bottom'; // No I18N
	        }
	        return dir;
	    }
	    _setDimensions() {
	        this._handles = this.container.find('.zslider__thumb').toArray(); // No I18N
	        let innerDim = 'width', // No I18N
	            outerDim = 'outerWidth', // No I18N
	            marginDir = this._getRTLBasedDir('left'), // No I18N
	            oppOuterDim = 'outerHeight', // No I18N
	            oppMargin = 'top'; // No I18N
	        if (this.vertical) {
	            innerDim = 'height'; // No I18N
	            outerDim = 'outerHeight'; // No I18N
	            marginDir = 'bottom'; // No I18N
	            // used only in this func
	            oppOuterDim = 'outerWidth'; // No I18N
	            oppMargin = 'left'; // No I18N
	        }
	        let _ticksLayout = this._ticksLayout;
	        if (_ticksLayout && _ticksLayout.length) {
	            let css = {};
	            css['margin-' + this.marginDir] = css[this.marginDir] = 'auto'; // No I18N
	            _ticksLayout.children().css(css);
	        }
	        this.innerDim = innerDim;
	        this.outerDim = outerDim;
	        this.marginDir = marginDir;
	        // used only in this func
	        this.oppOuterDim = oppOuterDim;
	        this.oppMargin = oppMargin;
	        let handle = $(this._handles[0]),
	            _innerSlider = this._innerSlider;
	        this.sliderDim = {
	            height: _innerSlider.height(),
	            width: _innerSlider.width(),
	            outerHeight: _innerSlider.outerHeight(),
	            outerWidth: _innerSlider.outerWidth()
	        }
	        this.handleDim = {
	            outerHeight: handle.outerHeight(),
	            outerWidth: handle.outerWidth()
	        }
	    }
	    _setHandlePosition() {
	        let innersliderOffset = this._innerSlider.position();
	        let trackTop = parseInt(innersliderOffset[this.oppMargin]);
	        let trackHalfHt = this.sliderDim[this.oppOuterDim] / 2;
	        let handleHalfHt = this.handleDim[this.oppOuterDim] / 2;
	        let shadowTrackHalfHt = this._shadowTrack[this.oppOuterDim]() / 2;
	        $(this._handles)
	            .css(this.oppMargin, trackTop - (handleHalfHt - trackHalfHt) + 'px') // No I18N
	            .css('margin-' + this.marginDir, -this.handleDim[this.outerDim] / 2 + 'px'); // No I18N
	        this._shadowTrack.css(this.oppMargin, trackTop - (shadowTrackHalfHt - trackHalfHt) + 'px'); // No I18N
	        this._tip && this._updateTip();
	    }
	    _setCurrentValues() {
	        this._setValueByFindingInner(this._opts.value);
	        this._updateLayout();
	    }
	    _setSelectedLimit() {
	        let o = this._opts,
	            notAllowedRanges = [];
	        this._data.selectedTrack = false;
	        if (o.minValueAllowed !== o.min) {
	            this._data.selectedTrack = true;
	        }
	        if (o.maxValueAllowed !== o.max) {
	            notAllowedRanges.push('1');
	        }
	        this._data.notAllowedRanges = notAllowedRanges;
	    }
	    _handleSelectedLimit() {
	        let o = this._opts;
	        this.container.find('.zslider__labels .is-disabled, .zslider__scale .is-disabled').removeClass('is-disabled'); // No I18N
	        if (this._data.selectedTrack) {
	            this._setLimitPosition(o.min, o.minValueAllowed, 'zslider__selected'); // No I18N
	        }
	        if (o.maxValueAllowed !== o.max) {
	            this._setLimitPosition(o.maxValueAllowed, o.max, 'zslider__notallowedrange'); // No I18N
	        }
	    }
	    _setLimitPosition(min, max, className) {
	        let _opts = this._opts;
	        let minPercent = parseFloat(min) === _opts.min ? 0 : this._getPercent(min);
	        let maxPercent = parseFloat(max) === _opts.max ? 100 : this._getPercent(max);
	        let track = $('.zslider__track .' + className, this.container), // No I18N
	            style = track.attr('style') + ';'; // No I18N
	        track.attr('style', style + this.marginDir + ':' + minPercent + '%;' + this.innerDim + ':' + (maxPercent - minPercent) + '%'); // No I18N
	        // Fading ticks & labels
	        let nodes = this.container.find('.zslider__tick, .zslider__label'); // No I18N
	        for (let i = 0; i < nodes.length; i++) {
	            let node = nodes[i];
	            let val = +node.getAttribute('data-val'); // No I18N
	            if (val < min || val > max || (val === min && min !== _opts.min) || (val === max && max !== _opts.max)) {
	                continue;
	            }
	            $(node).addClass('is-disabled'); // No I18N
	        }
	    }
	    _bindEvents() {
	        let _namespace = '.' + this.name, // No I18N
	            thumbClass = '.zslider__thumb'; // No I18N
	        this.container
	            .on('mousedown' + _namespace + ' touchstart' + _namespace, '.zslider__shadowtrack,.zslider__track,' + thumbClass + ',.zslider__tick,.zslider__label', this._onMouseDown.bind(this)) // No I18N
	            .on('keydown' + _namespace, thumbClass, this._onSlide.bind(this)) // No I18N
	            .on('keyup' + _namespace, thumbClass, this._onSlideEnd.bind(this)) // No I18N
	            .on('mouseup' + _namespace, this._onSlideEnd.bind(this)) // No I18N
	            .on('mouseenter' + _namespace, thumbClass, this._onThumbEnter.bind(this)) // No I18N
	            .on('mouseleave' + _namespace, thumbClass, this._onThumbLeave.bind(this)) // No I18N
	            .on('focusin' + _namespace, this._onFocus.bind(this))
	            .on('focusout' + _namespace, this._onFocusout.bind(this));
	        this._setCurrentValues();
	        this._frominit = false;
	        this._trigger('init'); // No I18N
	    }
	    _onFocus(origEvent) {
	        this.container.addClass('has-focus' + (this._mouseActive ? '' : ' on-tabfocus')); // No I18N
	        this._trigger('focus', origEvent); // No I18N
	    }
	    _onFocusout(origEvent) {
	        clearTimeout(this.blurtimer);
	        this.blurtimer = setTimeout(() => {
	            if (!$(this._handles).is(':focus') && !$(document.activeElement).closest('.zslider').length) { // No I18N
	                this.container.removeClass('is-active has-focus on-tabfocus'); // No I18N
	                this._activeHandle && this._activeHandle.removeClass('is-active');
	                this._mouseActive = this._animate = false;
	                this._trigger('blur', origEvent); // No I18N
	            }
	        }, 1);
	    }
	    _onThumbEnter(origEvent) {
	        if (this._opts.disabled) {
	            let target = $(origEvent.target).closest('.zslider__thumb'); // No I18N
	            target.addClass('on-mouseover'); // No I18N
	            this._tip && this._showTip(origEvent);
	        }
	    }
	    _onThumbLeave(origEvent) {
	        if (this._opts.disabled) {
	            let target = $(origEvent.target).closest('.zslider__thumb'); // No I18N
	            target.removeClass('on-mouseover'); // No I18N
	            this._tip && !this._dragStarted && !this._dragSelectionStarted && this._hideTip();
	        }
	    }
	    _keyPress(origEvent) {
	        let keyCode = origEvent.keyCode,
	            keyCodes = ZC.keyCode,
	            _opts = this._opts,
	            value = _opts.value,
	            invert = this._opts.rtl && !this.vertical;
	        if ([ keyCodes.RIGHT, keyCodes.UP, keyCodes.PAGE_UP ].indexOf(keyCode) > -1) {
	            value = this._increase(!invert);
	        } else if ([ keyCodes.LEFT, keyCodes.DOWN, keyCodes.PAGE_DOWN ].indexOf(keyCode) > -1) {
	            value = this._increase(invert);
	        } else if (keyCode === keyCodes.HOME) {
	            value = _opts.minValueAllowed;
	        } else if (keyCode === keyCodes.END) {
	            value = _opts.maxValueAllowed;
	        } else {
	            return;
	        }
	        this._tip && this._showTip(origEvent);
	        origEvent.preventDefault();
	        return value;
	    }
	    _getActiveHandle(origEvent) {
	        return this._handles[0];
	    }
	    _onMouseDown(origEvent) {
	        let activeClass = 'is-active'; // No I18N
	        origEvent.type = 'mousedown'; // No I18N
	        if (!origEvent.button && !this._opts.disabled) {
	            this._mouseActive = true;
	            this.container.removeClass('on-tabfocus').addClass(activeClass); // No I18N
	            let _activeHandle = this._activeHandle;
	            _activeHandle && _activeHandle.removeClass(activeClass);
	            _activeHandle = $(this._getActiveHandle(origEvent));
	            _activeHandle.addClass(activeClass);
	            if (_activeHandle.length) {
	                _activeHandle[0][this._opts.blurOnMouseRelease ? 'blur' : 'focus'](); // No I18N
	            }
	            this._activeHandle = _activeHandle;
	            this.container.addClass(activeClass);
	            if (!$(origEvent.target).closest('.zslider__thumb').length && !this._dragSelectionStarted) { // No I18N
	                this._onSlide(origEvent);
	            }
	            this._bindDocumentEvent(origEvent);
	        }
	    }
	    _bindDocumentEvent(origEvent) {
	        let _namespace = '.' + this.name;
	        ZC.$document.off(_namespace)
	            .on('mousemove' + _namespace + ' touchmove' + _namespace, (origEvent) => {
	                origEvent.type = 'mousemove'; // No I18N
	                this._onSlide(origEvent);
	            })
	            .on('mouseup' + _namespace + ' touchend' + _namespace + ' touchcancel' + _namespace, (origEvent) => {
	                origEvent.type = 'mouseup'; // No I18N
	                this._onSlideEnd(origEvent);
	            });
	        origEvent.preventDefault();
	    }
	    _onSlide(origEvent) {
	        if (!this._opts.disabled) {
	            let value = this._getValueFromEvent(origEvent);
	            (origEvent.type !== 'keydown') && this._tip && this._showTip(origEvent); // No I18N
	            if (this._isNotNull(value)) {
	                this._animate = (origEvent.type !== 'mousemove'); // No I18N
	                if (!this._dragStarted) {
	                    this._storeInitialValue();
	                    this._dragStarted = true;
	                    this._trigger('slidestart', origEvent); // No I18N
	                }
	                this._setValue(value, origEvent);
	                this._trigger('slide', origEvent); // No I18N
	                origEvent.preventDefault();
	            }
	        }
	    }
	    _onSlideEnd(origEvent) {
	        if (!this._opts.disabled) {
	            ZC.$document.off('.' + this.name);
	            if (this._dragStarted) {
	                this._trigger('slideend', origEvent); // No I18N
	                if (this._isValueChanged()) {
	                    this._animate = true;
	                    /* ONCHANGE */
	                    this._updateLayout(origEvent);
	                }
	            }
	            this._tip && (!this._activeHandle || !this._activeHandle.hasClass('on-mouseover')) && this._hideTip(); // No I18N
	            this.container.removeClass('is-active'); // No I18N
	            this._animate = this._mouseActive = this._dragStarted = false;
	        }
	    }
	    _storeInitialValue() {
	        this._startValue = this.getValue();
	    }
	    _isValueChanged() {
	        return this._startValue !== this.getValue();
	    }
	    _getTipText() {
	        let o = this._opts;
	        return this._getLabel(o.tooltip.text, o.value, o.tooltip.isHTMLEncoded);
	    }
	    _getLabel(template, label, encode) {
	        if (this._isRange && this._formatLabel) {
	            label = this._formatLabel(label);
	        }
	        if (typeof template === 'string' && template.trim() !== '') { // No I18N
	            label = template.replace(/#value#/gi, label); // No I18N
	        }
	        return encode ? label : ZC.encodeHTML(label);
	    }
	    _getValueFromEvent(origEvent) {
	        let target = $(origEvent.target);
	        if (origEvent.type === 'mousedown' && (/* target.hasClass("zslider__tick") || */ target.hasClass('zslider__label'))) { // No I18N
	            if (target.hasClass('is-disabled')) {
	                return;
	            }
	            return this._getInnerVal(target.attr('data-val')); // No I18N
	        } else if (origEvent.type === 'keydown') { // No I18N
	            return this._keyPress(origEvent);
	        }
	        let sliderLength = this.sliderDim[this.innerDim];
	        let handleLength = this.handleDim[this.outerDim];
	        let totalpixel = sliderLength - handleLength;
	        let offset;
	        let cursorPercent;
	        let slideroffset = this._innerSlider.offset();
	        let getCustomVal;
	        let _opts = this._opts;
	        if (typeof _opts.getCustomValue === 'function') { // No I18N
	            getCustomVal = _opts.getCustomValue;
	            handleLength = 0;
	        }
	        let coords = origEvent.touches && origEvent.touches[0] || origEvent;
	        if (this.vertical) {
	            offset = (coords.pageY - (slideroffset.top + handleLength / 2));
	            cursorPercent = 1 - offset / totalpixel;
	        } else {
	            offset = (coords.pageX - (slideroffset.left + handleLength / 2 /* + 1 */ /* border width */));
	            cursorPercent = offset / totalpixel;
	            if (_opts.rtl) {
	                cursorPercent = 1 - cursorPercent;
	            }
	        }
	        if (cursorPercent < 0) {
	            cursorPercent = 0;
	        } else if (cursorPercent > 1) {
	            cursorPercent = 1;
	        }
	        if (getCustomVal) {
	            return getCustomVal(cursorPercent * 100, _opts.min, _opts.max, this._handles.indexOf(this._activeHandle[0]));
	        }
	        let value = this._trimDecimal(_opts.min, _opts.step, (_opts.min + cursorPercent * (_opts.max - _opts.min)));
	        if (_opts.snapToTicks && this._dragStarted && this._ticksLayout) {
	            value = this._trimForSnap(value, offset + handleLength / 2);
	        }
	        return value;
	    }
	    _trimValue(value) {
	        let o = this._opts;
	        let step = o.step;
	        if (!this._skipTrimValue) {
	            let mod = (parseFloat(value) - o.min) % step;
	            if (mod !== 0) {
	                let adjustedVal = parseFloat(value) - mod;
	                if (Math.abs(mod) * 2 > step) {
	                    adjustedVal = adjustedVal + (mod > 0 ? step : -step);
	                }
	                value = adjustedVal;
	            }
	        }
	        return this._trimDecimal(o.min, step, value);
	    }
	    // Function to round off the value incase of decimal value as in some case, addition of decimal numbers leads to unexpected result : Ex: 13.3 + 13.3 + 13.3 gives 39.9000000000006.
	    _trimDecimal(min, step, value) {
	        let minDecimal = String(min).split('.')[1] || ''; // No I18N
	        let stepDecimal = String(step).split('.')[1] || ''; // No I18N
	        return +(+value).toFixed(Math.max(minDecimal.length, stepDecimal.length));
	    }
	    _setValue(value, origEvent) {
	        // if( value !== undefined ){
	        let _opts = this._opts;
	        _opts.value = this._getActualVal(this._getCorrectedValue(value, _opts.minValueAllowed, _opts.maxValueAllowed));
	        if (this._prevValue !== _opts.value) {
	            /* ONCHANGE */
	            this._updateLayout(origEvent);
	        }
	        this._prevValue = _opts.value;
	        // this.element[0]._addedByComponent = true;
	        // this.isCE && this.element.attr("value", this._opts.value); //No I18N
	        // }
	    }
	    _getCorrectedValue(value, min, max) {
	        value = +value;
	        let o = this._opts;
	        if (o.valuesType === 'fixed') { // No I18N
	            min = o.min;
	            max = o.max;
	        } else {
	            if (min < o.min) {
	                min = o.min;
	            }
	            if (max > o.max) {
	                max = o.max;
	            }
	        }
	        /* Force edges implementation */
	        if (o.stepBehavior === 'default' && (value <= min || value >= max || isNaN(value))) { // No I18N
	            if (value < min || isNaN(value)) {
	                value = min;
	            } else if (value > max) {
	                value = max;
	            }
	        } else {
	            value = this._trimValue(value);
	            if (value < min || isNaN(value)) {
	                //* **** BEHAVIOR This implementation is temporarily commented as ionRangeSlider does"nt take it to account when edge is reached
	                let mod = (min - o.min) % o.step || o.step;
	                value = min + o.step - mod;
	            } else if (value > max) {
	                value = max - (max - o.min) % o.step;
	            }
	            value = this._trimDecimal(o.min, o.step, value);
	        }
	        return value;
	    }
	    _getInnerVal(value) {
	        return this._isFixed ? this._values.indexOf(String(value)) : value;
	    }
	    _getActualVal(value) { // Value is given as number
	        return this._isFixed ? this._values[value] : value;
	    }
	    _updateLayout(origEvent) {
	        let handleObj = {};
	        let o = this._opts;
	        let valPer = this._getPercent(o.value);
	        handleObj[this.marginDir] = valPer + '%'; // No I18N
	        let rangeObj = {};
	        let left = 0;
	        let width = valPer;
	        let selectionStartValue = o.selectionStartValue;
	        let progressFrom = parseFloat(selectionStartValue);
	        if (!isNaN(progressFrom) && progressFrom > o.min && progressFrom <= o.max) {
	            left = progressFrom === o.max ? 100 : this._getPercent(selectionStartValue);
	            if (selectionStartValue >= o.value) {
	                /* swapping */
	                width = [ left, left = width ][0];
	            }
	        }
	        rangeObj[this.marginDir] = left + '%'; // No I18N
	        rangeObj[this.innerDim] = (width - left) + '%'; // No I18N
	        let value = this._getInnerVal(o.value);
	        this._handleAnimation($(this._handles[0]), handleObj, value, o.value);
	        this._handleAnimation(this._range, rangeObj, false, false, () => {
	            this._animate = false;
	            // Change Should be called
	            if (!this._frominit && (!origEvent || !/(keydown|mousedown|mousemove)/.test(origEvent.type))) {
	                this._trigger('change', origEvent); // No I18N
	            }
	        });
	        this._tip && this._updateTip(handleObj);
	    }
	    _handleAnimation(element, object, value, title, callback) {
	        if (value !== false) {
	            element.attr({
	                'data-val': value, // No I18N
	                'aria-valuenow': value, // No I18N
	                'aria-valuetext': title // No I18N
	            });
	        }
	        this.container[this._animate ? 'addClass' : 'removeClass']('zslider--transition'); // No I18N
	        element.css(object);
	        callback && callback();
	    }
	    _getPercent(value) {
	        let opts = this._opts,
	            getCustomPosition = opts.getCustomPosition;
	        value = this._getInnerVal(value);
	        if (getCustomPosition) {
	            return getCustomPosition(value, opts.min, opts.max);
	        }
	        let percent = ((parseFloat(value) - opts.min) / (opts.max - opts.min));
	        let sliderLength = this.sliderDim[this.innerDim];
	        let handleLength = this.handleDim[this.outerDim];
	        // Handle should not exceed the track.Consider slider is 100px length and min=0, max=100, handlewidth =10. If value =100, it is 100% but the handle exceeds the track. Handle left must be 90% for 100% value.
	        // For value = 0 ===> 0 * x = 0%
	        // For value = 100 ===>  100 * x = 90% => x = 90/100 = 9/10
	        percent = (percent * (1 - handleLength / sliderLength) + (handleLength * 0.5) / sliderLength) * 100;
	        return percent;
	    }
	    _increase(increase = true, value, step) {
	        let options = this._opts;
	        step = step || options.step;
	        value = this._getInnerVal(value || options.value);
	        let newValue = (step - (value - options.min) % step);
	        return increase ? (value + newValue) : (value - newValue);
	    }
	    _trigger(customEvent, origEvent, data) {
	        data = data || {};
	        data.slider = this.getElement();
	        data.value = this.getValue();
	        return this._dispatchEvent(customEvent, origEvent, data, undefined, !!origEvent);
	    }
	    _restoreMeasurements() {
	        this._MEASUREMENTS.forEach((opt) => {
	            this._opts[opt] = this.actualProps[opt];
	        });
	    }
	    _parseArray(value) {
	        if (typeof value === 'string') { // No I18N
	            try {
	                value = JSON.parse(value);
	            } catch (e) {
	            }
	        }
	        return value;
	    }
	    increase(origEvent) {
	        this._setValue(this._increase(), origEvent);
	    }
	    decrease(origEvent) {
	        this._setValue(this._increase(false), origEvent);
	    }
	    _setValueByFindingInner(value, origEvent) {
	        if (this._isNotNull(value)) {
	            this._setValue(this._getInnerVal(value), origEvent);
	        }
	    }
	    setValue(value, origEvent) {
	        this._skipTrimValue = true;
	        this._setValueByFindingInner(...arguments);
	        this._skipTrimValue = false;
	    }
	    getValue() {
	        return this._opts.value;
	    }
	    _validateProperty() {
	        let o = this._opts,
	            step = o.step,
	            min = o.min,
	            max = o.max,
	            minValueAllowed = o.minValueAllowed,
	            maxValueAllowed = o.maxValueAllowed,
	            value = o.value;
	        if (o.valuesType === 'fixed') { // No I18N
	            step = 1;
	            min = minValueAllowed = 0;
	            max = maxValueAllowed = o.values.length - 1;
	            if (this._getInnerVal(value) < 0) {
	                value = this._getInnerVal(0);
	            }
	        } else {
	            step = parseFloat(step);
	            min = parseFloat(min);
	            max = parseFloat(max);
	            value = parseFloat(value);
	            minValueAllowed = parseFloat(minValueAllowed);
	            maxValueAllowed = parseFloat(maxValueAllowed);
	            if (isNaN(step) || step <= 0) {
	                step = 1;
	            }
	            min = isNaN(min) ? 0 : min;
	            max = isNaN(max) ? 100 : max;
	            if (max <= min) {
	                max = min + step;
	            }
	            if ((max - min) < step) {
	                step = max - min;
	            }
	            /* Validating min and max allowed value */
	            if (isNaN(minValueAllowed) || minValueAllowed < min || (max - minValueAllowed) < step) {
	                minValueAllowed = min;
	            }
	            if (isNaN(maxValueAllowed) || maxValueAllowed > max || maxValueAllowed < minValueAllowed || (maxValueAllowed - minValueAllowed) < step) {
	                maxValueAllowed = max;
	            }
	            if (isNaN(value) || value < minValueAllowed) {
	                value = minValueAllowed;
	            } else if (value > maxValueAllowed) {
	                value = maxValueAllowed;
	            }
	        }
	        o.step = step;
	        o.min = min;
	        o.max = max;
	        o.minValueAllowed = minValueAllowed;
	        o.maxValueAllowed = maxValueAllowed;
	        o.value = value;
	    }
	    _cacheMeasurements() {
	        this.actualProps = {};
	        this._MEASUREMENTS.forEach((opt) => {
	            this.actualProps[opt] = this._opts[opt];
	        });
	    }
	    _showParent() {
	        if (document.body.contains(this.container[0]) && this.container.is(':hidden')) { // No I18N
	            let i = 1;
	            this._hiddenParents = [];
	            let parent = this.container;
	            while (i && parent && !parent.is('body')) { // No I18N
	                if (parent.css('display') === 'none') { // No I18N
	                    this._hiddenParents.push(parent);
	                    parent.addClass('zslider__parent'); // No I18N
	                    i = parent.is(':hidden'); // No I18N
	                }
	                parent = parent.parent();
	            }
	        }
	    }
	    _hideParent() {
	        if (this._hiddenParents) {
	            this._hiddenParents.forEach((parent) => {
	                parent.removeClass('zslider__parent'); // No I18N
	            });
	            this._hiddenParents = [];
	        }
	    }
	    refresh() {
	        this._reInit = true;
	        this._renderAttrChange();
	    }
		_destroy  () {
		    if (this.isCE) {
		        this.element.empty().removeClass('zslider'); // No I18N
		    } else {
		        this.element.show();
		    }
		    ZC.$document.off('.' + this.name); // No I18N
		}
		_disable  (disable = true, resetTip=true) {
		    this._opts.disabled = disable;
		    // this._showHiddenParent();
		    this._handles.forEach((handle)=>{
		        super._disable(disable, $(handle));
		    });
		    super._disable(disable);
		    let tabIndex = (disable) ? null : (this._opts.tabIndex || 0);
		    if (this._tip && !disable && resetTip) {
		        this._resetTip();
		    }
		    $(this._handles).attr('tabIndex', tabIndex); // No I18N
		}
		_setFixedValues  () {
		    this._values = [];
		    this._labels = [];
		    this._opts.values.forEach((obj) => {
		        let value = obj,
		            label = obj;
		        if (typeof obj === 'object') { // No I18N
		            value = obj.value;
		            label = obj.label || value;
		        }
		        if (value || value === 0) {
		            this._values.push(String(value));
		            this._labels.push(label);
		        }
		    });
		}
		_formatLabel  (label) {
		    if (label || label === 0) {
		        let formatter = this._opts.valueDisplayFormat;
		        let precision = parseInt(formatter.decimalPlaces);
		        let decimalSep = this._getFromLocale('decimalSeparator'); // No I18N
		        label = label.toString();
		        if ((precision >= 0) && (precision <= 20) && !isNaN(precision)) {
		            label = (+label).toFixed(precision);
		        }
		        let splits = label.split('.'); // No I18N
		        if (formatter.thousandSeparator) {
		            let thousandSep = this._getFromLocale('thousandSeparator'); // No I18N
		            splits[0] = splits[0].replace(/(\d{1,3}(?=(?:\d\d\d)+(?!\d)))/g, '$1' + (thousandSep || ',')); // No I18N
		        }
		        label = splits.join(decimalSep || '.'); // No I18N
		        let pattern = label;
		        if (formatter.prefix) {
		            pattern = formatter.prefix + pattern;
		        } else if (formatter.type === 'currency') { // No I18N
		            pattern = '#symbol#' + pattern; // No I18N
		        }
		        pattern += (formatter.suffix || ''); // No I18N
		        if (pattern !== label) {
		            label = pattern.replace(/#value#/gi, label);
		            // Currency implementation
		            if (formatter.type === 'currency') { // No I18N
		                [ 'code', 'symbol', 'name' ].forEach((prop) => { // No I18N
		                    let regex = new RegExp('#' + prop + '#', 'gi'); // No I18N
		                    if (regex.test(pattern)) {
		                        let value = this._getFromLocale(prop, true);
		                        if (value) {
		                            label = label.replace(regex, value);
		                        }
		                    }
		                });
		            }
		        }
		    }
		    return label;
		}
		_pointerBottom  (menu) {
		    return '<path class="pointerthumb__border" d="M16.5,15.2l-6.5,7l-6.5-7V5c0-0.9,0.7-1.6,1.6-1.6H15c0.8,0,1.5,0.7,1.5,1.6V15.2z"></path> <path class="pointerthumb__innerborder" d="M15.5,14.4l-5.5,6l-5.5-6V5.7c0-0.7,0.6-1.3,1.3-1.3h8.3c0.8,0,1.4,0.6,1.4,1.3V14.4z"></path> <path class="pointerthumb" d="M14.5,13.9L10,18.8l-4.5-4.9V6.5c0-0.6,0.5-1.1,1.1-1.1h6.8c0.6,0,1.1,0.5,1.1,1.1V13.9z"></path>';	// No I18N
		}
		_pointerLeft  (menu) {
		    return '<path class="pointerthumb__border" d="M12.8,16.5l-7-6.5l7-6.5l10.2,0c0.9,0,1.6,0.7,1.6,1.6l0,9.9c0,0.8-0.7,1.5-1.6,1.5L12.8,16.5z"></path> <path class="pointerthumb__innerborder" d="M13.6,15.5l-6-5.5l6-5.5l8.7,0c0.7,0,1.3,0.6,1.3,1.3l0,8.3c0,0.8-0.6,1.4-1.3,1.4L13.6,15.5z"></path> <path class="pointerthumb" d="M14.1,14.5L9.2,10l4.9-4.5l7.4,0c0.6,0,1.1,0.5,1.1,1.1l0,6.8c0,0.6-0.5,1.1-1.1,1.1L14.1,14.5z"></path>';	// No I18N
		}
		_pointerRight  (menu) {
		    return '<path class="pointerthumb__border" d="M15.2,3.5l7,6.5l-7,6.5L5,16.5c-0.9,0-1.6-0.7-1.6-1.6V5c0-0.8,0.7-1.5,1.6-1.5L15.2,3.5z"></path> <path class="pointerthumb__innerborder" d="M14.4,4.5l6,5.5l-6,5.5H5.7c-0.7,0-1.3-0.6-1.3-1.3l0-8.3c0-0.8,0.6-1.4,1.3-1.4H14.4z"></path> <path class="pointerthumb" d="M13.9,5.5l4.9,4.5l-4.9,4.5H6.5c-0.6,0-1.1-0.5-1.1-1.1l0-6.8c0-0.6,0.5-1.1,1.1-1.1H13.9z"></path>';	// No I18N
		}
		_pointerTop  (menu) {
		    return '<path class="pointerthumb__border" d="M3.5,12.8l6.5-7l6.5,7V23c0,0.9-0.7,1.6-1.6,1.6H5c-0.8,0-1.5-0.7-1.5-1.6V12.8z"></path> <path class="pointerthumb__innerborder" d="M4.5,13.6l5.5-6l5.5,6v8.7c0,0.7-0.6,1.3-1.3,1.3H5.9c-0.8,0-1.4-0.6-1.4-1.3V13.6z"></path> <path class="pointerthumb" d="M5.5,14.1L10,9.2l4.5,4.9v7.4c0,0.6-0.5,1.1-1.1,1.1H6.6c-0.6,0-1.1-0.5-1.1-1.1V14.1z"></path>';	// No I18N
		}
		_setRangeLabels  () {
		    let o = this._opts;
		    let groups,
		        rangeHtmls = [],
		        rangeLabelHtmls = [];
		    if (Array.isArray(groups = this._parseArray(o.rangeGroups.groups)) && groups.length) { // No I18N
		        groups.forEach((rangeLabel) => {
		            rangeHtmls.push({
		                label: rangeLabel.label,
		                className: (rangeLabel.className || ''),
		                CSSStyle: (rangeLabel.background ? 'background:' + rangeLabel.background : '') // No I18N
		            });
		            rangeLabelHtmls.push({
		                label: rangeLabel.label
		            });
		        });
		        if (this.vertical) {
		            rangeHtmls = rangeHtmls.reverse(); // No I18N
		            rangeLabelHtmls = rangeLabelHtmls.reverse(); // No I18N
		        }
		        let position = this._getCorrectDir(o.rangeGroups.labelPosition),
		            showRangeLabelsInTop = false,
		            rangeLabelsClass = 'zh-inverted'; // No I18N
		        if (/^(top|left)$/.test(position)) {
		            rangeLabelsClass = '';
		            showRangeLabelsInTop = true;
		        }
		        this._data.showRangeLabelsInTop = showRangeLabelsInTop;
		        this._data.rangeLabelsClass = rangeLabelsClass;
		    }
		    this._data.rangeLabels = rangeLabelHtmls;
		    this._data.ranges = rangeHtmls;
		}
		_setRangeLabelsPosition  () {
		    let lastPer = 0,
		        o = this._opts;
		    if (this._data.ranges.length) {
		        let rangeGroupDOMs = this.container.find('.zslider__rangegroup'), // No I18N
		            rangeLabelDOMs = this.container.find('.zslider__rangelabel'); // No I18N
		        let getPercent = (value) => {
		            if (value || value === 0) {
		                if (/%$/.test(value)) {
		                    value = o.min + (o.max - o.min) * parseFloat(value) / 100;
		                }
		                if (isNaN(value) || value < o.min || value > o.max) {
		                    return 0;
		                } else if (+value !== o.max) {
		                    return this._getPercent(+value);
		                }
		            }
		        }
		        o.rangeGroups.groups.forEach((rangeLabel, i) => {
		            let from = parseFloat(rangeLabel.from);
		            let to = parseFloat(rangeLabel.to);
		            let fromPer = 0;
		            if (from !== o.min) {
		                fromPer = getPercent(from);
		            }
		            if (!isNaN(fromPer)) {
		                lastPer = fromPer;
		            }
		            let curPer = 100;
		            if (to !== o.max) {
		                curPer = getPercent(to);
		            }
		            if (isNaN(curPer)) {
		                return;
		            }
		            let replaceRegx = /(margin-left|margin-bottom|bottom|width|height|left)[.%:\w\d\s]+;/gi;
		            let style = rangeGroupDOMs[i].getAttribute('style') || 0;
		            if (style) {
		                style = style.replace(replaceRegx, '');
		            }
		            let newStyle = this.marginDir + ':' + lastPer + '%;' + this.innerDim + ':' + (curPer - lastPer) + '%;'; // No I18N
		            rangeGroupDOMs[i].setAttribute('style', style + ';' + newStyle);
		            let rangeLabelDOM = rangeLabelDOMs[i];
		            style = rangeLabelDOM.getAttribute('style') || 0;
		            if (style) {
		                style = style.replace(replaceRegx, '');
		            }
		            rangeLabelDOM.setAttribute('style', style + ';' + newStyle);
		            if (this.vertical) {
		                let rangeLabelTextDOM = $(rangeLabelDOM).find('.zslider__text'); // No I18N
		                style = rangeLabelTextDOM.attr('style') || ''; // No I18N
		                style.replace(replaceRegx, '');
		                rangeLabelTextDOM.attr('style', style + ';' + 'max-' + this.innerDim + ':' + (this.sliderDim[this.outerDim] * (curPer - lastPer) / 100) + 'px'); // No I18N
		            }
		            lastPer = curPer;
		        });
		    }
		}
		_setAttribute  (optionName, value) {
		    // this._showHiddenParent();
		    let o = this._opts,
		        canRender = false;
		    switch (optionName) {
		        case 'min': // No I18N
		        case 'max': // No I18N
		        case 'minValueAllowed': // No I18N
		        case 'maxValueAllowed': // No I18N
		        case 'step': // No I18N
		            this._restoreMeasurements();
		            o[optionName] = value;
		            this._cacheMeasurements();
		            this._validateProperty();
		            canRender = true;
		            break;
		        case 'selectionStartValue': // No I18N
		            o[optionName] = value;
		            this._updateLayout();
		            break;
		        case 'value': // No I18N
		            this.setValue(value);
		            break;
		        case 'valuesType': // No I18N
		            o[optionName] = value;
		            if (value === 'range') { // No I18N
		                o.ticksStep = this.actualProps.ticksStep;
		            } else {
		                this.actualProps.ticksStep = o.ticksStep;
		            }
		            canRender = true;
		            break;
		        case 'values': // No I18N
		            if (Array.isArray(value)) {
		                o[optionName] = value;
		                canRender = true;
		            }
		            break;
		        case 'showTooltip': // No I18N
		            o[optionName] = value;
		            this._tip = (value !== 'never'); // No I18N
		            this._resetTip();
		            break;
		        case 'tooltip': // No I18N
		            if (this._handleObjUpdate(optionName, value)) {
		                this._resetTip();
		            }
		            break;
		        case 'rangeGroups': // No I18N
		        case 'ticks': // No I18N
		        case 'valueDisplayFormat': // No I18N
		            this._reStoreRef = false;
		            canRender = this._handleObjUpdate(optionName, value);
		            break;
		        case 'animation': // No I18N
		            o[optionName] = value;
		            break;
		        case 'rtl': // No I18N
		        case 'orientation': // No I18N
		        case 'showTicks': // No I18N
		        case 'locale': // No I18N
		        case 'thumbIconStyle': // No I18N
		        case 'thumbSVGIconId': // No I18N
		        case 'thumbIconClassName': // No I18N
		            this._reStoreRef = false;
		            o[optionName] = value;
		            if (optionName === 'width') { // No I18N
		                this.container.width(value);
		            } else if (optionName === 'orientation') { // No I18N
		                o[optionName] = value;
		                // this.vertical = (value === 'vertical'); // No I18N
		                // this.container[this.vertical ? 'addClass' : 'removeClass']('zslider--vertical'); // No I18N
		                $('.ztooltip, .ztooltip__pointer, .zslider__labels .zslider__label, .zslider__selected, .zslider__notallowedrange', this.container).removeAttr('style'); // No I18N
		                this._range.removeAttr('style'); // No I18N
		                $(this._handles).removeAttr('style'); // No I18N
		                $(this._ticks).removeAttr('style'); // No I18N
		                this._shadowTrack.css({
		                    left: 'auto', // No I18N
		                    top: 'auto' // No I18N
		                });
		            }
		            canRender = true;
		            break;
		    }
		    if (canRender) {
		        this._reRender();
		    }
		    // this._resetParent();
		}
		_reRender  () {
		    this._values = this._labels = undefined;
		    this._reInit = true;
		}
		_handleObjUpdate  (optionName, value) {
		    let update;
		    Object.keys(value).forEach((key) => {
		        this._opts[optionName][key] = value[key];
		        update = true;
		    });
		    return update;
		}
		_handleTicks  () {
		    let o = this._opts;
		    this._data.labels = this._data.ticksList = [];
		    this._setTicks();
		    if (o.ticks.showLabels) {
		        this._setLabels();
		        this._ticksLabel = true;
		    }
		    // Here RTL is not considered becos this layout is directly handled in css for rtl case.
		    let position = this._getCorrectDir(o.ticks.position),
		        ticksClass = '', showTicksInTop = /^(left|top)$/.test(position);
		    if (showTicksInTop) {
		        ticksClass = 'zh-inverted'; // No I18N
		    }
		    this._data.showTicksInTop = showTicksInTop;
		    this._data.ticksClass = ticksClass;
		    this._data.labelsClass = ticksClass;
		}
		_setTicks  () {
		    let o = this._opts,
		        value,
		        values = [],
		        splitBy = o.ticks.splitBy,
		        step = o.ticks.step,
		        min = o.min,
		        max = o.max,
		        ticks = [],
		        random;
		    if (o.valuesType === 'fixed') { // No I18N
		        step = 1;
		        splitBy = 'step'; // No I18N
		    }
		    if (splitBy === 'step' && step > 0) { // No I18N
		        step = parseFloat(step);
		        for (let val = min; val <= max; val = val + step) {
		            ticks.push({
		                value: this._getActualVal(this._trimDecimal(min, step, val))
		            });
		        }
		        o.ticks.step = step;
		    } else if (splitBy === 'random' && Array.isArray(random = this._parseArray(o.ticks.randomValues))) { // No I18N
		        random.forEach((val) => {
		            val = parseFloat(val);
		            if (!isNaN(val) && val >= min && val <= max) {
		                if (values.indexOf(val) === -1) {
		                    values.push(val);
		                }
		            }
		        });
		        values = values.sort((a, b) => +a - +b);
		        values.forEach((value) => {
		            ticks.push({
		                value: value
		            });
		        });
		    } else {
		        let count = parseInt(o.ticks.count);
		        o.ticks.count = count;
		        count = (count > 1 ? count : 4);
		        step = (max - min) / (count - 1);
		        ticks.push({
		            value: min
		        });
		        for (let i = 1; i < count - 1; i++) {
		            ticks.push({
		                value: this._trimDecimal(min, step, i * step + min)
		            });
		        }
		        ticks.push({
		            value: max
		        });
		    }
		    this._data.ticksList = ticks;
		}
		_setTicksPosition  () {
		    let _ticksLayout = this.container.find('.zslider__scale'); // No I18N
		    let _ticks = _ticksLayout.children();
		    this._data.ticksList && this._data.ticksList.forEach((val, i) => {
		        $(_ticks[i]).css(this.marginDir, this._getPercent(val.value) + '%'); // No I18N
		    });
		    let gridlength = $(_ticks[0])[this.outerDim]();
		    _ticks.css('margin-' + this.marginDir, -gridlength / 2 + 'px'); // No I18N
		    this._ticksLayout = _ticksLayout;
		}
		_trimForSnap  (value, left) {
		    let ticksList = this._data.ticksList || [],
		        ticksListLength = ticksList.length, tickValue, dis, i;
		    if (ticksListLength) {
		        value = parseFloat(value);
		        /* To find the nearest snap point */
		        let nearestPt = ticksList[0].value,
		            min_dis = Math.abs(nearestPt - value);
		        for (i = 1; i < ticksListLength; i++) {
		            tickValue = ticksList[i].value;
		            dis = Math.abs(tickValue - value);
		            if (dis < min_dis) {
		                nearestPt = tickValue;
		                min_dis = dis;
		            }
		        }
		        /* To check whether the snap point is reachable */
		        if ((nearestPt % this._opts.step === 0) && (nearestPt !== value)) {
		            let nearestGrid = this._ticksLayout.find('[data-val="' + nearestPt + '"]'); // No I18N
		            let gridLeft = nearestGrid.position()[this.vertical ? 'top' : 'left']; // No I18N
		            if (Math.abs(gridLeft - left) < 7) {
		                value = this._getActualVal(nearestPt);
		            }
		        }
		    }
		    return value;
		}
		_setLabelsPosition  () {
		    let _labelledGrids = this._data.labels || '',
		        _ticksList = this._ticksLayout.children();
		    if (_labelledGrids.length && _ticksList.length) {
		        let labelsDOMs = this.container.find('.zslider__labels .zslider__label'), // No I18N
		            ticksDOMLength = labelsDOMs.length;
		        if (this.vertical) {
		            for (let i = 0; i < ticksDOMLength; i++) {
		                labelsDOMs[i].style.bottom = `calc(${_ticksList[i].style.bottom} - ${labelsDOMs[i].offsetHeight / 2}px)`;
		            }
		        } else {
		            labelsDOMs.removeAttr('style'); // No I18N
		            let EXTRADIM = 60;
		            let sliderLength = this.sliderDim[this.innerDim];
		            let prevDim = parseInt($(_ticksList[0]).css(this.marginDir)) + EXTRADIM;
		            for (let i = 0; i < ticksDOMLength; i++) {
		                let curGrid = $(_ticksList[i]);
		                let nextGrid = $(_ticksList[i + 1]);
		                let nextDim = Math.abs((nextGrid.length ? parseInt(nextGrid.css(this.marginDir)) : (sliderLength + EXTRADIM)) - parseInt(curGrid.css(this.marginDir)));
		                let labelDimensions = $(labelsDOMs[i])[this.outerDim]() + 1;
		                let nextLabelDimensions = $(labelsDOMs[i + 1])[this.outerDim]() + 1;
		                if (nextGrid.length) {
		                    // space free by next label can also be occupied.
		                    if (nextLabelDimensions < nextDim) {
		                        nextDim = Math.abs(nextDim + (nextDim - nextLabelDimensions));
		                    }
		                }
		                // Giving minimum dim to the label
		                let labelDim = Math.min(prevDim, nextDim, labelDimensions);
		                if (labelDim) {
		                    prevDim = nextDim + (nextDim - labelDim);
		                    // Finding the value of the grid to position the grid
		                    let percent = this._getPercent(curGrid.attr('data-val')) + '%'; // No I18N
		                    percent = `calc(${percent} - ${(labelDim / 2)}px)`;
		                    labelsDOMs[i].style[this.innerDim] = labelDim + 'px';
		                    labelsDOMs[i].style[this.marginDir] = percent;
		                }
		            }
		        }
		        // Including title for ellipses
		        let labels = this._ticksLayout.find('.zslider__labels');
		        for (let i = 0; i < labels.length; i++) {
		            let label = labels[i];
		            if (label.offsetWidth < label.scrollWidth) {
		                label.setAttribute('title', label.textContent); // No I18N
		            }
		        }
		    }
		}
		_setLabels  () {
		    let o = this._opts;
		    let grids = this._data.ticksList;
		    if (grids && grids.length) {
		        // let sliderLength = this.sliderDim[this.innerDim];
		        let labels = o.valuesType === 'fixed' ? this._labels : this._parseArray(o.ticks.customLabels); // No I18N
		        let finalLabels = [];
		        let showFor = this._parseArray(o.ticks.showLabelsFor);
		        let showAllLabels = (!Array.isArray(showFor) || !showFor.length);
		        let labelCount = 0,
		            gridsLength = grids.length;
		        if (Array.isArray(labels) && labels.length) {
		            let labelsLength = labels.length;
		            for (let i = 0; (i < gridsLength) && (labelCount !== labelsLength); i++) {
		                let value = grids[i].value;
		                if (showAllLabels || showFor.indexOf(value) > -1) {
		                    let label = labels[labelCount++];
		                    finalLabels.push({
		                        value: value,
		                        label: o.ticks.isLabelHTMLEncoded ? label : ZC.encodeHTML(label)
		                    });
		                }
		            }
		        } else {
		            grids.forEach((grid, i) => {
		                let value = grid.value;
		                if (showAllLabels || showFor.indexOf(value) > -1) {
		                    finalLabels.push({
		                        value: value,
		                        label: this._getLabel(o.ticks.labelPattern, this._translateEToA(value), o.ticks.isLabelHTMLEncoded)
		                    });
		                }
		            });
		        }
		        this._data.labels = finalLabels;
		    }
		}
		_getTipPosition  (handleObj) {
		    let pos = {};
		    let position = this._tipDir;
		    let operator = /^(top|left)$/.test(position) ? -1 : 1;
		    let length = 'outerHeight'; // No I18N
		    let adjLength = 'outerWidth'; // No I18N
		    let mainDir = 'top'; // No I18N
		    if (this._opts.orientation === 'vertical') { // No I18N
		        length = 'outerWidth'; // No I18N
		        adjLength = 'outerHeight'; // No I18N
		        mainDir = 'left'; // No I18N
		    }
		    let sliderLn = this.sliderDim[length];
		    let pointer = this._tooltip.find('.ztooltip__pointer'); // No I18N
		    let pointerLn = pointer.length ? pointer[length]() : 0;
		    let handleLn = this.handleDim[length];
		    let totalLn = (sliderLn > handleLn ? 0 : (handleLn - sliderLn) / 2) + pointerLn + 0;
		    totalLn += (position === mainDir) ? this._tooltip[length]() : sliderLn;
		    pos[mainDir] = this._innerSlider.position()[mainDir] + totalLn * operator + 'px'; // No I18N
		    if (position !== 'at-cursor') { // No I18N
		        pos['margin-' + this.marginDir] = -((this._tooltip[adjLength]()) / 2) + 'px'; // No I18N
		        pos[this.marginDir] = handleObj ? handleObj[this.marginDir] : this._handles[0].style[this.marginDir];
		    }
		    return pos;
		}
		_setTooltip  () {
		    let o = this._opts;
		    if (o.valuesType !== 'fixed' && o.showTooltip !== 'never') { // No I18N
		        let position = o.tooltip.position,
		            callout = (position !== 'at-cursor'); // No I18N
		        let pointerClass = {
		            left: 'zh-right', // No I18N
		            right: 'zh-left', // No I18N
		            top: 'zh-bottom', // No I18N
		            bottom: 'zh-top', // No I18N
		            'at-cursor': 'zh-top' // No I18N
		        };
		        let tooltipClass = {
		            left: 'ztooltip--left', // No I18N
		            right: 'ztooltip--right', // No I18N
		            top: 'ztooltip--top', // No I18N
		            bottom: 'ztooltip--bottom', // No I18N
		            'at-cursor': 'ztooltip--bottom' // No I18N
		        };
		        if (position === 'at-cursor' && o.showTooltip === 'onslide') { // No I18N
		            o.tooltip.displayType = 'box'; // No I18N
		            callout = false;
		        } else {
		            position = this._getRTLBasedDir(this._getCorrectDir(position));
		        }
		        this._data.tooltip = {
		            callout: callout,
		            'class': tooltipClass[position] || '', // No I18N
		            pointerClass: pointerClass[position] || '' // No I18N
		        }
		        this._tipDir = position;
		    } else {
		        this._data.tooltip = this._tooltip = undefined;
		    }
		}
		_handleTip  () {
		    if (this._tip) {
		        this._tooltip = this.container.find('.ztooltip'); // No I18N
		        if (this._opts.tooltip.displayType === 'callout') { // No I18N
		            let pointer = this._tooltip.find('.ztooltip__pointer'); // No I18N
		            let pointerStyles = {};
		            pointerStyles[this.marginDir] = 'calc(50% - ' + (pointer[this.outerDim]() / 2) + 'px';
		            if (this.vertical) {
		                pointerStyles.top = 'auto'; // No I18N
		            }
		            pointer.css(pointerStyles);
		        }
		        this._opts.showTooltip === 'always' ? this._updateTip() : this._hideTip(); // No I18N
		    }
		}
		_showTip  (origEvent) {
		    if (this._tip) {
		        this._tooltip[0].style.display = ''; // No I18N
		        // Left positioning is done based on pageX value when tooltip position is  'at-cursor'
		        if (this._tipDir === 'at-cursor' && origEvent) { // No I18N
		            this._setTipAtCursor(origEvent);
		        }
		    }
		}
		_hideTip  () {
		    this._tip && this._opts.showTooltip !== 'always' && this._tooltip.hide(); // No I18N
		}
		_updateTip  (handleObj) {
		    if (!this._opts.disabled && this._tip) {
		        this._tooltip.find('.ztooltip__content').text(this._getTipText()); // No I18N
		        // Setting the position for the tooltip when the value changes only for position top|bottom|left|right. For at-cursor, only top is set as the tooltip left is positioned on "mouseenter" and "mousemove" based on pageX.
		        this._handleAnimation(this._tooltip, this._getTipPosition(handleObj));
		    }
		}
		_resetTip  () {
		    this._setTooltip();
		    this._reStoreRef = false;
		    this._render();
		    if (this._tooltip) {
		        this._tooltip.removeAttr('style'); // No I18N
		    }
		    this._reStoreRef = true;
		    if (this._tip) {
		        this._handleTip();
		        this._updateTip();
		    }
		}
		_setTipAtCursor  (origEvent) {
		    let left = 'left', // No I18N
		        pageX = 'pageX', // No I18N
		        outerWidth = 'outerWidth'; // No I18N
		    if (this.vertical) {
		        left = 'top'; // No I18N
		        pageX = 'pageY'; // No I18N
		        outerWidth = 'outerHeight'; // No I18N
		    }
		    this._tooltip[0].style[left] = Math.max(Math.min(origEvent[pageX] - this.container.offset()[left], this.sliderDim[outerWidth]), 0) + 'px'; // No I18N
		}
	}
	ZC.registerComponent('ZSlider', ZSlider); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zslider.Templates; 
template.WCContainer = (data) => ZT.html `<z-slider class="zslider" >${data.children && template.WCChildren(data)}</z-slider>`; 
template.WCChildren = (data) => { 
let responseTemplate = ZT.html ` <div class="zslider__shadowtrack" style="${data.shadowCSSStyle}"></div> ${data.showRangeLabelsInTop && template.WCRangeLabels(data)} ${data.showTicksInTop && template.WCTicks(data)} <div class="zslider__track"> ${data.ranges && data.ranges.map((range) => ZT.html `<div class="zslider__rangegroup ${range.className}" style="${ range.CSSStyle }">${range.text}</div>`)} <div class="zslider__selection" style="${data.selectionPosition}"></div> ${data.selectedTrack && ZT.html `<div class="zslider__selected"></div>`} ${data.notAllowedRanges.map((data) => ZT.html `<div class="zslider__notallowedrange zslider__notallowedrange${data}"></div>`)} </div> ${!data.showTicksInTop && template.WCTicks(data)} ${!data.showRangeLabelsInTop && template.WCRangeLabels(data)} ${data.thumbs.map((thumb) => ZT.html `<div role="slider" class="zslider__thumb ${ thumb.iconClass }" ?aria-disabled="${data.disabled}" aria-orientation="${ data.orientation }" aria-valuemin="${data.min}" aria-valuemax="${data.min}" tabindex="${ thumb.tabIndex }" data-val="${data.min}" aria-valuenow="${data.min}" aria-valuetext="${ data.min }">${ZT.customHTML(thumb.iconHTML)}</div>`)} ${data.tooltip && template.WCTooltip(data.tooltip)} `; return responseTemplate; } 
template.WCRangeLabels = (data) => { 
let returnTemplate = data.rangeLabels && ZT.html `<div class="zslider__rangelabels ${ data.rangeLabelsClass }"> ${data.rangeLabels.map((label) => ZT.html `<div class="zslider__rangelabel"> <span class="zslider__textcontainer"><span class="zslider__text">${label.label}</span></span> </div>`)} </div>`; return returnTemplate; } 
template.WCTicks = (data) => data.ticksList.length && ZT.html `${!data.showTicksInTop && ZT.html `<div class="zslider__scale ${data.ticksClass}"> ${data.ticksList.map((tick) => ZT.html `<div class="zslider__tick" data-val="${tick.value}"></div>`)} </div>`} ${data.labels && ZT.html `<div class="zslider__labels ${data.labelsClass}"> ${data.labels.map((label) => ZT.html `<div class="zslider__label" data-val="${label.value}">${label.label}</div>`)} </div>`} ${data.showTicksInTop && ZT.html `<div class="zslider__scale ${data.ticksClass}"> ${data.ticksList.map((tick) => ZT.html `<div class="zslider__tick" data-val="${tick.value}"></div>`)} </div>`} `; 
template.WCTooltip = (data) => ZT.html `<div class='ztooltip ${data.class}'> <div class='ztooltip__content'></div> ${data.callout && ZT.html `<div class="ztooltip__pointer ${data.pointerClass}"></div>`} </div>`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zslider.Templates; 
template.container = (data) => ZT.html `<div class="zslider" >${data.children && template.children(data)}</div>`; 
template.children = (data) => { 
let responseTemplate = ZT.html ` <div class="zslider__shadowtrack" style="${data.shadowCSSStyle}"></div> ${data.showRangeLabelsInTop && template.rangeLabels(data)} ${data.showTicksInTop && template.ticks(data)} <div class="zslider__track"> ${data.ranges && data.ranges.map((range) => ZT.html `<div class="zslider__rangegroup ${range.className}" style="${ range.CSSStyle }">${range.text}</div>`)} <div class="zslider__selection" style="${data.selectionPosition}"></div> ${data.selectedTrack && ZT.html `<div class="zslider__selected"></div>`} ${data.notAllowedRanges.map((data) => ZT.html `<div class="zslider__notallowedrange zslider__notallowedrange${data}"></div>`)} </div> ${!data.showTicksInTop && template.ticks(data)} ${!data.showRangeLabelsInTop && template.rangeLabels(data)} ${data.thumbs.map((thumb) => ZT.html `<div role="slider" class="zslider__thumb ${ thumb.iconClass }" ?aria-disabled="${data.disabled}" aria-orientation="${ data.orientation }" aria-valuemin="${data.min}" aria-valuemax="${data.min}" tabindex="${ thumb.tabIndex }" data-val="${data.min}" aria-valuenow="${data.min}" aria-valuetext="${ data.min }">${ZT.customHTML(thumb.iconHTML)}</div>`)} ${data.tooltip && template.tooltip(data.tooltip)} `; return responseTemplate; } 
template.rangeLabels = (data) => { 
let returnTemplate = data.rangeLabels && ZT.html `<div class="zslider__rangelabels ${ data.rangeLabelsClass }"> ${data.rangeLabels.map((label) => ZT.html `<div class="zslider__rangelabel"> <span class="zslider__textcontainer"><span class="zslider__text">${label.label}</span></span> </div>`)} </div>`; return returnTemplate; } 
template.ticks = (data) => data.ticksList.length && ZT.html `${!data.showTicksInTop && ZT.html `<div class="zslider__scale ${data.ticksClass}"> ${data.ticksList.map((tick) => ZT.html `<div class="zslider__tick" data-val="${tick.value}"></div>`)} </div>`} ${data.labels && ZT.html `<div class="zslider__labels ${data.labelsClass}"> ${data.labels.map((label) => ZT.html `<div class="zslider__label" data-val="${label.value}">${label.label}</div>`)} </div>`} ${data.showTicksInTop && ZT.html `<div class="zslider__scale ${data.ticksClass}"> ${data.ticksList.map((tick) => ZT.html `<div class="zslider__tick" data-val="${tick.value}"></div>`)} </div>`} `; 
template.tooltip = (data) => ZT.html `<div class='ztooltip ${data.class}'> <div class='ztooltip__content'></div> ${data.callout && ZT.html `<div class="ztooltip__pointer ${data.pointerClass}"></div>`} </div>`; }(ZComponents)); 
(function(ZC, $){
		class ZSpinnerslider extends ZC.CoreComponent {
			get name(){
				return "zspinnerslider";
			}
		    get attrs() {
		        return {
		            min: 0,
		            max: 100,
		            step: 1,
		            disabled: false,
		            value: null,
		            className: '', // No I18N
		            zclassName: 'zspinnerslider' // No I18N
		        }
		    }
		    get props() {
		        return {
		            numberfield: { // ##revisit: name can be numberFieldOptions and sliderOptions since in data select components, we have picker options in that kind of names.(ie datePickerOptions )
		                spinButtons: true, // No I18N
		                clearButton: 'none', // No I18N
		                spinValues: true, // ##revisit: By default the prop value is true in number field, so you can omit here. Only have options that you need to override
		                width: 100
		            },
		            slider: {} // ##revisit: sliderOptions
		        }
		    }
		    get tagName() { // ## revisit: tagName definitions not needed since we have defined in tagNames.json. So, remove the getter itself.
		        return 'z-spinnerslider' // No I18N
		    }
		    get EVENTS() {
		        return [ 'change', 'start', 'stop', 'spin' ]; // No I18N
		    }
		    _onSliderChange(customEvent, orgEvent) {
		        let data = orgEvent.detail;
		        let value = this._opts.value = data.value;
		        if(data.fromUI){
		            this._setFieldValue(value);
		            this._trigger(customEvent, orgEvent.originalEvent, {
		                value
		            });
		        }
		    }
		    _onInputChange(customEvent, orgEvent) {
		        let data = orgEvent.detail;
		        let value = this._opts.value = data.value;
		        this._setSliderValue(value);
		        this._trigger(customEvent, orgEvent.originalEvent, {
		            value
		        });
		    }
		    _trigger(customEvent, orgEvent, data){
		        return this._dispatchEvent(customEvent, orgEvent, data, undefined, !!orgEvent);        
		    }
		    _init() {
		        this._validate();
		    }
		    _validate() { // ##revisit: this method is invoked only on init. So, better have the entire code inside init method itself and remove the extra function.
		        let opts = this._opts,
		            data = this._data,
		            numberfield = opts.numberfield;
		        [ 'min', 'max', 'step', 'value' ].forEach((attr) => { // No I18N
		            let attrValue = this.element.attr(attr)
		            if (attrValue !== undefined && attrValue !== '') { // No I18N
		                opts[attr] = this.element[0][attr];
		            }
		        });
		        opts.disabled = opts.disabled || this.element[0].disabled;
		        opts.value = isNaN(opts.value) ? opts.min : opts.value;
		        let commonSettings = {
		            min: opts.min,
		            max: opts.max,
		            step: opts.step,
		            value: opts.value,
		            templateRender: true,
		            isCE: this.isCE,
		            disabled: opts.disabled
		        }
		        // SLIDER CREATION
		        // ## revisit: Check whether events are triggered properly for web component elements. I think event binding syntaxes has to be changed.
		        data.slider = $.extend(true, {}, commonSettings, {
		            slidestart: (orgEvent, data) => {
		                this._onSliderChange('start', orgEvent, data); // No I18N
		            },
		            slide: (orgEvent, data) => {
		                this._onSliderChange('spin', orgEvent, data); // No I18N
		            },
		            slideend: (orgEvent, data) => {
		                this._onSliderChange('stop', orgEvent, data); // No I18N
		            },
		            change: (orgEvent, data) => {
		                this._onSliderChange('change', orgEvent, data); // No I18N
		            },
		            id: this._getID()
		        }, opts.slider);
		        // NUMBERFIELD CREATION
		        data.numberfield = $.extend(true, {}, commonSettings, {
		            spinstart: (orgEvent, data) => {
		                this._onInputChange('start', orgEvent, data); // No I18N
		            },
		            spin: (orgEvent, data) => {
		                this._onInputChange('spin', orgEvent, data); // No I18N
		            },
		            spinend: (orgEvent, data) => {
		                this._onInputChange('stop', orgEvent, data); // No I18N
		            },
		            blur: (orgEvent, data) => {
		                this._onInputChange('change', orgEvent, data); // No I18N
		            },
		            id: this._getID(),
		            customAttributes: {
		                style: 'width:' + numberfield.width + 'px' // No I18N
		            }
		        }, numberfield);
		    }
		    _postEachRender() {
		        let container = this.container;
		        let numberfieldEle = container.find(`#${this._data.numberfield.id}`); // No I18N
		        let sliderEle = container.find(`#${this._data.slider.id}`); // No I18N
		        this._fieldInstance = ZC.numberfield(numberfieldEle);
		        this._sliderInstance = ZC.slider(sliderEle);
		        this._sliderInstance.refresh();
		    }
		    _setAttribute(optionName, value) {
		        if (optionName === 'value') { // No I18N
		            this.setValue(value);
		        } else if (optionName === 'disabled') { // No I18N
		            this._sliderInstance.setAttribute('disabled', value); //No I18N
		            this._fieldInstance.setAttribute('disabled', value);//No I18N
		        } else if (optionName === 'numberfield') { // No I18N
		            this._fieldInstance.setAttributes(value);
		        } else if (optionName === 'slider') { // No I18N
		            this._sliderInstance.setAttributes(value);
		        }
		        this._opts[optionName] = value;
		    }
		    setValue(value) {
		        if (!isNaN(value)) {
		            this._setFieldValue(value);
		            this._setSliderValue(value);
		            this._trigger('change', null, { //No I18N
		                value
		            });
		        }
		    }
		    _setFieldValue(value){
		        this._fieldInstance.setValue(value);
		    }
		    _setSliderValue(value){
		        this._sliderInstance.setValue(value);
		    }
		    getValue() { 
		        return this._opts.value;
		    }
		    _destroy() { 
		        this._sliderInstance.destroy();
		        this._fieldInstance.destroy();
		    }
		}
	ZC.registerComponent('ZSpinnerslider', ZSpinnerslider); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zspinnerslider.Templates; 
template.WCContainer = (data) => ZT.html `<z-spinnerslider ?aria-label="${data.text}" ?id="${data.id}" ?role="${data.role}" class="${data.className}">${data.children && template.WCChildren(data)}</z-spinnerslider>`; 
template.WCChildren = (data) => ZT.html `${data.slider && ZC.createSlider(data.slider)} ${data.numberfield && ZC.createNumberField(data.numberfield)}`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zspinnerslider.Templates; 
template.container = (data) => ZT.html `<div ?aria-label="${data.text}" ?id="${data.id}" ?role="${data.role}" class="${data.className}">${data.children && template.children(data)}</div>`; 
template.children = (data) => ZT.html `${data.slider && ZC.createSlider(data.slider)} ${data.numberfield && ZC.createNumberField(data.numberfield)}`; }(ZComponents)); 
(function(ZC, $){
		ZC.scrollBindings = [];
		ZC.nullLowestDeltaTimeout = undefined;
		ZC.lowestDelta = undefined;
		ZC.detectPassiveEventSupport = function() {
		    let passive = false,
		        options;
		    try {
		        options = Object.defineProperty({}, 'passive', { // No I18N
		            get: function() {
		                passive = true;
		            }
		        });
		        window.addEventListener('passiveListenerSupportTest', $.noop(), options); // No I18N
		        window.removeEventListener('passiveListenerSupportTest', $.noop(), options); // No I18N
		        this.passiveListenerSupport = passive;
		    } catch (err) {
		        this.passiveListenerSupport = false;
		    }
		}
		ZC.specialMouseWheelHandler = function() {
		    this.detectPassiveEventSupport();
		    let toFix = [ 'wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll' ],	// No I18N
		        toBind = ('onwheel' in document || document.documentMode >= 9) ?	// No I18N
		            [ 'wheel' ] : [ 'mousewheel', 'DomMouseScroll', 'MozMousePixelScroll' ];	// No I18N
		    if ($.event.fixHooks) {
		        for (let i = toFix.length; i >= 0; i--) {
		            $.event.fixHooks[toFix[i]] = $.event.mouseHooks
		        }
		    }
		    ZC.mouseSpecial = $.event.special.mousewheel = {
		        setup: function() {
		            if (this.addEventListener) {
		                for (let i = toBind.length; i >= 0; i--) {
		                    this.addEventListener(toBind[i], ZC.mouseWheelHandler, ZC.passiveListenerSupport && ZC.Browser.isMobile ? {
		                        passive: true
		                    } : false);
		                }
		            } else {
		                this.onmousewheel = ZC.mouseWheelHandler;
		            }
		            $.data(this, 'mousewheel-line-height', ZC.mouseSpecial.getLineHeight(this));	// No I18N
		            $.data(this, 'mousewheel-elem-height', ZC.mouseSpecial.getElementHeight(this));	// No I18N
		        },
		        getElementHeight: function(element) {
		            return $(element).height();
		        },
		        getLineHeight: function(element) {
		            var element = $(element),
		                parent = element['offsetParent' in $.fn ? 'offsetParent' : 'parent']();	// No I18N
		            if (!parent.length) {
		                parent = $('body');
		            }
		            return parseInt(parent.css('fontSize'), 10) || parseInt(element.css('fontSize'), 10) || 16;	// No I18N
		        },
		        teardown: function() {
		            if (this.removeEventListener) {
		                for (let i = toBind.length; i >= 0; i--) {
		                    this.removeEventListener(toBind[i], ZC.mouseWheelHandler, false);
		                }
		            } else {
		                this.onmousewheel = null;
		            }
		            $.removeData(this, 'mousewheel-line-height');	// No I18N
		            $.removeData(this, 'mousewheel-elem-height');	// No I18N
		        },
		        settings: {
		            adjustOldDeltas: true,
		            normalizeOffset: true
		        }
		    }
		}
		ZC.shouldAdjustOldDeltas = function(orgEvent, absDelta) {
		    return ZC.mouseSpecial.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;	// No I18N
		}
		ZC.mouseWheelHandler = function(orgEvent) {
		    let originalEvent = orgEvent || window.event,
		        args = Array.prototype.slice.call(arguments, 1),
		        delta = 0,
		        deltaX = 0,
		        deltaY = 0,
		        absDelta = 0,
		        offsetX = 0,
		        offsetY = 0;
		    orgEvent = $.event.fix(originalEvent);
		    orgEvent.type = 'mousewheel';	// No I18N
		    if ('detail' in originalEvent) {	// No I18N
		        deltaY = originalEvent.detail * -1;
		    }
		    if ('wheelDelta' in originalEvent) {	// No I18N
		        deltaY = originalEvent.wheelDelta;
		    }
		    if ('wheelDeltaY' in originalEvent) {	// No I18N
		        deltaY = originalEvent.wheelDeltaY;
		    }
		    if ('wheelDeltaX' in originalEvent) {	// No I18N
		        deltaX = originalEvent.wheelDeltaX * -1;
		    }
		    delta = deltaY === 0 ? deltaX : deltaY;
		    if ('deltaY' in originalEvent) {	// No I18N
		        deltaY = originalEvent.deltaY * -1;
		        delta = deltaY;
		    }
		    if ('deltaX' in originalEvent) {	// No I18N
		        deltaX = originalEvent.deltaX;
		        if (deltaY === 0) {
		            delta = deltaX * -1;
		        }
		    }
		    if (deltaY === 0 && deltaX === 0) {
		        return;
		    }
		    if (originalEvent.deltaMode === 1) {
		        let lineHeight = $.data(this, 'mousewheel-line-height');	// No I18N
		        delta *= lineHeight;
		        deltaY *= lineHeight;
		        deltaX *= lineHeight;
		    } else if (originalEvent.deltaMode === 2) {
		        let pageHeight = $.data(this, 'mousewheel-elem-height');	// No I18N
		        delta *= pageHeight;
		        deltaY *= pageHeight;
		        deltaX *= pageHeight;
		    }
		    absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
		    if (!ZC.lowestDelta || absDelta < ZC.lowestDelta) {
		        ZC.lowestDelta = absDelta;
		        if (ZC.shouldAdjustOldDeltas(originalEvent, absDelta)) {
		            ZC.lowestDelta /= 40;
		        }
		    }
		    if (ZC.shouldAdjustOldDeltas(originalEvent, absDelta)) {
		        delta /= 40;
		        deltaX /= 40;
		        deltaY /= 40;
		    }
		    delta = Math[ delta >= 1 ? 'floor' : 'ceil' ](delta / ZC.lowestDelta);	// No I18N
		    deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / ZC.lowestDelta);	// No I18N
		    deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / ZC.lowestDelta);	// No I18N
		    if (ZC.mouseSpecial.settings.normalizeOffset && this.getBoundingClientRect) {
		        let boundingRect = this.getBoundingClientRect();
		        offsetX = orgEvent.clientX - boundingRect.left;
		        offsetY = orgEvent.clientY - boundingRect.top;
		    }
		    orgEvent.deltaX = deltaX;
		    orgEvent.deltaY = deltaY;
		    orgEvent.deltaFactor = ZC.lowestDelta;
		    orgEvent.offsetX = offsetX;
		    orgEvent.offsetY = offsetY;
		    orgEvent.deltaMode = 0;
		    args.unshift(orgEvent, delta, deltaX, deltaY);
		    if (ZC.nullLowestDeltaTimeout) {
		        clearTimeout(ZC.nullLowestDeltaTimeout);
		    }
		    ZC.nullLowestDeltaTimeout = setTimeout(ZC.nullLowestDelta, 200);
		    if (ZC.Browser.isMobile) {
		        let customEvent = new CustomEvent('custommousewheel', { 	// No I18N
		            bubbles: true,
		            composed: true,
		            cancelable: true,
		            detail: args
		        }); // No I18N
		        this.dispatchEvent(customEvent);
		    } else {
		        return ($.event.dispatch || $.event.handle).apply(this, args);
		    }
		}
		ZC.nullLowestDelta = function() {
		    ZC.lowestDelta = null;
		}
		function invokeResizeHandler(element) {
		    (function($, window) {
		        let instance = element.data('zscroll'); // No I18N
		        if (instance) {
		            clearTimeout(instance._resizeTimeout);
		            instance._resizeTimeout = setTimeout(function() {
		                if (element && element.is(':visible')) { // No I18N
		                    instance._reinitialize();
		                }
		            }, 0);
		        }
		    }(jQuery, window));
		}
		ZC.$window.on('resize.zscroll', function(orgEvent) {	// No I18N
		    if (ZC.scrollBindings) {
		        for (let i = 0; i < ZC.scrollBindings.length; i++) {
		            invokeResizeHandler($(ZC.scrollBindings[i]))
		        }
		    }
		})
		class ZScroll extends ZC.CoreComponent {
			get name(){
				return "zscroll";
			}
		    get attrs() {
		        return {
		            dynamicDimensions: false,	// No I18N
		            top: 0,	// No I18N
		            left: 0, 	// No I18N
		            autoReinit: false, // No I18N
		            scrollIncrement: 55,	// No I18N
		            showScrollBarOnHover: false,	// No I18N
		            showScrollBarAlways: false,	// No I18N
		            disappearDelay: 1200,	// No I18N
		            animateHide: false,	// No I18N
		            forceRefresh: true,	// No I18N
		            reinitDelay: 500, // No I18N
		            showScrollBarOnTrackHover: false // No I18N
		        }
		    }
		    get EVENTS() {
		        return [ 'scroll', 'scrollxend', 'scrollyend', 'scrollend' ];// No I18N
		    }
		    get name() {
		        return 'zscroll'; 	// No I18N
		    }
		    _create(element, options) {
		        ZC.specialMouseWheelHandler();
		        this._initialize();
		        this._opts.dynamicDimensions && ZC.scrollBindings.push(this.element);
		    }
		    _initialize() {
		        this._minScrollBarSize = 35;
		        if (this._isUL) {
		            this.element.removeClass('zoverflow__visible'); // No I18N
		        }
		        if (this._pane === undefined) {
		            this._padding = {
		                top: this.element.css('paddingTop'), 	// No I18N
		                left: this.element.css('paddingLeft'),	// No I18N
		                bottom: this.element.css('paddingBottom'), 	// No I18N
		                right: this.element.css('paddingRight')	// No I18N
		            };
		            this._originalPadding = this.element.css('paddingTop') + ' ' +	this.element.css('paddingRight') + ' ' + this.element.css('paddingBottom') + ' ' + this.element.css('paddingLeft'); // No I18N
		        } else {
		            this.element.removeClass('zscroll'); // No I18N
		        }
		        let actualElement = this._reinitialized && this._isUL ? this._parentElement : this.element;
		        this._elementWidth = actualElement.width();
		        this._elementHeight = actualElement.height();
		        this._paneWidth = actualElement.innerWidth();
		        this._paneHeight = this.element.innerHeight();
		        if (this.element[0].tagName !== 'UL') {	// No I18N
		            this.element.addClass('zscroll');
		            if (this._pane !== undefined) {
		                let maxHeight = this.element.css('max-height'); // No I18N
		                if (maxHeight && maxHeight !== 'none' && maxHeight.indexOf('%') === -1) {		// No I18N
		                    let contentElement = this.element.find('.zscroll__content'),
		                        elementHeight = parseInt(maxHeight); // No I18N
		                    if (!isNaN(elementHeight)) {
		                        this._paneHeight = contentElement.innerHeight() || this._paneHeight;
		                        if (this._paneHeight > elementHeight) {
		                            this._paneHeight = elementHeight;
		                        }
		                    }
		                    this._paneWidth = contentElement.innerWidth() || this._paneWidth;
		                }
		            }
		        } else {
		            this._isUL = true;
		            this.element.addClass('zoverflow__visible'); // No I18N
		        }
		        if (this._pane === undefined) {
		            this._outerPane = $('<div class="zscroll__container"/>');
		            if (this._isUL) {
		                this._parentElement = $('<div>');
		                let elementParent = this.element.parent();
		                this.element.appendTo(this._parentElement);
		                this._parentElement.appendTo(elementParent).addClass('zscroll');	// No I18N
		            }
		            this._pane = $('<div class="zscroll__content" />').css('padding', this._originalPadding).append(this._isUL ? this._parentElement.children() : this.element.children()).appendTo(this._outerPane);
		            this._outerPane.appendTo(this._isUL ? this._parentElement : this.element);
		            if (ZC.Browser.isFirefox || ZC.Browser.isIE) {
		                this._pane.css('padding-bottom', '0px');	// No I18N
		            }
		        }
		        this._createStyle();
		        this._outerPane.css({
		            width: this._paneWidth,
		            height: this._paneHeight
		        })
		        this._pane.width(this._elementWidth)
		        this._pane.css('overflow', 'auto');	// No I18N
		        this._contentWidth = this._pane[0].scrollWidth, this._contentHeight = this._pane[0].scrollHeight;
		        if (this._isUL) {
		            if (this._contentHeight !== this.element[0].scrollHeight) {
		                this._contentHeight = this.element[0].scrollHeight;
		            }
		            if (this._contentWidth !== this.element[0].scrollWidth) {
		                this._contentWidth = this.element[0].scrollWidth;
		            }
		        }
		        this._pane.css('overflow', '');	// No I18N
		        this._percentInViewX = this._contentWidth / this._paneWidth;
		        this._percentInViewY = this._contentHeight / this._paneHeight;
		        this._horizontal = this._percentInViewX > 1;
		        this._vertical = this._percentInViewY > 1;
		        this._handleScrollYTrack();
		        this._handleScrollXTrack();
		        if (!this._reinitialized) {
		            this._bindEvents();
		        }
		        this._maxScrollY = this._contentHeight - this._paneHeight;
		        this._maxScrollX = this._contentWidth - this._paneWidth;
		        if (this._vertical && this._finalVerValue) {
		            var position = -this._pane.position().top,
		                percentScrolled;
		            var percentScrolled = position / this._maxScrollY;
		            this._scrollPosY(undefined, percentScrolled * this._maxDragY);
		        }
		        if (this._horizontal && this._finalHorValue) {
		            var position = -this._pane.position().left,
		                percentScrolled;
		            var percentScrolled = position / this._maxScrollX;
		            this._scrollPosX(undefined, percentScrolled * this._maxDragX);
		        }
		        if (!this._reinitialized) {
		            window.clearInterval(this._clearAutoreinit);
		            if (this._opts.autoReinit) {
		                this._clearAutoreinit = window.setInterval(this._reinitialize.bind(this), this._opts.reinitDelay);
		            }
		        }
		        this._vertical && this._reflectOptionValueInElement('top'); // No I18N
		        this._horizontal && this._reflectOptionValueInElement('left'); // No I18N
		        this._reinitialized = false;
		    }
		    _createStyle(doNotGenerate) {
		        this._style = document.getElementById('zcomponentsstyle');
		        if (!this._style) {
		            this._style = document.createElement('style'); // No I18N
		            this._style.setAttribute('id', 'zcomponentsstyle');
		            $(document.body).prepend(this._style);
		        }
		        if (!doNotGenerate) {
		            $(this._textNode).remove();
		            this._currentClass = Math.floor(Math.random() * 1000000) + this.componentName;
		            this._props = ' { width: ' + this._paneWidth + 'px; height: ' + this._paneHeight + 'px; } '; // No I18N
		            let cssText = ' .' + this._currentClass + ' ' + this._props; // No I18N
		            this._textNode = document.createTextNode(cssText);
		            this._style.appendChild(this._textNode);
		        }
		        this[this._isUL ? '_parentElement' : 'element'].addClass(this._currentClass); // No I18N
		    }
		    _reflectOptionValueInElement(optionName) {
		        let base = this;
		        Object.defineProperty(this.element[0], 'scroll' + (optionName[0].toUpperCase() + optionName.substring(1)), { // No I18N
		            set: function(value) {
		                if (!this._addedByComponent) {
		                    base.setAttribute(optionName, value);
		                }
		                delete this._addedByComponent;
		            },
		            get: function() {
		                return -base._opts.top;
		            },
		            configurable: true
		        });
		    }
		    _handleScrollYTrack() {
		        if (this._vertical) {
		            if (this._verticalTrack === undefined) {
		                this._verticalTrack = $("<div class='zscroll__track--v'>");
		                this._verticalBar = $("<div class='zscroll__thumb zscroll__thumb--v'>").appendTo(this._verticalTrack);
		                this._verticalTrack.appendTo(this._outerPane);
		                this._opts.className && this._verticalTrack.addClass(this._opts.className);
		                this._bindVerticalTrackEvents();
		            }
		            this._setVerticalScrollSize();
		        } else if (this._verticalTrack !== undefined) {
		            this._verticalTrack.remove();
		            this._verticalBar.remove();
		            this._verticalTrack = this._verticalBar = this._finalVerValue = undefined;
		            this._pane.css('top', '0px');	// No I18N
		        }
		    }
		    _handleScrollXTrack() {
		        if (this._horizontal) {
		            if (this._horizontalTrack === undefined) {
		                this._horizontalTrack = $("<div class='zscroll__track--h'>");
		                this._horizontalBar = $("<div class='zscroll__thumb zscroll__thumb--h'>").appendTo(this._horizontalTrack);
		                this._horizontalTrack.appendTo(this._outerPane);
		                this._opts.className && this._horizontalTrack.addClass(this._opts.className);
		                this._bindHorizontalTrackEvents();
		            }
		            this._setHorScrollSize();
		        } else if (this._horizontalTrack !== undefined) {
		            this._horizontalTrack.remove();
		            this._horizontalBar.remove();
		            this._horizontalTrack = this._horizontalBar = this._finalHorValue = undefined;
		            this._pane.css('left', '0px');	// No I18N
		        }
		    }
		    _setVerticalScrollSize() {
		        if (this._verticalTrack) {
		            this._verticalBarHeight = Math.ceil(1 / this._percentInViewY * this._paneHeight);
		            if (this._verticalBarHeight < this._minScrollBarSize) {
		                this._verticalBarHeight = this._minScrollBarSize;
		            }
		            this._verticalTrack.css('height', this._paneHeight);	// No I18N
		            this._maxDragY = this._paneHeight - this._verticalBarHeight;
		            this._verticalBar.css('height', this._verticalBarHeight);		// No I18N
		            this._opts.showScrollBarAlways && this._showVerticalScroll();
		        }
		    }
		    _setHorScrollSize() {
		        if (this._horizontalTrack) {
		            this._horizontalBarWidth = Math.ceil(1 / this._percentInViewX * this._paneWidth);
		            if (this._horizontalBarWidth < this._minScrollBarSize) {
		                this._horizontalBarWidth = this._minScrollBarSize
		            }
		            this._horizontalTrack.css('width', this._paneWidth);	// No I18N
		            this._maxDragX = this._paneWidth - this._horizontalBarWidth;
		            this._horizontalBar.css('width', this._horizontalBarWidth);	// No I18N
		            this._opts.showScrollBarAlways && this._showHorizontalScroll();
		        }
		    }
		    _getScrollbarWidth() {
		        if (!this._defaultScrollbarWidth) {
		            let scrollEle = $('<div>').css({
		                width: '100px', // No I18N
		                height: '100px',	// No I18N
		                overflow: 'scroll'	// No I18N
		            }).appendTo('body'); 	// No I18N
		            this._defaultScrollbarWidth = scrollEle.width() - scrollEle[0].scrollWidth;
		            scrollEle.remove();
		        }
		        return this._defaultScrollbarWidth
		    }
		    _bindEvents() {
		        let base = this,
		            componentName = this.componentName;
		        let oldDeltaY, oldDeltaX;
		        this._scrollX = false, this._scrollY = false;
		        if (ZC.Browser.isMobile) {
		            this._outerPane[0].addEventListener('custommousewheel', this._mouseWheelHandler.bind(this));
		            this._outerPane.on('mousewheel.' + componentName, $.noop); // No I18N
		        } else {
		            this._outerPane.on('mousewheel.' + componentName, this._mouseWheelHandler.bind(this)); // No I18N
		        }
		        if (this._opts.showOne) {
		            this._outerPane.on('mouseout.' + componentName, function(orgEvent) { // No I18N
		                let target;
		                if (orgEvent.relatedTarget) {
		                    target = $(orgEvent.relatedTarget).closest('.zscroll'); // No I18N
		                }
		                ZC._activeContainer = target;
		                let actualElement = base._isUL ? base._parentElement[0] : base.element[0]
		                if (ZC._activeContainer && ZC._activeContainer[0] !== actualElement) {
		                    base._hideVerticalScroll();
		                    base._hideHorizontalScroll();
		                }
		            });
		        }
		        this._outerPane.on('mouseenter.' + componentName, function(orgEvent) {		// No I18N
		            (base._opts.forceRefresh || !base._mouseEnter) && base._refresh();
		            base._mouseEnter = true;
		            ZC._activeContainer = base._isUL ? base._parentElement : base.element;
		            $('body').addClass('h-overflowhidden');
		            base._mouseLeave = false;
		            if (base._opts.showScrollBarOnHover) {
		                base._showVerticalScroll();
		                base._showHorizontalScroll();
		            }
		        }).on('mouseleave.' + componentName, function(orgEvent) {	// No I18N
		            $('body').removeClass('h-overflowhidden');
		            base._mouseLeave = true;
		            if (base._opts.showScrollBarOnHover) {
		                base._removeVerticalTrackSettings();
		                base._removeHorizontalTrackSettings();
		            }
		        });
		        this._bindVerticalTrackEvents();
		        this._bindHorizontalTrackEvents();
		    }
		    _bindVerticalTrackEvents() {
		        let componentName = this.componentName,
		            base = this;
		        this._verticalBar && this._verticalBar.on('mousedown.' + componentName, function(orgEvent) {	// No I18N
		            orgEvent.preventDefault();
		            orgEvent.stopPropagation();
		            base._startY = orgEvent.pageY - base._verticalBar.position().top;
		            base._mousedown = true;
		            ZC.$document.on('mousemove.' + componentName, function(orgEvent) {	// No I18N
		                orgEvent.preventDefault();
		                base._animate = false;
		                base._scrollPosY(orgEvent, orgEvent.pageY - base._startY);
		            }).on('mouseup.' + componentName, function(orgEvent) {	// No I18N
		                orgEvent.preventDefault();
		                base._mousedown = false;
		                ZC.$document.off('mouseup.' + componentName + ' mousemove.' + componentName + ' mousedown.' + componentName);	// No I18N
		            })
		        });
		        this._verticalTrack && this._verticalTrack.on('mousedown.' + componentName, function(orgEvent) {	// No I18N
		            if (base._verticalBar.is(':visible') || base._defaultScrollbarWidth > 0) {	// No I18N
		                let offset = base._verticalTrack.offset(),
		                    pos;
		                let direction = orgEvent.pageY - offset.top - base._finalVerValue;
		                pos = orgEvent.pageY - offset.top - base._verticalBarHeight / 2;
		                let value = direction > 0 ? base._finalVerValue + base._opts.scrollIncrement : base._finalVerValue - base._opts.scrollIncrement;
		                base._animate = true;
		                if (direction > 0) {
		                    if (value < pos) {
		                        base._scrollPosY(orgEvent, value);
		                    } else {
		                        base._scrollPosY(orgEvent, pos);
		                    }
		                } else if (value > pos) {
		                    base._scrollPosY(orgEvent, value);
		                } else {
		                    base._scrollPosY(orgEvent, pos);
		                }
		            }
		        }).on('mouseenter.' + componentName, function(orgEvent) {	// No I18N
		            base._addVerticalTrackSettings();
		        }).on('mouseleave.' + componentName, function(orgEvent) {	// No I18N
		            base._removeVerticalTrackSettings();
		        });
		    }
		    _bindHorizontalTrackEvents() {
		        let componentName = this.componentName,
		            base = this;
		        this._horizontalBar && this._horizontalBar.off('mousedown.' + componentName).on('mousedown.' + componentName, function(orgEvent) {		// No I18N
		            orgEvent.preventDefault();
		            base._startX = orgEvent.pageX - base._horizontalBar.position().left;
		            base._mousedown = true;
		            ZC.$document.on('mousemove.' + componentName, function(orgEvent) {		// No I18N
		                orgEvent.preventDefault();
		                base._animate = false;
		                base._scrollPosX(orgEvent, orgEvent.pageX - base._startX);
		            }).on('mouseup.' + componentName, function(orgEvent) {		// No I18N
		                orgEvent.preventDefault();
		                base._mousedown = false;
		                ZC.$document.off('mouseup.' + componentName + ' mousemove.' + componentName + ' mousedown.' + componentName);		// No I18N
		            })
		        });
		        this._horizontalTrack && this._horizontalTrack.on('mousedown.' + componentName, function(orgEvent) {	// No I18N
		            if (base._horizontalBar.is(':visible') || base._defaultScrollbarWidth > 0) {	// No I18N
		                let offset = base._horizontalTrack.offset(),
		                    pos;
		                let direction = orgEvent.pageX - offset.left - base._finalHorValue;
		                pos = orgEvent.pageX - offset.left - base._horizontalBarWidth / 2;
		                let value = direction > 0 ? base._finalHorValue + base._opts.scrollIncrement : base._finalHorValue - base._opts.scrollIncrement;
		                base._animate = true;
		                if (direction > 0) {
		                    if (value < pos) {
		                        base._scrollPosX(orgEvent, value);
		                    } else {
		                        base._scrollPosX(orgEvent, pos);
		                    }
		                } else if (value > pos) {
		                    base._scrollPosX(orgEvent, value);
		                } else {
		                    base._scrollPosX(orgEvent, pos);
		                }
		            }
		        }).on('mouseenter.' + componentName, function(orgEvent) {	// No I18N
		            base._addHorizontalTrackSettings();
		        }).on('mouseleave.' + componentName, function(orgEvent) {	// No I18N
		            base._removeHorizontalTrackSettings();
		        });
		    }
		    _mouseWheelHandler(orgEvent, delta, deltaX, deltaY) {
		        var base = this,
		            delta, deltaX, deltaY;
		        if (ZC.Browser.isMobile) {
		            delta = orgEvent.detail[1], deltaX = orgEvent.detail[2], deltaY = orgEvent.detail[3];
		            orgEvent = orgEvent.detail[0];
		        }
		        let actualElement = this._isUL ? this._parentElement[0] : this.element[0];
		        if (base._vertical && (this._oldDeltaY !== 0 || !Object.is(this._oldDeltaY, -0) || deltaY !== 0) && (this._oldDeltaX === 0 || Object.is(this._oldDeltaX, -0) || this._oldDeltaX === undefined)) {
		            this._oldDeltaY = deltaY;
		            if (!base._opts.showScrollBarAlways) {
		                if (!base._opts.showOne || (base._opts.showOne && ZC._activeContainer && ZC._activeContainer[0] === actualElement)) {
		                    base._showVerticalScroll();
		                    !base._opts.showScrollBarOnHover && base._hideHorizontalScroll();
		                } else if (base._opts.showOne && ZC._activeContainer && ZC._activeContainer[0] !== actualElement) {
		                    base._hideVerticalScroll();
		                }
		            }
		            base._scrollY = true;
		            base._scrollX = false;
		        }
		        if (base._horizontal && (this._oldDeltaX !== 0 || !Object.is(this._oldDeltaX, -0) || deltaX !== 0) && (this._oldDeltaY === 0 || Object.is(this._oldDeltaY, -0) || this._oldDeltaY === undefined)) {
		            this._oldDeltaX = deltaX;
		            if (!base._opts.showScrollBarAlways) {
		                if (!base._opts.showOne || (base._opts.showOne && ZC._activeContainer && ZC._activeContainer[0] === actualElement)) {
		                    base._showHorizontalScroll();
		                    !base._opts.showScrollBarOnHover && base._hideVerticalScroll();
		                } else if (base._opts.showOne && ZC._activeContainer && ZC._activeContainer[0] !== actualElement) {
		                    base._hideHorizontalScroll();
		                }
		            }
		            base._scrollX = true;
		            base._scrollY = false;
		        }
		        let factor = this._opts.scrollSensivity || orgEvent.deltaFactor;
		        if (!base._prevHorPosition) {
		            base._prevHorPosition = 0
		        }
		        if (!base._prevVerPosition) {
		            base._prevVerPosition = 0;
		        }
		        let dX = base._prevHorPosition,
		            dY = base._prevVerPosition;
		        base._scrollContent(orgEvent, deltaX * factor, -deltaY * factor);
		        return dX === base._prevHorPosition && dY === base._prevVerPosition;
		    }
		    _hideVerticalScroll() {
		        if (this._vertical && this._verticalBar && this._verticalTrack) {
		            this._verticalBar.hide();
		            this._verticalTrack.removeClass('zscroll__handler--hover zscroll__handler--hoverv');
		        }
		    }
		    _hideHorizontalScroll() {
		        if (this._horizontal && this._horizontalBar && this._horizontalTrack) {
		            this._horizontalBar.hide();
		            this._horizontalTrack.removeClass('zscroll__handler--hover zscroll__handler--hoverh');
		        }
		    }
		    _removeHorizontalTrackSettings() {
		        let base = this;
		        clearTimeout(this._removeHTimeout);
		        this._removeHTimeout = setTimeout(function() {
		            if (!base._mousedown && base._horizontal && (base._horizontalBar && base._horizontalBar.is(':visible') || base._horizontalTrack && base._horizontalTrack.is(':visible'))) {
		                base._horizontalTrack && base._horizontalTrack.removeClass('zscroll__handler--hover zscroll__handler--hoverh');	// No I18N
		                if (base._horizontalBar) {
		                    base._horizontalBar.removeClass('zscroll__thumb--hoverh h-scrollhorheight');
		                    (!base._opts.showScrollBarAlways && !base._opts.showScrollBarOnHover) && (base._opts.animateHide ? base._horizontalBar.fadeOut() : base._horizontalBar.hide());
		                    if (base._opts.showScrollBarOnHover && base._mouseLeave || base._opts.showScrollBarOnTrackHover) {
		                        base._opts.animateHide ? base._horizontalBar.fadeOut() : base._horizontalBar.hide();
		                    }
		                }
		            }
		        }, this._opts.disappearDelay);
		    }
		    _removeVerticalTrackSettings() {
		        let base = this;
		        clearTimeout(this._removeVTimeout);
		        this._removeVTimeout = setTimeout(function() {
		            if (!base._mousedown && base._vertical && (base._verticalBar && base._verticalBar.is(':visible') || base._verticalTrack && base._verticalTrack.is(':visible'))) {	// No I18N
		                base._verticalTrack && base._verticalTrack.removeClass('zscroll__handler--hover zscroll__handler--hoverv');	// No I18N
		                if (base._verticalBar) {
		                    base._verticalBar.removeClass('zscroll__thumb--hoverv h-scrollverheight');
		                    (!base._opts.showScrollBarAlways && !base._opts.showScrollBarOnHover) && (base._opts.animateHide ? base._verticalBar.fadeOut() : base._verticalBar.hide());
		                    if (base._opts.showScrollBarOnHover && base._mouseLeave || base._opts.showScrollBarOnTrackHover) {
		                        base._opts.animateHide ? base._verticalBar.fadeOut() : base._verticalBar.hide();
		                    }
		                }
		            }
		        }, this._opts.disappearDelay);
		    }
		    _addVerticalTrackSettings() {
		        clearTimeout(this._removeVTimeout);
		        if (this._opts.showScrollBarOnTrackHover) {
		            this._showVerticalScroll();
		        }
		        if (this._vertical && this._verticalBar) {
		            if (this._verticalBar.is(':visible') || this._opts.showScrollBarOnTrackHover) {	 // No I18N
		                this._verticalTrack.addClass('zscroll__handler--hover zscroll__handler--hoverv');	// No I18N
		                this._verticalBar.addClass('zscroll__thumb--hoverv h-scrollverheight');
		            }
		        }
		    }
		    _showVerticalScroll() {
		        if (this._verticalBar && this._verticalTrack && this.element.is(':visible')) {
		            this._verticalBar.show();
		            this._verticalTrack.show();
		        }
		    }
		    _showHorizontalScroll() {
		        if (this._horizontalBar && this._horizontalTrack && this.element.is(':visible')) {
		            this._horizontalBar.show();
		            this._horizontalTrack.show();
		        }
		    }
		    _addHorizontalTrackSettings() {
		        clearTimeout(this._removeHTimeout);
		        if (this._opts.showScrollBarOnTrackHover) {
		            this._showHorizontalScroll();
		        }
		        if (this._horizontal && this._horizontalBar) {
		            if (this._horizontalBar.is(':visible') || this._opts.showScrollBarOnTrackHover) { // No I18N
		                this._horizontalTrack.addClass('zscroll__handler--hover zscroll__handler--hoverh');	// No I18N
		                this._horizontalBar.addClass('zscroll__thumb--hoverh h-scrollhorheight');
		            }
		        }
		    }
		    _scrollContent(orgEvent, deltaX, deltaY) {
		        if (this._horizontal) {
		            this._scrollHorContent(orgEvent, deltaX);
		        }
		        if (this._vertical) {
		            this._scrollVerContent(orgEvent, deltaY);
		        }
		    }
		    _scrollHorContent(orgEvent, deltaX) {
		        if (this._scrollY === true) {
		            return false;
		        }
		        let destX = -this._pane.position().left + Math[deltaX < 0 ? 'floor' : 'ceil'](deltaX), 	// No I18N
		            percentScrolled;		// No I18N
		        percentScrolled = destX / (this._maxScrollX);
		        this._scrollPosX(orgEvent, (percentScrolled * this._maxDragX));
		    }
		    _scrollPosX(orgEvent, finalHorValue, animation) {
		        if (this._horizontalBar) {
		            if (finalHorValue < 0) {
		                finalHorValue = 0;
		                if (!ZC.Browser.isMobile) {
		                    orgEvent && orgEvent.preventDefault();
		                }
		            } else if (finalHorValue > this._maxDragX) {
		                finalHorValue = this._maxDragX;
		                if (!ZC.Browser.isMobile) {
		                    orgEvent && orgEvent.preventDefault();
		                }
		            } else {
		                orgEvent && orgEvent.stopPropagation();
		            }
		            if (this._animate) {
		                this._horizontalBar.animate({
		                    left: finalHorValue
		                }, 100, 'swing');	// No I18N
		            } else {
		                animation = animation || this._opts.animation;
		                if (animation) {
		                    this._horizontalBar.animate({
		                        left: finalHorValue
		                    }, animation.duration, animation.name); // No I18N
		                } else {
		                    this._horizontalBar.css('left', finalHorValue);	// No I18N
		                }
		            }
		            this._opts.left = finalHorValue;
		            this._removeHorizontalTrackSettings();
		            this._finalHorValue = finalHorValue;
		            this._positionX(orgEvent, finalHorValue, animation);
		        }
		    }
		    _positionX(orgEvent, finalHorValue, animation) {
		        this._prevHorPosition = finalHorValue || 0;
		        let percentScrolled = finalHorValue / this._maxDragX;
		        let horLeftvalue = -percentScrolled * (this._maxScrollX);
		        if (animation) {
		            this._pane.animate({
		                left: horLeftvalue
		            }, animation.duration, animation.name); // No I18N
		        } else {
		            this._pane.css('left', horLeftvalue);		// No I18N
		        }
		        Object.defineProperty(this.element[0], 'scrollLeft', {
		            value: -horLeftvalue,
		            configurable: true
		        });
		        this._dispatchEvent('scroll', orgEvent, { 	// No I18N
		            scrollBarPos: finalHorValue,
		            scrollLeft: -horLeftvalue
		        });
		        this._positionXEnded = (finalHorValue !== this._maxDragX) ? false : this._positionXEnded;
		        if (finalHorValue === this._maxDragX && !this._positionXEnded) {
		            this._dispatchEvent('scrollend', orgEvent, { 	// No I18N
		                scrollBarPos: finalHorValue,
		                scrollLeft: -horLeftvalue
		            }); // No I18N
		            this._positionXEnded = true;
		            this._dispatchEvent('scrollxend', orgEvent, { 	// No I18N
		                scrollBarPos: finalHorValue,
		                scrollLeft: -horLeftvalue
		            }); // No I18N
		        }
		    }
		    _scrollVerContent(orgEvent, deltaY) {
		        this._animate = false;
		        if (this._scrollX === true) {
		            return false;
		        }
		        let destY, percentScrolled;
		        destY = -this._pane.position().top + Math[deltaY < 0 ? 'floor' : 'ceil'](deltaY);		// No I18N
		        percentScrolled = destY / (this._maxScrollY);
		        this._scrollPosY(orgEvent, percentScrolled * this._maxDragY);
		    }
		    _scrollPosY(orgEvent, finalVerValue, animation) {
		        animation = animation || this._opts.animation;
		        if (orgEvent) {
		            let target = $(orgEvent.target).closest('[allowscroll]'); // No I18N
		            if (target.length) {
		                return;
		            }
		        }
		        if (this._verticalBar) {
		            this._finalVerValue = finalVerValue;
		            if (finalVerValue < 0) {
		                finalVerValue = 0;
		                if (!ZC.Browser.isMobile) {
		                    orgEvent && orgEvent.preventDefault();
		                }
		            } else if (finalVerValue > this._maxDragY) {
		                finalVerValue = this._maxDragY;
		                if (!ZC.Browser.isMobile) {
		                    orgEvent && orgEvent.preventDefault();
		                }
		            } else {
		                orgEvent && orgEvent.stopPropagation();
		            }
		            this._finalVerValue = finalVerValue;
		            this._prevVerPosition = finalVerValue || 0;
		            let percentScrolled = finalVerValue / this._maxDragY;
		            let verTopValue = -percentScrolled * (this._maxScrollY),
		                returnValue;
		            returnValue = this._dispatchEvent('scroll', orgEvent, { 	// No I18N
		                scrollBarPos: finalVerValue,
		                scrollTop: -verTopValue,
		                scroll: 'vertical', 	// No I18N
		                maxScrollValue: this._maxDragY
		            })
		            if (returnValue) {
		                this._opts.top = verTopValue;
		                if (this._animate) {
		                    this._verticalBar.animate({
		                        top: finalVerValue
		                    }, 100, 'swing');			// No I18N
		                } else if (animation) {
		                    this._verticalBar.animate({
		                        top: finalVerValue
		                    }, animation.duration, animation.name); 	// No I18N
		                } else {
		                    this._verticalBar.css('top', finalVerValue);		// No I18N
		                }
		                if (animation) {
		                    this._pane.animate({
		                        top: verTopValue
		                    }, animation.duration, animation.name); // No I18N
		                } else {
		                    this._pane.css('top', verTopValue);		// No i18n
		                }
		                this.element[0]._addedByComponent = true;
		                this.element[0].scrollTop = -verTopValue;
		                this._removeVerticalTrackSettings();
		            }
		            this._positionYEnded = (finalVerValue !== this._maxDragY) ? false : this._positionYEnded;
		            if (finalVerValue === this._maxDragY && !this._positionYEnded) {
		                this._dispatchEvent('scrollend', orgEvent, { 	// No I18N
		                    scrollBarPos: finalVerValue,
		                    scrollTop: -verTopValue,
		                    scroll: 'vertical' 	// No I18N
		                });
		                this._positionYEnded = true;
		                this._dispatchEvent('scrollyend', orgEvent, { 	// No I18N
		                    scrollBarPos: finalVerValue,
		                    scrollTop: -verTopValue,
		                    scroll: 'vertical' 	// No I18N
		                });
		            }
		        }
		    }
		    _refresh() {
		        let actualElement = this[this._isUL ? '_parentElement' : 'element']; // No I18N
		        if (this._isUL) {
		            this.element.removeClass('zoverflow__visible'); // No I18N
		        }
		        if (this._currentClass) {
		            actualElement.removeClass(this._currentClass);
		        }
		        this._getScrollbarWidth();
		        this._elementWidth = this.element.width();
		        this._paneWidth = this.element.innerWidth();
		        this._paneHeight = this.element.innerHeight();
		        if (this._currentClass) {
		            actualElement.addClass(this._currentClass);
		        }
		        if (this._isUL) {
		            this.element.addClass('zoverflow__visible'); // No I18N
		        }
		        this._outerPane.css({
		            width: this._paneWidth,
		            height: this._paneHeight
		        });
		        this._pane.width(this._paneWidth);
		        this._checkScrollChanges();
		    }
		    _checkScrollChanges() {
		        let isChanged,
		            oldContentHeight = this._contentHeight,
		            oldContentWidth = this._contentWidth;
		        this._contentWidth = this._pane[0].scrollWidth, this._contentHeight = this._pane[0].scrollHeight;
		        if (this._isUL) {
		            if (this._contentHeight !== this.element[0].scrollHeight) {
		                this._contentHeight = this.element[0].scrollHeight;
		            }
		            if (this._contentWidth !== this.element[0].scrollWidth) {
		                this._contentWidth = this.element[0].scrollWidth;
		            }
		        }
		        if (oldContentHeight !== this._contentHeight || oldContentWidth !== this._contentWidth) {
		            isChanged = true;
		        }
		        if (isChanged) {
		            this._percentInViewX = this._contentWidth / this._paneWidth;
		            this._percentInViewY = this._contentHeight / this._paneHeight;
		            this._horizontal = this._percentInViewX > 1;
		            this._vertical = this._percentInViewY > 1;
		            this._handleScrollYTrack();
		            this._handleScrollXTrack();
		            this._maxScrollY = this._contentHeight - this._paneHeight;
		            this._maxScrollX = this._contentWidth - this._paneWidth;
		            if (this._finalVerValue && this._vertical) {
		                var position = -this._pane.position().top,
		                    percentScrolled;
		                var percentScrolled = position / this._maxScrollY;
		                this._scrollPosY(undefined, percentScrolled * this._maxDragY);
		            } else if (this._finalVerValue && !this._vertical) {
		                this._verticalBar.hide();
		                this._finalVerValue = undefined
		            }
		            if (this._horizontal && this._finalHorValue) {
		                var position = -this._pane.position().left,
		                    percentScrolled;
		                var percentScrolled = position / this._maxScrollX;
		                this._scrollPosX(undefined, percentScrolled * this._maxDragX);
		            } else if (this._finalHorValue && !this._horizontal) {
		                this._horizontalBar.hide();
		                this._finalHorValue = undefined
		            }
		        }
		    }
		    _reinitialize() {
		        if (this.element.is(':visible')) { 	// No I18N
		            let actualElement = this.element[0].tagName === 'UL' ? this._parentElement : this.element;
		            actualElement.removeClass(this._currentClass);
		            let height = this.element.innerHeight(),
		                width = actualElement.innerWidth();
		            this._hasDimensionsChanged = height !== this._paneHeight || width !== this._paneWidth;
		            if (this._hasDimensionsChanged) {
		                this._reinitialized = true;
		                this._initialize();
		            } else {
		                this._createStyle(true);
		                this._checkScrollChanges();
		            }
		        }
		    }
		    _resetScrollPosition() {
		        this._pane.css({
		            top: '0px', 	// No I18N
		            left: '0px'	// No I18N
		        });
		        this._horizontal && this._horizontalBar.css('left', '0px');	// No I18N
		        this._vertical && this._verticalBar.css('top', '0px');	// No I18N
		    }
		    _dispatchEvent(customEvent, orgEvent, ui) {
		        let content = {
		            value: ui 	// No i18n
		        };
		        return super._dispatchEvent(customEvent, orgEvent, content);
		    }
		    reinitialize() {
		        this._reinitialize();
		    }
		    refresh() {
		        this._refresh();
		    }
		    resetScrollPosition() {
		        this._resetScrollPosition();
		    }
		    setAttribute(optionName, value, animation) {
		        this._opts[optionName] = value;
		        if (optionName === 'top') {	// No I18N
		            this._getTopValue(value, animation);
		        } else if (optionName === 'left') {	// No I18N
		            this._getLeftValue(value, animation);
		        }
		    }
		    _getTopValue(top, animation) {
		        let percentScrolled = top / this._maxScrollY;
		        this._scrollPosY(undefined, percentScrolled * this._maxDragY, animation);
		    }
		    _getLeftValue(left, animation) {
		        let percentScrolled = left / this._maxScrollX;
		        this._scrollPosX(undefined, percentScrolled * this._maxDragX, animation);
		    }
		    destroy() {
		        let componentName = this.componentName;
		        this.element.removeData(componentName);
		        let containerElement = this._isUL ? this._parentElement : this.element;
		        containerElement.find('.zscroll__content').children().unwrap();
		        containerElement.find('.zscroll__container').children().unwrap();
		        if (this._isUL) {
		            this._parentElement.children().unwrap();
		            this.element.removeClass('zoverflow__visible');
		        } else {
		            this.element.removeClass('zscroll');	// No I18N
		        }
		        if (this._currentClass) {
		            this[this._isUL ? '_parentElement' : 'element'].removeClass(this._currentClass); // No I18N
		            $(this._textNode).remove();
		            this._textNode = undefined;
		        }
		        let index = ZC.scrollBindings.indexOf(this.element);
		        ZC.scrollBindings.splice(index, 1);
		        this.element.css({
		            padding: this._originalPadding,
		            overflow: '',
		            width: '',
		            height: ''
		        });	// No I18N
		        this.element.off('.' + componentName);	// No I18N
		        ZC.$document.off('.' + componentName);	// No I18N
		        this._clearAutoreinit && window.clearInterval(this._clearAutoreinit);
		        this._pane.remove();
		        this._outerPane.remove();
		        this._outerPane = this._pane = undefined;
		        this._removeHTimeout && clearTimeout(this._removeHTimeout);
		        this._removeVTimeout && clearTimeout(this._removeVTimeout);
		        if (this._horizontal) {
		            this._horizontalBar.remove();
		            this._horizontalTrack.remove();
		            this._horizontalTrack = this._horizontalBar = undefined;
		        }
		        if (this._vertical) {
		            this._verticalBar.remove();
		            this._verticalTrack.remove();
		            this._verticalTrack = this._verticalBar = undefined;
		        }
		    }
		}
	ZC.registerComponent('ZScroll', ZScroll); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
	ZC.scrollBindings = [];
	ZC.getLineHeight = (function(element) {
	    element = $(element);
	    let parent = element['offsetParent' in $.fn ? 'offsetParent' : 'parent']();	// No I18N
	    if (!parent.length) {
	        parent = $('body');
	    }
	    return parseInt(parent.css('fontSize'), 10) || parseInt(element.css('fontSize'), 10) || 16;	// No I18N
	});
	ZC.handleMousewheel = (function(ev) {
	    let args = Array.prototype.slice.call(arguments, 1),
	        delta = 0,
	        deltaX = 0,
	        deltaY = 0,
	        factor = 0,
	        orgEvent = $.event.fix(ev);
	    orgEvent.type = 'mousewheel';// No I18N
	    if ('detail' in ev) {	// No I18N
	        deltaY = ev.detail * -1;
	    }
	    if ('wheelDelta' in ev) {	// No I18N
	        deltaY = ev.wheelDelta;
	    }
	    if ('wheelDeltaY' in ev) {	// No I18N
	        deltaY = ev.wheelDeltaY;
	    }
	    if ('wheelDeltaX' in ev) {	// No I18N
	        deltaX = ev.wheelDeltaX * -1;
	    }
	    delta = deltaY || deltaX;
	    if ('deltaY' in ev) {	// No I18N
	        delta = deltaY = ev.deltaY * -1;
	    }
	    if ('deltaX' in ev) {	// No I18N
	        deltaX = ev.deltaX;
	        if (deltaY === 0) {
	            delta = deltaX * -1;
	        }
	    }
	    if (deltaY === 0 && deltaX === 0) {
	        return;
	    }
	    if (ev.deltaMode === 1) {
	        let lineHeight = $.data(this, 'mousewheel-line-height'); // No I18N
	        delta *= lineHeight;
	        deltaY *= lineHeight;
	        deltaX *= lineHeight;
	    } else if (ZC.OS.isWindows() && ZC.Browser.isChrome) {
	        /* For windows chrome alone delta values are higher. Hence, it is normalized to give smooth interaction */
	        let normalizingVal = 8;
	        delta /= normalizingVal;
	        deltaY /= normalizingVal;
	        deltaX /= normalizingVal;
	    }
	    factor = Math.max(Math.abs(deltaY), Math.abs(deltaX));
	    /* Store lowest absolute delta to normalize the delta values (Changes can be seen visually seen in windows if removed) */
	    if (!ZC.deltaFactor || factor < ZC.deltaFactor) {
	        ZC.deltaFactor = factor;
	    }
	    factor = ZC.deltaFactor;
	    delta = Math[ delta >= 1 ? 'floor' : 'ceil' ](delta / factor);	// No I18N
	    deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / factor);	// No I18N
	    deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / factor);	// No I18N
	    orgEvent.deltaX = deltaX;
	    orgEvent.deltaY = deltaY;
	    orgEvent.deltaFactor = factor;
	    args.unshift(orgEvent, delta, deltaX, deltaY);
	    if (ZC.unsetDeltaTimeout) {
	        window.clearTimeout(ZC.unsetDeltaTimeout);
	    }
	    ZC.unsetDeltaTimeout = window.setTimeout(ZC.unsetDelta, 200);
	    return ($.event.dispatch || $.event.handle).apply(this, args);
	});
	ZC.unsetDelta = function() {
	    ZC.deltaFactor = null;
	}
	ZC.handleMousewheelSpecial = (function() {
	    ZC.specialHandled = true;
	    let passive,
	        opts,
	        /* wheel event is not supported in some versions of chrome and opera */
	        toBind = ('onwheel' in document || document.documentMode >= 9) ? 'wheel' : 'mousewheel', // No I18N
	        handler = ZC.handleMousewheel;
	    if (ZC.Browser.isMobile) {
	        /* Checking for passive listener support */
	        try {
	            opts = Object.defineProperty({}, 'passive', { // No I18N
	                get() {
	                    passive = true;
	                    return passive;
	                }
	            });
	            window.addEventListener('test', $.noop(), opts); // No I18N
	            window.removeEventListener('test', $.noop(), opts); // No I18N
	        } catch (err) {
	            passive = false;
	        }
	    }
	    opts = passive ? {
	        passive
	    } : false;
	    $.event.special.mousewheel = {
	        setup() {
	            this.addEventListener(toBind, handler, opts);
	            /* In Linux firefox, scroll amount is in lines. Hence, It has to be multiplied by line height */
	            $.data(this, 'mousewheel-line-height', ZC.getLineHeight(this)); // No I18N
	        },
	        teardown() {
	            this.removeEventListener(toBind, handler, opts);
	        }
	    }
	});
	class ZScrollbar extends ZC.CoreComponent {
			get name(){
				return "zscrollbar";
			}
	    get attrs() {
	        return {
	            autoResize: false,
	            scrollTop: 0,
	            scrollLeft: 0,
	            autoUpdate: false,
	            step: 55,
	            showScrollbar: 'onscroll',	// No I18N
	            hideDelay: 800,
	            animateOnHide: true,
	            autoUpdateDelay: 500,
	            disableKeyboardScroll: false,
	            scrollButtons: false,
	            thumbGrippy: false,
	            verticalGrippyIconClassName: '', // No I18N
	            horizontalGrippyIconClassName: '', // No I18N
	            verticalGrippySVGIconId: '', // No I18N
	            horizontalGrippySVGIconId: '', // No I18N
	            arrowKeysStep: 20,
	            spaceBarKeyStep: 50,
	            scrollOnSelectionDrag: true,
	            scrollLeftButtonIconClassName: '', // No I18N
	            scrollRightButtonIconClassName: '', // No I18N
	            scrollLeftButtonSVGIconId: '', // No I18N
	            scrollRightButtonSVGIconId: '', // No I18N
	            scrollUpButtonIconClassName: '', // No I18N
	            scrollUpButtonSVGIconId: '', // No I18N
	            scrollDownButtonIconClassName: '', // No I18N
	            scrollDownButtonSVGIconId: '', // No I18N
	            scrollbarSize: 8,
	            contentScrolledCueFor: 'scroll', // No I18N
	            verticalScroll: true,
	            horizontalScroll: true,
	            className: '', // No I18N
	            elasticScrollEffect: 'none', // No I18N
	            stopPropagation: true,
	            forceInit: true,
	            expandOnMouseover: true,
	            showTrackOnScrollbarHover: null // No I18N
	        }
	    }
	    get EVENTS() {
	        return [ 'scroll', 'horizontalscrollend', 'verticalscrollend', 'verticalscrollstart', 'horizontalscrollstart', 'scrollend', 'beforeelasticeffect' ]; // No I18N
	    }
	    get minBarSize() {
	        return 35;
	    }
	    _init() {
	        this._useParent = true;
	        let browser = ZC.Browser,
	            opts = this._opts,
	            className = '';
	        this._isBtns = opts.scrollButtons;
	        this._isCustom = browser.isIE || browser.isFirefox || browser.isEdge || opts.forceInit;
	        this._saveOptionToShowSBar(); // revisit- rename
	        if (this._isCustom) {
	            !ZC.specialHandled && ZC.handleMousewheelSpecial();
	            this._initialize();
	            if (opts.autoResize) {
	                this._handleAutoResizeEle();
	            }
	        }
	        className += (opts.rtl ? 'zh-rtl ' : '') + (opts.className || ''); // No I18N
	        this._origEle.addClass(className).attr('tabindex', 0); // No I18N
	        this._bindCommonEv();
	        if (this._vertical) {
	            this._setVerInitialState(opts);
	        }
	        if (this._horizontal) {
	            this._setHorInitialState(opts);
	        }
	        this._initialized = true;
	    }
	    _saveOptionToShowSBar() {
	        let showBar = this._opts.showScrollbar;
	        this._showOnHover = this._showOnScroll = this._showAlways = false;
	        if (showBar === 'onmouseover') { // No I18N
	            this._showOnHover = true;
	        } else if (showBar === 'onscroll') { // No I18N
	            this._showOnScroll = true;
	        } else {
	            this._showAlways = true;
	        }
	    }
	    _initialize() {
	        let elem = this.element,
	            firstInit = !this._origEle,
	            actualElement = this._origEle || elem,
	            eleWd = actualElement.width(),
	            eleHt = actualElement.height(),
	            opts = this._opts;
	        /* Removing this line since it is not producing any issues */
	        // elem.removeClass('zscrollbar--container'); // No I18N
	        this._elemWd = actualElement.outerWidth();
	        this._elemHt = actualElement.outerHeight();
	        if (firstInit) {
	            this._checkProps();
	            this._initialWdAndHt = {
	                width: elem[0].style.width,
	                height: elem[0].style.height
	            }
	            let origEle = elem,
	                clsName = 'zscrollbar--container', // No I18N
	                props = window.getComputedStyle(elem[0]);
	            this._padding = {
	                right: props.paddingRight,
	                left: props.paddingLeft,
	                bottom: props.paddingBottom,
	                top: props.paddingTop
	            };
	            if (elem[0].tagName === 'UL') {	// No I18N
	                this._isUL = true;
	                let parentEle = elem.parent();
	                origEle = this._parentElement = $('<div>'); // No I18N
	                elem.appendTo(this._parentElement);
	                this._parentElement.appendTo(parentEle);
	            }
	            /* Hidden is set instead of adding the container class because padding shouldn't be removed for calculating scrollHt and scrollWd. (which is done in zscrollbar--container) */
	            // revisit - check whether it can be achived by classnames
	            let oldVal = origEle[0].style.overflow;
	            origEle[0].style.overflow = 'hidden';
	            /* Pre-calculated here for first time because, for some type of fonts content is not loaded immediately after appending to pane and calculating after that produces wrong results. */
	            this._contentScrollHt = origEle[0].scrollHeight; /* scrollHeight and scrollWidth is calculated after adding the classes because if the element's overflow property is set as scroll, then scrollheight and scrollwidth will be different due to native scrollbars. */
	            this._contentScrollWd = origEle[0].scrollWidth;
	            origEle[0].style.overflow = oldVal;
	            if (this._isBtns) {
	                clsName += ' zscrollbar--withbuttons'; // No I18N
	            }
	            if (this._showOnHover) {
	                clsName += ' zscrollbar--showonmouseover'; // No I18N
	            } else if (this._showAlways) {
	                clsName += ' zscrollbar--showalways'; // No I18N
	            }
	            origEle.addClass(clsName);
	            this._pane = $('<div class="zscrollbar__content" />'); // No I18N
	            this._setPanePadding();
	            this._pane.append(origEle.children()).appendTo(origEle);
	            // revisit
	            // if (ZC.Browser.isFirefox || ZC.Browser.isIE) {
	            //     this._pane.css('padding-bottom', '0px');	// No I18N
	            // }
	            this._elemId = this._getID(origEle);
	            origEle.attr('id', this._elemId); // No I18N
	            this._origEle = origEle;
	        }
	        if (!opts.autoResize) {
	            let sizeObj = {};
	            if (opts.horizontalScroll) {
	                sizeObj.width = this._elemWd;
	            }
	            if (opts.verticalScroll) {
	                sizeObj.height = this._elemHt;
	            }
	            this._origEle.css(sizeObj);
	        }
	        this._pane.css({
	            width: eleWd,
	            height: eleHt
	        });
	        !firstInit && this._saveContentSize();
	        this._calcCrctHtWd(eleWd, eleHt);
	        this._buildScrollBar(firstInit);
	        if (opts.autoUpdate && firstInit) {
	            this._autoUpdateHandler(true);
	        }
	    }
	    _setPanePadding() {
	        let paddingObj = this._padding;
	        let padding = paddingObj.top + ' ' + paddingObj.left + ' ' + paddingObj.right + ' ' + paddingObj.bottom; // No I18N; /* getting elem.css("padding") not working in firefox */
	        this._pane.css('padding', padding); // No i18N
	    }
	    _checkProps() {
	        let opts = this._opts,
	            showOnHover = opts.showTrackOnScrollbarHover;
	        if (showOnHover === null) {
	            showOnHover = !this._showAlways;
	        } else {
	            showOnHover = this._showAlways ? showOnHover : true; /* If false, then showScrollbar should be shown always */
	        }
	        opts.showTrackOnScrollbarHover = showOnHover;
	        // if (opts.showOnExpandedState === undefined) {
	        //     opts.showOnExpandedState = this._showAlways;
	        // }
	    }
	    _bindCommonEv() {
	        let keydownEv = 'keydown.' + this.name;// No I18N
	        this._origEle.off(keydownEv).on(keydownEv, this._keydownHandler.bind(this));
	    }
	    _constructTrack(vertical) {
	        let showOnHover = this._opts.showTrackOnScrollbarHover;
	        let orientation = vertical ? 'vertical' : 'horizontal'; // No I18N
	        let hoverClass = showOnHover ? '' : `zscrollbar--${orientation}--hover`;
	        let container = `
	                <div class="zscrollbar--${orientation}  ${hoverClass}" aria-expanded=false>
	                    <div class="zscrollbar__track zscrollbar__track--${orientation}">
	                        <div class="zscrollbar__thumb zscrollbar__thumb--${orientation}">
	                        </div>
	                    </div>
	                </div>
	            `
	        return $(container).appendTo(this._origEle);
	    }
	    _calcCrctHtWd(paneWd, paneHt) {
	        if (this._opts.showScrollbar === 'always') { // No I18N
	            let dummyTrack = this._constructTrack();
	            this._origEle.append(dummyTrack);
	            let correctionPx = this._correctionPx = dummyTrack.width(20).outerHeight();
	            dummyTrack.remove();
	            let scrollWd = this._correctWd = this._contentScrollWd;
	            let scrollHt = this._correctHt = this._contentScrollHt;
	            let verticalScroll = this._opts.verticalScroll;
	            let horizontalScroll = this._opts.horizontalScroll;
	            if (verticalScroll && horizontalScroll) {
	                let findPaneWd = horizontalScroll && scrollWd <= this._elemWd;
	                let findPaneHt = verticalScroll && scrollHt <= this._elemHt;
	                if (findPaneWd || findPaneHt) {
	                    let dummyContainer = this._pane.clone().css({
	                        position: 'absolute', // No I18N
	                        visibility: 'hidden', // No I18N
	                        width: findPaneWd ? 'auto' : paneWd, // No I18N
	                        height: findPaneHt ? 'auto' : paneHt // No I18N
	                    });
	                    this._origEle.prepend(dummyContainer);
	                    if (findPaneWd) {
	                        this._correctWd = dummyContainer.width();
	                    }
	                    if (findPaneHt) {
	                        this._correctHt = dummyContainer.height();
	                    }
	                    dummyContainer.remove();
	                }
	                let addedForHor = false;
	                let calcVertical = () => {
	                    if (scrollHt > this._elemHt) {
	                        let pxToAdd = ((this._correctWd - correctionPx) <= this._elemWd) ? 0 : correctionPx;
	                        scrollWd += pxToAdd;
	                        addedForHor = true;
	                    }
	                }
	                let calcHorizontal = () => {
	                    if (scrollWd > this._elemWd) {
	                        let pxToAdd = ((this._correctHt - correctionPx) <= this._elemHt) ? 0 : correctionPx;
	                        if (pxToAdd) {
	                            scrollHt += pxToAdd;
	                            !addedForHor && calcVertical();
	                        }
	                    }
	                }
	                calcVertical();
	                calcHorizontal();
	                this._contentScrollWd = scrollWd;
	                this._contentScrollHt = scrollHt;
	            }
	            let paneCSS = {};
	            if (verticalScroll && scrollHt > this._elemHt) {
	                paneCSS['padding-' + ZC.getRTLBasedDir('right', this._opts.rtl)] = correctionPx + parseFloat(this._padding.right) + 'px'; // No I18N
	            }
	            if (horizontalScroll && scrollWd > this._elemWd) {
	                paneCSS['padding-bottom'] = correctionPx + parseFloat(this._padding.bottom) + 'px'; // No I18N
	            }
	            this._pane.css(paneCSS);
	        }
	    }
	    _buildScrollBar(firstInit) {
	        let opts = this._opts,
	            horizontal = opts.horizontalScroll,
	            vertical = opts.verticalScroll;
	        if (vertical) {
	            this._setVerValues();
	        }
	        if (horizontal) {
	            this._setHorValues();
	        }
	        horizontal && this._buildXTrack(); // cannot be called inside the block since, this._vertical and this._horizontal are interdependent
	        vertical && this._buildYTrack();
	        if (firstInit) {
	            this._bindEvents();
	        }
	        if (this._showAlways && !opts.showTrackOnScrollbarHover) {
	            if (this._vertical && this._horizontal) {
	                if (!this._cornerDiv) {
	                    this._cornerDiv = $('<div class="zscrollbar__corner">').css({
	                        width: this._vTrackWd,
	                        height: this._hTrackHt
	                    })
	                    this._origEle.append(this._cornerDiv);
	                }
	            } else if (this._cornerDiv) {
	                this._cornerDiv.remove();
	                this._cornerDiv = undefined;
	            }
	        }
	        this._updateThumbPos();
	    }
	    _addAriaLabels(isVertical) {
	        let container;
	        if (isVertical) {
	            container = this._vContainer;
	        } else {
	            container = this._hContainer;
	        }
	        container.attr({
	            role: 'scrollbar', // No I18N
	            'aria-controls': this._elemId, // No I18N
	            'aria-orientation': isVertical ? 'vertical' : 'horizontal', // No I18N
	            'aria-valuemin': 0, // No I18N
	            'aria-valuemax': isVertical ? this._maxScrollY : this._maxScrollX, // No I18N
	            'aria-valuenow': isVertical ? this._opts.scrollTop : this._opts.scrollLeft // No I18N
	        })
	    }
	    _updateThumbPos() {
	        let opts = this._opts;
	        if (this._vertical && this._finalVBarTop) {
	            this._scrollPosY(undefined, (opts.scrollTop / this._maxScrollY) * this._maxDragY);
	        }
	        if (this._horizontal && this._finalHBarLeft) {
	            this._scrollPosX(undefined, (opts.scrollLeft / this._maxScrollX) * this._maxDragX);
	        }
	    }
	    _bindTrackEv(isVertical) {
	        let base = this,
	            cName = this.name,
	            barMousedownHandler = this._barMousedownHandler.bind(this, isVertical),
	            trackMousedownHandler = this._trackMousedownHandler.bind(this, isVertical),
	            mousedownEv = 'mousedown.' + cName, // No I18N
	            showMethod = isVertical ? '_showVtrack' : '_showHtrack', // No I18N
	            hideMethod = isVertical ? '_hideVtrack' : '_hideHtrack', // No I18N
	            container = isVertical ? this._vContainer : this._hContainer;
	        if (isVertical) {
	            this._vBar.on(mousedownEv, barMousedownHandler);
	            this._vTrack.on(mousedownEv, trackMousedownHandler);
	        } else {
	            this._hBar.on(mousedownEv, barMousedownHandler);
	            this._hTrack.on(mousedownEv, trackMousedownHandler);
	        }
	        container.on('mouseenter.' + cName + ' mousedown.' + cName, (ev) => { // No I18N
	            if (ev.type === 'mouseenter') {
	                base._trackMouseEnter = isVertical ? 'vertical' : 'horizontal'; // No I18N
	            }
	            base[showMethod]();
	        }).on('mouseleave.' + cName, () => { // No I18N
	            base._trackMouseEnter = undefined;
	            base[hideMethod]();
	        });
	    }
	    _trackMousedownHandler(isVertical, orgEvent) {
	        let target = $(orgEvent.target),
	            track = isVertical ? this._vTrack : this._hTrack,
	            isShown = isVertical ? this._vTrackShown : this._hTrackShown;
	        if (target.is(track) && isShown) {
	            orgEvent.preventDefault();
	            orgEvent.stopPropagation();
	            this._handleDocMouseEv();
	            this._isFirstMove = true;
	            if (isVertical) {
	                this._vTrackMouseup = false;
	                this._moveVbar(orgEvent);
	            } else {
	                this._hTrackMouseup = false;
	                this._moveHbar(orgEvent);
	            }
	        }
	    }
	    _barMousedownHandler(isVertical, ev) {
	        let base = this,
	            cName = '.' + this.name,
	            isRtl = this._opts.rtl,
	            isShown,
	            showMethod,
	            method;
	        ev.preventDefault();
	        ev.stopPropagation(); // If not stopped, triggers mousedown for pane
	        this._mousedown = true;
	        if (isVertical) {
	            this._startVal = ev.pageY - this._vBar.position().top;
	            method = '_scrollPosY'; // No I18N
	            showMethod = '_showVtrack'; // No I18N
	        } else {
	            this._startVal = ev.pageX + (isRtl ? this._finalHBarLeft : -this._hBar.position().left);
	            method = '_scrollPosX'; // No I18N
	            showMethod = '_showHtrack'; // No I18N
	        }
	        ZC.$document.on('mousemove' + cName, function(orgEvent) { // No I18N
	            isShown = isVertical ? base._vBarShown : base._hBarShown;
	            if (!isShown) {
	            /* On hiding, due to opacity setting, mousedown over bar does not shows the scrollbar. Happens when showScrollbar set as "onscroll" */
	                base._showOrHideScroll(isVertical);
	                base[showMethod]();
	            }
	            orgEvent.preventDefault();
	            let value = (isVertical ? orgEvent.pageY : orgEvent.pageX);
	            value = (isRtl && !isVertical) ? base._startVal - value : value - base._startVal;
	            base[method](orgEvent, value);
	        }).on('mouseup' + cName, function(orgEvent) {		// No I18N
	            orgEvent.preventDefault();
	            base._mousedown = false;
	            ZC.$document.off(cName);
	        });
	    }
	    _getIcon(iconCls = '', svgCls = '', svgId = '') {
	        return '<i class="' + iconCls + '"><svg class="' + svgCls + '"><use xlink:href="#' + svgId + '"></use></svg></i>';
	    }
	    _saveContentSize() {
	        let opts = this._opts;
	        if (opts.verticalScroll) {
	            this._contentScrollHt = this._pane[0].scrollHeight;
	        }
	        if (opts.horizontalScroll) {
	            this._contentScrollWd = this._pane[0].scrollWidth;
	        }
	    }
	    _bindEvents() {
	        let base = this,
	            cName = this.name,
	            elem = this._origEle;
	        elem.on('mousewheel.' + cName, this._mouseWheelHandler.bind(this)) 	// No I18N
	            .on('mouseenter.' + cName, function() {	// No I18N
	                base._mouseLeave = false;
	                base._isActive = true;
	                if (base._showOnHover) {
	                    base._vertical && base._showOrHideScroll(true);
	                    base._horizontal && base._showOrHideScroll(false);
	                }
	            }).on('mouseleave.' + cName, function() { // No I18N
	                base._isActive = false;
	                base._mouseLeave = true;
	                if (!base._showAlways) {
	                    base._vertical && base._hideVtrack();
	                    base._horizontal && base._hideHtrack();
	                }
	            }).on('mousemove.' + cName, () => base._isActive = true); // No I18N
	        this._pane.on('mousedown.' + cName, this._mouseDownHandler.bind(this)); // No I18N
	        if (this._isBtns) {
	            this._bindBtnEv();
	        }
	    }
	    _keydownHandler(ev) {
	        if (!ev.shiftKey) {
	            let opts = this._opts,
	                keyCode = ev.keyCode,
	                keys = ZC.keyCode,
	                isBigStep = [ keys.PAGE_DOWN, keys.PAGE_UP, keys.SPACE ].indexOf(keyCode) > -1,
	                homeOrEnd = [ keys.HOME, keys.END ].indexOf(keyCode) > -1,
	                btn = ev.currentTarget.id.replace('Btn-' + this._elemId, ''); // No I18N
	            btn = [ 'up', 'down', 'left', 'right' ].indexOf(btn) > -1 ? keys[btn.toUpperCase()] : undefined; // No I18N
	            if ([ keys.LEFT, keys.RIGHT, keys.UP, keys.DOWN ].indexOf(keyCode) > -1 || isBigStep || homeOrEnd || btn) {
	                if (opts.disableKeyboardScroll) {
	                    return false;
	                }
	                this._handleKeydown(ev, isBigStep, homeOrEnd, btn);
	            }
	        }
	    }
	    _mouseDownHandler(ev) {
	        if (this._opts.scrollOnSelectionDrag) {
	            this._handleScrollOnSelection(ev);
	        }
	    }
	    _mouseWheelHandler(orgEvent, delta, deltaX, deltaY) {
	        let isVertical = true,
	            isActive = this._isActive,
	            oldDeltaX = this._oldDeltaX,
	            oldDeltaY = this._oldDeltaY;
	        if (!isActive) {
	            return false;
	        }
	        // if (ZC.Browser.isMobile) {
	        //     delta = orgEvent.detail[1];
	        //     deltaX = orgEvent.detail[2];
	        //     deltaY = orgEvent.detail[3];
	        //     orgEvent = orgEvent.detail[0];
	        // }
	        if (this._vertical && (oldDeltaX === undefined || oldDeltaY !== 0 || !Object.is(oldDeltaY, -0) || deltaY !== 0) && (oldDeltaX === 0 || Object.is(oldDeltaX, -0))) {
	            oldDeltaY = this._oldDeltaY = deltaY;
	        }
	        if (this._horizontal && (oldDeltaX !== 0 || !Object.is(oldDeltaX, -0) || deltaX !== 0) && (oldDeltaY === 0 || Object.is(oldDeltaY, -0) || oldDeltaY === undefined)) {
	            this._oldDeltaX = deltaX;
	            isVertical = false;
	        }
	        if (isActive) {
	            this._showOne(isVertical);
	        }
	        let factor = this._opts.scrollSensivity || orgEvent.deltaFactor,
	            dX = this._finalHBarLeft,
	            dY = this._finalVBarTop;
	        this._scrollContent(orgEvent, deltaX * factor, -deltaY * factor, isVertical);
	        return this._opts.stopPropagation ? false : (isVertical ? dY === this._finalVBarTop : dX === this._finalHBarLeft);
	    }
	    _scrollContent(orgEvent, deltaX, deltaY, isVertical) {
	        let position = this._pane.position();
	        if (isVertical) {
	            if (this._vertical) {
	                let destY = Math[deltaY < 0 ? 'floor' : 'ceil'](deltaY) - position.top; // No I18N
	                this._scrollPosY(orgEvent, (destY / this._maxScrollY) * this._maxDragY, null);
	            }
	        } else if (this._horizontal) {
	            let isRtl = this._opts.rtl;
	            if (isRtl) {
	                deltaX *= -1;
	            }
	            let destX = Math[deltaX < 0 ? 'floor' : 'ceil'](deltaX) - (isRtl ? parseInt(this._pane.css('right')) : position.left); // No I18N
	            this._scrollPosX(orgEvent, (destX / this._maxScrollX) * this._maxDragX, null);
	        }
	    }
	    _animateScroll(isLeft, value, animation, elem, prop) {
	        prop = prop || (isLeft ? this._opts.rtl ? 'right' : 'left' : 'top'); // No I18N
	        prop = {
	            [prop]: value
	        }
	        if (animation) {
	            elem.animate(prop, animation.duration, animation.name); // No I18N
	        } else if (this._animate) {
	            elem.animate(prop, 100, 'swing'); // No I18N
	        } else {
	            elem.css(prop); // No I18N
	        }
	    }
	    _showCue(top, left) {
	        let show = this._display.bind(this);
	        if (top !== undefined && this._verCue) {
	            top = Math.floor(top) // to avoid values like 0.000000014
	            show(top === 0, this._verCue);
	        }
	        if (left !== undefined && this._horCue) {
	            left = Math.floor(left);
	            show(left === 0, this._horCue);
	        }
	    }
	    _showOne(isVertical) {
	        if (this._showOnScroll) {
	            clearTimeout(this[isVertical ? '_verTimeout' : '_horTimeout']); // No I18N
	            this._showOrHideScroll(isVertical, false);
	            this._showOrHideScroll(!isVertical, true);
	        }
	        if (this._opts.showTrackOnScrollbarHover) {
	            /* While scrolling over the track, bar is shown. But since track mouseenter event will not be taken into account at that time, it is not shown even when cursor is over it. So, the following handling is done. */
	            let isTrackShown,
	                showMethod,
	                trackHovered = this._trackMouseEnter;
	            if (trackHovered) {
	                if (trackHovered === 'vertical') {
	                    if (isVertical) {
	                        isTrackShown = this._vTrackShown;
	                        showMethod = '_showVtrack'; // No I18N
	                    }
	                } else if (!isVertical) {
	                    isTrackShown = this._hTrackShown;
	                    showMethod = '_showHtrack'; // No I18N
	                }
	                if (!isTrackShown && showMethod) { /* showMethod check is needed when hovering vertical track and scrolling horizontally and vice versa */
	                    this[showMethod]();
	                }
	            }
	        }
	    }
	    _showOrHideScroll(isVertical, hide) {
	        let show = this._display.bind(this),
	            animate = this._opts.animateOnHide,
	            isBarShown,
	            isTrackShown,
	            track,
	            bar;
	        if (isVertical) {
	            bar = this._vBar;
	            track = this._vTrack;
	            isBarShown = this._vBarShown;
	            isTrackShown = this._vTrackShown;
	            this._vBarShown = !hide;
	        } else {
	            bar = this._hBar;
	            track = this._hTrack;
	            isBarShown = this._hBarShown;
	            isTrackShown = this._hTrackShown;
	            this._hBarShown = !hide;
	        }
	        if (bar && track) {
	            if (hide) {
	                isBarShown && show(!isTrackShown, bar);
	            } else if (!isBarShown) {
	                /* It is stopped for displaying it because the scrollbar is animated only when it is hidden. And hence, It is not done for hiding. */
	                if (animate && !this._showAlways) { /* for always case, fadeOut may not be applicable, since it is present always. */
	                    bar.stop(true, true);
	                }
	                show(false, bar);
	            }
	        }
	    }
	    _handleDocMouseEv() {
	        let $document = ZC.$document,
	            base = this;
	        $document.one('mouseup.' + this.name, function() {
	            base._btnMouseup = base._vTrackMouseup = base._hTrackMouseup = true;
	            base._animate = false;
	        });
	    }
	    _startMouseDownTimer(ev, isVertical) {
	        let timeout = this._isFirstMove ? 400 : 100;
	        this._isFirstMove = undefined;
	        clearTimeout(this._mouseDownTimer);
	        this._mouseDownTimer = setTimeout(this._repetitiveMouseDownHandler.bind(this, ev, isVertical), timeout);
	    }
	    _repetitiveMouseDownHandler(ev, isVertical) {
	        if (isVertical && !this._vTrackMouseup) {
	            this._moveVbar(ev)
	        } else if (isVertical === false && !this._hTrackMouseup) {
	            this._moveHbar(ev);
	        } else if (isVertical === undefined && !this._btnMouseup) {
	            this._keydownHandler(ev);
	        } else {
	            clearTimeout(this._mouseDownTimer);
	        }
	    }
	    _dispatchScrollEndEv(orgEvent, finalValue, value, isVertical) {
	        let scroll = isVertical ? 'vertical' : 'horizontal', // No I18N
	            eventObj = {
	                scrollBarPos: finalValue,
	                [isVertical ? 'scrollTop' : 'scrollLeft']: value, // No I18N
	                scroll
	            },
	            isBothEnded = (this._horizontal ? this._finalHBarLeft === this._maxDragX : true) && (this._vertical ? this._finalVBarTop === this._maxDragY : true);
	        this._dispatchEvent(scroll + 'scrollend', orgEvent, eventObj); // No I18N
	        isBothEnded && this._dispatchEvent('scrollend', orgEvent, eventObj);// No I18N
	    }
	    update() {
	        // revisit -native
	        if (this.element.is(':visible')) { // No I18N
	            let actualElement = this._origEle,
	                opts = this._opts,
	                isUpdated;
	            if ((opts.verticalScroll && actualElement.outerHeight() !== this._elemHt) || (opts.horizontalScroll && actualElement.outerWidth() !== this._elemWd)) {
	                this._initialize();
	                isUpdated = true;
	            } else {
	                let oldHt = this._contentScrollHt,
	                    oldWd = this._contentScrollWd;
	                this._saveContentSize();
	                if ((opts.horizontalScroll && oldWd !== this._contentScrollWd) || (opts.verticalScroll && oldHt !== this._contentScrollHt)) {
	                    this._buildScrollBar();
	                    isUpdated = true;
	                }
	            }
	            if (isUpdated) {
	                this._dispatchEvent('update', undefined, { // No I18N
	                    scrollTop: opts.scrollTop,
	                    scrollLeft: opts.scrollLeft
	                })
	            }
	        }
	    }
	    resetScrollPosition() {
	        // revisit-native
	        this._opts.scrollTop = this._opts.scrollLeft = 0;
	        this._pane.css({
	            top: '0px', // No I18N
	            left: '0px' // No I18N
	        });
	        this._horizontal && this._hBar.css('left', '0px');	// No I18N
	        this._vertical && this._vBar.css('top', '0px');	// No I18N
	        this._showCue(0, 0);
	        this._disableHorBtns(0);
	        this._disableVerBtns(0);
	    }
	    _setAttribute(name, value) {
	        let opts = this._opts,
	            isTopOrLeft = [ 'scrollTop', 'scrollLeft' ].indexOf(name) > -1, // No I18N
	            oldVal = opts[name];
	        !isTopOrLeft && (opts[name] = value);
	        if (name === 'autoUpdate') { // No I18N
	            this._autoUpdateHandler();
	        } else if ([ 'verticalScroll', 'horizontalScroll' ].indexOf(name) > -1) { // No I18N
	            this.update();
	        } else if (isTopOrLeft) {
	            this._attrModified = name;
	            this[name === 'scrollTop' ? 'setScrollTop' : 'setScrollLeft'](value);// No I18N
	        } else if (name === 'className') { // No I18N
	            this.element.removeClass(oldVal).addClass(value);
	        } else {
	            this._setAdvancedAttr(name, value);
	        }
	        this._attrModified = undefined;
	    }
	    _destroy() {
	        let cName = '.' + this.name,
	            element = this.element;
	        element.off(cName);	// No I18N
	        // revisit -native
	        let container = this._origEle;
	        if (this._opts.autoResize) {
	            this._handleAutoResizeEle(true);
	        }
	        ZC.$document.off(cName);	// No I18N
	        container.find('.zscrollbar__content').children().unwrap(); // No I18N
	        if (this._isUL) {
	            container.children().unwrap();
	            container.remove();
	        }
	        element.removeClass('zscrollbar--container zscrollbar--withbuttons').css(this._initialWdAndHt);
	        clearTimeout(this._autoUpdateTimer);
	        clearTimeout(this._cleartimeout);
	        clearTimeout(this._mouseDownTimer);
	        this._pane.remove();
	        if (this._cornerDiv) {
	            this._cornerDiv.remove();
	            this._cornerDiv = undefined;
	        }
	        if (this._horizontal) {
	            this._destroyHorScroll();
	        }
	        if (this._vertical) {
	            this._destroyVerScroll();
	        }
	        this._setUndefined([ 'pane', 'isBtns', 'isCustom', 'showOnHover', 'showAlways', 'showOnScroll', 'initialized' ], ''); // No I18N
	    }
		_handleAutoResizeEle  (remove) {
		    let scrollBindings = ZC.scrollBindings,
		        isEmpty = !scrollBindings.length,
		        elem = this.element;
		    if (remove) {
		        scrollBindings.splice(scrollBindings.indexOf(elem), 1);
		        isEmpty = !scrollBindings.length
		        if (isEmpty) {
		            clearTimeout(this._resizeTimeOut);
		            ZC.$window.off('.' + this.name);
		        }
		    } else {
		        if (isEmpty) {
		            this._bindResizeEv();
		        }
		        scrollBindings.push(elem);
		    }
		}
		_bindResizeEv  () {
		    let eventName = 'resize.' + this.name, // No I18N
		        base = this;
		    ZC.$window.off(eventName).on(eventName, function() {
		        let scrollBindings = ZC.scrollBindings,
		            len = scrollBindings.length;
		        // timeout is set because while called synchronously, width/height wouldn't be set at that time.
		        clearTimeout(base._resizeTimeOut);
		        if (len) {
		            base._resizeTimeOut = setTimeout(() => {
		                for (let i = 0; i < len; i++) {
		                    let elem = $(scrollBindings[i]),
		                        instance = elem.data('zscrollbar'); // No I18N
		                    if (instance && elem.is(':visible')) { // No I18N
		                        instance.update();
		                    }
		                }
		            }, 0)
		        }
		    });
		}
		_autoUpdateHandler  (doNotCall) {
		    let opts = this._opts;
		    clearTimeout(this._autoUpdateTimer);
		    if (opts.autoUpdate) {
		        !doNotCall && this.update();
		        this._autoUpdateTimer = setTimeout(this._autoUpdateHandler.bind(this), opts.autoUpdateDelay);
		    }
		}
		_createElasticScroll  (bounceVal, orgEvent, isEnd, isVertical) {
		    let opts = this._opts,
		        shouldCheckRtl = opts.rtl && !isVertical;
		    if (shouldCheckRtl) {
		        isEnd = !isEnd;
		    }
		    let condtn = bounceVal - ((shouldCheckRtl ? !isEnd : isEnd) ? 0 : isVertical ? this._maxScrollY : this._maxScrollX) > (ZC.OS.isWindows() && ZC.Browser.isChrome ? 30 : 120);
		    if (condtn) {
		        let classArr,
		            dirArr,
		            base = this,
		            pane = this._pane;
		        if (isVertical) {
		            classArr = [ 'zscrollbar--elastic--bottom', 'zscrollbar--elastic--top' ]; // No I18N
		            dirArr = [ 'bottom', 'top' ]; // No I18N
		        } else {
		            classArr = [ 'zscrollbar--elastic--right', 'zscrollbar--elastic--left' ]; // No I18N
		            dirArr = [ 'right', 'left' ]; // No I18N
		        }
		        let bounceCls = isEnd ? classArr[0] : classArr[1];
		        this._dispatchEvent('beforeelasticeffect', orgEvent, { // No I18N
		            direction: isEnd ? dirArr[0] : dirArr[1],
		            scrollTop: opts.scrollTop,
		            scrollLeft: opts.scrollLeft
		        })
		        pane.addClass(bounceCls);
		        clearTimeout(base._cleartimeout);
		        base._cleartimeout = setTimeout(() => {
		            pane.removeClass(bounceCls);
		        }, 100);
		    }
		}
		_createHorBtns  (destroy, rebuild) {
		    let hContainer = this._hContainer,
		        shoudBuild = rebuild === undefined ? !destroy : rebuild,
		        opts = this._opts,
		        id = this._elemId,
		        leftBtn;
		    if (destroy) {
		        this._btnWd = 0;
		        $('#leftBtn-' + id).remove();
		        $('#rightBtn-' + id).remove();
		    }
		    if (shoudBuild) {
		        leftBtn = this._getBtn('leftBtn', opts.scrollLeftButtonIconClassName, opts.scrollLeftButtonSVGIconId || 'zc__svg--arrowleft'); // No I18N
		        hContainer.prepend(leftBtn);// No I18N
		        hContainer.append(this._getBtn('rightBtn', opts.scrollRightButtonIconClassName, opts.scrollRightButtonSVGIconId || 'zc__svg--arrowright'));// No I18N
		        this._btnWd = leftBtn.innerHeight();
		    }
		}
		_disableHorBtns  (value) {
		    this._disable(value === 0, $('#leftBtn-' + this._elemId));
		    this._disable(value === this._maxScrollX, $('#rightBtn-' + this._elemId));
		}
		_setHorInitialState  (opts) {
		    this.setScrollLeft(opts.scrollLeft);
		    opts.scrollbarSize !== 8 && this._hBar.height(opts.scrollbarSize);
		}
		_setHorValues  () {
		    this._maxScrollX = this._contentScrollWd - this._elemWd;
		    this._percentInViewX = this._contentScrollWd / this._elemWd;
		    this._horizontal = this._percentInViewX > 1;
		}
		_buildXTrack  () {
		    let hTrack = this._hTrack,
		        hContainer = this._hContainer,
		        opts = this._opts;
		    if (this._horizontal) {
		        if (!hContainer) {
		            let showOnHover = opts.showTrackOnScrollbarHover;
		            this._finalHBarLeft = 0;
		            hContainer = this._hContainer = $('<div class="zscrollbar--horizontal ' + (showOnHover ? '' : 'zscrollbar--horizontal--hover') + '" aria-expanded="' + !showOnHover + '">');// No I18N
		            hTrack = this._hTrack = $("<div class='zscrollbar__track zscrollbar__track--horizontal'>").appendTo(hContainer); // No I18N
		            this._hBar = $("<div class='zscrollbar__thumb zscrollbar__thumb--horizontal'>").appendTo(hTrack); // No I18N
		            this._addAriaLabels();
		            this._createHorThumbGrippy();
		            if ([ 'scroll', 'hscroll' ].indexOf(opts.contentScrolledCueFor) > -1) { // No I18N
		                this._createHorCue();
		            }
		            hContainer.appendTo(this._origEle);
		            this._btnWd = 0;
		            if (this._isBtns) {
		                this._createHorBtns();
		            }
		            this._hTrackHt = hTrack.height();
		            this._bindTrackEv();
		        }
		        this._setHorSBarSize();
		        this._showAlways && this._showOrHideScroll();
		    } else if (hContainer) {
		        this._destroyHorScroll();
		        this._hContainer = this._hTrack = this._hBar = this._finalHBarLeft = this._horCue = this._hTrackHt = this._btnWd = this._hBarWd = this._hBarShown = this._hTrackShown = undefined;
		    }
		}
		_createHorThumbGrippy  (remove) {
		    let opts = this._opts,
		        hBar = this._hBar,
		        grippyCls = 'zscrollbar__grippy'; // No I18N
		    if (remove) {
		        hBar.find('.' + grippyCls).remove();
		    }
		    if (opts.thumbGrippy) {
		        // hBar.append($(this._getIcon(grippyCls + ' ' + (opts.horizontalGrippyIconClassName || ''), undefined, opts.horizontalGrippySVGIconId || 'hor-grippy__svg')));
		        hBar.append($(this._getIcon(grippyCls + ' ' + (opts.horizontalGrippyIconClassName || ''), undefined, opts.horizontalGrippySVGIconId))); // revisit - default SVGId is removed since it is handled in css itself.
		    }
		}
		_setHorSBarSize  () {
		    let hTrackWidth = this._origEle.innerWidth() - (this._vertical ? this._hTrackHt : 0) - 2 * this._btnWd,
		        hWidth = Math.ceil(1 / this._percentInViewX * hTrackWidth);
		    hWidth = Math.max(this.minBarSize, hWidth);
		    if (this._opts.thumbGrippy && hWidth % 2 !== 0) {
		        hWidth++; // converting to even number for grippy to be centered
		    }
		    this._hTrack.css('width', hTrackWidth);	// No I18N
		    this._hTrackWd = hTrackWidth;
		    let hBar = this._hBar,
		        cssProps = window.getComputedStyle(hBar[0]);
		    hBar.css('width', hWidth);	// No I18N
		    hWidth += parseInt(cssProps['margin-right'] || 0) + parseInt(cssProps['margin-left'] || 0); // No I18N
		    this._maxDragX = hTrackWidth - hWidth;
		    this._hBarWd = hWidth;
		}
		_scrollPosX  (orgEvent, finalHBarLeft, animation, forceSet) {
		    if (this._horizontal) {
		        let opts = this._opts,
		            stopPropagation = opts.stopPropagation,
		            dispatchEv = this._dispatchEvent.bind(this),
		            shouldApplyBounce,
		            isEndReached,
		            horLeftvalue,
		            evObj,
		            bounceVal = Math.abs(this._maxScrollX - (finalHBarLeft / this._maxDragX * this._maxScrollX));
		        if (finalHBarLeft < 0 || finalHBarLeft > this._maxDragX) {
		            finalHBarLeft = finalHBarLeft <= 0 ? 0 : this._maxDragX;
		            isEndReached = !!finalHBarLeft;
		            if ([ 'hscroll', 'scroll' ].indexOf(opts.elasticScrollEffect) > -1 && stopPropagation) {
		                this._pane.removeClass('zscrollbar--elastic--right zscrollbar--elastic--left');// No I18N
		                shouldApplyBounce = orgEvent && orgEvent.type === 'mousewheel'; // No I18N
		            }
		            // if (!ZC.Browser.isMobile && opts.stopPropagation) {
		            if (stopPropagation) {
		                orgEvent && orgEvent.preventDefault();
		            }
		        } else {
		            orgEvent && orgEvent.stopPropagation();
		        }
		        horLeftvalue = (finalHBarLeft / this._maxDragX) * (this._maxScrollX);
		        evObj = {
		            scrollBarPos: finalHBarLeft,
		            scrollLeft: horLeftvalue,
		            scroll: 'horizontal', // No I18N
		            maxScrollValue: this._maxDragX
		        };
		        /* Since if size changed, thumb has to be repositioned. But the value will not be changed. Hence, sizeChanged is used. */
		        if ((opts.scrollLeft !== horLeftvalue || !this._initialized || this._sizeChanged || forceSet) && dispatchEv('horizontalscrollstart', orgEvent, evObj)) { // No I18N
		            this._hContainer.attr('aria-valuenow', horLeftvalue); // No I18N
		            this._positionX(orgEvent, finalHBarLeft, animation, horLeftvalue);
		            dispatchEv('scroll', orgEvent, evObj); // No I18N
		            if (isEndReached) {
		                this._dispatchScrollEndEv(orgEvent, finalHBarLeft, horLeftvalue);
		            }
		            if (this._isBtns) {
		                this._disableHorBtns(horLeftvalue);
		            }
		        }
		        if (shouldApplyBounce && (!horLeftvalue || isEndReached)) {
		            this._createElasticScroll(bounceVal, orgEvent, isEndReached);
		        }
		        !this._btnClick && this._hideHtrack();
		    }
		}
		_positionX  (orgEvent, finalHBarLeft, animation, horLeftvalue) {
		    this._opts.scrollLeft = horLeftvalue;
		    this._finalHBarLeft = finalHBarLeft;
		    this._showCue(undefined, horLeftvalue);
		    animation = this._animate ? null : (animation || this._opts.animation);
		    this._animateScroll(true, finalHBarLeft, animation, this._hBar);
		    this._animateScroll(true, -horLeftvalue, animation, this._pane);
		}
		_moveHbar  (orgEvent) {
		    !this._hTrackShown && this._showHtrack();
		    let offset = this._hTrack.offset(),
		        pos,
		        direction,
		        step = this._opts.step,
		        isRtl = this._opts.rtl,
		        value,
		        condtn;
		    this._animate = true;
		    if (isRtl) {
		        pos = (offset.left + this._hTrackWd - orgEvent.pageX) - this._hBarWd / 2;
		        direction = orgEvent.pageX - offset.left - this._hBar.position().left; /* Since finalHBarLeft value contains right position value, position() is used for rtl */
		    } else {
		        pos = orgEvent.pageX - offset.left - this._hBarWd / 2;
		        direction = orgEvent.pageX - offset.left - this._finalHBarLeft;
		    }
		    value = this._finalHBarLeft + step * ((isRtl ? direction < 0 : direction > 0) ? 1 : -1);
		    if (isRtl) {
		        condtn = direction < 0;
		    } else {
		        condtn = direction > 0;
		    }
		    value = (condtn ? value < pos : value > pos) ? value : pos;
		    this._scrollPosX(orgEvent, value);
		    this._startMouseDownTimer(orgEvent, false);
		}
		_showHtrack  () {
		    clearTimeout(this._horTimeout);
		    if (this._horizontal && !this._hTrackShown && this._hBarShown) { // No I18N
		        this._setHTrackClass(true);
		    }
		}
		_hideHtrack  () {
		    let base = this,
		        opts = base._opts;
		    clearTimeout(this._horTimeout);
		    this._horTimeout = setTimeout(function() {
		        if (base._horizontal && (base._hBarShown || base._hTrackShown) && (!base._mousedown || base._showOnScroll)) {
		            base._setHTrackClass();
		            if (base._showOnScroll || base._showOnHover && base._mouseLeave) {
		                base._hBarShown = false;
		                base._hBar[opts.animateOnHide ? 'fadeOut' : 'hide'](); // No I18N
		            }
		        }
		    }, opts.hideDelay);
		}
		_setHTrackClass  (add) {
		    let opts = this._opts,
		        container = this._hContainer,
		        ariaexpanded = add && opts.expandOnMouseover,
		        className = 'zscrollbar--horizontal--hover'; // No I18N
		    if (add) {
		        container.addClass(className);
		    } else {
		        opts.showTrackOnScrollbarHover && container.removeClass(className);
		        ariaexpanded = false;
		    }
		    container.attr('aria-expanded', ariaexpanded); // No I18N
		    this._hTrackShown = !!add;
		}
		setScrollLeft  (left, animation) {
		    // used to set left value for the content
		    let opts = this._opts,
		        initialized = this._initialized,
		        isAttrModified = [ 'scrollLeft', 'rtl' ].indexOf(this._attrModified) > -1; // No I18N
		    if (this._horizontal && (!initialized || opts.scrollLeft !== left || isAttrModified)) { // No I18N
		        let maxVal = this._maxScrollX;
		        left = left < 0 ? 0 : (left > maxVal ? maxVal : left);
		        initialized && this._showOne();
		        this._scrollPosX(undefined, (left / maxVal) * this._maxDragX, animation, isAttrModified);
		    }
		}
		_destroyHorScroll  () {
		    this._horTimeout && clearTimeout(this._horTimeout);
		    this._hContainer.remove();
		    this._createHorCue(true);
		}
		_handleKeydown  (ev, isBigStep, homeOrEnd, btn) {
		    // revisit - native
		    let keys = ZC.keyCode,
		        isMousedown = ev.type === 'mousedown',
		        keyCode = isMousedown ? btn : ev.keyCode,
		        opts = this._opts,
		        step = opts[ isBigStep ? 'spaceBarKeyStep' : 'arrowKeysStep'], // No I18N
		        isVertical = false,
		        fn,
		        value;
		    this._btnClick = isMousedown;
		    ev.preventDefault();
		    if ([ keys.DOWN, keys.UP ].indexOf(keyCode) > -1 || isBigStep || homeOrEnd) {
		        /* this._vertical check is added inside because, if it is false, horizontal scroll will happen for vertical scroll key press. */
		        if (this._vertical) {
		            let isUp = [ keys.UP, keys.PAGE_UP, keys.HOME ].indexOf(keyCode) > -1;
		            isVertical = true;
		            if (ev.metaKey || homeOrEnd) {
		                value = isUp ? 0 : this._maxScrollY;
		            } else {
		                value = isUp ? -step : step;
		            }
		            fn = 'Top'; // No I18N
		        }
		    } else if (this._horizontal) {
		        let isLeft = keyCode === ((opts.rtl && !isMousedown) ? keys.RIGHT : keys.LEFT); // No I18N
		        if (ev.metaKey) {
		            value = isLeft ? 0 : this._maxScrollX;
		        } else {
		            value = isLeft ? -step : step;
		        }
		        fn = 'Left'; // No I18N
		    }
		    if (fn) {
		        this._showOne(isVertical);
		        if (!(ev.metaKey || homeOrEnd)) {
		            value = opts[isVertical ? 'scrollTop' : 'scrollLeft'] + (isVertical ? (value / this._maxDragY * this._maxScrollY) : (value / this._maxDragX * this._maxScrollX)); // No I18N
		        }
		        this['setScroll' + fn](value, { // No I18N
		            name: 'swing', // No I18N
		            duration: 100
		        })
		    }
		    if (isMousedown) {
		        this._startMouseDownTimer(ev);
		    }
		}
		_createHorCue  (remove) {
		    if (remove) {
		        this._horCue && this._horCue.length && this._horCue.remove();
		        this._horCue = undefined;
		    } else if (!this._horCue) {
		        this._horCue = $('<div class="zscrollbar--scrollleftcue" style="display:none"/>');
		        this._origEle.prepend(this._horCue);
		    }
		}
		_createVerCue  (remove) {
		    if (remove) {
		        this._verCue && this._verCue.length && this._verCue.remove();
		        this._verCue = undefined;
		    } else if (!this._verCue) {
		        this._verCue = $('<div class="zscrollbar--scrollupcue" style="display:none"/>');
		        this._origEle.prepend(this._verCue);
		    }
		}
		_getBtn  (id, iconCls = '', svgIconId, svgCls) {
		    return $('<button id="' + id + '-' + this._elemId + '" class="zscrollbar__button">' + this._getIcon('zscrollbar__icon ' + iconCls, svgCls, svgIconId) + '</button>');
		}
		_btnMousedownHandler  (ev) {
		    this._btnMouseup = false;
		    this._handleDocMouseEv();
		    this._isFirstMove = true;
		    this._keydownHandler(ev);
		}
		_bindBtnEv  () {
		    let btns = [ 'upBtn', 'downBtn', 'leftBtn', 'rightBtn' ], // No I18N
		        mousedownEv = 'mousedown.' + this.name;	// No I18N
		    btns.forEach((elem) => {
		        elem = $('#' + elem + '-' + this._elemId); 	// No I18N
		        elem.length && elem.off(mousedownEv).on(mousedownEv, this._btnMousedownHandler.bind(this));
		    })
		}
		_handleScrollOnSelection  () {
		    let base = this,
		        cName = '.' + this.name,
		        ele = this._origEle,
		        rect = ele[0].getBoundingClientRect(), // since If body scrolled, its position changes
		        endHt = rect.top + ele.height(),
		        endWd = rect.left + ele.width();
		    ZC.$document.on('mousemove' + cName, function(orgEvent) {	// No I18N
		        let clientY = orgEvent.clientY,
		            clientX = orgEvent.clientX,
		            opts = base._opts;
		        if (base._vertical && (clientY <= rect.top || clientY >= endHt)) {
		            base.setScrollTop(opts.scrollTop + ((clientY >= endHt ? 1 : -1) * (2 / base._maxDragY * base._maxScrollY)));
		        }
		        if (base._horizontal && (clientX <= rect.left || clientX >= endWd)) {
		            base.setScrollLeft(opts.scrollLeft + ((clientX >= endWd ? 1 : -1) * (2 / base._maxDragX * base._maxScrollX)));
		        }
		    }).one('mouseup' + cName, function() {	// No I18N
		        ZC.$document.off(cName);
		    })
		}
		_setAdvancedAttr  (name, value) {
		    let isVertical = this._vertical,
		        isHorizontal = this._horizontal,
		        opts = this._opts,
		        addHoverCls,
		        isBtns = name === 'scrollButtons', // No I18N
		        btns = [ 'scrollLeftButtonIconClassName', 'scrollRightButtonIconClassName', 'scrollLeftButtonSVGIconId', 'scrollRightButtonSVGIconId', 'scrollUpButtonIconClassName', 'scrollUpButtonSVGIconId', 'scrollDownButtonIconClassName', 'scrollDownButtonSVGIconId' ], // No I18N
		        setVSize, setHSize;
		    if (name === 'autoResize') { // No I18N
		        this._handleAutoResizeEle(!value);
		    } else if (name === 'scrollOnSelectionDrag') { // No I18N
		        let mousedownEv = 'mousedown.' + this.name; // No I18N
		        this._pane.off(mousedownEv);
		        if (value) {
		            this._pane.on(mousedownEv, this._mouseDownHandler.bind(this));
		        }
		    } else if (btns.indexOf(name) > -1 || isBtns) {
		        if (isBtns) {
		            this._isBtns = value;
		            this.element[value ? 'addClass' : 'removeClass']('zscrollbar--withbuttons'); // No I18N
		        }
		        if (isHorizontal) {
		            setHSize = true
		            this._createHorBtns(true, value);
		        }
		        if (isVertical) {
		            setVSize = true;
		            this._createVerBtns(true, value);
		        }
		        if (value && isBtns) {
		            this._disableHorBtns(opts.scrollLeft);
		            this._disableVerBtns(opts.scrollTop);
		            this._bindBtnEv();
		        }
		    } else if (name === 'showScrollbar') { // No I18N
		        if (value !== 'always') { // No I18N
		            this._setPanePadding();
		        }
		        this._saveOptionToShowSBar();
		        let hide = value !== 'always'; // No I18N
		        this._showOrHideScroll(null, hide);
		        this._showOrHideScroll(true, hide);
		        if (hide && !opts.showTrackOnScrollbarHover) {
		            addHoverCls = false;
		            opts.showTrackOnScrollbarHover = true;
		        }
		    } else if (name.indexOf('Grippy') > -1) { // No I18N
		        let isThumbGrippy = name === 'thumbGrippy'; // No I18N
		        if (isHorizontal && (isThumbGrippy || name.indexOf('horizontal') > -1)) { // No I18N
		            this._createHorThumbGrippy(true);
		            setHSize = true
		        }
		        if (isVertical && (isThumbGrippy || name.indexOf('vertical') > -1)) { // No I18N
		            this._createVerThumbGrippy(true);
		            setVSize = true;
		        }
		    } else if (name === 'scrollbarSize') { // No I18N
		        this._vBar && this._vBar.width(value);
		        this._hBar && this._hBar.height(value);
		    } else if (name === 'showTrackOnScrollbarHover' && opts.showScrollbar === 'always') { // No I18N
		        addHoverCls = !value;
		    } else if (name === 'contentScrolledCueFor') { // No I18N
		        this._createHorCue([ 'vscroll', 'none' ].indexOf(value) > -1); // No I18N
		        this._createVerCue([ 'hscroll', 'none' ].indexOf(value) > -1); // No I18N
		    } else if (name === 'rtl') { // No I18N
		        this._attrModified = 'rtl'; // No I18N
		        isVertical && this.setScrollTop(0);
		        isHorizontal && this.setScrollLeft(0);
		        this._setPanePadding(); /* If padding set for always case */
		    }
		    if (setHSize) {
		        this._setHorSBarSize();
		    }
		    if (setVSize) {
		        this._setVerSBarSize();
		    }
		    if (setHSize || setVSize) {
		        this._sizeChanged = true;
		        this._updateThumbPos();
		        this._sizeChanged = undefined;
		    }
		    if (addHoverCls !== undefined) {
		        let clsFn = addHoverCls ? 'addClass' : 'removeClass'; // No I18N
		        this._vContainer[clsFn]('zscrollbar--vertical--hover'); // No I18N
		        this._hContainer[clsFn]('zscrollbar--horizontal--hover'); // No I18N
		    }
		}
		_createVerBtns  (destroy, rebuild) {
		    let vContainer = this._vContainer,
		        shoudBuild = rebuild === undefined ? !destroy : rebuild,
		        opts = this._opts,
		        id = this._elemId,
		        upBtn;
		    if (destroy) {
		        this._btnHt = 0;
		        $('#upBtn-' + id).remove();
		        $('#downBtn-' + id).remove();
		    }
		    if (shoudBuild) {
		        upBtn = this._getBtn('upBtn', opts.scrollUpButtonIconClassName, opts.scrollUpButtonSVGIconId || 'zc__svg--arrowup'); // No I18N
		        vContainer.prepend(upBtn); // No I18N
		        vContainer.append(this._getBtn('downBtn', opts.scrollDownButtonIconClassName, opts.scrollDownButtonSVGIconId || 'zc__svg--arrowbottom'));// No I18N
		        this._btnHt = upBtn.innerHeight();
		    }
		}
		_disableVerBtns  (value) {
		    this._disable(value === 0, $('#upBtn-' + this._elemId));
		    this._disable(value === this._maxScrollY, $('#downBtn-' + this._elemId));
		}
		_setVerInitialState  (opts) {
		    this.setScrollTop(opts.scrollTop);
		    opts.scrollbarSize !== 8 && this._vBar.width(opts.scrollbarSize);
		}
		_setVerValues  () {
		    this._maxScrollY = this._contentScrollHt - this._elemHt;
		    this._percentInViewY = this._contentScrollHt / this._elemHt;
		    this._vertical = this._percentInViewY > 1;
		}
		_buildYTrack  () {
		    let vTrack = this._vTrack,
		        vContainer = this._vContainer,
		        opts = this._opts;
		    if (this._vertical) {
		        if (!vContainer) {
		            let showOnHover = opts.showTrackOnScrollbarHover;
		            this._finalVBarTop = 0;
		            vContainer = this._vContainer = $('<div class="zscrollbar--vertical ' + (showOnHover ? '' : 'zscrollbar--vertical--hover') + '" aria-expanded="' + !showOnHover + '" >'); // No I18N
		            vTrack = this._vTrack = $("<div class='zscrollbar__track zscrollbar__track--vertical'>").appendTo(vContainer);// No I18N
		            this._vBar = $("<div class='zscrollbar__thumb zscrollbar__thumb--vertical'>").appendTo(vTrack); // No I18N
		            this._addAriaLabels(true);
		            this._createVerThumbGrippy();
		            if ([ 'scroll', 'vscroll' ].indexOf(opts.contentScrolledCueFor) > -1) { // No I18N
		                this._createVerCue();
		            }
		            vContainer.appendTo(this._origEle);
		            this._btnHt = 0;
		            if (this._isBtns) {
		                this._createVerBtns();
		            }
		            this._vTrackWd = vTrack.width();
		            this._bindTrackEv(true);
		        }
		        this._setVerSBarSize();
		        this._showAlways && this._showOrHideScroll(true); // No i18n
		    } else if (vContainer) {
		        this._destroyVerScroll();
		        this._vContainer = this._vTrack = this._vBar = this._finalVBarTop = this._verCue = this._vTrackWd = this._btnHt = this._vBarHt = this._vBarShown = this._vTrackShown = undefined;
		    }
		}
		_createVerThumbGrippy  (remove) {
		    let opts = this._opts,
		        vBar = this._vBar,
		        grippyCls = 'zscrollbar__grippy'; // No I18N
		    if (remove) {
		        vBar.find('.' + grippyCls).remove();
		    }
		    if (opts.thumbGrippy) {
		        // vBar.append($(this._getIcon(grippyCls + ' ' + (opts.verticalGrippyIconClassName || ''), undefined, opts.verticalGrippySVGIconId || 'grippy-scroll'))); // No I18N
		        vBar.append($(this._getIcon(grippyCls + ' ' + (opts.verticalGrippyIconClassName || ''), undefined, opts.verticalGrippySVGIconId))); // No I18N
		    }
		}
		_setVerSBarSize  () {
		    let vTrackHt = this._origEle.innerHeight() - (this._horizontal ? this._vTrackWd : 0) - 2 * this._btnHt, // revisit
		        vBarHt = Math.floor(1 / this._percentInViewY * vTrackHt);
		    vBarHt = Math.max(this.minBarSize, vBarHt);
		    if (this._opts.thumbGrippy && vBarHt % 2 !== 0) {
		        vBarHt++;
		    }
		    this._vTrack.css('height', vTrackHt);	// No I18N
		    let vBar = this._vBar,
		        cssProps = window.getComputedStyle(vBar[0]);
		    vBar.css('height', vBarHt);// No I18N
		    vBarHt += parseInt(cssProps['margin-top'] || 0) + parseInt(cssProps['margin-bottom'] || 0); // No I18N
		    this._maxDragY = vTrackHt - vBarHt;
		    this._vBarHt = vBarHt;
		}
		_scrollPosY  (orgEvent, finalVBarTop, animation, forceSet) {
		    if (this._vertical) {
		        let opts = this._opts,
		            stopPropagation = opts.stopPropagation,
		            dispatchEv = this._dispatchEvent.bind(this),
		            shouldApplyBounce,
		            isEndReached,
		            evObj,
		            verTopValue,
		            bounceVal = Math.abs(this._maxScrollY - (finalVBarTop / this._maxDragY * this._maxScrollY))
		        if (finalVBarTop <= 0 || finalVBarTop >= this._maxDragY) {
		            finalVBarTop = finalVBarTop <= 0 ? 0 : this._maxDragY;
		            isEndReached = !!finalVBarTop;
		            if ([ 'vscroll', 'scroll' ].indexOf(opts.elasticScrollEffect) > -1 && stopPropagation) { /* Since, If stopPropagation is false, after end is reached, event will be propagated and the parent element will be scrolled. */
		                this._pane.removeClass('zscrollbar--elastic-bottom zscrollbar--elastic-top');// No I18N
		                shouldApplyBounce = orgEvent && orgEvent.type === 'mousewheel'; // No I18N
		            }
		            // if (!ZC.Browser.isMobile && stopPropagation) {
		            if (stopPropagation) {
		                orgEvent && orgEvent.preventDefault();
		            }
		        } else {
		            orgEvent && orgEvent.stopPropagation();
		        }
		        verTopValue = (finalVBarTop / this._maxDragY) * (this._maxScrollY);
		        evObj = {
		            scrollBarPos: finalVBarTop,
		            scrollTop: verTopValue,
		            scroll: 'vertical', // No I18N
		            maxScrollValue: this._maxDragY
		        };
		        if ((opts.scrollTop !== verTopValue || !this._initialized || this._sizeChanged || forceSet) && dispatchEv('verticalscrollstart', orgEvent, evObj)) { // No I18N
		            this._vContainer.attr('aria-valuenow', verTopValue); // No I18N
		            this._positionY(orgEvent, finalVBarTop, animation, verTopValue);
		            dispatchEv('scroll', orgEvent, evObj); // No I18N
		            if (isEndReached) {
		                this._dispatchScrollEndEv(orgEvent, finalVBarTop, verTopValue, true);
		            }
		            if (this._isBtns) {
		                this._disableVerBtns(verTopValue);
		            }
		        }
		        if (shouldApplyBounce && (!verTopValue || isEndReached)) {
		            this._createElasticScroll(bounceVal, orgEvent, isEndReached, true);
		        }
		        !this._btnClick && this._hideVtrack();
		    }
		}
		_positionY  (orgEvent, finalVBarTop, animation, verTopValue) {
		    this._opts.scrollTop = verTopValue;
		    this._finalVBarTop = finalVBarTop;
		    this._showCue(verTopValue, undefined);
		    animation = this._animate ? null : (animation || this._opts.animation);
		    this._animateScroll(false, finalVBarTop, animation, this._vBar);
		    this._animateScroll(false, -verTopValue, animation, this._pane);
		}
		_moveVbar  (orgEvent) {
		    this._showVtrack();
		    let offset = this._vTrack.offset(),
		        direction = orgEvent.pageY - offset.top - this._finalVBarTop,
		        pos = orgEvent.pageY - offset.top - this._vBarHt / 2,
		        step = this._opts.step,
		        value = this._finalVBarTop + (direction > 0 ? step : -step);
		    this._animate = true;
		    value = (direction > 0 ? value < pos : value > pos) ? value : pos;
		    this._scrollPosY(orgEvent, value);
		    this._startMouseDownTimer(orgEvent, true);
		}
		_setVTrackClass  (add) {
		    let opts = this._opts,
		        container = this._vContainer,
		        ariaexpanded = add && opts.expandOnMouseover,
		        className = 'zscrollbar--vertical--hover'; // No I18N
		    if (add) {
		        container.addClass(className);
		    } else {
		        opts.showTrackOnScrollbarHover && container.removeClass(className);/* Track hover class should not be removed if track is shown always */
		        ariaexpanded = false;
		    }
		    container.attr('aria-expanded', ariaexpanded); // No I18N
		    this._vTrackShown = !!add;
		}
		_showVtrack  () {
		    clearTimeout(this._verTimeout);
		    if (this._vertical && !this._vTrackShown && this._vBarShown) {	 // No I18N
		        this._setVTrackClass(true);
		    }
		}
		_hideVtrack  () {
		    let base = this,
		        opts = this._opts;
		    clearTimeout(base._verTimeout);
		    this._verTimeout = setTimeout(function() {
		        if (base._vertical && (base._vBarShown || base._vTrackShown) && (!base._mousedown || base._showOnScroll)) {// No I18N
		            base._setVTrackClass();
		            if (base._showOnScroll || base._showOnHover && base._mouseLeave) {
		                base._vBarShown = false;
		                base._vBar[opts.animateOnHide ? 'fadeOut' : 'hide'](); // No I18N
		            }
		        }
		    }, opts.hideDelay);
		}
		setScrollTop  (top, animation) {
		    // used to set top value for the content
		    let opts = this._opts,
		        initialized = this._initialized,
		        isAttrModified = [ 'scrollTop', 'rtl' ].indexOf(this._attrModified) > -1; // No I18N
		    if (this._vertical && (!initialized || opts.scrollTop !== top || isAttrModified)) {
		        let maxVal = this._maxScrollY;
		        top = top < 0 ? 0 : (top > maxVal ? maxVal : top);
		        initialized && this._showOne(true);
		        this._scrollPosY(undefined, (top / maxVal) * this._maxDragY, animation, isAttrModified);
		    }
		}
		_destroyVerScroll  () {
		    this._verTimeout && clearTimeout(this._verTimeout);
		    this._vContainer.remove();
		    this._createVerCue(true);
		}
	}
	ZC.registerComponent('ZScrollbar', ZScrollbar); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
	class ZDoubleSlider extends ZC.ZSlider {
			get name(){
				return "zdoubleslider";
			}
	    get attrs() {
	        return {
	            fromValue: 0,
	            toValue: 0,
	            isFromValueFixed: false,
	            isToValueFixed: false,
	            minFromValueAllowed: undefined,
	            maxFromValueAllowed: undefined,
	            minToValueAllowed: undefined,
	            maxToValueAllowed: undefined,
	            isSelectionDraggable: false,
	            minRangeDiff: 0,
	            maxRangeDiff: 0
	        }
	    }
	    get props() {
	        return {
	            tooltip: {
	                text: '#fromvalue# - #tovalue#' // No I18N
	            }
	        }
	    }
	    get _MEASUREMENTS() {
	        return [ 'minValueAllowed', 'maxValueAllowed', 'minFromValueAllowed', 'maxFromValueAllowed', 'minToValueAllowed', 'maxToValueAllowed' ] // No I18N
	    }
	    _init(element, options) {
	        options.templateName = options.templateName || 'zslider'; // No I18N
	        options.valuesType = 'range'; // No I18N
	        options.minValueAllowed = options.maxValueAllowed = undefined;
	        super._init(...arguments);
	    }
	    _buildData() {
	        super._buildData();
	        this._data.thumbs.push(this._data.thumbs[0]);
	    }
	    _storeRef() {
	        super._storeRef();
	        this._setFixedThumb();
	        this._range.attr('tabindex', -1); // No I18N
	    }
	    _setFixedThumb() {
	        let isFromValueFixed = this._opts.isFromValueFixed;
	        let isToValueFixed = this._opts.isToValueFixed;
	        let fixedThumbClass = 'zslider__fixedthumb'; // No I18N
	        $(this._handles[0])[isFromValueFixed ? 'addClass' : 'removeClass'](fixedThumbClass); // No I18N
	        $(this._handles[1])[isToValueFixed ? 'addClass' : 'removeClass'](fixedThumbClass); // No I18N
	        this._handleDrag();
	    }
	    _setCurrentValues() {
	        this._setBoth(this._opts.fromValue, this._opts.toValue);
	        this._updateLayout();
	    }
	    _validateProperty() {
	        super._validateProperty();
	        let o = this._opts;
	        if (o.valuesType === 'fixed') { // No I18N
	            o.minToValueAllowed = o.minFromValueAllowed = o.min;
	            o.maxToValueAllowed = o.maxFromValueAllowed = o.max;
	            o.minRangeDiff = o.maxRangeDiff = 0;
	        } else {
	            let minFromValueAllowed = parseFloat(o.minFromValueAllowed);
	            let maxFromValueAllowed = parseFloat(o.maxFromValueAllowed);
	            let minToValueAllowed = parseFloat(o.minToValueAllowed);
	            let maxToValueAllowed = parseFloat(o.maxToValueAllowed);
	            let minValueAllowed = o.minValueAllowed;
	            let maxValueAllowed = o.maxValueAllowed;
	            let minRangeDiff = parseFloat(o.minRangeDiff);
	            let maxRangeDiff = parseFloat(o.maxRangeDiff);
	            if (isNaN(minFromValueAllowed) || minFromValueAllowed < minValueAllowed || (maxValueAllowed - minFromValueAllowed) <= o.step) {
	                minFromValueAllowed = minValueAllowed;
	            }
	            if (isNaN(maxToValueAllowed) || maxToValueAllowed > maxValueAllowed || (maxToValueAllowed - minFromValueAllowed) <= o.step) {
	                maxToValueAllowed = maxValueAllowed;
	            }
	            if (isNaN(maxFromValueAllowed) || maxFromValueAllowed <= minFromValueAllowed || maxFromValueAllowed > maxToValueAllowed) {
	                maxFromValueAllowed = maxToValueAllowed;
	            }
	            if (isNaN(minToValueAllowed) || minToValueAllowed <= minFromValueAllowed || minToValueAllowed >= maxToValueAllowed) {
	                minToValueAllowed = minFromValueAllowed;
	            }
	            // Need to be revisited
	            // if( maxFromValueAllowed !== maxValueAllowed && maxFromValueAllowed > minToValueAllowed ){
	            //     minToValueAllowed = maxFromValueAllowed;
	            // }
	            // Validating minRangeDiff and maxRangeDiff
	            if (isNaN(minRangeDiff) || (o.max - o.min) < minRangeDiff || minRangeDiff > (maxToValueAllowed - minFromValueAllowed)) {
	                minRangeDiff = 0;
	            }
	            // If maxRangeDiff is <= diff btn minToValueAllowed && maxFromValueAllowed
	            if (isNaN(maxRangeDiff) || (o.max - o.min) < maxRangeDiff || maxRangeDiff < minRangeDiff || maxRangeDiff < (minToValueAllowed - maxFromValueAllowed)) {
	                maxRangeDiff = 0;
	            }
	            if (Math.abs(maxRangeDiff - minRangeDiff) < o.step) {
	                maxRangeDiff = minRangeDiff = 0;
	            }
	            o.minFromValueAllowed = minFromValueAllowed;
	            o.maxFromValueAllowed = maxFromValueAllowed;
	            o.minToValueAllowed = minToValueAllowed;
	            o.maxToValueAllowed = maxToValueAllowed;
	            o.minRangeDiff = minRangeDiff;
	            o.maxRangeDiff = maxRangeDiff;
	        }
	    }
	    _setSelectedLimit() {
	        let o = this._opts,
	            notAllowedRanges = [],
	            rangeClass = 'zslider__notallowedrange'; // No I18N
	        if (o.minFromValueAllowed !== o.minValueAllowed) {
	            notAllowedRanges.push('from'); // No I18N
	        }
	        if (o.maxFromValueAllowed < o.minToValueAllowed) {
	            this._data.selectedTrack = true;
	        }
	        if (o.maxToValueAllowed !== o.maxValueAllowed) {
	            notAllowedRanges.push('to'); // No I18N
	        }
	        this._data.notAllowedRanges = notAllowedRanges;
	    }
	    _handleSelectedLimit() {
	        let o = this._opts,
	            rangeClass = 'zslider__notallowedrange'; // No I18N
	        if (o.minFromValueAllowed !== o.minValueAllowed) {
	            this._setLimitPosition(o.min, o.minFromValueAllowed, rangeClass + 'from'); // No I18N
	        }
	        if (this._data.selectedTrack) {
	            this._setLimitPosition(o.maxFromValueAllowed, o.minToValueAllowed, 'zslider__selected'); // No I18N
	        }
	        if (o.maxToValueAllowed !== o.maxValueAllowed) {
	            this._setLimitPosition(o.maxToValueAllowed, o.maxValueAllowed, rangeClass + 'to'); // No I18N
	        }
	    }
	    _getTipPosition(rangeObj) {
	        let position = super._getTipPosition();
	        if (position && (this._opts.tooltip.position !== 'at-cursor')) { // No I18N
	            let rangeWidth = parseFloat(rangeObj ? rangeObj[this.innerDim] : this._range[0].style[this.innerDim]);
	            let offset = parseFloat(rangeObj ? rangeObj[this.marginDir] : this._range[0].style[this.marginDir]);
	            position[this.marginDir] = offset + rangeWidth / 2 + '%'; // No I18N
	        }
	        return position;
	    }
	    _getTipText() {
	        let o = this._opts,
	            label = ''; // No I18N
	        let template = (o.tooltip.text || '').trim(); // No I18N
	        if (template.length) {
	            label = template.replace(/#fromvalue#/gi, this._getLabel('', o.fromValue)).replace(/#tovalue#/gi, this._getLabel('', o.toValue)); // No I18N
	        }
	        return o.tooltip.isHTMLEncoded ? label : ZC.encodeHTML(label);
	    }
	    _onFocus(origEvent) {
	        this._activeHandle = $(origEvent.target);
	        super._onFocus();
	    }
	    _onMouseDown(origEvent) {
	        let options = this._opts;
	        if (!options.disabled) {
	            this._mouseActive = true;
	            if ($(origEvent.target).is(this._range) && options.isSelectionDraggable) {
	                this._dragSelection(options, origEvent);
	            } else {
	                super._onMouseDown.apply(this, arguments);
	            }
	        }
	    }
	    _onSlide(origEvent) {
	        if (!this._opts.disabled) {
	            if (!this._dragSelectionStarted && (!this._activeHandle || $(this._activeHandle).hasClass('zslider__fixedthumb'))) { // No I18N
	                return;
	            }
	            this._animate = (origEvent.type !== 'mousemove'); // No I18N
	            (origEvent.type !== 'keydown') && this._tip && this._showTip(origEvent); // No I18N
	            if (this._dragSelectionStarted) {
	                if (this.vertical) {
	                    origEvent.pageY = origEvent.pageY + this.offsetY;
	                } else {
	                    let correction = this._opts.rtl ? -1 : 1;
	                    origEvent.pageX = origEvent.pageX - this.offsetX * correction;
	                }
	            }
	            let value = this._getValueFromEvent(origEvent);
	            if (value !== undefined) {
	                if (!this._dragStarted) {
	                    this._storeInitialValue();
	                    this._trigger('slidestart', origEvent); // No I18N
	                    this._dragStarted = true;
	                }
	                if (this._dragSelectionStarted) {
	                    this._setBoth(value, undefined, origEvent);
	                } else {
	                    let handleindex = this._handles.indexOf(this._activeHandle[0]);
	                    if (handleindex === 0 || handleindex === 1) {
	                        this._setFromTo((handleindex === 0), value, null, origEvent);
	                    }
	                }
	                this._trigger('slide', origEvent); // No I18N
	                origEvent.preventDefault();
	            }
	        }
	    }
	    _onSlideEnd(origEvent) {
	        if (!this._opts.disabled) {
	            if (this._dragSelectionStarted) {
	                this._opts.minRangeDiff = this.tempminRangeDiff;
	                this._opts.maxRangeDiff = this.tempmaxRangeDiff;
	                this._opts.snapToTicks = true;
	                this._dragSelectionStarted = false;
	            }
	            super._onSlideEnd(origEvent);
	        }
	    }
	    _storeInitialValue() {
	        this._startToValue = this.getToValue();
	        this._startFromValue = this.getFromValue();
	    }
	    _isValueChanged() {
	        return (this._startToValue !== this.getToValue() || this._startFromValue !== this.getFromValue());
	    }
	    _getValueFromEvent(origEvent) {
	        if (this._dragSelectionStarted) {
	            origEvent = $.extend({}, origEvent);
	            origEvent.target = null;
	        }
	        return super._getValueFromEvent(origEvent);
	    }
	    _keyPress(origEvent) {
	        let _activeHandle = this._activeHandle;
	        if (_activeHandle && !_activeHandle.hasClass('zslider__fixedthumb')) { // No I18N
	            let _opts = this._opts,
	                keyCode = origEvent.which,
	                keyCodes = ZC.keyCode,
	                tempValue = this._handles.indexOf(_activeHandle[0]) ? _opts.toValue : _opts.fromValue,
	                value,
	                invert = this._opts.rtl && !this.vertical;
	            if ([ keyCodes.RIGHT, keyCodes.UP, keyCodes.PAGE_UP ].indexOf(keyCode) > -1) {
	                value = this._increase(!invert, tempValue);
	            } else if ([ keyCodes.LEFT, keyCodes.DOWN, keyCodes.PAGE_DOWN ].indexOf(keyCode) > -1) {
	                value = this._increase(invert, tempValue);
	            } else if (keyCode === keyCodes.HOME) {
	                value = _opts.minValueAllowed;
	            } else if (keyCode === keyCodes.END) {
	                value = _opts.maxValueAllowed;
	            } else {
	                return;
	            }
	            this._tip && this._showTip(origEvent);
	            origEvent.preventDefault();
	            return value;
	        }
	    }
	    _getActiveHandle(origEvent) {
	        let activeHandleIndex = this._handles.indexOf($(origEvent.target).closest('.zslider__thumb')[0]); // No I18N
	        if (activeHandleIndex === -1) {
	            if (this._opts.isFromValueFixed) {
	                activeHandleIndex = 1;
	            } else if (this._opts.isToValueFixed) {
	                activeHandleIndex = 0;
	            } else {
	                let prop = 'left', // No I18N
	                    _innerSliderOffset = this._innerSlider.offset(),
	                    cursorPos = origEvent.pageX - _innerSliderOffset.left;
	                if (this.vertical) {
	                    prop = 'top'; // No I18N
	                    cursorPos = origEvent.pageY - _innerSliderOffset.top;
	                }
	                let diff1 = parseInt($(this._handles[0]).css(prop)) - cursorPos;
	                let diff2 = parseInt($(this._handles[1]).css(prop)) - cursorPos;
	                if (Math.abs(diff1) === Math.abs(diff2)) {
	                    activeHandleIndex = ((this.vertical || this._opts.rtl) ? (diff1 > 0) : (diff1 < 0)) ? 1 : 0;
	                } else {
	                    activeHandleIndex = Math.abs(diff1) > Math.abs(diff2) ? 1 : 0;
	                }
	            }
	        }
	        return this._handles[activeHandleIndex];
	    }
	    _setBoth(fromvalue, tovalue, origEvent) {
	        if (fromvalue === undefined && tovalue === undefined) {
	            return;
	        }
	        let o = this._opts;
	        this._setFrom(fromvalue);
	        this._setTo(tovalue);
	        if (this._prevFrom !== o.fromValue || this._prevTo !== o.toValue) {
	            this._prevFrom = o.fromValue;
	            this._prevTo = o.toValue;
	            /* ONCHANGE */
	            this._updateLayout(origEvent);
	        }
	    }
	    _setTo(value) {
	        /* if( value === undefined ){
	             return;
	         } */
	        let o = this._opts;
	        let min = Math.max(o.minToValueAllowed, o.minValueAllowed, o.fromValue + o.minRangeDiff);
	        let max = Math.min(o.maxToValueAllowed, o.maxValueAllowed, o.maxRangeDiff ? (o.fromValue + o.maxRangeDiff) : o.maxValueAllowed);
	        o.toValue = this._getActualVal(this._getCorrectedValue(value, min, max));
	        // this.isCE && this.element.attr("to-value", o.toValue); //No I18N
	        return o.toValue;
	    }
	    _setFrom(value, considerToVal) {
	        /* if( value === undefined ){
	            return;
	        } */
	        let o = this._opts;
	        let min = Math.max(o.minFromValueAllowed, o.minValueAllowed, o.maxRangeDiff ? ((considerToVal ? o.toValue : o.minToValueAllowed) - o.maxRangeDiff) : o.minFromValueAllowed);
	        let max = Math.min(o.maxFromValueAllowed, (considerToVal ? o.toValue : o.maxToValueAllowed) - o.minRangeDiff);
	        o.fromValue = this._getActualVal(this._getCorrectedValue(value, min, max));
	        // this.isCE && this.element.attr("from-value", o.fromValue); //No I18N
	        return o.fromValue;
	    }
	    _setFromTo(isFrom, value, operator, origEvent) {
	        let keyName = isFrom ? 'fromValue' : 'toValue'; // No I18N
	        let o = this._opts;
	        let prevVal = o[keyName];
	        if (operator) {
	            value = this._increase(operator !== '+', prevVal); // No I18N
	        }
	        this[isFrom ? '_setFrom' : '_setTo'](value, origEvent); // No I18N
	        if (prevVal !== o[keyName]) {
	            /* ONCHANGE */
	            this._updateLayout(origEvent);
	        }
	        return o[keyName];
	    }
	    _updateLayout(origEvent) {
	        let object = {};
	        let o = this._opts;
	        let leftPer = this._getPercent(o.fromValue);
	        let rightPer = this._getPercent(o.toValue);
	        object[this.marginDir] = leftPer + '%'; // No I18N
	        let title = this._getTipText();
	        this._handleAnimation($(this._handles[0]), object, o.fromValue, title);
	        object[this.marginDir] = rightPer + '%'; // No I18N
	        this._handleAnimation($(this._handles[1]), object, o.toValue, title);
	        object[this.marginDir] = leftPer + '%'; // No I18N
	        object[this.innerDim] = (rightPer - leftPer) + '%'; // No I18N
	        this._handleAnimation(this._range, object, false, false, () => {
	            if (!this._frominit && (!origEvent || !/(keydown|mousedown|mousemove)/.test(origEvent.type))) {
	                this._trigger('change', origEvent); // No I18N
	            }
	        });
	        this._updateTip(object);
	    }
	    _trigger(customEvent, origEvent) {
	        return this._dispatchEvent(customEvent, origEvent, {
	            slider: this.getElement(),
	            fromValue: this.getFromValue(),
	            toValue: this.getToValue()
	        });
	    }
	    _handleDrag() {
	        let _opts = this._opts,
	            enableDrag = _opts.isSelectionDraggable;
	        if (!enableDrag && (_opts.isFromValueFixed || _opts.isToValueFixed || _opts.disabled)) {
	            enableDrag = false;
	        }
	        this.container[ enableDrag ? 'addClass' : 'removeClass']('zslider--selectiondraggable'); // No I18N
	    }
	    setFromValue(value) {
	        (value || value === 0) && this._setFromTo(true, this._getInnerVal(value));
	    }
	    setToValue(value) {
	        (value || value === 0) && this._setFromTo(false, this._getInnerVal(value));
	    }
	    increaseFromValue() {
	        this._setFromTo(true, null, '+'); // No I18N
	    }
	    increaseToValue() {
	        this._setFromTo(false, null, '+'); // No I18N
	    }
	    decreaseFromValue() {
	        this._setFromTo(true, null, '-'); // No I18N
	    }
	    decreaseToValue() {
	        this._setFromTo(false, null, '-'); // No I18N
	    }
	    getFromValue() {
	        return this._opts.fromValue;
	    }
	    getToValue() {
	        return this._opts.toValue;
	    }
		_disable  (disable) {
		    super._disable(disable);
		    this._handleDrag();
		}
		_dragSelection  (options, origEvent) {
		    if (options.isFromValueFixed || options.isToValueFixed) {
		        return false;
		    }
		    this._dragSelectionStarted = true;
		    options.snapToTicks = false;
		    this.tempminRangeDiff = options.minRangeDiff;
		    this.tempmaxRangeDiff = options.maxRangeDiff;
		    let rangeOffest = this._range.offset();
		    if (this.vertical) {
		        this.offsetY = (rangeOffest.top + this._range.outerHeight()) - origEvent.pageY;
		    } else {
		        let offsetX = origEvent.pageX - rangeOffest.left;
		        if (this._opts.rtl) {
		            offsetX = (rangeOffest.left + this._range.outerWidth()) - origEvent.pageX;
		        }
		        this.offsetX = offsetX;
		    }
		    options.maxRangeDiff = options.minRangeDiff = options.toValue - options.fromValue;
		    this.container
		        .removeClass('on-tabfocus') // No I18N
		        .addClass('is-active'); // No I18N
		    this._bindDocumentEvent(origEvent);
		    this._range.focus();
		}
		_setAttribute  (optionName, value) {
		    // Revisit use if with a not condition
		    if (/^(value|valuesType|values|minValueAllowed|maxValueAllowed)$/.test(optionName)) {
		        return;
		    } else {
		        switch(optionName){
		            case "fromValue":
		                    this.setFromValue(value);
		                break;
		            case "toValue":
		                    this.setToValue(value);
		                break;
		            case "isFromValueFixed":
		                this._opts[optionName] = value;
		                if(value){
		                    this._opts.isToValueFixed = false;
		                }
		                this._setFixedThumb();
		                break;
		            case "isToValueFixed":
		                    this._opts[optionName] = value;
		                    if(value){
		                        this._opts.isFromValueFixed = false;
		                    }
		                    this._setFixedThumb();
		                    break;
		            case "isSelectionDraggable":
		                    this._opts[optionName] = value;
		                    this._handleDrag(value);
		                break;
		            case 'minFromValueAllowed':
		            case 'maxFromValueAllowed':
		            case 'minToValueAllowed':
		            case 'maxToValueAllowed':
		            case 'minRangeDiff':
		            case 'maxRangeDiff':
		                    this._restoreMeasurements();
		                    this._opts[optionName] = value;
		                    this._cacheMeasurements();
		                    this._reRender();
		                    // this._resetScale();
		                break;
		            default:
		                super._setAttribute(optionName, value);
		        }
		    }
		}
	}
	ZC.registerComponent('ZDoubleSlider', ZC.ZSlider, ZDoubleSlider); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
	/* eslint-disable no-unused-expressions */
	/* $Id$ */
	class ZToggleSwitch  extends ZC.CoreComponent{
			get name(){
				return "ztoggleswitch";
			}
	    get attrs() {
	        return {
	            rtl: false,
	            contentType: 'none', // No I18N
	            orientation: 'horizontal', // No I18N
	            size: 'medium', // No I18N
	            on: false,
	            checked: false,
	            disabled: false,
	            minWidth: null,
	            maxWidth: 500,
	            minHeight: null,
	            maxHeight: 300,
	            thumbMinWidth: null,
	            thumbMinHeight: null,
	            thumbMaxHeight: 100,
	            thumbMaxWidth: 100,
	            height: null,
	            width: null,
	            isThumb: false,
	            onState: 'zswitch__onstate', // No i18n
	            offState: 'zswitch__offstate', // No i18n
	            mainClass: 'zswitch' // No i18n
	        };
	    }
	    get props() {
	        return {
	            track: {
	                color: null,
	                offStateClassName: null,
	                onStateColor: null,
	                offStateColor: null,
	                onStateClassName: null,
	                onStateLabel: null,
	                offStateLabel: null,
	                onStateIconClassName: null,
	                onStateSVGIconId: null,
	                offStateIconClassName: null,
	                offStateSVGIconId: null
	            },
	            thumb: {
	                color: null,
	                offStateClassName: null,
	                onStateColor: null,
	                onStateClassName: null,
	                onStateIconClassName: null,
	                onStateSVGIconId: null,
	                offStateIconClassName: null,
	                offStateSVGIconId: null
	            },
	            keys: {
	                on: 'On', // No i18n
	                off: 'Off' // No i18n
	            }
	        };
	    }
	    get EVENTS() {
	        return [ 'change' ]; // No I18N
	    }
	    get clsname() {
	        return {
	            oncls: 'onStateClassName', // No I18N
	            offcls: 'offStateClassName', // No I18N
	            onicon: 'onStateIconClassName', // No I18N
	            officon: 'offStateIconClassName', // No I18N
	            onsvg: 'onStateSVGIconId', // No I18N
	            offsvg: 'offStateSVGIconId', // No I18N
	            onlbl: 'onStateLabel', // No I18N
	            offlbl: 'offStateLabel' // No I18N
	        };
	    }
	    _init() {
	        let opts = this._opts,
	            clsName = opts.mainClass;
	        opts.id = this._getID(opts);
	        opts.isToggle = clsName === 'zswitch'; // No i18n
	        opts.appendTo = this.element[0];
	        this._setContentType();
	        if (opts.appendTo.tagName === 'INPUT') { // No i18n
	            opts.appendTo = this.element.parent();
	        }
	        opts.checked = opts.on = opts.on === null ? opts.checked : opts.on;
	        if (opts.checked === null) {
	            opts.on = opts.checked = this.element[0].checked;
	        } else {
	            this.element[0].checked = opts.checked;
	        }
	        opts.transition = navigator.userAgent.indexOf('Trident') !== -1 || navigator.userAgent.indexOf('Edge') !== -1 ? 'zswitch--notransition' : ''; // No I18N
	        this._leftText = this._getI18NText('on', null, 'keys'); // No i18n
	        this._rightText = this._getI18NText('off', null, 'keys'); // No i18n
	        opts.isCE = this.isCE;
	        let thumb = opts.thumb,
	            offthumb = thumb.offStateClassName,
	            onthumb = thumb.onStateClassName;
	        opts.thumb && (opts.thumbClassName = opts.checked ? onthumb === null ? '' : onthumb : offthumb === null ? '' : offthumb);
	        opts.name && (this._data.attrs = {
	            name: opts.name
	        });
	        this._assignIcons(false);
	    }
	    _assignIcons(value) {
	        let data = this._data,
	            opts = this._opts;
	        data.hasOnIcon = data.hasOffIcon = data.hasThumbIcon = false;
	        opts.isToggle && this._mergeData(opts.thumb, opts.on ? 'on' : 'off', true) && (data.isThumb = true); // No i18n
	        opts.contentType === 'icon' && this._initIcon(); // No i18n
	        data.track = opts.isToggle ? opts.track : this._buildTrack(opts);
	        this._firstRender = data.firstRender = true;
	    }
	    _postRender(element) {
	        let opts = this._opts,
	            base = this,
	            mainClass = opts.mainClass,
	            container = this.container,
	            widget = this.name,
	            disabled = opts.disabled;
	        if (!opts.isToggle) {
	            this.element = element || container;
	        }
	        this._data.className += ` ${mainClass} ` + mainClass + (opts.checked ? '--on ' : '--off ') + mainClass + '--' + opts.size.toLowerCase() + (opts.orientation === 'vertical' ? ' ' + mainClass + '--vertical ' : ''); // No I18N
	        container.attr({
	            'aria-checked': opts.checked, // No I18N
	            'aria-pressed': opts.checked, // No I18N
	            checked: opts.checked, // No I18N
	            'aria-orientation': opts.orientation, // No I18N
	            id: base._getID(container),
	            role: 'switch' // No I18N
	        }).on('contextmenu.' + widget, () => false);
	        opts.isToggle && (this._thumb = container.find('.' + mainClass + '__thumb')); // No i18n
	        this._touchInit();
	        this._buildElements();
	        this._setSize();
	        disabled && this._disable(disabled);
	    }
	    _postEachRender() {
	        this._buildElements();
	        this._resizeSwitch();
	    }
	    _initIcon() {
	        let opts = this._opts,
	            track = opts.isToggle ? opts.track : this._buildTrack(opts); // No i18n
	        this._mergeData(track, 'on'); // No i18n
	        this._mergeData(track, 'off'); // No i18n
	    }
	    _mergeData(track, state, isThumb) {
	        let obj = ZC._getIconInfo(track[`${state}StateIconClassName`], track[`${state}StateSVGIconId`], undefined, `${this._opts.mainClass}__icon`),
	            data = this._data; // No i18n
	        state = isThumb ? 'thumb' : state; // No I18N
	        data[`${state}SVGIconId`] = obj.SVGIconId; // No I18N
	        data[`${state}iconClassName`] = obj.iconClassName; // No I18N
	        data[`${state}SVGIconClassName`] = obj.SVGIconClassName; // No I18N
	        if (obj.SVGIconId || obj.iconClassName || obj.SVGIconClassName) {
	            if (isThumb) {
	                data.hasThumbIcon = true;
	            } else {
	                data.hasOnIcon = data.hasOffIcon = true;
	            }
	        }
	    }
	    _hasSVG(attr) {
	        return !!(attr.onStateSVGIconId || attr.offStateSVGIconId);
	    }
	    _buildElements() {
	        let opts = this._opts,
	            container = this.container;
	        this._switchWrapper = container.find(`.${opts.mainClass}__statescontainer`);
	        this._left = container.find(`.${opts.onState}`);
	        this._right = container.find(`.${opts.offState}`);
	        this._switchActions();
	    }
	    _thumbIcon(fromui) {
	        let opts = this._opts,
	            state = opts.on ? 'on' : 'off'; // No i18n
	        let attrName = state + (this._hasSVG(opts.thumb) ? 'StateSVGIconId' : 'StateIconClassName'); // No i18n
	        this._createIcon(attrName, opts.thumb[attrName], true, !fromui);
	    }
	    _buildTrack(data) {
	        return {
	            onStateClass: data.onStateClass,
	            offStateClass: data.offStateClass,
	            onStateLabel: data.onStateLabel,
	            offStateLabel: data.offStateLabel,
	            onStateIconClassName: data.onStateIconClassName,
	            offStateIconClassName: data.offStateIconClassName,
	            onStateSVGIconId: data.onStateSVGIconId,
	            offStateSVGIconId: data.offStateSVGIconId
	        }
	    }
	    _createIcon(options, value, isThumb, fromui) {
	        if (value) {
	            let opts = this._opts,
	                data = this._data,
	                state = options.indexOf('off') === -1 ? 'on' : 'off', // No I18N
	                attr = isThumb ? 'thumb' : 'track'; // No i18n
	            opts[attr][options] = value;
	            data[attr] = opts[attr];
	            this._mergeData(opts[attr], state, isThumb);
	            !opts.isToggle && (opts.track = this._buildTrack(opts)); // No i18n
	            if (fromui) {
	                this._render(data);
	                this._buildElements();
	            }
	            isThumb && (this._thumb = this.container.find(`.${opts.mainClass}__thumb`)); // No i18n
	        }
	    }
	    _setContentType() {
	        let opts = this._opts,
	            clsName = this.clsname,
	            track = opts.isToggle ? opts.track : this._buildTrack(opts);
	        if (track[clsName.onicon] && track[clsName.officon] || track[clsName.onsvg] && track[clsName.offsvg]) {
	            opts.contentType = 'icon'; // No i18n
	        } else if (track[clsName.onlbl] && track[clsName.offlbl]) {
	            opts.contentType = 'text'; // No i18n
	        }
	    }
	    _setSize() {
	        let opts = this._opts,
	            container = this.container,
	            thumb = this._thumb,
	            wrapper = this._switchWrapper,
	            orientation = opts.orientation,
	            height = opts.height,
	            width = opts.width;
	        opts.minHeight = height || parseInt(container.css('min-height')); // No i18n
	        opts.minWidth = width || parseInt(container.css('min-width')); // No i18n
	        if (opts.isToggle) {
	            opts.thumbMinWidth = parseInt(thumb.css('width')); // No i18n
	            opts.thumbMinHeight = parseInt(thumb.css('height')); // No i18n
	            this._maxWidth = parseInt(wrapper.css(orientation === 'vertical' ? 'top' : 'left')); // No i18n
	            this._setPosition(orientation, opts.checked);
	            this._domChanged = true;
	        }
	        this._resizeSwitch(height, width);
	    }
	    _handleState() {
	        let base = this,
	            widget = this.name;
	        this.container.off('mouseup.' + widget).on('mouseup.' + widget, function() { // No i18n
	            base._opts.checked ? base.switchOff(true) : base.switchOn(true);
	        });
	    }
	    _switchActions() {
	        let base = this,
	            widget = '.' + this.name, // No i18n
	            container = this.container,
	            opts = this._opts;
	        this._isEnabled = !opts.disabled;
	        container.off('keydown' + widget).on('keydown' + widget, function(e) { // No i18n
	            if (e.which === 32 && base._isEnabled) {
	                base.element[0].checked ? base.switchOff(true) : base.switchOn(true);
	                e.preventDefault();
	            }
	        }).off('mousedown' + widget).on('mousedown' + widget, function(e) { // No I18N
	            if (base._isEnabled) {
	                base._handleState(e, base._thumb.outerHeight(), base._thumb.outerWidth());
	                container.attr('tabindex', 0); // No I18N
	            }
	        }).off('mouseenter' + widget).on('mouseenter' + widget, function() { // No I18N
	            base._setTooltip();
	        });
	        this._setPosition(opts.orientation, opts.checked);
	    }
	    _setTooltip() {
	        let ele = (this._opts.checked === true ? this._left : this._right).find('span.zswitch__label'), // No i18n
	            hasTitle = ele.length > 0 && ele[0].offsetWidth < ele[0].scrollWidth;
	        this.container[hasTitle ? 'attr' : 'removeAttr']('title', ele.text()); // No i18n
	    }
	    _trigger(fromui) {
	        return this._dispatchEvent('change', null, { // No I18N
	            state: this._opts.checked
	        }, null, fromui); // No I18N
	    }
	    getState() {
	        return this._opts.checked;
	    }
	    switch() {
	        this.element[0].checked ? this.switchOff() : this.switchOn();
	    }
	    switchOn(fromui) {
	        this._swtichOnOff(true, !this.element[0].checked, fromui);
	    }
	    switchOff(fromui) {
	        this._swtichOnOff(false, !!this.element[0].checked, fromui);
	    }
	    _swtichOnOff(on, triggerEvent, fromui) {
	        if (this._isEnabled) {
	            let opts = this._opts,
	                mClass = opts.mainClass,
	                thumb = opts.thumb,
	                track = opts.track,
	                onClass = mClass + '--on ' + track.onStateClassName, // No I18N
	                offClass = mClass + '--off ' + track.offStateClassName, // No I18N
	                data = this._data;
	            this.container.addClass(on ? onClass : offClass).removeClass(on ? offClass : onClass).attr({
	                'aria-checked': on, // No I18N
	                'aria-pressed': on // No I18N
	            });
	            opts.isThumb && (data.thumbClassName = thumb[ on ? 'onStateClassName' : 'offStateClassName']); // No I18N
	            this._setPosition(opts.orientation, on);
	            data.checked = data.on = opts.checked = opts.on = this.element[0].checked = on;
	            if (data.hasThumbIcon) {
	                this._thumbIcon(false);
	            }
	            triggerEvent && this._trigger(fromui);
	            this._setTooltip();
	        }
	        this._thumb.css({
	            top: '', // No i18n
	            left: '' // No i18n
	        });
	    }
	    disable() {
	        this._disable(true);
	    }
	    enable() {
	        this._disable(false);
	    }
	    _disable(state) {
	        let container = this.container;
	        state = !!(state || state === 'disabled'); // No I18N
	        this._isEnabled = !state;
	        if (state) {
	            container.attr({
	                'aria-disabled': true, // No I18N
	                disabled: true
	            });
	        } else {
	            container.removeAttr('aria-disabled disabled'); // No I18N
	        }
	        container[state ? 'addClass' : 'removeClass']('is-disabled'); // No I18N
	    }
	    resizeSwitch(height, width) {
	        let data = this._opts;
	        data.minHeight = data.maxHeight = data.height = height;
	        data.minWidth = data.maxWidth = data.width = width;
	        this._resizeSwitch(height, width);
	    }
	    _getStyles(ele, position) {
	        let size = ele.css(position);
	        return size === undefined ? 0 : parseInt(size, 10);
	    }
	    _getWidth(position) {
	        let pos = `border-${position}-width`,
	            id = this.container.attr('id'); // No I18N
	        return parseInt(getComputedStyle(document.getElementById(id), null).getPropertyValue(pos), 10); // No i18n
	    }
	    _getEle(ele) {
	        return this._opts.contentType === 'text' ? ele.html() : ele.clone(); // No I18N
	    }
	    _resizeSwitch(height, width) {
	        let data = this._opts,
	            ltEle = this._left,
	            rtEle = this._right,
	            lele = this._getEle(ltEle.children()),
	            rele = this._getEle(rtEle.children()),
	            left = $('<label style="font-size:12px;">').html(lele).appendTo($('body')); // No i18n
	        let right = left.clone().html(rele).appendTo($('body')); // No i18n
	        let bwidth = this._getWidth('left') + this._getWidth('right'), // No i18n
	            bheight = this._getWidth('top') + this._getWidth('bottom'); // No i18n
	        let rtlleft = data.rtl ? 'padding-left' : 'padding-right', // No i18n
	            rtlright = data.rtl ? 'padding-right' : 'padding-left', // No i18n
	            tpadding = this._getStyles(ltEle, 'padding-' + (data.rtl ? 'bottom' : 'top')); // No i18n
	        let lwidth = left.width(),
	            rwidth = right.width(),
	            thumbWidth = data.thumbMinWidth,
	            nwwidth = lwidth > rwidth ? lwidth : rwidth,
	            swidth = data.minWidth,
	            switchHeight = data.minHeight,
	            nwheight = data.minHeight,
	            thumbHeight = data.thumbMinHeight,
	            thumbLeft = thumbWidth + bwidth,
	            thumbRight = thumbHeight + bheight,
	            padding;
	        thumbWidth = this._max(thumbWidth, 'thumbMinWidth', 'thumbMaxWidth'); // No I18N
	        if (thumbWidth >= data.thumbMinWidth) {
	            if (data.orientation === 'horizontal') { // No I18N
	                ltEle.css({
	                    'padding-bottom': 0, // No I18N
	                    left: data.rtl ? -thumbWidth * 1 : 'auto' // No I18N
	                }).css(rtlleft, thumbLeft); // No I18N
	                rtEle.css({
	                    'padding-top': 0, // No I18N
	                    left: data.rtl ? 'auto' : -thumbWidth * 1 // No I18N
	                }).css(rtlright, thumbLeft);
	            } else {
	                ltEle.css({
	                    'padding-bottom': thumbRight, // No I18N
	                    left: 0
	                }).css(rtlleft, 0);
	                rtEle.css({
	                    'padding-top': thumbRight, // No I18N
	                    left: 'auto' // No I18N
	                }).css(rtlright, 0);
	            }
	        }
	        if (data.orientation === 'vertical') { // No I18N
	            if (height !== undefined && height !== null) {
	                nwheight = switchHeight = this._max(height, 'minHeight', 'maxHeight'); // No I18N
	                this._maxWidth = switchHeight - thumbHeight - bheight;
	            } else {
	                nwheight = this._max(nwheight + thumbHeight + tpadding + bheight, 'minHeight', 'maxHeight'); // No I18N
	            }
	            padding = data.contentType === 'none' ? 0 : this._getStyles(ltEle.children(), 'margin-top') + this._getStyles(ltEle.children(), 'margin-bottom'); // No I18N
	            this.container.width(data.minWidth).height(data.minHeight + (padding === '' ? 0 : padding) + bheight);
	            this._maxWidth = data.minHeight - thumbHeight + (padding === '' ? 0 : padding) + bheight;
	            this._setPosition(data.orientation, data.checked);
	        } else {
	            if (width !== undefined && width !== null) {
	                nwwidth = this._max(width, 'minWidth', 'maxWidth'); // No i18n
	                this._maxWidth = nwwidth - thumbWidth - bwidth;
	            } else {
	                padding = this._getStyles(ltEle.children(), 'margin-left') + this._getStyles(ltEle.children(), 'margin-right'); // No i18n
	                swidth = nwwidth + thumbWidth + bwidth + (data.contentType === 'text' ? padding + (nwwidth > 18 ? nwwidth * 0.2 : 0) : 0); // No i18n
	                // 4 is borderWidth, 18 size of two words
	                if (data.contentType !== 'none') { // No i18n
	                    swidth += 4;
	                }
	                nwwidth = this._max(swidth, 'minWidth', 'maxWidth'); // No i18n
	            }
	            this.container.width(nwwidth).height(nwheight);
	            this._maxWidth = nwwidth - thumbWidth;
	            this._setPosition(data.orientation, data.checked);
	            this._setTooltip();
	        }
	        left.remove();
	        right.remove();
	    }
	    _setPosition(type, on) {
	        if (type === 'vertical') { // No I18N
	            this._switchWrapper.css({
	                top: on ? 0 : -this._maxWidth,
	                left: 0
	            }); // No I18N
	        } else {
	            this._switchWrapper.css({
	                left: this._swapValue(0, -this._maxWidth, on),
	                top: 0
	            }); // No I18N
	        }
	    }
	    _swapValue(a, b, on) {
	        return on && this._opts.rtl || !on && !this._opts.rtl ? b : a;
	    }
	    _max(attr, min, max) {
	        let data = this._opts;
	        return attr < data[min] ? data[min] : attr > data[max] ? data[max] : attr;
	    }
	    _changeDirection(value) {
	        let _opts = this._opts
	        this._left[0].removeAttribute('style'); // No I18N
	        this._right[0].removeAttribute('style'); // No I18N
	        this._data.rtl = _opts.rtl = value;
	        this._updateClass('zh-rtl', value, this.container); // No I18N
	        this._render();
	    }
	    _setAttribute(attrName, value) {
	        let _opts = this._opts;
	        if ((attrName === 'checked' || attrName === 'on') && this._isEnabled) { // No I18N
	            value ? this.switchOn() : this.switchOff();
	        } else if (attrName === 'disabled') { // No I18N
	            this._disable(value);
	        } else if (attrName === 'className') { // No I18N
	            this.container.addClass(value).removeClass(_opts[attrName]);
	        }
	        if (attrName === 'rtl') { // No I18N
	            this._changeDirection(value);
	        } else if (!/^(disabled|className|orientation|size)$/.test(attrName)) {
	            this._domChanged = true;
	        }
	        if (attrName === 'height' || attrName === 'width') { // No I18N
	            this._resizeSwitch(_opts.height, _opts.width);
	        }
	    }
	    _touchInit() {
	        let switch1 = this.container,
	            base = this;
	        switch1[0].addEventListener('touchstart', base._touchHandler, true);
	        switch1[0].addEventListener('touchmove', base._touchHandler, true);
	        switch1[0].addEventListener('touchend', base._touchHandler, true);
	        switch1[0].addEventListener('touchcancel', base._touchHandler, true);
	    }
	    _touchHandler(event) {
	        let touches = event.changedTouches,
	            first = touches[0],
	            type = '';
	        switch (event.type) {
	            case 'touchstart':
	                type = 'mousedown'; // No I18N
	                break;
	            case 'touchmove':
	                type = 'mousemove'; // No I18N
	                break;
	            case 'touchend':
	                type = 'mouseup'; // No I18N
	                break;
	            case 'touchcancel':
	                type = 'mouseup'; // No I18N
	                break;
	            default:
	                return;
	        }
	        let simulatedEvent = document.createEvent('MouseEvent'); // No I18N
	        simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0, null);
	        first.target.dispatchEvent(simulatedEvent);
	        event.preventDefault();
	    }
		_switchHandler   (abs, x, width) {
		    abs = Math.abs(x);
		    let data = this._opts,
		        type = data.orientation;
		    if (width / 2 >= abs && (!data.rtl || type === 'vertical') || width / 2 <= abs && data.rtl && type === 'horizontal') { // No I18N
		        return true;
		    }
		    return false;
		}
		_addTransition   () {
		    this._opts.transition !== '' && this._switchWrapper.addClass('zswitch--notransition'); // No I18N
		}
		_handleState   (ev) {
		    let base = this,
		        _opts = this._opts,
		        startX = ev.clientX,
		        container = this.container,
		        _thumb = this._thumb,
		        mouseMove = false,
		        widget = this.name,
		        maxWidth,
		        wrapper = this._switchWrapper,
		        baseLeft = parseInt(wrapper.css('left')), // No i18n
		        position = 'left',  // No i18n
		        XX = baseLeft,
		        XAbs, clsname = _opts.mainClass,
		        oncls = clsname + '--on ',  // No i18n
		        offcls = clsname + '--off ',    // No i18n
		        orientation = _opts.orientation; // No I18N
		    if (orientation === 'vertical') { // No I18N
		        XX = baseLeft = parseInt(wrapper.css('top')); // No I18N
		        startX = ev.clientY;
		        position = 'top'; // No I18N
		    }
		    this.container.on('mousemove.' + widget, function (ev) { // No I18N
		        wrapper.removeClass('zswitch--notransition'); // No I18N
		        setTimeout(function () {
		            mouseMove = true;
		        }, 100);
		        maxWidth = base._maxWidth;
		        let thumbLeft = parseInt(container.width()) - _thumb.outerWidth(true),
		            thumbTop = parseInt(container.height()) - _thumb.outerHeight(true),
		            tposition, wposition, track = _opts.track,
		            thumb = thumbLeft,
		            X = ev.clientX - startX + baseLeft;
		        if (orientation !== 'horizontal') { // No I18N
		            thumb = thumbTop;
		            X = ev.clientY - startX + baseLeft;
		        }
		        if (X <= 0 && X >= -maxWidth) {
		            XX = X;
		            tposition = thumb + X;
		            wposition = X;
		        } else if (X < 0) {
		            tposition = 0;
		            wposition = -maxWidth;
		        } else if (X > -maxWidth) {
		            tposition = thumb;
		            wposition = 0;
		        }
		        _thumb.css(position, tposition);
		        wrapper.css(position, wposition);
		        if(base._switchHandler(XAbs, XX, maxWidth)){
		            container.addClass(oncls + track.onStateClassName).removeClass(offcls + track.offStateClassName);
		        }else{
		            container.addClass(offcls + track.offStateClassName).removeClass(oncls + track.onStateClassName);
		        }
		    }).on('mouseup.' + widget, function () { // No I18N
		        base.container.off('mousemove.' + widget + ' mouseup.' + widget + ' selectstart.' + widget); // No I18N
		        if (mouseMove) {
		            base._switchHandler(XAbs, XX, maxWidth) ? base.switchOn(true) : base.switchOff(true);
		        } else {
		            base.element[0].checked ? base.switchOff(true) : base.switchOn(true);
		        }
		        base._addTransition();
		    }).on('selectstart.' + widget, function () { // No I18N
		        return false;
		    }).off('mouseleave.' + widget).on('mouseleave.' + widget, function () { // No i18n
		        base.container.off('mousemove.' + widget + ' mouseup.' + widget + ' selectstart.' + widget); // No I18N
		    });
		    ZC.$window.off('mouseup.' + widget).on('mouseup.' + widget, function () { // No I18N
		        if (mouseMove) {
		            base._switchHandler(XAbs, XX, maxWidth) ? base.switchOn(true) : base.switchOff(true);
		            base._addTransition();
		        }
		        ZC.$window.off('mouseup.' + widget); // No I18N
		    });
		}
		/* eslint-disable no-unused-expressions */
		_setAttribute  (attrName, value) {
		    let data = this._opts,
		        _opts = this._data,
		        mainClass = data.mainClass,
		        oldValue = data[attrName];
		    if (!/^(track|thumb|className)$/.test(attrName)) { // No i18n
		        if (/^(checked|on)$/.test(attrName) && !this._isEnabled) { // No i18n
		            return false;
		        }
		        _opts[attrName] = data[attrName] = value;
		    }
		    if (attrName === 'orientation') { // No I18N
		        this._updateClass(`${mainClass}--vertical`, value !== 'vertical', this.container); // No i18n
		        this.container.attr('aria-orientation', value); // No i18n
		        this._setSize();
		        return false;
		    } else if (attrName === 'size') { // No I18N
		        this.container.addClass(mainClass + '--' + value).removeClass(mainClass + '--' + oldValue); // No i18n
		        this._thumb && this._thumb.removeAttr('style'); // No I18N
		        this._setSize();
		    } else if (/^(track|thumb)$/.test(attrName)) { // No I18N
		        if (value === 'none') { // No I18N
		            this._resetOption(attrName);
		            if (attrName === 'track') { // No I18N
		                data.contentType = 'none'; // No I18N
		                this._initIcon();
		            } else {
		                _opts.hasThumbIcon = false;
		                this._thumbIcon(true);
		            }
		        } else {
		            let val;
		            for (let option in value) {
		                val = value[option];
		                if (this._isNotNull(val) && val !== oldValue[option]) {
		                    this._changeContents(option, attrName, val, oldValue, attrName === 'thumb'); // No I18N
		                }
		            }
		        }
		    } else if (/^(checked|on)$/.test(attrName)) { // No I18N
		        this._isEnabled && (value ? this.switchOn() : this.switchOff());
		    } else if (attrName === 'disabled') { // No I18N
		        this._disable(value);
		    } else if (attrName === 'className') { // No I18N
		        this.container.addClass(value).removeClass(oldValue);
		    }
		    if (attrName === 'rtl') { // No I18N
		        this._changeDirection(value);
		    } else if (!/^(disabled|className|orientation|size)$/.test(attrName)) { // No I18N
		        this._domChanged = true;
		    }
		    if (attrName === 'height' || attrName === 'width') { // No i18n
		        this._resizeSwitch(data.height, data.width);
		    }
		}
		_changeContents  (option, attrName, value, oldValue, isThumb) {
		    let _opts = this._opts,
		        _data = this._data,
		        attr = attrName === undefined ? _opts : _opts[attrName];
		    if (option.indexOf('StateClassName') !== -1 || option === 'className') { // No i18n
		        let isChecked = _opts.checked;
		        if (option === 'className' || isChecked && option === 'onStateClassName'
					|| !isChecked && option === 'offStateClassName') { // No I18N
		            let element = isThumb === true ? this._thumb : this.container;
		            element.addClass(value).removeClass(oldValue[option]);
		        }
		        attr[option] = value;
		    } else if (option.indexOf('StateLabel') !== -1 && !isThumb) { // No i18n
		        _opts.contentType = 'text'; // No i18n
		        _data.hasOnIcon = _data.hasOffIcon = false;
		        let attrs = attrName === undefined ? _opts : _opts[attrName];
		        attrs[option] = attr[option] = value;
		        this._resetOption(attrName, 'icons'); // No i18n
		        this._resetOption(attrName, 'svg'); // No i18n
		        this._createLabel(attr);
		    } else if (option.indexOf('StateIconClassName') !== -1 || option.indexOf('StateSVGIconId') !== -1) { // No i18n
		        let element = option.indexOf('off') === -1 ? this._left : this._right; // No i18n
		        let checked = false;
		        if (isThumb) {
		            _opts.isThumb = this._isNotNull(value);
		            element = this._thumb;
		            checked = option.indexOf('onS') !== -1 && _opts.checked || option.indexOf('off') !== -1 && !_opts.checked; // No i18n
		        } else {
		            _opts.contentType = 'icon'; // No i18n
		        }
		        this._updateIcons(element, attrName, option, value, isThumb, checked);
		    }
		}
		_updateIcons  (element, attrName, option, value, isThumb, checked) {
		    let attr = attrName === undefined ? this._opts : this._opts[attrName],
		        type = this._opts.contentType;
		    if (type === 'icon' || type === 'icon-text' || isThumb) { // No i18n
		        this._resetOption(attrName, 'text'); // No i18n
		        attr[option] = value;
		        if (option.indexOf('StateIconClassName') === -1) {
		            this._resetOption(attrName, 'icons'); // No i18n
		        } else {
		            this._resetOption(attrName, 'svg'); // No i18n
		        }
		        if (value && (isThumb && checked || !isThumb)) {
		            this._createIcon(option, value, isThumb);
		        }
		    }
		}
		_createLabel  (attr) {
		    attr.onStateLabel = attr.onStateLabel || this._leftText;
		    attr.offStateLabel = attr.offStateLabel || this._rightText;
		    let data = this._data,
		        _opts = this._opts,
		        options = this._buildTrack(attr);
		    if (_opts.isToggle) {
		        data.track = _opts.track = options;
		    } else {
		        var rendered = this._data.rendered;
		        data = _opts = options;
		        data.rendered = rendered;
		    }
		}
		_resetOption  (attrName, value) {
		    let attr = attrName === undefined ? this._opts : this._opts[attrName];
		    switch (value) {
		        case 'text': // No i18n
		            attr.onStateLabel = attr.offStateLabel = null;
		            break;
		        case 'icons': // No i18n
		            attr.onStateIconClassName = attr.offStateIconClassName = null;
		            break;
		        case 'svg': // No i18n
		            attr.onStateSVGIconId = attr.offStateSVGIconId = null;
		            break;
		        default:
		            attr.onStateSVGIconId = attr.offStateSVGIconId = attr.onStateIconClassName = attr.offStateIconClassName = attr.onStateLabel = attr.offStateLabel = null;
		            break;
		    } 
		}
	}
	ZC.registerComponent('ZToggleSwitch', ZToggleSwitch); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.ztoggleswitch.Templates; 
template.WCContainer = (data) => ZT.html `<z-toggleswitch type="input" ?aria-label="${data.text}" ?id="${data.id}" ?role="${data.role}" class="zswitch ${data.className}" ?checked="${data.checked}">${data.children && template.WCChildren(data)}</z-toggleswitch>`; 
template.WCChildren = (data) => ZT.html `<div class="zswitch__thumb ${data.thumbClassName}">${data.hasThumbIcon && (data.iconType = 'thumb') && template.WCIcon(data)}</div><div class="zswitch__wrapper"><div class="zswitch__statescontainer ${data.transition}"><div class="zswitch__onstate">${data.track.onStateLabel && ZT.html `<span class="zswitch__label">${data.track.onStateLabel}</span>`}${data.hasOnIcon && (data.iconType = 'on') && template.WCIcon(data)}</div><div class="zswitch__offstate">${data.track.offStateLabel && ZT.html `<span class="zswitch__label">${data.track.offStateLabel}</span>`}${data.hasOffIcon && (data.iconType = 'off') && template.WCIcon(data)}</div></div></div>`; 
template.WCIcon = (data) => ZT.html `<i class="${data[data.iconType + 'iconClassName']}">${ZT.customHTML(data[data.iconType + 'SVGIconId'] && `<svg class='${data[data.iconType + 'SVGIconClassName']}'><use xlink:href='${data[data.iconType + 'SVGIconId']}'></use></svg>`)}</i>`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.ztoggleswitch.Templates; 
template.container = (data) => ZT.html `<div type="input" ?aria-label="${data.text}" ?id="${data.id}" ?role="${data.role}" class="zswitch ${data.className}" ?checked="${data.checked}">${data.children && template.children(data)}</div>`; 
template.children = (data) => ZT.html `<div class="zswitch__thumb ${data.thumbClassName}">${data.hasThumbIcon && (data.iconType = 'thumb') && template.icon(data)}</div><div class="zswitch__wrapper"><div class="zswitch__statescontainer ${data.transition}"><div class="zswitch__onstate">${data.track.onStateLabel && ZT.html `<span class="zswitch__label">${data.track.onStateLabel}</span>`}${data.hasOnIcon && (data.iconType = 'on') && template.icon(data)}</div><div class="zswitch__offstate">${data.track.offStateLabel && ZT.html `<span class="zswitch__label">${data.track.offStateLabel}</span>`}${data.hasOffIcon && (data.iconType = 'off') && template.icon(data)}</div></div></div>`; 
template.icon = (data) => ZT.html `<i class="${data[data.iconType + 'iconClassName']}">${ZT.customHTML(data[data.iconType + 'SVGIconId'] && `<svg class='${data[data.iconType + 'SVGIconClassName']}'><use xlink:href='${data[data.iconType + 'SVGIconId']}'></use></svg>`)}</i>`; }(ZComponents)); 
(function(ZC, $){
		/* $Id$ */
		class ZRockerSwitch extends ZC.ZToggleSwitch {
			get name(){
				return "zrockerswitch";
			}
		    get attrs() {
		        return {
		            rtl: false,
		            contentType: 'none', // No I18N
		            orientation: 'horizontal', // No I18N
		            size: 'medium', // No I18N
		            on: false,
		            checked: false,
		            onStateClass: null,
		            offStateClass: null,
		            onStateLabel: null,
		            onStateIconClassName: null,
		            onStateSVGIconId: null,
		            offStateLabel: null,
		            offStateIconClassName: null,
		            offStateSVGIconId: null,
		            mainClass: 'zrockerswitch', // No I18N
		            onState: 'zrockerswitch__onpart', // No I18N
		            offState: 'zrockerswitch__offpart' // No I18N
		        }
		    }
		    _createIcon(options, value, isThumb, fromui) {
		        let state = options.indexOf('off') === -1 ? 'on' : 'off', rendered = this._data.rendered; // No i18n
		        this._data = this._opts;
		        this._data[options] = value;
		        this._data.rendered = rendered;
		        this._mergeData(this._data, state);
		        if (fromui) {
		            this._render(this._data)
		            this._buildElements();
		        }
		    }
		    _handleState(e) {
		        let target = $(e.target),
		            isChecked = this.element[0].checked,
		            isStateContainer = target.is('.' + this._opts.mainClass + '__statescontainer'); // No I18N
		        if (!isStateContainer && target.closest('.' + this._opts.offState).length > 0 && isChecked) { // No I18N
		            this.switchOff(true);
		        } else if (!isStateContainer && target.closest('.' + this._opts.onState).length > 0 && !isChecked) { // No I18N
		            this.switchOn(true);
		        }
		        this.container.attr('tabindex', 0); // No I18N
		    }
		    _switchActions() {
		        let base = this,
		            componentName = '.' + this.name;
		        this._isEnabled = true;
		        this.container.off('keydown' + componentName).on('keydown' + componentName, function(e) { // No i18n
		            if (e.which === 32) {
		                base.element[0].checked ? base.switchOff(true) : base.switchOn(true);
		            }
		        }).off('mousedown' + componentName).on('mousedown' + componentName, function(e) { // No I18N
		            base._handleState(e);
		        });
		    }
		    _swtichOnOff(on, triggerEvent, fromui) {
		        if (this._isEnabled) {
		            this.container.addClass(on === true ? this._opts.mainClass + '--on ' + this._opts.onStateClassName : this._opts.mainClass + '--off ' + this._opts.offStateClassName).removeClass(on === true ? this._opts.mainClass + '--off ' + this._opts.offStateClassName : this._opts.mainClass + '--on ' + this._opts.onStateClassName).attr({ // No i18n
		                'aria-checked': on, // No i18n
		                'aria-pressed': on // No i18n
		            }); // No I18N
		            this._opts.checked = this._opts.on = this.element[0].checked = on;
		            if (triggerEvent) {
		                this._trigger(fromui);
		            }
		            this._setTooltip();
		        }
		    }
		    _resizeSwitch(height, width) {
		        this._switchWrapper.css({
		            left: 'auto', // No i18n
		            top: 'auto' // No i18n
		        }) // No i18n
		        if (height !== undefined && height !== null || width !== undefined && width !== null) {
		            this.container.width(width).height(height);
		        }
		        this._setTooltip();
		    }
		    _setAttribute(attrName, value) {
		        let oldValue = this._opts[attrName],
		            data = this._opts;
		        if (/^(disabled|rtl|checked|on|className|size|orientation)$/.test(attrName)) { // No I18N
		            super._setAttribute(attrName, value);
		        } else if (attrName.indexOf('StateClass') !== -1 || attrName.indexOf('StateIcon') !== -1 || attrName.indexOf('StateSVG') !== -1 || attrName.indexOf('StateLabel') !== -1) { // No i18n
		            if (value !== undefined && value !== null) {
		                this._changeContents(attrName, undefined, value, oldValue, false);
		            } else {
		                data.contentType = 'none'; // No I18N
		                data[attrName] = null;
		                this._initIcon();
		            }
		            this._domChanged = true;
		        }
		        if (attrName === 'height' || attrName === 'width') { // No i18n
		            this._resizeSwitch(data.height, data.width);
		        }
		    }
		}
	ZC.registerComponent('ZRockerSwitch', ZC.ZToggleSwitch, ZRockerSwitch); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zrockerswitch.Templates; 
template.WCContainer = (data) => ZT.html `<z-rockerswitch type="input" ?aria-label="${data.text}" ?id="${data.id}" ?role="${data.role}" class="zrockerswitch ${data.className}">${data.children && template.WCChildren(data)}</z-rockerswitch>`; 
template.WCChildren = (data) => ZT.html `<div class="zrockerswitch__wrapper"><div class="zrockerswitch__statescontainer" ><div class="zrockerswitch__offpart">${data.offStateLabel && ZT.html `<span class="zrockerswitch__label">${data.offStateLabel}</span>`}${data.hasOffIcon && (data.iconType = 'off') && template.WCIcon(data)}</div><div class="zrockerswitch__onpart">${data.onStateLabel && ZT.html `<span class="zrockerswitch__label">${data.onStateLabel}</span>`}${data.hasOnIcon && (data.iconType = 'on') && template.WCIcon(data)}</div></div></div>`; 
template.WCIcon = (data) => ZT.html `<i class="${data[data.iconType + 'iconClassName']}">${ZT.customHTML(data[data.iconType + 'SVGIconId'] && `<svg class='${data[data.iconType + 'SVGIconClassName']}'><use xlink:href='${data[data.iconType + 'SVGIconId']}'></use></svg>`)}</i>`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zrockerswitch.Templates; 
template.container = (data) => ZT.html `<div type="input" ?aria-label="${data.text}" ?id="${data.id}" ?role="${data.role}" class="zrockerswitch ${data.className}">${data.children && template.children(data)}</div>`; 
template.children = (data) => ZT.html `<div class="zrockerswitch__wrapper"><div class="zrockerswitch__statescontainer" ><div class="zrockerswitch__offpart">${data.offStateLabel && ZT.html `<span class="zrockerswitch__label">${data.offStateLabel}</span>`}${data.hasOffIcon && (data.iconType = 'off') && template.icon(data)}</div><div class="zrockerswitch__onpart">${data.onStateLabel && ZT.html `<span class="zrockerswitch__label">${data.onStateLabel}</span>`}${data.hasOnIcon && (data.iconType = 'on') && template.icon(data)}</div></div></div>`; 
template.icon = (data) => ZT.html `<i class="${data[data.iconType + 'iconClassName']}">${ZT.customHTML(data[data.iconType + 'SVGIconId'] && `<svg class='${data[data.iconType + 'SVGIconClassName']}'><use xlink:href='${data[data.iconType + 'SVGIconId']}'></use></svg>`)}</i>`; }(ZComponents)); 
(function(ZC, $){
	class ZProgressBar  extends ZC.CoreComponent{
			get name(){
				return "zprogressbar";
			}
	    get attrs() {
	        return {
	            mode: 'determinate', // No I18N
	            value: 0,
	            max: 100,
	            locale: null,
	            progressColor: '#4190F2', // No I18N
	            progressClass: '', // No I18N
	            trackColor: '#DBDBDB', // No I18N
	            trackBorder: null,
	            trackBorderColor: null,
	            trackClass: '', // No I18N
	            progressTooltipText: '#value#%', // No I18N
	            trackTooltipText: '100 - #value#%', // No I18N
	            innerHTML: null
	        }
	    }
	    get props() {
	        return {
	            progressClassName: '', // No I18N
	            trackClassName: '', // No I18N
	            statusMessage: {}
	        }
	    }
	    get EVENTS() {
	        return [ 'complete', 'change' ]; // No I18N
	    }
	    _init() {
	        let opts = this._opts; // No I18N
	        if (!opts.locale) {
	            this._opts.locale = ZC.locale;
	        }
	        opts.max = parseInt(opts.max); // To convert the values passed as string.
	        this._eventTriggered = false;
	        if (opts.mode === 'indeterminate') { // No I18N
	            this._data.progressModifier = 'zeffects--move'; // No I18N
	        }
	        this._data.trackClass = opts.trackClassName + ' ' + opts.trackClass; // No I18N
	        this._data.progressClass = opts.progressClassName + ' ' + opts.progressClass; // No I18N
	        this._setBarStyles();
	        if (!ZC.isEmpty(opts.statusMessage)) {
	            this._updateStatusMessageData();
	        }
	    }
	    _setBarStyles() { // reused in setAttribute method
	        let opts = this._opts;
	        this._data.progressStyle = 'background:' + opts.progressColor; // No I18N
	        this._data.trackStyle = this._getStyle({
	            background: opts.trackColor, // No I18N
	            border: opts.trackBorder, // No I18N
	            'border-color': opts.trackBorderColor // No I18N
	        });
	    }
	    _postRender(ele, opts) {
	        ele.attr({
	            role: 'progressbar', // No I18N
	            'aria-valuemin': 0, // No I18N
	            'aria-valuemax': opts.max // No I18N
	        });
	    }
	    _postEachRender(ele) {
	        let opts = this._opts,
	            data = this._data;
	        // produces prblm in setAttribute case.
	        data.className = data.className.replace(/zprogress--group|zprogress--indeterminate|zprogress__labeltop|zprogress__labelleft|zprogress__labelright|zprogress__labelbottom|zprogress__labelinside|zprogress__labelcenter|/g, ''); // No I18N
	        let cls = ' zprogress--group '; // No I18N
	        if (opts.mode === 'indeterminate') { // No I18N
	            cls += 'zprogress--indeterminate '; // No I18N
	        }
	        data.className += cls + (opts.labelModifier || ''); // No I18N
	        this._progressValue = ele.find('.zprogress__bar'); // No I18N
	        this._progressValue.css('width', opts.mode === 'indeterminate' ? '' : (opts.value * (100/opts.max)) + '%'); // No I18N
	        if (!ZC.isEmpty(opts.statusMessage) && opts.statusMessage.displayType === 'callout' && (!data.rendered || data.isStatusModified)) { // No I18N
	            data.isStatusModified = null;
	            this._setCalloutPosition(); // callout position has to be set based on the rendered callout element's width & height. So, it is handled in postRender.
	        }
	    }
	    setValue(value) {
	        this._setValue(value);
	    }
	    getValue() {
	        if (this._opts.mode !== 'indeterminate') { // No I18N
	            return this._opts.value;
	        }
	    }
	    _setValue(value) {
	        let opts = this._opts,
	            maxVal = opts.max;
	        if (opts.mode !== 'indeterminate' && !isNaN(value)) { // No I18N
	            value = parseInt(value);
	            value > maxVal && (value = maxVal);
	            if (opts.value !== value) {
	                this._opts.value = value;
	                if (this._eventTriggered && value !== maxVal) { // taking reverse direction after maximum value is reached.
	                    this._eventTriggered = false;
	                }
	                let widVal = value * (100/maxVal);
	                this._progressValue.css('width', widVal + '%').on(ZC._animationEnd, () => { // No I18N
	                    // updating the status message after the transition has been completed.
	                    if (!this._eventTriggered && this._lastValue !== this._opts.value) { // retaining the last value since transitionend event triggered twice for same width value.
	                        !ZC.isEmpty(opts.statusMessage) && this._updateStatusText();
	                        this._triggerEvent();
	                    }
	                });
	            }
	        }
	    }
	    _triggerEvent() {
	        let val = this._opts.value,
	            data = {
	                indicator: this.container,
	                value: val
	            };
	        this.element.attr('aria-valuenow', val); // No I18N
	        this._dispatchEvent('change', {}, data); // No I18N
	        if (val === this._opts.max) {
	            this._eventTriggered = true;
	            this._dispatchEvent('complete', {}, data); // No I18N
	        }
	        this._lastValue = val;
	    }
	    _destroy() {
	        this.element.removeAttr('role aria-valuenow'); // No I18N
	        // this._data = this._opts = Temporarily commenting this since we should find a efficient way to garbage collect objects;
	        this._progressValue = this._messageElement = undefined;
	    }
		_handleProgress  (stop) {
		    if (this._opts.mode === 'indeterminate') { // No I18N
		        let modeCls = 'zprogress--indeterminate';// No I18N
		        this.element[stop ? 'removeClass' : 'addClass'](modeCls); // No I18N
		        let cls = this._data.className;
		        cls = stop ? cls.replace(modeCls, '') : cls + ' ' + modeCls; // No I18N
		        this._data.className = cls;
		    }
		}
		startProgress  () {
		    this._handleProgress();
		}
		stopProgress  () {
		    this._handleProgress(true);
		}
		_updateStatusMessageData  () {
		    this._data.isMessageCallout = this._data.isMessageAdjacentTop = this._data.isMessageAdjacentBottom = this._data.isMessageInline = undefined;
		    let messageProps = this._opts.statusMessage,
		        cls = '',
		        dType = messageProps.displayType && this._opts.mode !== 'indeterminate' ? messageProps.displayType : 'adjacent'; // No I18N
		    this._data['isMessage' + dType[0].toUpperCase() + dType.slice(1)] = true; // No I18N
		    if (!messageProps.position) {
		        messageProps.position = dType === 'inline' ? 'center' : (dType === 'adjacent' ? 'top' : 'bottom'); // No I18N
		    }
		    if (dType === 'adjacent') { // No I18N
		        cls = 'zprogress__label' + (messageProps.position ? messageProps.position : 'top'); // No I18N
		        this._data.isMessageAdjacentTop = messageProps.position === 'top' || messageProps.position === 'left'; // No I18N
		        this._data.isMessageAdjacentBottom = messageProps.position === 'bottom' || messageProps.position === 'right'; // No I18N
		    } else if (dType === 'inline') { // No I18N
		        cls = 'zprogress__labelinside'; // No I18N
		        this._data.inlineClass = (messageProps.position === 'left' || messageProps.position === 'right') ? 'zh-align' + (messageProps.position) : ''; // No I18N
		        this._data.inlineTextWidth = window.getComputedStyle(this.element[0]).width;
		    } else {
		        this._data.calloutClass = 'zh-' + (messageProps.position === 'bottom' ? 'top' : 'bottom'); // No I18N
		    }
		    this._data.text = messageProps.text.replace(/#value#/g, this._translateEToA(this._opts.value));
		    this._opts.labelModifier = cls;
		    this.element.attr('aria-valuetext', this._data.text); // No I18N
		}
		_setCalloutPosition  (renderNotNeeded) {
		    let calloutElement = this.element.find('.ztooltip'),
		        pointerElement = calloutElement.find('.ztooltip__pointer'),
		        propName = this._opts.rtl ? 'right' : 'left', // No I18N
		        // Revisit - Remove literals
		        callout = {
		            [propName]: `calc(50% - ${pointerElement.width() / 2}px)`
		        };
		    this._data.pointerStyle = this._getStyle(callout);
		    this._data.calloutStyle = this._getStyle({
		        top: (this._opts.statusMessage.position === 'top' ? -parseInt(this.element.height() + calloutElement.outerHeight(true)) : parseInt(this.element.height() + 5)) + 'px', // No I18N
		        [propName]: this._progressValue.width() - Math.ceil(calloutElement.outerWidth(true) / 2) + 'px', // No I18N
		        '-webkit-transition': 'all 0.2s ease', // No I18N
		        '-moz-transition': 'all 0.2s ease', // No I18N
		        '-o-transition': 'all 0.2s ease', // No I18N
		        '-ms-transition': 'all 0.2s ease', // No I18N
		        transition: 'all 0.2s ease' // No I18N
		    });
		    !renderNotNeeded && this._render();
		}
		_updateStatusText  () {
		    let messageProps = this._opts.statusMessage;
		    let formattedText = messageProps.text.replace(/#value#/g, this._translateEToA(this._opts.value));
		    if (formattedText.trim() === '') { // No I18N
		        return;
		    }
		    this._data.text = messageProps.isTextHTMLEncoded ? formattedText : ZC.encodeHTML(formattedText);
		    this._render();
		    if (messageProps.displayType === 'callout') { // No I18N
		        this._setCalloutPosition();
		    }
		    this.element.attr('aria-valuetext', this._data.text); // No I18N
		}
		_setAttribute  (optionName, value) {
		    this._domChanged = true;
		    let data = this._data;
		    if (optionName === 'mode') { // No I18N
		        if (!ZC.isEmpty(this._opts.statusMessage)) {
		            this._opts.mode = value;
		            this._updateStatusMessageData();
		        }
		        data.progressModifier = value === 'indeterminate' ? 'zeffects--move' : ''; // No I18N
		    } else if (optionName === 'value') { // No I18N
		        this._setValue(value);
		        this._domChanged = false;
		    } else if (optionName === 'progressColor' || optionName === 'trackColor' || optionName === 'trackBorder' || optionName === 'trackBorderColor') { // No I18N
		        this._opts[optionName] = value;
		        this._setBarStyles();
		    } else if (optionName === 'trackClassName' || optionName === 'progressClassName') { // No I18N
		        data[optionName.replace('Name', '')] = value; // No I18N
		    } else if (optionName === 'rtl') { // No I18N
		        if (!ZC.isEmpty(this._opts.statusMessage)) {
		            this._opts.rtl = value;
		            this._setCalloutPosition(true);
		        }
		    } else if (optionName === 'statusMessage') { // No I18N
		        let opts = this._opts;
		        opts[optionName] = value === null ? {} : value;
		        if (typeof opts[optionName] === 'object' && (opts[optionName].text && opts[optionName].text.trim() === '')) { // No I18N
		            return;
		        }
		        if (value === null) {
		            data.isMessageAdjacentTop = data.isMessageInline = data.isMessageAdjacentBottom = data.isMessageCallout = undefined;
		        } else {
		            this._updateStatusMessageData();
		        }
		        data.isStatusModified = true;
		    }
		    this._opts[optionName] = value;
		}
	}
	ZC.registerComponent('ZProgressBar', ZProgressBar); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zprogressbar.Templates; 
template.WCChildren = (data)=> ZT.html` ${data.isMessageAdjacentTop && ZT.html`<span class="zprogress__label">${data.text}</span>`} <div class="zprogress ${data.trackClass}" ?style="${data.trackStyle}" > ${data.isMessageInline && ZT.html`<span class="zprogress__text h-reversecolor ${data.inlineClass || ''}">${data.text}</span>`} <div class="zprogress__bar ${data.progressClass} ${data.progressModifier || ''}" ?style="${data.progressStyle}" > ${data.isMessageInline && ZT.html`<span class="zprogress__text ${data.inlineClass || ''}" style="width:${data.inlineTextWidth}" >${data.text}</span>`} </div> </div> ${data.isMessageAdjacentBottom && !data.showMessageInTop && ZT.html`<span class="zprogress__label">${data.text}</span>`} ${data.isMessageCallout && ZT.html`<div class="ztooltip" ?style="${data.calloutStyle}"> <div class="ztooltip__content"> <div class="ztooltip__text">${data.text}</div> </div> <div class="ztooltip__pointer ${data.calloutClass || ''}" ?style="${data.pointerStyle}" ></div> </div>`} 	`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zprogressbar.Templates; 
template.children = (data)=> ZT.html` ${data.isMessageAdjacentTop && ZT.html`<span class="zprogress__label">${data.text}</span>`} <div class="zprogress ${data.trackClass}" ?style="${data.trackStyle}" > ${data.isMessageInline && ZT.html`<span class="zprogress__text h-reversecolor ${data.inlineClass || ''}">${data.text}</span>`} <div class="zprogress__bar ${data.progressClass} ${data.progressModifier || ''}" ?style="${data.progressStyle}" > ${data.isMessageInline && ZT.html`<span class="zprogress__text ${data.inlineClass || ''}" style="width:${data.inlineTextWidth}" >${data.text}</span>`} </div> </div> ${data.isMessageAdjacentBottom && !data.showMessageInTop && ZT.html`<span class="zprogress__label">${data.text}</span>`} ${data.isMessageCallout && ZT.html`<div class="ztooltip" ?style="${data.calloutStyle}"> <div class="ztooltip__content"> <div class="ztooltip__text">${data.text}</div> </div> <div class="ztooltip__pointer ${data.calloutClass || ''}" ?style="${data.pointerStyle}" ></div> </div>`} 	`; }(ZComponents)); 
(function(ZC, $){
	class ZProgressWheel  extends ZC.CoreComponent{
			get name(){
				return "zprogresswheel";
			}
	    get attrs() {
	        return {
	            mode: 'determinate', // No I18N
	            value: 0,
	            max: 100,
	            progressColor: '#4190F2', // No I18N
	            fillGradient: null,
	            progressClass: '', // No I18N
	            trackColor: '#DBDBDB', // No I18N
	            trackBorder: null,
	            trackBorderColor: null,
	            locale: null,
	            trackGradient: null,
	            trackClass: '', // No I18N
	            size: 'medium', // No I18N
	            strokeWidth: '3px', // No I18N
	            progressTooltipText: '#value#%', // No I18N
	            trackTooltipText: '100 - #value#%', // No I18N
	            innerHTML: null,
	            width: 'auto' // No I18N
	        }
	    }
	    get props() {
	        return {
	            progressClassName: '', // No I18N
	            trackClassName: '', // No I18N
	            statusMessage: {}
	        }
	    }
	    get _MED_DATA() {
	        return {
	            size: 40,
	            strokeWidth: '3px' // No I18N
	        }
	    }
	    get EVENTS() {
	        return [ 'complete', 'change' ]; // No I18N
	    }
	    _init() {
	        let opts = this._opts; // No I18N
	        this.element.attr({
	            role: 'progressbar', // No I18N
	            'aria-valuemin': 0, // No I18N
	            'aria-valuemax': opts.max // No I18N
	        });
	        if (!opts.locale) {
	            this._opts.locale = ZC.locale;
	        }
	        this._data.animateClass = opts.mode === 'indeterminate' ? 'zeffects--rotate' : ''; // No I18N
	        this._data.trackClass = opts.trackClassName + ' ' + opts.trackClass; // No I18N
	        this._data.progressClass = opts.progressClassName + ' ' + opts.progressClass; // No I18N
	        this._setWheelData();
	        if (!ZC.isEmpty(opts.statusMessage)) {
	            this._updateStatusMessageData();
	        }
	    }
	    _postEachRender() {
	        let opts = this._opts,
	            data = this._data;
	        data.className = data.className.replace(/zprogress--group|zprogress--indeterminate|zprogresscircular--labelcenter|zprogresscircular--labelleft|zprogresscircular--labelright|zprogresscircular--labelbottom|zprogresscircular--labeltop/g, ''); // No I18N
	        let cls = ' zprogress--group'; // No I18N
	        if (opts.mode === 'indeterminate') { // No I18N
	            cls += ' zprogress--indeterminate'; // No I18N
	        }
	        this._data.className += cls + (opts.labelModifier ? ' ' + opts.labelModifier : ''); // No I18N
	    }
	    _setWheelData() { // setting circle element related data.
	        let opts = this._opts,
	            size = opts.size,
	            isStr = isNaN(size),
	            isMed = typeof size === 'string' && size === 'medium' ? this._MED_DATA[size] : false, // No I18N
	            diameter = isStr ? (isMed ? this._MED_DATA.size : this._SIZES[size]) : parseInt(size),
	            radius = diameter / 2,
	            strokeWidth = isStr ? (isMed ? this._MED_DATA.strokeWidth : this._STROKE_WIDTH[size]) : opts.strokeWidth,
	            circumference = 2 * (radius - parseInt(strokeWidth)) * (22 / 7);
	        $.extend(true, this._data, {
	            diameter: diameter,
	            radius: radius,
	            circumference: circumference,
	            strokeWidth: strokeWidth,
	            axis: radius - parseInt(strokeWidth),
	            strokeOffset: opts.mode === 'indeterminate' ? this._calculateStrokeOffset(circumference) : (opts.value ? (circumference - opts.value * circumference / opts.max) : circumference) // No I18N
	        });
	        this._setWheelStyles();
	    }
	    _calculateStrokeOffset(circumference) {
	        if (circumference) {
	            // 25% of the circle.
	            return circumference - parseFloat(circumference / 4);
	        }
	    }
	    _setWheelStyles() { // reused in _setAttribute method
	        let opts = this._opts;
	        this._data.progressStyle = this._getStyle({
	            stroke: opts.fillGradient || opts.progressColor // No I18N
	        });
	        this._data.trackStyle = this._getStyle({
	            stroke: opts.trackGradient || opts.trackColor, // No I18N
	            border: opts.trackBorder, // No I18N
	            'border-color': opts.trackBorderColor // No I18N
	        });
	    }
	    getValue() {
	        if (this._opts.mode !== 'indeterminate') { // No I18N
	            return this._opts.value;
	        }
	    }
	    setValue(value) {
	        this._setValue(value);
	    }
	    _setValue(value, dontRender) {
	        if (this.element.is(':hidden')) { // No I18N
	            this.element.show();
	        }
	        if (isNaN(value)) {
	            return;
	        }
	        let opts = this._opts,
	            maxVal = opts.max,
	            data = this._data;
	        value = parseInt(value);
	        if (value > maxVal) {
	            value = maxVal;
	        }
	        this._opts.value = value;
	        value = data.circumference - (value * data.circumference / maxVal);
	        value = value >= 0 ? value : 0;
	        data.strokeOffset = value;
	        if (!ZC.isEmpty(opts.statusMessage)) {
	            this._updateStatusText(opts.statusMessage);
	        }
	        // updating tooltip text of circular progress indicators.
	        value = this._opts.value;
	        data.trackTooltip = opts.trackTooltipText.replace(maxVal+' - #value#', maxVal - value).replace('#value#', value); // No I18N
	        data.progressTooltip = opts.progressTooltipText.replace('#value#', value); // No I18N
	        this._triggerEvent();
	        !dontRender && this._render();
	    }
	    _triggerEvent() {
	        let val = this._opts.value,
	            data = {
	                indicator: this.element,
	                value: val
	            };
	        this.element.attr('aria-valuenow', val); // No I18N
	        this._dispatchEvent('change', {}, data); // No I18N
	        if (val === this._opts.max) {
	            this._dispatchEvent('complete', {}, data); // No I18N
	        }
	    }
	    _destroy() {
	        this.element.removeAttr('role aria-valuenow'); // No I18N
	    }
		_handleProgress  (stop) {
		    if (this._opts.mode === 'indeterminate') { // No I18N
		        let modeCls = 'zprogress--indeterminate';// No I18N
		        this.element[stop ? 'removeClass' : 'removeClass'](modeCls); // No I18N
		        let cls = this._data.className;
		        cls = stop ? cls.replace(modeCls, '') : cls + ' ' + modeCls; // No I18N
		        this._data.className = cls;
		    }
		}
		startProgress  () {
		    this._handleProgress();
		}
		stopProgress  () {
		    this._handleProgress(true);
		}
		_updateStatusMessageData  () {
		    let pos = this._opts.statusMessage.position || 'center'; // No I18N
		    // Revisit - Check whether it is necessary
		    $.extend(true, this._data, {
		        showMessageAtTop: pos === 'left' || pos === 'top', // No I18N
		        showMessageAtBottom: pos === 'right' || pos === 'bottom', // No I18N
		        showMessageAtCenter: pos === 'center' // No I18N
		    });
		    this._opts.labelModifier = 'zprogresscircular--label' + pos; // No I18N
		    this._updateStatusText();
		}
		_updateStatusText  () {
		    let messageProps = this._opts.statusMessage,
		        formattedText = messageProps.text.replace(/#value#/g, this._opts.value);
		    this._data.text = messageProps.isTextHTMLEncoded ? formattedText : ZC.encodeHTML(formattedText);
		}
		_setAttribute  (optionName, value) {
		    this._domChanged = true;
		    let data = this._data;
		    if (optionName === 'mode') { // No I18N
		        let isIndeterminate = value === 'indeterminate'; // No I18N
		        this._data.animateClass = isIndeterminate ? 'zeffects--rotate' : ''; // No I18N
		        !isIndeterminate && this._setValue(this._opts.value, true); // true is passed to prevent render function from being executed there.
		    } else if (optionName === 'value') { // No I18N
		        this._setValue(value, true);
		    } else if ([ 'progressColor', 'trackColor', 'fillGradient', 'trackGradient', 'trackGradient', 'trackBorderColor' ].indexOf(optionName) > -1) { // No I18N
		        this._opts[optionName] = value;
		        this._setWheelStyles();
		    } else if (optionName === 'progressClassName' || optionName === 'trackClassName') { // No I18N
		        this._data[optionName.replace('Name', '')] = value; // No I18N
		    } else if (optionName === 'statusMessage' || optionName === 'size' || optionName === 'strokeWidth') { // No I18N
		        this._opts[optionName] = value === null ? {} : value;
		        if (optionName === 'statusMessage') { // No I18N
		            // Revisit - Shorten name
		            if (value === null) {
		                data.showMessageAtTop = data.showMessageAtCenter = data.showMessageAtBottom = undefined;
		            } else {
		                this._updateStatusMessageData()
		            }
		        } else {
		            this._setWheelData();
		        }
		    }
		    this._opts[optionName] = value;
		}
		get _SIZES (){
			return	 {
		    micro: 16,
		    mini: 20,
		    small: 24,
		    medium: 40,
		    large: 48,
		    mega: 64
		}
		 }
  
	get _STROKE_WIDTH (){
			return	 {
		    micro: '2px', // No I18N
		    mini: '2px', // No I18N
		    small: '2px', // No I18N
		    medium: '3px', // No I18N
		    large: '3px', // No I18N
		    mega: '4px' // No I18N
		}
		}
	}
	ZC.registerComponent('ZProgressWheel', ZProgressWheel); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zprogresswheel.Templates; 
template.WCChildren = (data) => ZT.html `${data.showMessageAtTop ? ZT.html `<span class="zprogress__label">${data.text}</span>` : ''} <div class="zprogress--circle zprogress"> ${data.showMessageAtCenter ? ZT.html `<span class="zprogress__label">${data.text}</span>` : ''} <svg class="zprogress__loader ${data.animateClass}" style="width:${data.diameter}px;height:${data.diameter}px;"> <circle class="circle__track ${data.trackClass}" cx="${data.radius}" cy="${data.radius}" r="${data.axis}" stroke-dasharray="${data.circumference}" stroke-dashoffset="0" stroke-width="${data.strokeWidth}" style="${data.trackStyle}"> <title>${data.trackTooltip}</title> </circle> <circle class="circle__load ${data.progressClass}" cx="${data.radius}" cy="${data.radius}" r="${data.axis}" stroke-dasharray="${data.circumference}" stroke-dashoffset="${data.strokeOffset}" stroke-width="${data.strokeWidth}" style="${data.progressStyle}"> <title>${data.progressTooltip}</title> </circle> </svg> </div> ${data.showMessageAtBottom ? ZT.html `<span class="zprogress__label">${data.text}</span>` : ''}`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zprogresswheel.Templates; 
template.children = (data) => ZT.html `${data.showMessageAtTop ? ZT.html `<span class="zprogress__label">${data.text}</span>` : ''} <div class="zprogress--circle zprogress"> ${data.showMessageAtCenter ? ZT.html `<span class="zprogress__label">${data.text}</span>` : ''} <svg class="zprogress__loader ${data.animateClass}" style="width:${data.diameter}px;height:${data.diameter}px;"> <circle class="circle__track ${data.trackClass}" cx="${data.radius}" cy="${data.radius}" r="${data.axis}" stroke-dasharray="${data.circumference}" stroke-dashoffset="0" stroke-width="${data.strokeWidth}" style="${data.trackStyle}"> <title>${data.trackTooltip}</title> </circle> <circle class="circle__load ${data.progressClass}" cx="${data.radius}" cy="${data.radius}" r="${data.axis}" stroke-dasharray="${data.circumference}" stroke-dashoffset="${data.strokeOffset}" stroke-width="${data.strokeWidth}" style="${data.progressStyle}"> <title>${data.progressTooltip}</title> </circle> </svg> </div> ${data.showMessageAtBottom ? ZT.html `<span class="zprogress__label">${data.text}</span>` : ''}`; }(ZComponents)); 
(function(ZC, $){
	class ZColorPickerBase  extends ZC.CoreComponent{
			get name(){
				return "zcolorpickerbase";
			}
	    get attrs() {
	        return {
	            value: 'rgba(0,0,0,1)', // No I18N
	            valueColorModel: 'auto', // No I18N
	            paletteColumns: 10,
	            isTitleHTMLEncoded: false,
	            title: '', // No I18N
	            closeButton: false,
	            closeIconClass: null,
	            closeSVGIconId: null,
	            closeOnSelect: true,
	            closeOnBodyClick: true,
	            position: 'auto', // No I18N
	            forElement: null,
	            displayType: 'box', // No I18N
	            type: 'popup', // No I18N
	            draggable: false,
	            appendTo: null,
	            viewport: null,
	            rtl: null,
	            positionAlterable: null,
	            locale: null
	        }
	    }
	    get props() {
	        return {
	            offset: null,
	            margin: null,
	            closeIconClassName: null,
	            labels: {
	                close: 'Close' // No I18N
	            },
	            animation: null
	        }
	    }
	    get CLASSES() {
	        return {
	            CONTAINER: 'zcolorpicker', // No I18N
	            RTL: 'h-rtl', // No I18N
	            FLIPY: 'h-flipY', // No I18N
	            ICON: 'zcolorpicker__icon', // No I18N
	            TEXT: 'zcolorpicker__text', // No I18N
	            TITLEBAR: 'zcolorpicker__titlebar', // No I18N
	            CLOSE: 'zcolorpicker__close', // No I18N
	            PALETTE: 'zcolorpicker__palette', // No I18N
	            WITHSHADES: 'zcolorpicker__shades', // No I18N
	            COLORBOX: 'zcolorpicker__colorpan', // No I18N
	            ACTIVE: 'is-selected', // No I18N
	            DISABLED: 'is-disabled', // No I18N
	            NUMBERFIELD: 'zcolorpicker__numberfield', // No I18N
	            COLORFIELD: 'zcolorpicker__colorfield', // No I18N
	            SLIDER: 'zslider', // No I18N
	            SLIDERTHUMB: 'zslider__thumb' // No I18N
	        }
	    }
	    get EVENTS() {
	        return [
	            'change', // No I18N
	            'select', // No I18N
	            'pick', // No I18N
	            'beforeopen', // No I18N
	            'open', // No I18N
	            'beforeclose', // No I18N
	            'close', // No I18N
	            'colorpanmouseover', // No I18N
	            'colorpanmouseout', // No I18N
	            'colorpanclick', // No I18N
	            'beforefocus', // No I18N
	            'focus', // No I18N
	            'blur', // No I18N
	            'dragstart', // No I18N
	            'drag', // No I18N
	            'dragstop' // No I18N
	        ]
	    }
	    get _REGEX() {
	        return {
	            position: /^(bottom-right|bottom-left|top-right|top-left|top|bottom|left|right|center|auto|right-bottom|right-top|left-bottom|left-top)$/,
	            colorMode: ZC.ColorUtil.REGEX.colorMode
	        }
	    }
	    _init(element, options) {
	        this._fromInit = true;
	        this._appendEle(this._opts.appendTo);
	        this._id = this._getID();
	        this._namespace = '.' + this.name; // No I18N
	        this._validate(options);
	        this._setInitial();
	        this._fromInit = false;
	        this._changedAttrs = [];
	    }
	    _isAttrChanged(optionName) {
	        let changedAttrs = this._changedAttrs;
	        return !this._data.rendered || changedAttrs.indexOf('all') > -1 || changedAttrs.indexOf(optionName) > -1; // No I18N
	    }
	    _setMainEle(objects) {
	        objects = this._toArr(objects);
	        let isBtn = false;
	        objects.forEach((obj) => {
	            if (obj && !obj.mainElement) {
	                let mainElement = this._getById(obj.id);
	                obj.mainElement = mainElement[0];
	                isBtn = obj.ctype === 'button'; // No I18N
	                if (!isBtn) {
	                    obj.instance = ZC[obj.ctype](mainElement);
	                }
	                obj.container = isBtn ? mainElement : obj.instance.getElement();
	            }
	        });
	    }
	    _destroyComp(object) {
	        if (object) {
	            let element = $('#' + object.id, this.element); // No I18N
	            if (element.length) {
	                if (!this.isCE) {
	                    ZC[object.ctype](element).destroy();
	                }
	                element.remove();
	            }
	        }
	    }
	    _getById(id) {
	        return $('#' + id, this.element); // No I18N
	    }
	    _getID(name) {
	        let id = name ? (name + '-' + this._id) : super._getID(); // No I18N
	        return id.replace(/\s/g, ''); // No I18N
	    }
	    _validateCount(number) {
	        return Math.max(+number || 0, 0);
	    }
	    _getCanvasContext(element) {
	        let canvas = element.querySelector('canvas'); // No I18N
	        return canvas.getContext('2d'); // No I18N
	    }
	    _preRender() {
	        let data = this._data;
	        let options = this._opts;
	        data.rgb = this._currentColor;
	        data._inPreRender = true;
	        this._setRenderData(data, options, this.element);
	        data._inPreRender = false;
	        return data;
	    }
	    _setRenderData(data, options, element) {
	        data.rtl = options.rtl;
	        data.closeOnSelect = options.closeOnSelect;
	        if (!data.rendered || this._domChanged) {
	            data.id = this._id;
	            let tabindex = element.attr('tabindex'); // No I18N
	            if (tabindex === undefined) {
	                tabindex = 0;
	            }
	            data.attrs = {
	                tabindex: tabindex,
	                title: element[0].title
	            }
	        }
	        let isAttrChanged = this._isAttrChanged.bind(this);
	        if (isAttrChanged('displayType')) { // No I18N
	            data.hasCallout = options.displayType === 'callout'; // No I18N
	        }
	        if (isAttrChanged('title')) { // No I18N
	            if (options.title || data.title) {
	                this._setTitleBarData(data, options);
	            }
	        }
	    }
	    _getRTLBasedPercent(percent) {
	        return this._opts.rtl ? 100 - percent : percent;
	    }
	    _postEachRender(element, data) {
	        this._storeRef(data, this._opts, element);
	        if (!data.rendered || this._domChanged) {
	            this._setClassName(data);
	            this._setDimension();
	            if (this._reopen) {
	                ZC.unBindDocumentEvents(this.element);
	                this._reopen = false;
	                this.open(null, null, false);
	            }
	            if (data.dragged) {
	                this._hideCallout();
	            }
	        }
	    }
	    _setDimension() {
	        if (!this._opened) {
	            this._display();
	        }
	        this._updateDim();
	        if (!this._opened && this._floating) {
	            this._display(false);
	        }
	    }
	    _setClassName(data) {
	        data.className = ' ' + this._CLASSES.CONTAINER + (this._opts.rtl ? ' zh-rtl' : ''); // No I18N
	    }
	    _storeRef(data, options, element) {
	        let isAttrChanged = this._isAttrChanged.bind(this);
	        if (isAttrChanged('displayType')) { // No I18N
	            this._callout = false;
	            if (data.hasCallout) {
	                this._callout = $(this.element[0].querySelector('.zcolorpicker__pointer')); // No I18N
	            }
	        }
	        if (isAttrChanged('title')) { // No I18N
	            this._titleBar = false;
	            if (options.title) {
	                this._storeTitleBarRef(data, options, element);
	            }
	        }
	        if (isAttrChanged('draggable') || isAttrChanged('title')) { // No I18N
	            if (options.draggable || data.draggableIns) {
	                this._initDraggable(data, options, element);
	            }
	        }
	        this._selectedPan = element.find('.' + this._CLASSES.COLORBOX + '.is-selected'); // No I18N
	    }
	    _validate(options) {
	        this._floating = options.type !== 'inline'; // No I18N
	        let colorInstance = this._getClrInstance(options.value);
	        if (options.value !== 'none' && options.value !== 'transparent' && !colorInstance.isValid()) { // No I18N
	            options.value = this._DEFAULTS.value;
	        }
	        this._setClrMode(options.value);
	    }
	    _bindEvents() {
	        this._addEvents({
	            keydown: 'keydown' // No I18N
	        });
	        if (this._colorPanEventHandler) {
	            this._addEvents({
	                colorPanEvent: 'click mouseover mouseout' // No I18N
	            }, this._container || this.container);
	        }
	        this._addEvents({
	            focus: 'focusin', // No I18N
	            blur: 'focusout' // No I18N
	        });
	    }
	    _focusHandler(orgEvent) {
	        clearTimeout(this._blurTimer);
	        if (!this._focussed) {
	            this._trigger('focus', orgEvent); // No I18N
	        }
	        this._focussed = true;
	    }
	    _blurHandler(orgEvent) {
	        clearTimeout(this._blurTimer);
	        this._blurTimer = setTimeout(() => {
	            this._focussed = false;
	            this._trigger('blur', orgEvent); // No I18N
	        });
	    }
	    _closeClickHandler(orgEvent) {
	        this.close(orgEvent)
	    }
	    _setInitial() {
	        this._setValue(this._opts.value);
	    }
	    _arrowCallback(element, direction) {
	        this.element
	            .removeClass('zcolorpicker--top zcolorpicker--bottom zcolorpicker--left zcolorpicker--right') // No I18N
	            .addClass('zcolorpicker--' + direction); // No I18N
	    }
	    _getTitle(orgObject, instance, baseObj) {
	        return orgObject.title || instance.getColor('hex').toUpperCase(); // No I18N
	    }
	    _hideCallout() {
	        if (this._data.hasCallout) {
	            this._display(false, this._callout);
	        }
	    }
	    _onDragStart() {
	        this._data.dragged = true;
	        this._hideCallout();
	    }
	    _keydownHandler(orgEvent) {
	        let code = orgEvent.keyCode;
	        let activeElement = document.activeElement;
	        let activeTag = activeElement.tagName;
	        if (activeTag === 'LI') { // No I18N
	            if (code === ZC.keyCode.ENTER || code === ZC.keyCode.SPACE) {
	                activeElement.click();
	            }
	        } else if (code === ZC.keyCode.ENTER && activeTag === 'INPUT') { // No I18N
	            this._onSubmit(orgEvent);
	        }
	    }
	    _toArr(value) {
	        return Array.isArray(value) ? value : [ value ];
	    }
	    _getClrInstance(color) {
	        return ZC.ColorUtil.getColorInstance(color);
	    }
	    _getPosition(positionSettings) {
	        return ZC.Position.get($(this._opts.forElement), this.element, positionSettings);
	    }
	    _setPosition() {
	        let options = this._opts;
	        let element = this.element;
	        if (options.offset) {
	            element.css(options.offset);
	            return;
	        }
	        if (ZC.Position) {
	            let positionAlterable = options.positionAlterable;
	            let target = $(options.forElement);
	            let position = this._lastPosition || options.position;
	            if (target.length) {
	                if (position === 'auto') { // No I18N
	                    position = options.displayType === 'callout' ? 'bottom' : 'bottom-left'; // No I18N
	                    positionAlterable = true;
	                }
	                positionAlterable = positionAlterable || 'fit'; // No I18N
	                let positionOptions = {
	                    rtl: options.rtl,
	                    direction: position,
	                    within: options.viewport || options.appendTo,
	                    positionAlterable: positionAlterable,
	                    arrow: {
	                        element: this._callout,
	                        callback: this._arrowCallback.bind(this)
	                    }
	                }
	                let positionObject = this._getPosition(positionOptions);
	                if (positionObject && positionObject.elementPosition) {
	                    let elementPos = positionObject.elementPosition;
	                    if (options.margin) {
	                        let top = +options.margin.top || 0;
	                        let left = +options.margin.left || 0;
	                        let dir = positionObject.direction.split('-'); // No I18N
	                        if (dir[0] === 'top') { // No I18N
	                            elementPos.top -= top;
	                        } else if (dir[0] === 'bottom') { // No I18N
	                            elementPos.top += top;
	                        } else if (dir[0] === 'right') { // No I18N
	                            elementPos.left += left;
	                        } else if (dir[0] === 'left') { // No I18N
	                            elementPos.left -= left;
	                        }
	                    }
	                    element.css(elementPos);
	                    if (this._callout) {
	                        this._callout.css(positionObject.arrowPosition);
	                    }
	                    this._lastPosition = positionObject.direction;
	                }
	            }
	        }
	    }
	    _setGradientColors(gradient, rgbs) {
	        rgbs = rgbs.slice(0);
	        let frac = Math.round((1 / (rgbs.length - 1)) * 100) / 100;
	        let offset = 0;
	        while (rgbs.length > 1) {
	            gradient.addColorStop(offset, rgbs.shift());
	            offset = offset + frac;
	        }
	        gradient.addColorStop(1, rgbs.shift());
	    }
	    _limit(value, min, max) {
	        return Math.max(Math.min(value, max), min);
	    }
	    _setClrMode(color) {
	        let options = this._opts;
	        this._colorMode = options.valueColorModel;
	        if (!this._REGEX.colorMode.test(this._colorMode)) {
	            let colorInstance = this._getClrInstance(color || options.value);
	            this._colorMode = colorInstance.format;
	            options.valueColorModel = 'auto'; // No I18N
	        }
	    }
	    _updateUI(setDim) {
	        if (!this._data._inPreRender && (this._mustRender || (this._data.rendered && !this._domChanged))) {
	            this._render();
	            setDim && this._setDimension();
	        }
	    }
	    _updateSelectedColor() {
	        this._selectedInstance = this._getClrInstance(this._colorInstance.getObject());
	        this._selectedInstance.initialColor = this._colorInstance.initialColor;
	        this._opts.value = this._noFill ? 'transparent' : this._colorInstance.getColor(this._colorMode, undefined, this._opts.valueColorModel === 'auto'); // No I18N
	    }
	    _dragStartHandler(orgEvent) {
	        if (!orgEvent.button) {
	            this._onPickerDragged(orgEvent);
	            this._trigger('dragstart', orgEvent); // No I18N
	            this._addEvents({
	                drag: 'mousemove', // No I18N
	                dragStop: 'mouseup' // No I18N
	            }, ZC.$document);
	        }
	    }
	    _dragHandler(orgEvent) {
	        this._onPickerDragged(orgEvent);
	        this._trigger('drag', orgEvent); // No I18N
	        orgEvent.preventDefault();
	    }
	    _dragStopHandler(orgEvent) {
	        this._onPickerDragged(orgEvent);
	        this._removeEvents('mousemove mouseup', ZC.$document); // No I18N
	        this._trigger('dragstop', orgEvent); // No I18N
	    }
	    _display(display = true, container) {
	        (container || this.element)[0].style.display = display ? '' : 'none'; // No I18N
	    }
	    _animate(element, animation, action, callback) {
	        let animationCallback = () => {
	            this._display(action !== 'close');// No I18N
	            callback && callback();
	        }
	        if (animation && ZC.animationHandler && !$.isEmptyObject(animation)) {
	            let animationObject = {
	                element,
	                action,
	                animation,
	                callback: animationCallback
	            }
	            ZC.animationHandler(animationObject);
	        } else {
	            animationCallback();
	        }
	    }
	    setFocus(orgEvent) {
	        if (this._trigger('beforefocus', orgEvent) && this.element.attr('tabindex') !== -1) { // No I18N
	            clearTimeout(this._focusTimer);
	            this._focusTimer = setTimeout(() => {
	                this.element[0].focus();
	            }, 100);
	        }
	    }
	    _onOpen(orgEvent) {
	        this._opened = true;
	        this._opts.closeOnBodyClick && this._bindBodyClick();
	        this.setFocus(orgEvent);
	        this._addedByComponent = true;
	        this.element.attr('aria-hidden', false); // No I18N
	        this._addedByComponent = false;
	        this._bindDocEvents();
	        this._trigger('open', orgEvent); // No I18N
	    }
	    /* Function to open the palette */
	    open(userOptions, orgEvent, animate = true) {
	        if (this._floating && this._trigger('beforeopen', orgEvent)) { // No I18N
	            this._opened = false;
	            let options = this._opts;
	            if (userOptions) {
	                this.setAttributes(userOptions);
	            }
	            this._setPosition();
	            if (!this._widthSet) {
	                this._setDimension();
	            }
	            this._animate(this.element, animate ? options.animation : false, 'open', this._onOpen.bind(this, orgEvent)); // No I18N
	        }
	    }
	    _bindDocEvents() {
	        this._addEvents({
	            docKeydown: 'keydown' // No I18N
	        }, ZC.$document);
	    }
	    _unBindDocEvents() {
	        this._removeEvents('', ZC.$document); // No I18N
	    }
	    _docKeydownHandler(orgEvent) {
	        if (orgEvent.keyCode === ZC.keyCode.ESCAPE) {
	            this.close(orgEvent);
	        }
	    }
	    _onClose(orgEvent) {
	        let data = this._data;
	        this._opened = this._lastPosition = false;
	        this._unBindDocEvents();
	        clearTimeout(this._focusTimer);
	        data.dragged = false;
	        if (data.hasCallout) {
	            this._display(true, this._callout);
	        }
	        if (data.closeButton) {
	            $(data.closeButton.mainElement).removeClass('has-focus'); // No I18N
	        }
	        this.element.attr('aria-hidden', true) // No I18N
	        this._trigger('close', orgEvent); // No I18N
	    }
	    _destroy() {
	        this._removeEvents('', ZC.$document); // No I18N
	        this.element
	            .removeClass(this._CLASSES.CONTAINER)
	            .removeAttr('style') // No I18N
	            .empty();
	        clearTimeout(this._fieldChangeTimer);
	        clearTimeout(this._focusTimer);
	        clearTimeout(this._blurTimer);
	    }
	    /* Function to trigger custom events */
	    _trigger(customEvent, orgEvent, data) {
	        if (!this._fromInit) {
	            let colorMode = this._colorMode;
	            let selectedInstance = this._selectedInstance;
	            let colorInstance = this._colorInstance;
	            orgEvent = orgEvent && orgEvent.preventDefault ? orgEvent : undefined;
	            data = data || {};
	            data.value = data.color = this.getValue();
	            data.rgb = selectedInstance.getColor();
	            data.opacity = selectedInstance.getAlpha();
	            data.colorData = selectedInstance.getObject(colorMode);
	            data.currentValue = colorInstance.getColor(colorMode);
	            data.currentRGB = colorInstance.getColor();
	            data.currentOpacity = colorInstance.getAlpha();
	            data.currentColorData = colorInstance.getObject(colorMode);
	            data.otherData = {};
	            let selectedPan = this._selectedPan;
	            if (selectedPan.length) {
	                data.otherData.colorPan = selectedPan;
	                selectedPan = $(selectedPan[0]);
	                if (selectedPan.attr('data-shade')) { // No I18N
	                    data.otherData.isShade = true;
	                    data.otherData.baseColor = selectedPan.attr('data-base-color'); // No I18N
	                    data.otherData.toneType = selectedPan.attr('data-tone-type'); // No I18N
	                    data.otherData.tonePercent = selectedPan.attr('data-tone-percent'); // No I18N
	                }
	                data.otherData.theme = selectedPan.attr('data-theme'); // No I18N
	            }
	            return this._dispatchEvent(customEvent, orgEvent, data, undefined, !!orgEvent);
	        }
	        return true;
	    }
	    getValue() {
	        return this._opts.value;
	    }
	    /* Function to select a color */
	    setValue(color, orgEvent) {
	        this._setValue(color, orgEvent, null, true);
	    }
	    close(orgEvent) {
	        if (this._floating && this._opened) {
	            if (this._trigger('beforeclose', orgEvent)) { // No I18N
	                this._animate(this.element, this._opts.animation, 'close', this._onClose.bind(this, orgEvent)); // No I18N
	            }
	        }
	    }
	    _setAttribute(optionName, value) {
	        if (optionName === 'value') { // No I18N
	            this._domChanged = true;
	            this.setValue(value);
	        } else {
	            return this._setAdvAttr(optionName, value);
	        }
	    }
		_updateColors  (paletteTemplateData) {
		    let colors = paletteTemplateData.colors;
		    paletteTemplateData.paletteData.colors = colors.map((color) => color.orgObject);
		    this._spliceColors(paletteTemplateData);
		    this._updateUI(true);
		}
		_addColors  (paletteName, colors, index) {
		    let paletteTemplateData = this._getPalette(paletteName);
		    if (paletteTemplateData) {
		        let nColors = this._getPaletteColors(paletteTemplateData, colors);
		        let orgColors = paletteTemplateData.colors;
		        this._addToObject(orgColors, nColors, index);
		        this._updateColors(paletteTemplateData);
		        return paletteTemplateData.paletteData.colors;
		    }
		}
		_removeColors  (palette, colors) {
		    let paletteTemplateData = this._getPalette(palette);
		    if (paletteTemplateData) {
		        colors = this._toArr(colors);
		        let paletteColors = paletteTemplateData.colors;
		        colors.forEach((color) => {
		            let colorInstance = this._getClrInstance(color);
		            if (colorInstance.isValid()) {
		                let color = colorInstance.getColor();
		                paletteColors = paletteColors.filter((pColor) => pColor.rgb !== color);
		            }
		        });
		        paletteTemplateData.colors = paletteColors;
		        this._updateColors(paletteTemplateData);
		    }
		}
		_removeColorsAt  (palette, indexes) {
		    let paletteTemplateData = this._getPalette(palette);
		    if (paletteTemplateData) {
		        indexes = this._toArr(indexes);
		        paletteTemplateData.colors = this._removeFromObjAt(paletteTemplateData.colors, indexes);
		        this._updateColors(paletteTemplateData);
		    }
		}
		addColor  (paletteName, color) {
		    this._addColors(paletteName, color);
		}
		insertColorAt  (paletteName, color, index) {
		    this._addColors(paletteName, color, index);
		}
		removeColor  (paletteName, color) {
		    this._removeColors(paletteName, color);
		}
		removeColorAt  (paletteName, index) {
		    this._removeColorsAt(paletteName, index);
		}
		_removePalettes  (palettes, paletteKey) {
		    let data = this._data;
		    paletteKey = paletteKey || 'palettes'; // No I18N
		    if (palettes) {
		        palettes = this._toArr(palettes);
		        palettes.forEach((palette) => {
		            let paletteTemplateData = this._getPalette(palette);
		            if (paletteTemplateData) {
		                data[paletteKey] = data[paletteKey].filter((ePalette) => ePalette !== paletteTemplateData);
		            }
		        });
		        this._updatePalettes(paletteKey);
		    }
		}
		_removePalettesAt  (indexes, paletteKey) {
		    let data = this._data;
		    paletteKey = paletteKey || 'palettes'; // No I18N
		    this._removeFromObjAt(data[paletteKey], indexes);
		    this._updatePalettes(paletteKey);
		}
		_removeFromObjAt  (object, indexes) {
		    indexes = this._toArr(indexes);
		    return object.filter((data, index) => indexes.indexOf(index) === -1);
		}
		addPalette  (paletteData) {
		    this._addPalettes(paletteData);
		}
		insertPaletteBefore  (paletteData, paletteName) {
		    let index;
		    let paletteTemplateData = this._getPaletteTemplateData(paletteName);
		    if (paletteTemplateData) {
		        index = this._data.palettes.indexOf(paletteTemplateData);
		    }
		    this._addPalettes(paletteData, index);
		}
		insertPaletteAt  (paletteData, index) {
		    this._addPalettes(paletteData, index);
		}
		removePalette  (palettes) {
		    this._removePalettes(palettes);
		}
		removePaletteAt  (indexes) {
		    this._removePalettesAt(indexes);
		}
		getPaletteColors  (paletteName) {
		    let paletteTemplateData = this._getPalette(paletteName);
		    if (paletteTemplateData) {
		        return paletteTemplateData.paletteData.colors;
		    }
		}
		setPaletteColors  (paletteName, colors) {
		    let paletteTemplateData = this._getPalette(paletteName);
		    if (paletteTemplateData) {
		        paletteTemplateData.colors = this._getPaletteColors(paletteTemplateData, colors);
		        this._updateColors(paletteTemplateData);
		    }
		}
		_setCloseBtnData  (data, options) {
		    let SVGIconId = options.closeSVGIconId;
		    let iconClassName;
		    if (!SVGIconId) {
		        iconClassName = options.closeIconClassName || options.closeIconClass;
		        if (!iconClassName) {
		            SVGIconId = 'zc__svg--close'; // No I18N
		        }
		    }
		    data.closeButton = ZC.ZButton.getBtnProps({
		        isCE: this.isCE,
		        rtl: this._opts.rtl,
		        templateRender: true,
		        ctype: 'button', // No I18N
		        className: this._CLASSES.CLOSE, // No I18N
		        id: this._getID('closebutton'), // No I18N
		        iconClassName,
		        SVGIconId,
		        defaultIconClassName: 'zcolorpicker__icon', // No I18N
		        title: this._getI18NText('close') // No I18N
		    });
		}
		_bindBodyClick  () {
		    ZC.bindDocumentEvents({
		        element: this.element,
		        forElement: this._opts.forElement,
		        ctype: this.name,
		        closeMethodName: 'close', // No I18N
		        closeEvent: 'close' // No I18N
		    });
		}
		_getBaseObj  (cname) {
		    return {
		        ctype: cname,
		        isCE: this.isCE,
		        rtl: this._opts.rtl,
		        templateRender: true,
		        locale: this._opts.locale
		    }
		}
		_initDraggable  (data, options, element) {
		    data.draggableIns && data.draggableIns.destroy();
		    data.draggableIns = undefined;
		    if (options.draggable && options.title && this._floating) {
		        data.draggableIns = ZC.draggable(element, {
		            handle: this._titleBar,
		            cursor: 'default', // No I18N
		            start: this._onDragStart.bind(this)
		        });
		    }
		}
		_getBasicNumberFieldOptions  () {
		    return {
		        ...this._getBaseObj('numberfield'), // No I18N
		        ...{
		            min: 0,
		            required: true,
		            width: 'none', // No I18N
		            spinButtons: 'none', // No I18N
		            clearButton: 'none', // No I18N
		            bindedSpinAndChange: true
		        }
		    };
		}
		_addPalettes  (paletteDatas, index, paletteKey) {
		    let data = this._data;
		    paletteKey = paletteKey || 'palettes'; // No I18N
		    let nPalettes = [];
		    let isCustom = paletteKey === 'customColorLibraries'; // No I18N
		    if (paletteDatas) {
		        paletteDatas = this._toArr(paletteDatas);
		        paletteDatas.forEach((paletteData) => {
		            paletteData.isCustom = isCustom;
		            let paletteTemplateData = this._getPaletteTemplateData(paletteData);
		            if (paletteTemplateData) {
		                nPalettes.push(paletteTemplateData);
		            }
		        });
		        this._addToObject(data[paletteKey], nPalettes, index);
		        data.rendered && this._updatePalettes(paletteKey);
		    }
		}
		_colorPanEventHandler  (orgEvent) {
		    let colorpan = orgEvent.target;
		    let $colorpan = $(colorpan);
		    if ($colorpan.is(`.${this._CLASSES.COLORBOX}`)) {
		        let eventType = orgEvent.type;
		        let isClick = eventType === 'click';  // No I18N
		        let eventData = this._getColorPanData(colorpan);
		        if (isClick){
		            this._setValue(colorpan.style.backgroundColor, orgEvent);
		        }
		        this._trigger('colorpan'+eventType, orgEvent, eventData); // No I18N
		        if (isClick && this._data.closeOnSelect){
		            this.close(orgEvent);
		        }
		    }
		}
		_getPaletteTemplateData  (paletteData) {
		    if (typeof paletteData === 'object') { // No I18N
		        let name = paletteData.name || paletteData.heading;
		        if (name && !this._getPalette(name)) {
		            let paletteTemplateData = {
		                heading: paletteData.heading,
		                name: name,
		                className: paletteData.className,
		                id: paletteData.id || this._getID(name),
		                hasTones: paletteData.hasTones,
		                tones: paletteData.tones,
		                maxColorsCount: this._validateCount(paletteData.maxColorsCount),
		                isCustom: paletteData.isCustom,
		                paletteData: paletteData
		            }
		            paletteTemplateData.colors = this._getPaletteColors(paletteTemplateData, paletteData.colors);
		            this._spliceColors(paletteTemplateData);
		            return paletteTemplateData;
		        }
		    }
		}
		_getPaletteColors  (paletteData, colors) {
		    let nColors = [];
		    if (colors) {
		        this._toArr(colors).forEach((orgObject) => {
		            let initalValue = orgObject;
		            if (typeof orgObject === 'string' || Array.isArray(orgObject)) { // No I18N
		                orgObject = {
		                    color: orgObject
		                };
		            }
		            let colorInstance = this._getClrInstance(orgObject.color);
		            if (colorInstance.isValid()) {
		                nColors.push({
		                    orgObject: initalValue,
		                    theme: orgObject.theme,
		                    rgb: colorInstance.getColor(),
		                    title: this._getTitle(orgObject, colorInstance),
		                    paletteId: paletteData.id,
		                    paletteName: paletteData.name,
		                    tabindex: this._data.attrs.tabindex,
		                    tones: paletteData.hasTones ? this._getTones(colorInstance, orgObject.tones || paletteData.tones, orgObject) : undefined
		                });
		            }
		        });
		    }
		    return nColors;
		}
		_spliceColors  (paletteTemplateData) {
		    let paletteColumns = this._opts.paletteColumns;
		    let colors = paletteTemplateData.colors;
		    let colorChunks = paletteTemplateData.colorChunks = [];
		    if (colors.length || paletteTemplateData.isCustom) {
		        let maxColorsCount = paletteTemplateData.maxColorsCount;
		        if (maxColorsCount && colors.length > maxColorsCount) {
		            let spliceCount = maxColorsCount - colors.length;
		            colors.splice(spliceCount);
		            paletteTemplateData.paletteData.colors.splice(spliceCount);
		        }
		        colors = [ ...colors ];
		        if (paletteTemplateData.isCustom) {
		            let addBtn = paletteTemplateData.addBtn = this._getAddBtnData(paletteTemplateData);
		            colors.push(addBtn);
		        }
		        if (paletteColumns) {
		            for (let i = 0; i < colors.length; i = i + paletteColumns) {
		                colorChunks.push(colors.slice(i, i + paletteColumns));
		            }
		        } else {
		            colorChunks.push(colors);
		        }
		    }
		}
		_addToObject  (object, newObject, index) {
		    if (index === undefined) {
		        object.push(...newObject);
		    } else {
		        object.splice(index, 0, ...newObject);
		    }
		}
		_getPalette  (paletteName) {
		    let data = this._data;
		    let callback = (palette) => palette.name === paletteName;
		    let paletteData = paletteName;
		    if (typeof paletteName === 'string') { // No I18N
		        paletteData = data.palettes.find(callback);
		        if (!paletteData && data.customColorLibraries) {
		            paletteData = data.customColorLibraries.find(callback);
		        }
		    }
		    return paletteData;
		}
		_getColorPanData  (colorpan) {
		    return {
		        colorpan,
		        colorpanData: {
		            color: this._getClrInstance(colorpan.getAttribute('data-zcolor')).getColor(this._colorMode) // No I18N
		        }
		    }
		}
		_updateClrSelection  (colors) {
		    colors.forEach((color) => {
		        color.selected = color.rgb === this._currentColor;
		        if (color.tones) {
		            this._updateClrSelection(color.tones);
		        }
		    });
		}
		_setAdvAttr  (optionName, value) {
		    let options = this._opts;
		    let changedAttrs = this._changedAttrs;
		    if (optionName === 'valueColorModel') { // No I18N
		        options[optionName] = value;
		        this._setClrMode();
		        this._updateSelectedColor();
		        changedAttrs.push('colorField'); // No I18N
		        this._domChanged = true;
		    } else if ([ 'title', 'isTitleHTMLEncoded', 'closeButton', 'closeIconClass', 'closeIconClassName', 'closeSVGIconId' ].indexOf(optionName) > -1) { // No I18N
		        options[optionName] = value;
		        changedAttrs.push('title');// No I18N
		        this._domChanged = true;
		    } else if (optionName === 'draggable' || optionName === 'displayType') { // No I18N
		        options[optionName] = value;
		        this._reopen = this._opened;
		        changedAttrs.push(optionName);// No I18N
		        this._domChanged = true;
		    } else if (optionName === 'type') { // No I18N
		        options[optionName] = value;
		        this._floating = value !== 'inline'; // No I18N
		        if (this._floating) {
		            this.close();
		        } else {
		            this._display();
		        }
		    } else if (optionName === 'closeOnSelect') { // No I18N
		        options[optionName] = value;
		        this._domChanged = true;
		    } else if ([ 'closeOnBodyClick', 'position', 'forElement', 'offset', 'margin', 'animation' ].indexOf(optionName) > -1) { // No I18N
		        options[optionName] = value;
		        this._reopen = this._opened;
		        this._domChanged = true;
		    } else if ([ 'locale', 'labels', 'rtl' ].indexOf(optionName) > -1) { // No I18N
		        options[optionName] = value;
		        changedAttrs.push('all'); // No I18N
		        this._domChanged = true;
		    } else {
		        return false;
		    }
		}
		_getThumbData  (data) {
		    if (data) {
		        let thumbIcon;
		        let thumbIconClassName = data.thumbIconClassName;
		        let thumbSVGIconId = data.thumbSVGIconId;
		        if (thumbSVGIconId || thumbIconClassName) {
		            ZC._getIconInfo(thumbIconClassName, thumbSVGIconId, '', '', thumbIcon = {}); // No I18N
		        }
		        return thumbIcon;
		    }
		}
		_getThumb  (element) {
		    return $(element.querySelector('.' + this._CLASSES.SLIDERTHUMB)); // No I18N
		}
		_bindTextField  (field) {
		    this._addEvents({
		        fieldChange: 'input change paste', // No I18N
		        textFieldFocus: 'focus blur' // No I18N
		    }, field);
		}
		_textFieldFocusHandler  (orgEvent) {
		    let target = orgEvent.target;
		    if (!target.readonly) {
		        $(target).parent()[(orgEvent.type === 'blur' || target.readOnly) ? 'removeClass' : 'addClass']('has-focus'); // No I18N
		    }
		}
		_setTitleBarData  (data, options) {
		    // this._destroyComp(data.closeButton);
		    data.closeButton = false;
		    data.title = options.isTitleHTMLEncoded ? options.title : ZC.encodeHTML(options.title);
		    if (options.closeButton) {
		        this._setCloseBtnData(...arguments);
		    }
		}
		_storeTitleBarRef  (data, options, element) {
		    this._titleBar = $(element[0].querySelector('.' + this._CLASSES.TITLEBAR)); // No I18N
		    if (options.closeButton) {
		        this._setMainEle(data.closeButton);
		        this._addEvents({
		            closeClick: 'mousedown' // No I18N
		        }, $(data.closeButton.mainElement));
		    }
		}
		/* Function to get tones for a base color */
		_getTones  (baseColorInstance, toneFactors, orgObject) {
		    toneFactors = toneFactors || this._getDefaultToneFactors(baseColorInstance);
		    /* Tones are given by the user */
		    return toneFactors.map((toneFactor) => {
		        let color = toneFactor.color || toneFactor;
		        if (typeof color === 'string') { // No I18N
		            let toneInstance = this._getClrInstance(color);
		            return {
		                rgb: toneInstance.getColor(),
		                baseColor: baseColorInstance.initialColor,
		                title: this._getTitle(toneFactor, toneInstance, orgObject),
		                theme: orgObject.theme,
		                isShade: 'true' // No I18N
		            };
		        }
		        return this._getTone(baseColorInstance, toneFactor, orgObject);
		    });
		}
		/* Function to generate default tones for a base color based on its brightness and darkness  */
		_getDefaultToneFactors  (colorInstance) {
		    let colorProps = colorInstance.getObject();
		    let rgbArr = [ colorProps.r, colorProps.g, colorProps.b ];
		    let brightness = ZC.ColorUtil.brightness(rgbArr);
		    let fixedPer = !((brightness >= 210 && brightness <= 255) || (brightness >= 0 && brightness <= 38));
		    let percents = brightness >= 240 && brightness <= 255 ? [ 0.05, 0.15, 0.25, 0.35, 0.50 ] : brightness >= 0 && brightness <= 15 ? [ 0.50, 0.35, 0.25, 0.15, 0.05 ] : brightness >= 224 && brightness < 240 ? [ 0.10, 0.25, 0.50, 0.75, 0.90 ] : brightness > 15 && brightness <= 31 ? [ 0.90, 0.75, 0.50, 0.25, 0.10 ] : [ 0.80, 0.60, 0.40, 0.25, 0.50 ];
		    let isDark = ZC.ColorUtil.isDark(rgbArr);
		    return percents.map((percent, index) => {
		        if (fixedPer) {
		            isDark = index <= 2;
		        }
		        return {
		            'function': isDark ? 'lighten' : 'darken', // No I18N
		            percent: percent * 100
		        }
		    });
		}
		/* Function to get tone from the given tone Factor */
		_getTone  (baseColorInstance, toneFactor, orgObject) {
		    let toneType = toneFactor['function'];
		    let tonePercent = toneFactor.percent;
		    if (/^(lighten|darken|tint|shade)$/.test(toneType)) {
		        let colorProps = baseColorInstance.getObject();
		        let nRGB = ZC.ColorUtil[toneType]([ colorProps.r, colorProps.g, colorProps.b ], tonePercent / 100);
		        nRGB.push(colorProps.a);
		        let toneInstance = this._getClrInstance(nRGB);
		        return {
		            rgb: toneInstance.getColor(),
		            title: this._getTitle(toneFactor, toneInstance, orgObject),
		            toneType,
		            tonePercent,
		            tabindex: this._data.attrs.tabindex,
		            baseColor: baseColorInstance.initialColor,
		            theme: orgObject.theme,
		            isShade: 'true' // No I18N
		        };
		    }
		}
	}
	ZC.registerComponent('ZColorPickerBase', ZColorPickerBase); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zcolorpickerbase.Templates; 
template.WCCanvas = (data) => ZT.html `<canvas class="${data.rtl ? 'zh-flipY' : ''}"></canvas>`; 
template.WCPalette = (data) => { 
let responseTemplate = data.colorChunks.length && ZT.html `<div ?id=${data.id} data-custom="${data.isCustom}" class="zcolorpicker__palettecontainer ${data.className || ''}" data-palettename="${data.name}"> ${data.heading && ZT.html `<span class="zcolorpicker__paletteheading"> ${data.heading} </span>`} <div class="zcolorpicker__palette"> ${data.colorChunks.map((colorChunk) => data.hasTones ? ZT.html `<div class="zcolorpicker__navigatable"> ${colorChunk.map((baseColor) => ZT.html `<ul class="zcolorpicker__shades"> ${template.WCColorpan(baseColor)} ${baseColor.tones.map((shade) => template.WCColorpan(shade))} </ul> `)} </div>` : ZT.html `<ul> ${colorChunk.map((baseColor) => baseColor.addBtn ? ZT.html `<li class="zcolorpicker__addcolor">${ZC.zbutton.Templates.WCContainer(baseColor)}</li>` : template.WCColorpan(baseColor))} </ul>`)} </div> </div> `; return responseTemplate; } 
template.WCColorpan = (data) => ZT.html `<li ?data-shade="${data.isShade}" data-palette-name="${data.paletteName}" class="zcolorpicker__colorpan ${data.selected ? 'is-selected' : ''}" tabindex=${data.tabindex} ?data-tone-type="${data.toneType}" ?data-theme="${data.theme}" ?data-tone-percent="${data.tonePercent}" ?data-zcolor="${data.rgb}" ?data-base-color="${data.baseColor}" style="background-color:${data.rgb};" ?aria-hidden="${data.hidden}" ?aria-selected="${data.selected}" title="${data.title}"></li>`; 
let utilities = ZC.Templates.Utilities; 
template.WCSlider = (data) => ZT.html `<div ?id=${data.id} class="zslider ${data.className || ''}"> <div class="zslider__track ${data.opacity ? 'zcolorpicker__transparentbg' : ''}"> ${template.WCCanvas(data)} </div> <div role="slider" class="zslider__thumb ${data.thumbIcon ? '' : 'zslider__circlethumb'}" style="left:${data.left}%;"> ${data.thumbIcon && utilities.WCIcon(data.thumbIcon)} </div> </div>` 
template.WCTitle = (data) => { 
let template = ZT.html `<div class="zcolorpicker__header zcolorpicker__titlebar"> <span class="zcolorpicker__title zcolorpicker__text">${ZT.customHTML(data.title)}</span> ${data.closeButton && ZT.html `<div class="zcolorpicker__actiongroup zcolorpicker__action"> ${ZC.zbutton.Templates.WCContainer(data.closeButton)} </div>`} </div>`; return template; } }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zcolorpickerbase.Templates; 
template.canvas = (data) => ZT.html `<canvas class="${data.rtl ? 'zh-flipY' : ''}"></canvas>`; 
template.palette = (data) => { 
let responseTemplate = data.colorChunks.length && ZT.html `<div ?id=${data.id} data-custom="${data.isCustom}" class="zcolorpicker__palettecontainer ${data.className || ''}" data-palettename="${data.name}"> ${data.heading && ZT.html `<span class="zcolorpicker__paletteheading"> ${data.heading} </span>`} <div class="zcolorpicker__palette"> ${data.colorChunks.map((colorChunk) => data.hasTones ? ZT.html `<div class="zcolorpicker__navigatable"> ${colorChunk.map((baseColor) => ZT.html `<ul class="zcolorpicker__shades"> ${template.colorpan(baseColor)} ${baseColor.tones.map((shade) => template.colorpan(shade))} </ul> `)} </div>` : ZT.html `<ul> ${colorChunk.map((baseColor) => baseColor.addBtn ? ZT.html `<li class="zcolorpicker__addcolor">${ZC.zbutton.Templates.container(baseColor)}</li>` : template.colorpan(baseColor))} </ul>`)} </div> </div> `; return responseTemplate; } 
template.colorpan = (data) => ZT.html `<li ?data-shade="${data.isShade}" data-palette-name="${data.paletteName}" class="zcolorpicker__colorpan ${data.selected ? 'is-selected' : ''}" tabindex=${data.tabindex} ?data-tone-type="${data.toneType}" ?data-theme="${data.theme}" ?data-tone-percent="${data.tonePercent}" ?data-zcolor="${data.rgb}" ?data-base-color="${data.baseColor}" style="background-color:${data.rgb};" ?aria-hidden="${data.hidden}" ?aria-selected="${data.selected}" title="${data.title}"></li>`; 
let utilities = ZC.Templates.Utilities; 
template.slider = (data) => ZT.html `<div ?id=${data.id} class="zslider ${data.className || ''}"> <div class="zslider__track ${data.opacity ? 'zcolorpicker__transparentbg' : ''}"> ${template.canvas(data)} </div> <div role="slider" class="zslider__thumb ${data.thumbIcon ? '' : 'zslider__circlethumb'}" style="left:${data.left}%;"> ${data.thumbIcon && utilities.icon(data.thumbIcon)} </div> </div>` 
template.title = (data) => { 
let template = ZT.html `<div class="zcolorpicker__header zcolorpicker__titlebar"> <span class="zcolorpicker__title zcolorpicker__text">${ZT.customHTML(data.title)}</span> ${data.closeButton && ZT.html `<div class="zcolorpicker__actiongroup zcolorpicker__action"> ${ZC.zbutton.Templates.container(data.closeButton)} </div>`} </div>`; return template; } }(ZComponents)); 
(function(ZC, $){
	class ZAdvancedColorPicker extends ZC.ZColorPickerBase {
			get name(){
				return "zadvancedcolorpicker";
			}
	    get attrs() {
	        return {
	            opacity: true,
	            mapMarkerIconClass: null,
	            mapMarkerSVGIconId: null,
	            colorPreview: true,
	            previousColorInPreview: true,
	            colorFields: true,
	            defaultColorField: 'hex', // No I18N
	            currentColorField: 'hex', // No I18N
	            opacityFieldType: 'percent', // No I18N
	            palettes: false,
	            paletteColumns: 0,
	            addIconClass: null,
	            addSVGIconId: null,
	            immediateCommit: false,
	            closeOnSelect: false,
	            OKButtonLabel: null,
	            OKButtonClass: null,
	            cancelButtonLabel: null,
	            cancelButtonClass: null,
	            hideCancelButton: false,
	            backButton: true,
	            backButtonLabel: null,
	            backButtonClass: null,
	            boxSelectionTypeDefaultColorModel: 'HSV' // No I18N
	        }
	    }
	    get props() {
	        return {
	            slider: null,
	            mapMarkerIconClassName: null,
	            addIconClassName: null,
	            OKButtonClassName: null,
	            cancelButtonClassName: null,
	            backButtonClassName: null,
	            colorFieldsList: null, // No I18N
	            colorFieldSelect: {
	                width: 'none', // No I18N
	                dropdownList: {
	                    viewport: window
	                }
	            },
	            palettesList: null,
	            customColorLibraries: null,
	            commandBar: {
	                leftColumn: null,
	                centerColumn: null,
	                rightColumn: {
	                    commands: [ 'cancel', 'OK' ] // No I18N
	                }
	            },
	            boxSpectrumHSVColorModel: {
	                xAxis: 'saturation', // No I18N
	                yAxis: 'value' // No I18N
	            },
	            boxSpectrumHSLColorModel: {
	                xAxis: 'hue', // No I18N
	                yAxis: 'saturation' // No I18N
	            },
	            labels: {
	                close: 'Close', // No I18N
	                addcolor: 'Add Color', // No I18N
	                HSV: 'HSV', // No I18N
	                RGB: 'RGB', // No I18N
	                HSL: 'HSL', // No I18N
	                CMYK: 'CMYK', // No I18N
	                HEX: 'HEX', // No I18N
	                opacityField: 'A', // No I18N
	                hexField: 'HEX', // No I18N
	                hueField: 'H', // No I18N
	                saturationField: 'S', // No I18N
	                valueField: 'V', // No I18N
	                lightnessField: 'L', // No I18N
	                redField: 'R', // No I18N
	                greenField: 'G', // No I18N
	                blueField: 'B', // No I18N
	                cyanField: 'C', // No I18N
	                magentaField: 'M', // No I18N
	                yellowField: 'Y', // No I18N
	                keyField: 'K', // No I18N
	                ok: 'OK', // No I18N
	                cancel: 'Cancel', // No I18N
	                back: 'Back' // No I18N
	            }
	        }
	    }
	    get CLASSES() {
	        return {
	            CONTAINER: 'zcolorpicker zcolorpicker--advanced' // No I18N
	        }
	    }
	    get EVENTS() {
	        return [
	            'cancel', // No I18N
	            'back', // No I18N
	            'ok', // No I18N
	            'beforecolorpanadd', // No I18N
	            'colorpanadd', // No I18N
	            'beforecolorpanremove', // No I18N
	            'colorpanremove', // No I18N
	            'colorfieldlistchange' // No I18N
	        ]
	    }
	    get _MODEPROPS() {
	        return {
	            hsv: [ 'h', 's', 'v' ], // No I18N
	            rgb: [ 'r', 'g', 'b' ], // No I18N
	            hex: [ 'hex' ], // No I18N
	            hsl: [ 'h', 's', 'l' ], // No I18N
	            cmyk: [ 'c', 'm', 'y', 'k' ] // No I18N
	        }
	    }
	    get PROP_EXP() {
	        return {
	            h: 'hue', // No I18N
	            s: 'saturation', // No I18N
	            v: 'value', // No I18N
	            l: 'lightness', // No I18N
	            r: 'red', // No I18N
	            g: 'green', // No I18N
	            b: 'blue', // No I18N
	            a: 'opacity', // No I18N
	            hex: 'hex', // No I18N
	            c: 'cyan', // No I18N
	            m: 'magenta', // No I18N
	            y: 'yellow', // No I18N
	            k: 'key' // No I18N
	        }
	    }
	    get _hueColors() {
	        return [ 'rgba(255, 0, 0, 1)', 'rgba(255, 255, 0, 1)', 'rgba(0, 255, 0, 1)', 'rgba(0, 255, 255, 1)', 'rgba(0, 0, 255, 1)', 'rgba(255, 0, 255, 1)', 'rgba(255, 0, 0, 1)' ] // No I18N
	    }
	    _setDimension() {
	        if (!this._widthSet) {
	            super._setDimension(...arguments);
	        }
	    }
	    _updateDim() {
	        if (!this.element[0].style.width) {
	            let width = this._opts.width || this._swatch[0].offsetWidth;
	            if (width) {
	                this.element[0].style.width = isNaN(width) ? width : (width + 'px'); // No I18N
	                this._widthSet = true;
	            }
	        }
	    }
	    _storeRef(data, options) {
	        let isAttrChanged = this._isAttrChanged.bind(this);
	        super._storeRef(...arguments);
	        if (!data.rendered) {
	            this._swatch = this._getById(data.swatchId); // No I18N
	            this._swatchContext = this._getCanvasContext(this._swatch[0]);
	            this._swatchThumb = $(this._swatch[0].querySelector('.zcolorpicker__mapmarker'));// No I18N
	            this._bar = this._getById(data.swatchBar.id);
	            this._barContext = this._getCanvasContext(this._bar[0]);
	            this._barThumb = this._getThumb(this._bar[0]);
	        }
	        if (isAttrChanged('opacity')) { // No I18N
	            this._opacityBar = this._opacityContext = this._opacityThumb = false;
	            if (options.opacity) {
	                this._storeOpacityRef(data);
	            }
	        }
	        if (isAttrChanged('colorPreview')) { // No I18N
	            if (data.colorPreview && options.previousColorInPreview) {
	                this._bindPreview(data.colorPreview);
	            }
	        }
	        if (isAttrChanged('commandBar')) { // No I18N
	            if (data.commandBar) {
	                this._storeCmdBarRef(data.commandBar);
	            }
	        }
	        if (isAttrChanged('palette') || this._paletteChanged) { // No I18N
	            this._paletteChanged = false;
	            if (options.palettes && options.customColorLibraries) {
	                this._storeCustomLibRef(data, options);
	            }
	        }
	        if (options.colorFields) {
	            this._storeClrFieldRef(data.colorFields);
	        }
	    }
	    _postEachRender(element, data) {
	        super._postEachRender(...arguments);
	        if (data.markerIcon) {
	            this._swatch
	                .find('.zcolorpicker__mapmarker') // No I18N
	                .css({
	                    left: data.x + '%', // No I18N
	                    top: data.y + '%' // No I18N
	                });
	        }
	        this._paintPicker(this._axisProps.x, this._axisProps.y, this._axisProps.z);
	        data.opacity && this._paintOpacity();
	        data.colorFields && this._setClrFieldValues(data.colorFields);
	        this._changedAttrs = [];
	    }
	    _setRenderData(data, options, element) {
	        super._setRenderData(...arguments);
	        let isAttrChanged = this._isAttrChanged.bind(this);
	        if (isAttrChanged('swatchBars')) { // No I18N
	            data.swatchId = this._getID('swatch');// No I18N
	            data.swatchBar = {
	                id: this._getID('swatchbar'), // No I18N
	                className: 'zcolorpicker__slider', // No I18N
	                rtl: data.rtl
	            }
	            this._vertical = options.barOrientation === 'vertical'; // No I18N
	        }
	        if (isAttrChanged('marker')) { // No I18N
	            data.markerIcon = false;
	            let mapMarkerIconClass = options.mapMarkerIconClass || options.mapMarkerIconClassName;
	            let mapMarkerSVGIconId = options.mapMarkerSVGIconId;
	            if (mapMarkerIconClass || mapMarkerSVGIconId) {
	                ZC._getIconInfo(mapMarkerIconClass, mapMarkerSVGIconId, '', 'zcolorpicker__mapmarker', data.markerIcon = {}); // No I18N
	            }
	        }
	        if (isAttrChanged('opacity')) { // No I18N
	            if (options.opacity || data.opacity) {
	                this._setOpacityData(data, options);
	            }
	        }
	        if (isAttrChanged('commandBar')) { // No I18N
	            if (!options.immediateCommit || data.commandBar) {
	                this._setCmdBarData(data, options);
	            }
	        }
	        if (isAttrChanged('swatch')) { // No I18N
	            data.swatchBar.thumbIcon = this._getThumbData(options.slider);
	            this._configurePickerMethods(options);
	        }
	        if (isAttrChanged('palette')) { // No I18N
	            if (options.palettes || data.palettes || data.customColorLibraries) {
	                this._setPaletteData(data, options);
	            }
	        }
	        if (isAttrChanged('colorField')) { // No I18N
	            if (options.colorFields || data.colorFields) {
	                this._setClrFieldData(data, options);
	            }
	        }
	        if (options.colorPreview || data.colorPreview) {
	            this._setPreviewData(data, options);
	        }
	        if (options.palettes) {
	            this._updateSelection(data, options);
	        }
	        if (data.colorFields) {
	            this._saveFieldValues(data.colorFields, options);
	        }
	        this._updatePickerPositionInData(data, options);
	    }
	    _bindEvents() {
	        super._bindEvents(...arguments);
	        let mousedownEvent = 'mousedown'; // No I18N
	        this._addEvents({
	            swatchDrag: mousedownEvent
	        }, this._swatch);
	        this._addEvents({
	            swatchPickerDrag: mousedownEvent
	        }, this._bar);
	    }
	    _swatchDragHandler(orgEvent) {
	        this._dragStartHandler(orgEvent, 'swatch'); // No I18N
	    }
	    _swatchPickerDragHandler(orgEvent) {
	        this._dragStartHandler(orgEvent, 'swatchbar'); // No I18N
	    }
	    _dragStartHandler(orgEvent, type) {
	        if (!orgEvent.button) {
	            let picker, container;
	            if (type === 'swatch') { // No I18N
	                container = this._swatch;
	                picker = this._swatchThumb;
	            } else if (type === 'swatchbar') {// No I18N
	                container = this._bar;
	                picker = this._barThumb;
	            } else {
	                container = this._opacityBar;
	                picker = this._opacityThumb;
	            }
	            this._activeContainer = {
	                picker,
	                type,
	                offset: container.offset(),
	                height: container.height(),
	                width: container.width()
	            }
	            super._dragStartHandler(orgEvent);
	            this.setFocus();
	        }
	    }
	    _onPickerDragged(orgEvent) {
	        orgEvent.preventDefault();
	        let container = this._activeContainer;
	        let cursorPos, totalPixel;
	        cursorPos = orgEvent.pageX - container.offset.left;
	        totalPixel = container.width;
	        let leftpercent = this._limit(cursorPos / totalPixel, 0, 1) * 100;
	        cursorPos = orgEvent.pageY - container.offset.top;
	        totalPixel = container.height;
	        let toppercent = this._limit(cursorPos / totalPixel, 0, 1) * 100;
	        let data = this._data;
	        if (container.type === 'swatch') { // No I18N
	            data.x = leftpercent;
	            data.y = toppercent;
	        } else {
	            data[container.type === 'opacity' ? 'o' : 'z'] = this._vertical ? toppercent : leftpercent; // No I18N
	        }
	        let colorObj = this._getColorFromCoords();
	        this._skipPickerData = true;
	        this._setValue(colorObj, orgEvent);
	        this._skipPickerData = false;
	    }
	    _getCoordsFromColor(options) {
	        let color = this._colorInstance.getPercentageObject(options.boxSelectionTypeDefaultColorModel.toLowerCase());
	        return {
	            x: this._getRTLBasedPercent(parseFloat(color[this._axisProps.x[0]])),
	            y: parseFloat(color[this._axisProps.y[0]]),
	            z: this._getRTLBasedPercent(parseFloat(color[this._axisProps.z[0]])),
	            o: this._getRTLBasedPercent(parseFloat(color.a))
	        }
	    }
	    _updatePickerPositionInData(data, options) {
	        data.vertical = this._vertical;
	        if (!this._skipPickerData) {
	            let coords = this._getCoordsFromColor(options);
	            data.x = coords.x;
	            data.y = (100 - coords.y);
	            data.z = coords.z;
	            data.o = coords.o;
	        }
	        data.swatchBar.left = data.z;
	        if (options.opacity) {
	            let opacitySlider = data.opacitySlider;
	            opacitySlider.left = data.o;
	            opacitySlider.vertical = this._vertical;
	        }
	    }
	    _configurePickerMethods(options) {
	        if (options.boxSelectionTypeDefaultColorModel === 'HSL') { // No I18N
	            this._paintPicker = this._HSLUtils.paintPicker.bind(this);
	            this._axisProps = this._HSLUtils.getXYProps(options.boxSpectrumHSLColorModel);
	        } else {
	            this._paintPicker = this._HSVUtils.paintPicker.bind(this);
	            this._axisProps = this._HSVUtils.getXYProps(options.boxSpectrumHSVColorModel);
	        }
	    }
	    _onSubmit(orgEvent) {
	        this._onOkButtonClick(orgEvent);
	    }
	    _onOkButtonClick(orgEvent) {
	        this.setValue(this._currentColor, orgEvent);
	        this._trigger('ok', orgEvent); // No I18N
	        this.close(orgEvent);
	    }
	    _onCancelButtonClick(orgEvent) {
	        this._revertColor(orgEvent);
	        this._trigger('cancel', orgEvent); // No I18N
	        this.close(orgEvent);
	    }
	    _onBackButtonClick(orgEvent) {
	        this._trigger('back', orgEvent); // No I18N
	    }
	    _revertColor(orgEvent, prevColor) {
	        this.setValue(prevColor || this._selectedInstance.getObject(), orgEvent);
	    }
	    _setHueStops(gradient) {
	        this._setGradientColors(gradient, this._hueColors);
	    }
	    _fillCanvas(context, gradient) {
	        context.fillStyle = gradient;
	        context.fill();
	    }
	    _clearCanvas() {
	        let rectContext = this._swatchContext;
	        let barContext = this._barContext;
	        rectContext.beginPath();
	        barContext.beginPath();
	        rectContext.clearRect(0, 0, rectContext.canvas.width, rectContext.canvas.height);
	        barContext.clearRect(0, 0, barContext.canvas.width, barContext.canvas.height);
	        rectContext.rect(0, 0, rectContext.canvas.width, rectContext.canvas.height);
	        barContext.rect(0, 0, barContext.canvas.width, barContext.canvas.height);
	    }
	    _createGradient(context, vertical) {
	        if (vertical) {
	            return context.createLinearGradient(0, context.canvas.height, 0, 0);
	        }
	        return context.createLinearGradient(0, 0, context.canvas.width, 0);
	    }
	    /* Function to select a color */
	    _setValue(color, orgEvent, data, fromUser) {
	        let isNoFill = color === 'none' || color === 'transparent'; // No I18N
	        let colorInstance = this._getClrInstance(isNoFill ? 'transparent' : color); // No I18N
	        if (!this._opts.opacity) {
	            colorInstance.setAlpha(1);
	        }
	        if (colorInstance.isValid()) {
	            colorInstance.initialColor = color;
	            let prevColor = this._currentColor;
	            this._colorInstance = colorInstance;
	            let currentColor = this._currentColor = this._colorInstance.getColor();
	            let triggerChange;
	            if (this._fromInit || fromUser || (this._opts.immediateCommit && (!orgEvent || !/^(mousedown|mousemove|znumberfieldspin|znumberfieldinput)$/.test(orgEvent.type)))) {
	                if (this._fromInit || currentColor !== this._selectedInstance.getColor()) {
	                    this._updateSelectedColor();
	                    triggerChange = true;
	                }
	            }
	            if (!this._opts.immediateCommit || fromUser || this._fromInit) {
	                this._previousInstance = this._selectedInstance;
	            }
	            this._updateUI();
	            if (prevColor !== currentColor) {
	                this._trigger('select', orgEvent); // No I18N
	            }
	            if (triggerChange) {
	                this._trigger('pick', orgEvent); // No I18N
	                this._trigger('change', orgEvent); // No I18N
	            }
	        }
	    }
	    _getColorFromCoords() {
	        let axisProps = this._axisProps;
	        let data = this._data;
	        let color = {};
	        let getRTLBasedPercent = this._getRTLBasedPercent.bind(this);
	        color[axisProps.x[0]] = getRTLBasedPercent(data.x) + '%'; // No I18N
	        color[axisProps.y[0]] = (100 - data.y) + '%'; // No I18N
	        color[axisProps.z[0]] = getRTLBasedPercent(data.z) + '%'; // No I18N
	        color.a = getRTLBasedPercent(data.o) + '%'; // No I18N
	        return color;
	    }
	    _onClose(orgEvent) {
	        // ColorFields are updated before closing
	        this._revertColor(orgEvent);
	        super._onClose(orgEvent);
	    }
	    setDimension() {
	        this._setDimension();
	    }
	    _destroy() {
	        let data = this._data;
	        if (data.colorFields) {
	            this._destroyClrFields();
	        }
	        if (data.commandBar) {
	            this._destroyCmdBar(data.commandBar);
	        }
	        this._paintPicker = undefined;
	        super._destroy(...arguments);
	    }
		addCustomColorsLibrary  (paletteData) {
		    this._addPalettes(paletteData, undefined, 'customColorLibraries'); // No I18N
		}
		insertCustomColorsLibraryBefore  (paletteData, paletteName) {
		    let index;
		    let paletteTemplateData = this._getPaletteTemplateData(paletteName);
		    if (paletteTemplateData) {
		        index = this._data.customColorLibraries.indexOf(paletteTemplateData);
		    }
		    this._addPalettes(paletteData, index, 'customColorLibraries'); // No I18N
		}
		insertCustomColorsLibraryAt  (paletteData, index) {
		    this._addPalettes(paletteData, index, 'customColorLibraries'); // No I18N
		}
		removeCustomColorsLibrary  (palettes) {
		    this._removePalettes(palettes, 'customColorLibraries'); // No I18N
		}
		removeCustomColorsLibraryAt  (index) {
		    this._removePalettesAt(index, 'customColorLibraries'); // No I18N
		}
		_setClrFieldData  (data, options) {
		    this._destroyClrFields();
		    if (options.colorFields) {
		        let colorFieldsList = options.colorFieldsList || [ 'hex', 'rgb', 'hsv', 'hsl', 'cmyk' ]; // No I18N
		        colorFieldsList = colorFieldsList.filter((mode) => /^(hex|rgb|cmyk|hex|hsv|hsl)$/.test(mode));
		        if (colorFieldsList && colorFieldsList.length) {
		            let colorFields = data.colorFields = {
		                hexFieldId: this._getID('hexfield') // No I18N
		            };
		            let defaultColorField = options.currentColorField || options.defaultColorField;
		            defaultColorField = (colorFieldsList.indexOf(defaultColorField) === -1) ? colorFieldsList[0] : defaultColorField;
		            if (colorFieldsList.length > 1) {
		                this._createClrFieldSelect(colorFields, colorFieldsList, defaultColorField);
		            }
		            colorFields.includeHexClass = options.opacity || (!options.opacity && !colorFields.select)
		            this._onModeChange(defaultColorField);
		            return;
		        }
		    }
		    data.colorFields = false;
		}
		_destroyClrFields  () {
		    let data = this._data;
		    let colorFields = data.colorFields;
		    if (colorFields) {
		        this._destroyComp(colorFields.select);
		        colorFields.numberFields.forEach((numberFieldObj) => this._destroyComp(numberFieldObj));
		        data.colorFields = false;
		    }
		}
		_storeClrFieldRef  (colorFields) {
		    if (this._isAttrChanged('colorField') || this._fromModeChange) { // No I18N
		        if (colorFields.currentMode === 'hex') { // No I18N
		            this._bindTextField(this._getById(colorFields.hexFieldId));
		        }
		        this._setMainEle(colorFields.select);
		        this._setMainEle(colorFields.numberFields);
		    }
		}
		_setClrFieldValues  (colorFields) {
		    if (!this._skipFieldUpdate) {
		        let values = colorFields.propValues;
		        if (colorFields.currentMode === 'hex') { // No I18N
		            this._getById(colorFields.hexFieldId).val(values.hex);
		        }
		        colorFields.numberFieldProps.forEach((prop, index) => {
		            colorFields.numberFields[index].instance.setAttribute('value', values[prop]); // No I18N
		        });
		    }
		}
		_saveFieldValues  (colorFields, options) {
		    if (!this._skipFieldUpdate) {
		        let currentMode = colorFields.currentMode;
		        let colorInstance = this._colorInstance;
		        let values = colorFields.propValues = {};
		        if (currentMode === 'hex') { // No I18N
		            let hexValue = colorInstance.getColor('hex', false, false); // No I18N
		            values[currentMode] = hexValue;
		        }
		        let color = colorInstance.getObject(currentMode);
		        colorFields.numberFieldProps.forEach((prop) => {
		            let value;
		            if (prop === 'a') { // No I18N
		                value = colorInstance.getAlpha();
		                value = options.opacityFieldType === 'decimal' ? value : Math.round(value * 100); // No I18N
		                values.a = parseInt(value);
		            } else {
		                value = parseInt(color[prop]);
		            }
		            values[prop] = value;
		        });
		    }
		}
		_onModeChange  (currentMode, orgEvent) {
		    let colorFields = this._data.colorFields;
		    let options = this._opts;
		    let opacity, emptyLabel;
		    let props = colorFields.numberFieldProps = [ ...this._MODEPROPS[currentMode] ];
		    colorFields.currentMode = options.currentColorField = currentMode;
		    // Prev HexField needs to be unbinded - since new hexfield is created each and every time its cache resides in memory.
		    let hexFieldId = colorFields.hexFieldId;
		    if (hexFieldId) {
		        this._getById(hexFieldId).off();
		    }
		    if (currentMode !== 'cmyk') { // No I18N
		        if (options.opacity) {
		            props.push('a'); // No I18N
		            opacity = true;
		        } else if (colorFields.select) {
		            emptyLabel = true;
		        }
		    }
		    colorFields.opacity = opacity;
		    colorFields.labels = props.map((prop) => this._getI18NText(this.PROP_EXP[prop] + 'Field')); // No I18N
		    if (emptyLabel) {
		        colorFields.labels.push(''); // No I18N
		    }
		    let numberFields = colorFields.numberFields = colorFields.numberFields || [];
		    if (currentMode === 'hex') { // No I18N
		        props.shift();
		    }
		    (props.length || numberFields.length) && this._updateNumberFieldSettings(props, numberFields);
		    orgEvent && this._trigger('colorfieldlistchange', orgEvent); // No I18N
		}
		_fieldChangeHandler  (orgEvent) {
		    let target = $(orgEvent.target);
		    let targetId = target[0].id;
		    let colorFields = this._data.colorFields;
		    let value, colorProperty;
		    if (targetId === colorFields.hexFieldId) {
		        colorProperty = 'hex'; // No I18N
		        value = target.val();
		    } else {
		        colorProperty = colorFields.numberFields.find((numberFieldObj) => numberFieldObj.id === targetId).colorProperty;
		        value = orgEvent.detail.value;
		    }
		    let propValues = colorFields.propValues;
		    // NumberField Based Value
		    propValues[colorProperty] = value;
		    propValues = {
		        ...propValues
		    }
		    for (var prop in propValues) {
		        if (/(s|v|l|c|m|y|k)/.test(prop)) {
		            propValues[prop] += '%' // No I18N
		        }
		    }
		    if (this._opts.opacityFieldType !== 'decimal') { // No I18N
		        // Decimal Based Value
		        propValues.a /= 100;
		    }
		    this._skipFieldUpdate = true;
		    this._setValue(propValues, orgEvent);
		    this._skipFieldUpdate = false;
		}
		_setPreviewData  (data, options) {
		    data.colorPreview = false;
		    if (options.colorPreview) {
		        let previousColor, previousColorId;
		        if (options.previousColorInPreview) {
		            previousColor = this._previousInstance.getColor();
		            previousColorId = this._getID('previouscolor'); // No I18N
		        }
		        data.colorPreview = {
		            color: data.rgb,
		            previousColor,
		            previousColorId
		        }
		    }
		}
		_bindPreview  (colorPreview) {
		    this._addEvents({
		        prevPreviewClick: 'mousedown'// No I18N
		    }, this._getById(colorPreview.previousColorId));
		}
		_prevPreviewClickHandler  (orgEvent) {
		    this._revertColor(orgEvent, this._data.colorPreview.previousColor);
		}
		_storeCmdBarRef  (commandBar) {
		    for (let column in commandBar) {
		        let buttons = commandBar[column];
		        buttons.forEach((buttonObj) => {
		            this._setMainEle(buttonObj);
		            let buttonEle = this._getById(buttonObj.id);
		            buttonEle
		                .off()
		                .on('click.' + this.name, buttonObj.zhandler); // No I18N
		            this._handleFocus(buttonEle);
		        });
		    }
		}
		_setCmdBarData  (data, options) {
		    // this._destroyCmdBar(data.commandBar);
		    data.commandBar = false;
		    if (!options.immediateCommit && options.commandBar) {
		        let commandBar = options.commandBar;
		        data.commandBar = {
		            left: [],
		            right: [],
		            center: []
		        }
		        let handlers = {
		            OK: this._onOkButtonClick,
		            cancel: this._onCancelButtonClick,
		            back: this._onBackButtonClick
		        }
		        let buttonObjects = {};
		        [ 'OK', 'cancel', 'back' ].forEach((command) => { // No I18N
		            buttonObjects[command] = ZC.ZButton.getBtnProps({
		                ...this._getBaseObj('button'), // No I18N
		                ...{
		                    id: this._getID('zactionbutton-' + command), // No I18N
		                    customAttributes: {
		                        actionName: command
		                    },
		                    size: 'small', // No I18N
		                    zhandler: handlers[command].bind(this),
		                    zclassName: options[command + 'ButtonClassName'] || options[command + 'ButtonClass'], // No I18N
		                    appearance: command === 'OK' ? 'primary' : 'normal', // No I18N
		                    text: options[command + 'ButtonLabel'] || this._getI18NText(command.toLowerCase()) // No I18N
		                }
		            });
		        });
		        // buttonObjects.OK.appearance = 'primary'; // No I18N
		        [ 'left', 'right', 'center' ].forEach((section) => {// No I18N
		            let column = commandBar[section + 'Column'];// No I18N
		            let commands = column && column.commands;
		            if (commands) {
		                commands.forEach((action) => {
		                    if (action !== 'cancel' || !options.hideCancelButton) { // No I18N
		                        let buttonObj = buttonObjects[action];
		                        if (buttonObj) {
		                            data.commandBar[section].push(buttonObj);
		                            buttonObjects[action] = undefined;
		                        }
		                    }
		                });
		            }
		        });
		    }
		}
		_destroyCmdBar  (commandBar) {
		    if (commandBar) {
		        for (let section in commandBar) {
		            commandBar[section].forEach((buttonObj) => this._destroyComp(buttonObj));
		        }
		    }
		}
		_storeCustomLibRef  (data, options) {
		    data.customColorLibraries.forEach((paletteData) => {
		        let addBtnObject = paletteData.addBtn;
		        this._setMainEle(addBtnObject);
		        let addBtn = addBtnObject.mainElement;
		        addBtn.paletteName = paletteData.name;
		        // Binding add button
		        this._handleFocus($(addBtn), this.name);
		        this._addEvents({
		            addBtnClick: 'mousedown' // No I18N
		        }, $(addBtn));
		        // Binding DELETE Key press
		        this._addEvents({
		            delKey: 'keydown' // No I18N
		        }, this._getById(paletteData.id));
		    });
		}
		_addBtnClickHandler  (orgEvent) {
		    let button = $(orgEvent.target).closest('.zbutton')[0]; // No I18N
		    this._skipPickerData = true;
		    if (this.isCE) {
		        button.$c._addedByComponent = true;
		    }
		    this.addColor(button.paletteName, this._colorInstance.getColor());
		    if (this.isCE) {
		        button.$c._addedByComponent = false;
		    }
		    orgEvent.target = button;
		    this._skipPickerData = false;
		    orgEvent.stopPropagation();
		}
		_delKeyHandler  (orgEvent) {
		    if (orgEvent.keyCode === ZC.keyCode.DELETE) {
		        let colorpan = orgEvent.target;
		        if ($(colorpan).is(`.${this._CLASSES.COLORBOX}`)) {
		            let eventData = this._getColorPanData(colorpan);
		            if (this._trigger('beforecolorpanremove', orgEvent, eventData)) { // No I18N
		                let paletteName = orgEvent.currentTarget.getAttribute('data-palettename'); // No I18N
		                this._removeColors(paletteName, colorpan.getAttribute('data-zcolor')); // No I18N
		                this._trigger('colorpanremove', orgEvent, eventData); // No I18N
		            }
		        }
		    }
		}
		_getAddBtnData  (paletteData) {
		    let addBtnDetails = paletteData.addBtn;
		    if (addBtnDetails) {
		        return addBtnDetails;
		    }
		    let id = this._getID(paletteData.name) + '-addicon'; // No I18N
		    let options = this._opts;
		    let SVGIconId = options.addSVGIconId;
		    let iconClassName = options.addIconClassName || options.addIconClass;
		    if (!SVGIconId && !iconClassName) {
		        SVGIconId = 'zc__svg--add addColorIcon'; // No I18N
		    }
		    let addBtnOptions = ZC.ZButton.getBtnProps({
		        ...this._getBaseObj('button'), // No I18N
		        ...{
		            id,
		            iconClassName,
		            SVGIconId,
		            defaultIconClassName: 'zcolorpicker__addcoloricon', // No I18N
		            title: this._getI18NText('addcolor'), // No I18N
		            addBtn: true
		        }
		    });
		    if (this._domChanged) {
		        this._destroyComp(addBtnOptions);
		    }
		    return addBtnOptions;
		}
		get _HSLUtils (){
			return	 {
		    fill(y, z, m, rgb) {
		        let context = z === m ? this._barContext : this._swatchContext;
		        let vertical = ((z === m && this._vertical) || y === m);
		        let gradient = this._createGradient(context, vertical);
		        switch (m) {
		            case 'hue': // No I18N
		                this._setHueStops(gradient);
		                break;
		            case 'saturation': // No I18N
		                this._setGradientColors(gradient, [ 'rgba(128,128,128,1)', rgb || 'rgba(128,128,128,0)' ]); // No I18N
		                break;
		            case 'lightness': // No I18N
		                gradient.addColorStop(0, 'rgb(0,0,0)'); // No I18N
		                if (rgb) {
		                    gradient.addColorStop(0.5, rgb);
		                } else {
		                    gradient.addColorStop(0.5, 'rgba(0,0,0,0)'); // No I18N
		                    gradient.addColorStop(0.5, 'rgba(255,255,255,0)'); // No I18N
		                }
		                gradient.addColorStop(1, 'rgb(255,255,255)'); // No I18N
		        }
		        this._fillCanvas(context, gradient);
		    },
		    getLightnessLayer(lightness) {
		        if (lightness < 50) {
		            return `rgba(0, 0, 0, ${1 - (lightness / 50)})`;
		        } else if (lightness > 50) {
		            return `rgba(255, 255, 255, ${(lightness - 50) / 50}`;
		        }
		    },
		    paintPicker(x, y, z) {
		        this._clearCanvas();
		        let hsl = this._colorInstance.getObject('hsl'); // No I18N
		        // let hsl = this._getColorFromCoords();
		        let rectContext = this._swatchContext;
		        let barContext = this._barContext;
		        let fill = this._HSLUtils.fill.bind(this, y, z);
		        let getLightnessLayer = this._HSLUtils.getLightnessLayer.bind(this, parseFloat(hsl.l));
		        switch (z) {
		            case 'lightness': // No I18N
		                // Hue
		                fill('hue'); // No I18N
		                // Saturation
		                fill('saturation'); // No I18N
		                // lightness
		                // var lightnessLayer = getLightnessLayer();
		                // lightnessLayer && this._fillCanvas( rectContext, lightnessLayer );
		                // z
		                fill('lightness', this._getClrInstance({ // No I18N
		                    h: hsl.h,
		                    s: hsl.s,
		                    l: '50%' // No I18N
		                }).getColor());
		                break;
		            case 'hue': // No I18N
		                // Actual Color
		                this._fillCanvas(rectContext, this._getClrInstance({
		                    h: hsl.h,
		                    s: '100%',
		                    l: '50%'
		                }).getColor());
		                // Saturation
		                fill('saturation'); // No I18N
		                // lightness
		                fill('lightness'); // No I18N
		                // z
		                fill('hue'); // No I18N
		                /* this._fillCanvas( barContext, 'rgba(128,128,128,'+ (1 - parseFloat( hsl.s )/100) +')'); //No I18N
		                    var lightnessLayer = getLightnessLayer();
		                    lightnessLayer && this._fillCanvas( barContext, lightnessLayer ); */
		                break;
		            case 'saturation': // No I18N
		                {
		                    // Hue
		                    fill('hue'); // No I18N
		                    // Saturation
		                    // this._fillCanvas( rectContext, 'rgba(128,128,128,'+(1 - parseFloat( hsl.s )/100)+')' ); //No I18N
		                    // lightness
		                    fill('lightness'); // No I18N
		                    // z
		                    fill('saturation', this._getClrInstance({ // No I18N
		                        h: hsl.h,
		                        s: '100%',
		                        l: '50%'
		                    }).getColor());
		                    let lightnessLayer = getLightnessLayer();
		                    lightnessLayer && this._fillCanvas(barContext, lightnessLayer);
		                }
		                break;
		        }
		    },
		    getXYProps(XYAxis) {
		        let x, y, z;
		        switch (XYAxis.xAxis + '-' + XYAxis.yAxis) { // No I18N
		            case 'saturation-hue': // No I18N
		                x = 'saturation'; // No I18N
		                y = 'hue'; // No I18N
		                z = 'lightness'; // No I18N
		                break;
		            case 'hue-lightness': // No I18N
		                x = 'hue'; // No I18N
		                y = 'lightness'; // No I18N
		                z = 'saturation'; // No I18N
		                break;
		            case 'lightness-hue': // No I18N
		                x = 'lightness'; // No I18N
		                y = 'hue'; // No I18N
		                z = 'saturation'; // No I18N
		                break;
		            case 'lightness-saturation': // No I18N
		                x = 'lightness'; // No I18N
		                y = 'saturation'; // No I18N
		                z = 'hue'; // No I18N
		                break;
		            case 'saturation-lightness': // No I18N
		                x = 'saturation'; // No I18N
		                y = 'lightness'; // No I18N
		                z = 'hue'; // No I18N
		                break;
		            default:
		                x = 'hue'; // No I18N
		                y = 'saturation'; // No I18N
		                z = 'lightness'; // No I18N
		                break;
		        }
		        return {
		            x,
		            y,
		            z
		        };
		    }
		}
		 }
  
	get _HSVUtils (){
			return	 {
		    fill(y, z, m, rgb) {
		        let context = z === m ? this._barContext : this._swatchContext;
		        let vertical = ((z === m && this._vertical) || y === m);
		        let gradient = this._createGradient(context, vertical);
		        switch (m) {
		            case 'hue': // No I18N
		                this._setHueStops(gradient);
		                break;
		            case 'saturation': // No I18N
		                this._setGradientColors(gradient, [ 'rgba(255,255,255,1)', rgb || 'rgba(255,255,255,0)' ]); // No I18N
		                break;
		            case 'value': // No I18N
		                this._setGradientColors(gradient, [ 'rgba(0,0,0,1)', rgb || 'rgba(0,0,0,0)' ]); // No I18N
		        }
		        this._fillCanvas(context, gradient);
		    },
		    getValueLayer(value) {
		        return 'rgba(0, 0, 0, ' + (1 - value / 100) + ')'; // No I18N
		    },
		    paintPicker(x, y, z) {
		        this._clearCanvas();
		        let hsv = this._colorInstance.getObject('hsv'); // No I18N
		        // let hsv = this._getColorFromCoords();
		        let rectContext = this._swatchContext;
		        let barContext = this._barContext;
		        let fill = this._HSVUtils.fill.bind(this, y, z);
		        let getValueLayer = this._HSVUtils.getValueLayer.bind(this, parseFloat(hsv.v));
		        switch (z) {
		            case 'value': // No I18N
		                // Hue
		                fill('hue'); // No I18N
		                // Saturation
		                fill('saturation'); // No I18N
		                // Value
		                this._fillCanvas(rectContext, getValueLayer());
		                // z
		                fill('value', this._getClrInstance({ // No I18N
		                    h: hsv.h,
		                    s: hsv.s,
		                    v: '100%'
		                }).getColor());
		                break;
		            case 'hue': // No I18N
		                // Actual Color
		                this._fillCanvas(rectContext, this._getClrInstance({
		                    h: hsv.h,
		                    s: '100%',
		                    v: '100%'
		                }).getColor());
		                // Saturation
		                fill('saturation'); // No I18N
		                // Value
		                fill('value'); // No I18N
		                // z
		                fill('hue'); // No I18N
		                break;
		            case 'saturation': // No I18N
		                // Hue
		                fill('hue'); // No I18N
		                // Saturation
		                this._fillCanvas(rectContext, 'rgba(255,255,255,' + (1 - parseFloat(hsv.s) / 100) + ')'); // No I18N
		                // Value
		                fill('value'); // No I18N
		                // z
		                fill('saturation', this._getClrInstance({ // No I18N
		                    h: hsv.h,
		                    s: '100%',
		                    v: '100%'
		                }).getColor());
		                this._fillCanvas(barContext, getValueLayer());
		                break;
		        }
		    },
		    getXYProps(XYAxis) {
		        let x, y, z;
		        switch (XYAxis.xAxis + '-' + XYAxis.yAxis) { // No I18N
		            case 'hue-saturation': // No I18N
		                x = 'hue'; // No I18N
		                y = 'saturation'; // No I18N
		                z = 'value'; // No I18N
		                break;
		            case 'saturation-hue': // No I18N
		                x = 'saturation'; // No I18N
		                y = 'hue'; // No I18N
		                z = 'value'; // No I18N
		                break;
		            case 'hue-value': // No I18N
		                x = 'hue'; // No I18N
		                y = 'value'; // No I18N
		                z = 'saturation'; // No I18N
		                break;
		            case 'value-hue': // No I18N
		                x = 'value'; // No I18N
		                y = 'hue'; // No I18N
		                z = 'saturation'; // No I18N
		                break;
		            case 'value-saturation': // No I18N
		                x = 'value'; // No I18N
		                y = 'saturation'; // No I18N
		                z = 'hue'; // No I18N
		                break;
		            default:
		                x = 'saturation'; // No I18N
		                y = 'value'; // No I18N
		                z = 'hue'; // No I18N
		                break;
		        }
		        return {
		            x,
		            y,
		            z
		        };
		    }
		}
		 }
  _updateNumberFieldSettings  (props, numberFields) {
		    props.forEach((prop, index) => {
		        let fieldSettings = this._getFieldSettings(prop);
		        let numberFieldObj = numberFields[index];
		        if (numberFieldObj) {
		            let instance = numberFieldObj.instance;
		            instance.setAttributes(fieldSettings);
		            this._display(true, numberFieldObj.container);
		        } else {
		            let basicSettings = this._getBasicNumberFieldOptions();
		            basicSettings.id = this._getID('znumberfield-' + index); // No I18N
		            [ 'change', 'spin', 'input', 'spinend' ].forEach((eventName) => { // No I18N
		                basicSettings[eventName] = this._fieldChangeHandler.bind(this);
		            });
		            numberFieldObj = {
		                ...basicSettings,
		                ...fieldSettings
		            }
		            if(!index && !this._data.colorFields.select && prop !== 'a'){ //No I18N
		                numberFieldObj.className += ' zcolorpicker--nomarginleft'; //No I18N
		            }
		            numberFields.push(numberFieldObj);
		        }
		        numberFieldObj.colorProperty = prop;
		    });
		    numberFields
		        .slice(props.length)
		        .forEach((numberFieldObj) => this._display(false, numberFieldObj.container));
		}
		_getFieldSettings  (prop) {
		    let settings = {
		        max: 100,
		        step: 1,
		        suffix: '', // No I18N
		        decimalPlaces: 0
		    }
		    if (prop === 'a' && this._opts.opacityFieldType === 'decimal') { // No I18N
		        settings.step = 0.01;
		        settings.decimalPlaces = 2;
		        settings.max = 1;
		    } else if (/^(s|l|v|c|m|y|k|a)$/.test(prop)) { // No I18N
		        settings.suffix = '%'; // No I18N
		    } else if (/^(r|g|b)$/.test(prop)) {
		        settings.max = 255;
		    } else if (prop === 'h') { // No I18N
		        settings.max = 359;
		    }
		    return settings;
		}
		_getBasicNumberFieldOptions  () {
		    let settings = super._getBasicNumberFieldOptions();
		    settings.className = 'zcolorpicker__othercolormodefield zcolorpicker__colorfield' // No I18N
		    return settings;
		}
		_paintOpacity  () {
		    let context = this._opacityContext;
		    context.beginPath();
		    context.clearRect(0, 0, context.canvas.width, context.canvas.height);
		    context.rect(0, 0, context.canvas.width, context.canvas.height);
		    let gradient = this._createGradient(context, this._vertical);
		    let rgbObj = this._colorInstance.getObject();
		    this._setGradientColors(gradient, [ `rgba(${rgbObj.r}, ${rgbObj.g}, ${rgbObj.b}, 0)`, `rgb(${rgbObj.r} ,${rgbObj.g} ,${rgbObj.b})` ]);
		    this._fillCanvas(context, gradient);
		}
		_storeOpacityRef  (data) {
		    let opacityBar = this._opacityBar = this._getById(data.opacitySlider.id);
		    this._opacityContext = this._getCanvasContext(opacityBar[0]);
		    this._opacityThumb = this._getThumb(opacityBar[0]);
		    this._addEvents({
		        opacityBarDrag: 'mousedown' // No I18N
		    }, opacityBar);
		}
		_setOpacityData  (data, options) {
		    data.opacitySlider = data.opacity = false;
		    if (options.opacity) {
		        data.opacity = true;
		        data.opacitySlider = {
		            id: this._getID('opacityslider'), // No I18N
		            className: 'zcolorpicker__opacityslider', // No I18N
		            rtl: data.rtl,
		            opacity: true,
		            thumbIcon: this._getThumbData(options.slider)
		        }
		    }
		}
		_opacityBarDragHandler  (orgEvent) {
		    this._dragStartHandler(orgEvent, 'opacity'); // No I18N
		}
		_createClrFieldSelect  (colorFields, colorFieldsList, defaultColorField) {
		    colorFields.select = $.extend(true, {},
		        this._getBaseObj('select'), // No I18N
		        {
		            id: this._getID('colorFields'), // No I18N
		            options: colorFieldsList.map((mode) => ({
		                label: this._getI18NText(mode.toUpperCase()),
		                value: mode,
		                selected: defaultColorField === mode
		            })),
		            zclassName: 'zcolorpicker__selectbox', // No I18N
		            change: (orgEvent) => {
		                this._fromModeChange = true;
		                this._onModeChange(orgEvent.detail.value, orgEvent);
		                this._updateUI();
		                this._fromModeChange = false;
		            },
		            dropdownList: {
		                appendTo: this.element
		            }
		        },
		        this._opts.colorFieldSelect);
		}
		_setPaletteData  (data, options) {
		    data.palettes = data.customColorLibraries = false;
		    if (options.palettes) {
		        data.palettes = [];
		        data.customColorLibraries = [];
		        this._addPalettes(options.palettesList);
		        this._addPalettes(options.customColorLibraries, null, 'customColorLibraries'); // No I18N
		    }
		}
		_updateSelection  (data) {
		    let callback = (palette) => this._updateClrSelection(palette.colors);
		    data.palettes.forEach(callback);
		    data.customColorLibraries.forEach(callback);
		}
		_updatePalettes  (paletteKey) {
		    let data = this._data;
		    let options = this._opts;
		    let callback = (paletteTemplateData) => paletteTemplateData.paletteData;
		    if (paletteKey === 'palettes') { // No I18N
		        options.palettesList = data.palettes.map(callback);
		    } else {
		        options.customColorLibraries = data.customColorLibraries.map(callback);
		    }
		    this._paletteChanged = true;
		    this._updateUI(true);
		}
		_setAttribute  (optionName, value) {
		    let response = super._setAttribute(optionName, value);
		    if (response === false) {
		        let regex = {
		            opacity: /^(opacity|opacityFieldType)$/,
		            colorField: /^(colorFields|colorFieldsList|currentColorField)$/,
		            palette: /^(paletteColumns|palettes|palettesList|customColorLibraries|addIconClassName|addIconClass|addSVGIconId)$/,
		            commandBar: /^(immediateCommit|commandBar|OKButtonLabel|OKButtonClassName|OKButtonClass|cancelButtonLabel|cancelButtonClassName|cancelButtonClass|hideCancelButton|backButtonLabel|backButtonClassName|backButtonClass)$/,
		            colorPreview: /^(colorPreview|previousColorInPreview)$/,
		            swatch: /^(boxSelectionTypeDefaultColorModel|boxSpectrumHSLColorModel|boxSpectrumHSVColorModel)$/,
		            marker: /^(mapMarkerIconClass|mapMarkerIconClassName|mapMarkerSVGIconId)$/
		        }
		        this._opts[optionName] = value;
		        if (optionName === 'slider') { // No I18N
		            this._changedAttrs.push('opacity', 'swatch'); // No I18N
		            this._domChanged = true;    
		        }else if(optionName === 'colorFieldSelect'){ //No I18N
		            let colorFieldsData = this._data.colorFields;
		            if(colorFieldsData){
		                let colorSelect = colorFieldsData.select;
		                if(colorSelect){
		                    ZC.select(colorSelect.mainElement)
		                        .setAttributes(value);     
		                }
		            }
		        } else if (regex.opacity.test(optionName)) {
		            this._changedAttrs.push('opacity', 'colorField'); // No I18N
		            this._domChanged = true;
		            if (!value) {
		                this._setValue(this._currentColor);
		            }
		        } else {
		            for (let mod in regex) {
		                if (regex[mod].test(optionName)) {
		                    this._changedAttrs.push(mod);
		                    this._domChanged = true;
		                }
		            }
		        }
		    }
		}
	}
	ZC.registerComponent('ZAdvancedColorPicker', ZC.ZColorPickerBase, ZAdvancedColorPicker); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zadvancedcolorpicker.Templates; 
let colorpickerBaseTemplate = ZC.zcolorpickerbase.Templates; 
let utilities = ZC.Templates.Utilities; 
template.WCChildren = (data) => { 
let returnTemplate = ZT.html `${data.hasCallout && ZT.html `<div class="zcolorpicker__pointer"></div>`} ${data.title && colorpickerBaseTemplate.WCTitle(data)} <div class="zcolorpicker__maparea" ?id=${data.swatchId}> ${colorpickerBaseTemplate.WCCanvas(data)} ${data.markerIcon ? utilities.WCIcon(data.markerIcon) : ZT.html ` <span class="zcolorpicker__mapmarker" style="left: ${data.x}%; top: ${data.y}%;"> </span>`} </div> <div class="zcolorpicker__colormodecontainer"> ${data.colorPreview && template.WCColorPreview(data.colorPreview)} <div class="zcolorpicker__slidercontainer"> ${colorpickerBaseTemplate.WCSlider(data.swatchBar)} ${data.opacitySlider && colorpickerBaseTemplate.WCSlider(data.opacitySlider)} </div> </div> ${data.colorFields && template.WCColorFields(data.colorFields)} ${data.palettes && data.palettes.map((paletteData) => colorpickerBaseTemplate.WCPalette(paletteData))} ${data.customColorLibraries && data.customColorLibraries.map((paletteData) => colorpickerBaseTemplate.WCPalette(paletteData))} ${data.commandBar && template.WCCommandBar(data.commandBar)} `; return returnTemplate; } 
template.WCColorFields = (data) => { 
let returnTemplate = ZT.html `<div class="zcolorpicker__colorfieldcontainer ${data.select ? '' : 'zh-aligncenter'}"> ${data.select && ZC.createSelect(data.select)} ${data.currentMode === 'hex' && template.WCHexField(data)} ${data.numberFields && data.numberFields.map((numberfield) => ZC.createNumberField(numberfield))} ${data.currentMode === 'hex' ? template.WCHexLabel(data) : ZT.html `<div class="zcolorpicker__othercolormodefieldlabelcontainer"> ${data.labels.map((label) => ZT.html `<label class="zcolorpicker__othercolormodefieldlabel">${label}</label>`)} </div>`} </div>`; return returnTemplate; } 
template.WCColorPreview = (data) => { 
let returnTemplate = ZT.html `<div class="zcolorpicker__previewbox"> <div class="zcolorpicker__transparentbg zcolorpicker__newcolorpreview"> <span class="zcolorpicker__dynamiccolor" style="background-color: ${data.color};"> </span> </div> ${data.previousColor && ZT.html `<div id=${data.previousColorId} class="zcolorpicker__transparentbg zcolorpicker__currentcolorpreview"> <span class="zcolorpicker__dynamiccolor" style="background-color: ${data.previousColor};"> </span> </div>`} </div>`; return returnTemplate; } 
template.WCCommandBar = (data) => { 
let returnTemplate = ZT.html `<div class="zcolorpicker__commandbar zcolorpicker__footer"> ${data.left.length && ZT.html `<div class="zcolorpicker__commandbaractionsleft"> ${template.WCColContent(data.left)} </div>`} ${data.center.length && ZT.html `<div class="zcolorpicker__commandbaractionscenter"> ${template.WCColContent(data.center)} </div>`} ${data.right.length && ZT.html `<div class="zcolorpicker__commandbaractionsright"> ${template.WCColContent(data.right)} </div>`} </div>`; return returnTemplate; } 
template.WCColContent = (data) => data.map((button) => ZC.zbutton.Templates.WCContainer(button)); 
template.WCHexField = (data) => { 
let returnTemplate = ZT.html `<div tabindex="-1" class="zinputfield zcolorpicker__colorfield ${data.select ? '' : 'zcolorpicker--nomarginleft'} ${data.includeHexClass ? 'zcolorpicker__hexcolorfield' : ''}" > <input id=${data.hexFieldId} data-zprop="hex" maxlength="7" class="zinputfield__textbox" aria-label=${data.labels[0]}> </div>`; return returnTemplate; } 
template.WCHexLabel = (data) => { 
let returnTemplate = ZT.html `<div class="zcolorpicker__hexcolorfieldlabelcontainer ${data.opacity ? '' : 'zcolorpicker__withoutopacity'}"> <label class="zcolorpicker__hexcolorfieldlabel">HEX</label> ${data.opacity && ZT.html `<label class="zcolorpicker__othercolormodefieldlabel">A</label>`} </div>`; return returnTemplate; } }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zadvancedcolorpicker.Templates; 
let colorpickerBaseTemplate = ZC.zcolorpickerbase.Templates; 
let utilities = ZC.Templates.Utilities; 
template.children = (data) => { 
let returnTemplate = ZT.html `${data.hasCallout && ZT.html `<div class="zcolorpicker__pointer"></div>`} ${data.title && colorpickerBaseTemplate.title(data)} <div class="zcolorpicker__maparea" ?id=${data.swatchId}> ${colorpickerBaseTemplate.canvas(data)} ${data.markerIcon ? utilities.icon(data.markerIcon) : ZT.html ` <span class="zcolorpicker__mapmarker" style="left: ${data.x}%; top: ${data.y}%;"> </span>`} </div> <div class="zcolorpicker__colormodecontainer"> ${data.colorPreview && template.colorPreview(data.colorPreview)} <div class="zcolorpicker__slidercontainer"> ${colorpickerBaseTemplate.slider(data.swatchBar)} ${data.opacitySlider && colorpickerBaseTemplate.slider(data.opacitySlider)} </div> </div> ${data.colorFields && template.colorFields(data.colorFields)} ${data.palettes && data.palettes.map((paletteData) => colorpickerBaseTemplate.palette(paletteData))} ${data.customColorLibraries && data.customColorLibraries.map((paletteData) => colorpickerBaseTemplate.palette(paletteData))} ${data.commandBar && template.commandBar(data.commandBar)} `; return returnTemplate; } 
template.colorFields = (data) => { 
let returnTemplate = ZT.html `<div class="zcolorpicker__colorfieldcontainer ${data.select ? '' : 'zh-aligncenter'}"> ${data.select && ZC.createSelect(data.select)} ${data.currentMode === 'hex' && template.hexField(data)} ${data.numberFields && data.numberFields.map((numberfield) => ZC.createNumberField(numberfield))} ${data.currentMode === 'hex' ? template.hexLabel(data) : ZT.html `<div class="zcolorpicker__othercolormodefieldlabelcontainer"> ${data.labels.map((label) => ZT.html `<label class="zcolorpicker__othercolormodefieldlabel">${label}</label>`)} </div>`} </div>`; return returnTemplate; } 
template.colorPreview = (data) => { 
let returnTemplate = ZT.html `<div class="zcolorpicker__previewbox"> <div class="zcolorpicker__transparentbg zcolorpicker__newcolorpreview"> <span class="zcolorpicker__dynamiccolor" style="background-color: ${data.color};"> </span> </div> ${data.previousColor && ZT.html `<div id=${data.previousColorId} class="zcolorpicker__transparentbg zcolorpicker__currentcolorpreview"> <span class="zcolorpicker__dynamiccolor" style="background-color: ${data.previousColor};"> </span> </div>`} </div>`; return returnTemplate; } 
template.commandBar = (data) => { 
let returnTemplate = ZT.html `<div class="zcolorpicker__commandbar zcolorpicker__footer"> ${data.left.length && ZT.html `<div class="zcolorpicker__commandbaractionsleft"> ${template.colContent(data.left)} </div>`} ${data.center.length && ZT.html `<div class="zcolorpicker__commandbaractionscenter"> ${template.colContent(data.center)} </div>`} ${data.right.length && ZT.html `<div class="zcolorpicker__commandbaractionsright"> ${template.colContent(data.right)} </div>`} </div>`; return returnTemplate; } 
template.colContent = (data) => data.map((button) => ZC.zbutton.Templates.container(button)); 
template.hexField = (data) => { 
let returnTemplate = ZT.html `<div tabindex="-1" class="zinputfield zcolorpicker__colorfield ${data.select ? '' : 'zcolorpicker--nomarginleft'} ${data.includeHexClass ? 'zcolorpicker__hexcolorfield' : ''}" > <input id=${data.hexFieldId} data-zprop="hex" maxlength="7" class="zinputfield__textbox" aria-label=${data.labels[0]}> </div>`; return returnTemplate; } 
template.hexLabel = (data) => { 
let returnTemplate = ZT.html `<div class="zcolorpicker__hexcolorfieldlabelcontainer ${data.opacity ? '' : 'zcolorpicker__withoutopacity'}"> <label class="zcolorpicker__hexcolorfieldlabel">HEX</label> ${data.opacity && ZT.html `<label class="zcolorpicker__othercolormodefieldlabel">A</label>`} </div>`; return returnTemplate; } }(ZComponents)); 
(function(ZC, $){
	class ZColorPicker extends ZC.ZColorPickerBase {
			get name(){
				return "zcolorpicker";
			}
	    get attrs() {
	        return {
	            defaultValue: 'rgba(0,0,0,1)', // No I18N
	            defaultColorButton: true,
	            // defaultColorButtonLabel: "Default Color", //No I18N
	            defaultColorButtonLabel: null,
	            noColorButton: true,
	            // noColorButtonLabel: "No Fill", //No I18N
	            noColorButtonLabel: null,
	            noColorIconClass: null,
	            noColorSVGIconId: null,
	            // defaultPaletteHeading:"Preset Colors", //No I18N
	            defaultPaletteHeading: null,
	            defaultPaletteType: 'preset', // No I18N
	            standardColors: true,
	            // standardColorsHeading:"Standard Colors", //No I18N
	            standardColorsHeading: null,
	            standardColorsPalette: 'ms-office', // No I18N
	            colorField: false,
	            opacity: false,
	            opacityFieldType: 'percent', // No I18N
	            advancedPicker: true,
	            // advancedPickerButtonLabel: "More Colors", //No I18N
	            advancedPickerButtonLabel: null,
	            advancedPickerIconClass: null,
	            advancedPickerSVGIconId: null,
	            advancedPickerArrowIconClass: null,
	            advancedPickerArrowSVGIconId: null,
	            otherUsedColors: true,
	            otherUsedColorsHasLimit: true,
	            otherUsedColorsLimit: 10,
	            // otherUsedColorsHeading:"Other Used Colors", //No I18N
	            otherUsedColorsHeading: null,
	            closeOnSelect: true
	            // className: null,
	        }
	    }
	    get props() {
	        return {
	            customPalette: null,
	            otherPalettes: [],
	            otherUsedColorsList: [],
	            advancedPickerOptions: {
	                commandBar: {
	                    leftColumn: {
	                        commands: [ 'back' ] // No I18N
	                    },
	                    rightColumn: {
	                        commands: [ 'cancel', 'OK' ] // No I18N
	                    },
	                    middleColumn: false
	                }
	            },
	            noColorIconClassName: null,
	            advancedPickerIconClassName: null,
	            advancedPickerArrowIconClassName: null,
	            colorFieldOptions: {
	                colorMode: 'auto', // No I18N
	                readonly: false,
	                preview: true
	            },
	            opacitySlider: {
	                thumbIconClassName: null,
	                thumbSVGIconId: null
	            },
	            labels: {
	                noColor: 'No Fill', // No I18N
	                defaultColor: 'Default Color', // No I18N
	                defaultColorsHeading: 'Preset Colors', // No I18N
	                standardColorsHeading: 'Standard Colors', // No I18N
	                otherUsedColorsHeading: 'Other Used Colors', // No I18N
	                advancedPicker: 'More Colors', // No I18N
	                colorField: 'Color Field', // No I18N
	                opacityField: 'Opacity Field' // No I18N
	            }
	        }
	    }
	    get EVENTS() {
	        return [
	            'beforeotherusedcoloradd', // No I18N
	            'otherusedcoloradd', // No I18N
	            'colorfieldlistchange' // No I18N
	        ]
	    }
	    _onSubmit(orgEvent) {
	        this.close(orgEvent);
	    }
	    _setAlpha(alpha, orgEvent) {
	        let color = this._colorInstance.getObject();
	        color.a = alpha;
	        if (this._trigger('beforefocus', orgEvent)) { // No I18N
	            this._data.opacityField.container.find('input').focus(); // No I18N
	        }
	        this._setValue(color, orgEvent);
	    }
	    _setRenderData(data, options) {
	        super._setRenderData(...arguments);
	        data.closeOnSelect = !options.opacity && options.closeOnSelect;
	        let isAttrChanged = this._isAttrChanged.bind(this);
	        if (isAttrChanged('noColorButton')) {// No I18N
	            if (data.noColorBtn) {
	                // To avoid memory leak
	                this._getById(data.noColorBtn.id).off();
	            }
	            data.noColorBtn = false;
	            if (options.noColorButton) {
	                data.noColorBtn = {
	                    id: this._getID('nocolorbtn'), // No I18N
	                    label: options.noColorButtonLabel || this._getI18NText('noColor') // No I18N
	                };
	                ZC._getIconInfo(options.noColorIconClassName || options.noColorIconClass, options.noColorSVGIconId, 'zc__svg--zcolorpicker-nocolor', 'zcolorpicker__icon', data.noColorBtn.icon = {});// No I18N
	            }
	        }
	        if (isAttrChanged('defaultColorButton')) {// No I18N
	            if (data.defaultColor) {
	                // To avoid memory leak
	                this._getById(data.defaultColor.id).off();
	            }
	            data.defaultColor = false;
	            if (options.defaultColorButton) {
	                let colorInstance = this._getClrInstance(options.defaultValue);
	                data.defaultColor = {
	                    id: this._getID('defaultcolorbtn'), // No I18N
	                    label: options.defaultColorButtonLabel || this._getI18NText('defaultColor'), // No I18N
	                    rgb: colorInstance.isValid() ? colorInstance.getColor() : this._DEFAULTS.defaultValue
	                };
	            }
	        }
	        if (isAttrChanged('advancedPicker')) {// No I18N
	            if (options.advancedPicker || data.advancedPicker) {
	                this._setMoreClrsData(options, data);
	            }
	        }
	        if (isAttrChanged('colorField')) {// No I18N
	            if (options.colorField || data.colorField) {
	                this._setClrFieldData(data, options);
	            }
	        }
	        if (isAttrChanged('opacity')) {// No I18N
	            if (options.opacity || data.opacity) {
	                this._setOpacityData(data, options);
	            }
	        }
	        if (isAttrChanged('palette')) { // No I18N
	            this._setPaletteData(data, options);
	        }
	        if (options.colorField) {
	            data.colorField.rgb = data.rgb;
	        }
	        if (data.opacity) {
	            this._setOpacityLeft(data);
	        }
	        this._updateSelection(data, options);
	    }
	    _setAdvPickerData(options, data) {
	        let userOptions = options.advancedPickerOptions;
	        let advancedPickerOptions = $.extend(true,
	            {},
	            this._getBaseObj('advancedcolorpicker'), // No I18N
	            this._DEFAULTS.advancedPickerOptions,
	            userOptions,
	            {
	                isFromPicker: true,
	                type: 'inline', // No I18N
	                hideCancelButton: true,
	                immediateCommit: false,
	                closeButton: false,
	                palettes: false,
	                value: options.value,
	                valueColorModel: options.valueColorModel,
	                colorFieldSelect: {
	                    dropdownList: {
	                        appendTo: this.element
	                    }
	                }
	            });
	        if (!advancedPickerOptions.id) {
	            advancedPickerOptions.id = this._getID('advancedpicker'); // No I18N
	        }
	        [ 'Ok', // No I18N
	            'Cancel', // No I18N
	            'Back', // No I18N
	            'Select', // No I18N
	            'ColorfieldListChangeHandler'// No I18N
	        ].forEach((eventName) => {
	            advancedPickerOptions[eventName.toLowerCase()] = this._advPickerCallback.bind(this, this['_advPicker' + eventName + 'Handler']); // No I18N
	        });
	        if (data.advancedPicker) {
	            data.advancedPicker.instance.setAttributes(advancedPickerOptions);
	        } else {
	            data.advancedPicker = advancedPickerOptions;
	        }
	    }
	    _advPickerCallback(callback, orgEvent) {
	        let data = orgEvent.detail;
	        if (data.fromUI) {
	            orgEvent = orgEvent.originalEvent;
	            callback.call(this, orgEvent, data);
	        }
	    }
	    _postEachRender(element, data) {
	        super._postEachRender(...arguments);
	        if (data.colorField) {
	            this._updateColorField();
	        }
	        if (data.opacity) {
	            this._updateOpacityValues();
	        }
	        // The following code is commented since getById implementation in listbox has been updated to getting from element instead of document.getElementById.
	        // if (!this._data.rendered) {
	        //     // ColorFieldSelect appendTo is modified later since if we set it initially the advancedpicker is created before colorpicker creation which resulted in removal of dropdownlist. Hence it is appended after render.
	        //     let advancedPicker = data.advancedPicker;
	        //     if (advancedPicker) {
	        //         ZComponents
	        //             .advancedcolorpicker(advancedPicker.mainElement)
	        //             .setAttribute('colorFieldSelect', { // No I18N
	        //                 dropdownList: {
	        //                     appendTo: this.element
	        //                 }
	        //             });
	        //     }
	        // }
	        this._changedAttrs = [];
	    }
	    _storeRef(data, options) {
	        super._storeRef(...arguments);
	        let element = this.element;
	        let isAttrChanged = this._isAttrChanged.bind(this);
	        if (!data.rendered) {
	            this._showHideContainer = $(this.element[0].querySelector('.zcolorpicker__showhidecontainer')); // No I18N
	            this._container = this._basicPicker = $(this.element[0].querySelector('.zcolorpicker__default')); // No I18N
	            this._borderThickness = (element.outerHeight() - element.height()) || 0;
	        }
	        if (isAttrChanged('colorField')) { // No I18N
	            this._colorBox = false;
	            if (options.colorField) {
	                this._storeClrFieldRef(data.colorField, options);
	            }
	        }
	        if (isAttrChanged('opacity')) { // No I18N
	            this._opacityCanvasContext = this._opacitySlider = false;
	            if (options.opacity) {
	                this._storeOpacityRef(data, options);
	            }
	        }
	        if (isAttrChanged('advancedPicker')) { // No I18N
	            this._advPicker = false;
	            if (options.advancedPicker) {
	                this._storeAdvPickerRef(data, options);
	            }
	        }
	        if (isAttrChanged('noColorButton')) { // No I18N
	            if (options.noColorButton) {
	                let noColorBtn = this._getById(data.noColorBtn.id);
	                // this._handleFocus(noColorBtn);
	                this._addEvents({
	                    noClrClick: 'click' // No I18N
	                }, noColorBtn);
	            }
	        }
	        if (isAttrChanged('defaultColorButton')) { // No I18N
	            if (options.defaultColorButton) {
	                let defaultColorButton = this._getById(data.defaultColor.id);
	                // this._handleFocus(defaultColorButton);
	                this._addEvents({
	                    defaultClrClick: 'click' // No I18N
	                }, defaultColorButton);
	            }
	        }
	    }
	    _makeSeen(element, display = true) {
	        element.css('visibility', display ? 'visible' : 'hidden'); // No I18N
	    }
	    _makeUnSeen(element) {
	        this._makeSeen(element, false);
	    }
	    _storeOpacityRef(data) {
	        let slider = this._opacitySlider = this._getById(data.opacitySlider.id);
	        this._opacityCanvasContext = this._getCanvasContext(slider[0]);
	        this._setMainEle(data.opacityField);
	        this._addEvents({
	            dragStart: 'mousedown' // No I18N
	        }, slider);
	    }
	    _validate(options) {
	        super._validate(...arguments);
	        options.paletteColumns = this._validateCount(options.paletteColumns);
	        if (options.otherUsedColorsHasLimit) {
	            options.otherUsedColorsLimit = this._validateCount(options.otherUsedColorsLimit);
	        }
	        if (!options.defaultValue) {
	            options.defaultValue = options.value;
	        }
	    }
	    _noClrClickHandler(orgEvent) {
	        this._setValue('none', orgEvent, { // No I18N
	            noColorButtonClick: true
	        });
	        this._data.closeOnSelect && this.close(orgEvent);
	    }
	    _defaultClrClickHandler(orgEvent) {
	        this._setValue(this._opts.defaultValue, orgEvent, {
	            defaultColorButtonClick: true
	        });
	        this._data.closeOnSelect && this.close(orgEvent);
	    }
	    _onPickerDragged(orgEvent) {
	        orgEvent.preventDefault();
	        let containerOffset = this._opacitySlider.offset();
	        let cursorPos = orgEvent.pageX - containerOffset.left;
	        let totalPixel = this._opacitySlider.width();
	        let percent = this._limit(cursorPos / totalPixel, 0, 1) * 100;
	        // this._opacityThumb.css('left', percent + '%'); // No I18N
	        percent = this._getRTLBasedPercent(percent);
	        this._setAlpha(Math.round(percent) / 100, orgEvent);
	    }
	    _updateColorField() {
	        if (this._colorBox && !this._skipClrFieldUpdate) {
	            let colorboxContent = /* this._noFill ? '' :  */this._colorInstance.getColor(this._data.colorField.colorMode, undefined, false);
	            this._colorBox.val(colorboxContent);
	            this._colorBox.attr('aria-value', colorboxContent); // No I18N
	            this._updateColorBoxTitle();
	        }
	    }
	    _onOpen() {
	        super._onOpen(...arguments);
	        this._updateColorBoxTitle();
	    }
	    _updateColorBoxTitle() {
	        if (this._colorBox && this._opened) {
	            let colorbox = this._colorBox[0];
	            if (colorbox.clientWidth < colorbox.scrollWidth) {
	                colorbox.title = this._colorBox[0].value; // No I18N
	            } else {
	                colorbox.title = ''; // No I18N
	            }
	        }
	    }
	    _fieldChangeHandler(orgEvent) {
	        // timer
	        clearTimeout(this._fieldChangeTimer);
	        this._fieldChangeTimer = setTimeout(() => {
	            let colorCode = this._colorBox.val();
	            this._updateColorBoxTitle();
	            let colorInstance = this._getClrInstance(colorCode);
	            this._skipClrFieldUpdate = orgEvent.type === 'input'; // No I18N
	            if (colorInstance.isValid()) {
	                this._setValue(colorInstance.getObject(), orgEvent);
	            } else {
	                this._updateColorField();
	            }
	            this._skipClrFieldUpdate = false;
	        });
	    }
	    _calcDimension() {
	        // Title height
	        let titleHeight = 0;
	        if (this._titleBar) {
	            titleHeight = this._titleBar.outerHeight();
	        }
	        this._showHideContainer[0].style['max-height'] = 'calc(100% - ' + titleHeight + 'px)'; // No I18N
	        let pickerWd = this._basicPicker[0].offsetWidth;
	        this._pickerWd = pickerWd ? pickerWd + 'px' : ''; // No I18N
	        let pickerHt = this._basicPicker[0].offsetHeight;
	        this._pickerHt = pickerHt ? (pickerHt + titleHeight) + 'px' : ''; // No I18N
	        this._advPickerWd = this._advPickerHt = 0;
	        let advPicker = this._advPicker;
	        if (advPicker) {
	            // Setting advancedpicker width to retrieve the values correctly.
	            this._data.advancedPicker.instance.setDimension();
	            let pickerWidth = advPicker.width();
	            let pickerHeight = advPicker.height();
	            this._advPickerWd = pickerWidth ? pickerWidth + 'px' : ''; // No I18N
	            this._advPickerHt = pickerHeight ? (pickerHeight + titleHeight) + 'px' : ''; // No I18N
	        }
	    }
	    _updateDim() {
	        this._widthSet = false;
	        if (this.element.is(':visible')) { // No I18N
	            this._setPickerDim('', ''); // No I18N
	            this._calcDimension();
	            if (this._advPickerVisible) {
	                this._setPickerDim(this._advPickerWd, this._advPickerHt);
	            } else {
	                this._setPickerDim(this._pickerWd, this._pickerHt);
	            }
	            this._widthSet = true
	        }
	    }
	    _setPaletteData(data, options) {
	        data.palettes = [];
	        data.defaultPalette = [];
	        data.otherUsedColors = data.standardPalette = false;
	        this._setDefaultPaletteData();
	        if (options.standardColors) {
	            this._setStandardPaletteData();
	        }
	        this._addPalettes(options.otherPalettes);
	        options.otherUsedColors && this._setRecentColorsPalette();
	    }
	    _setStandardPaletteData() {
	        let options = this._opts;
	        let presetData = this._getPresetColors(options.standardColorsPalette);
	        if (presetData) {
	            this._data.standardPalette = this._getPaletteTemplateData({
	                heading: options.standardColorsHeading || this._getI18NText('standardColorsHeading'), // No I18N
	                name: 'standardcolors', // No I18N
	                colors: presetData.colors
	            });
	        }
	    }
	    _setDefaultPaletteData() {
	        let options = this._opts;
	        let defaultPaletteData = options.defaultPaletteType === 'custom' && options.customPalette; // No I18N
	        if (!defaultPaletteData) {
	            let presetData = this._getPresetColors('preset'); // No I18N
	            defaultPaletteData = {
	                colors: presetData.colors,
	                hasTones: true,
	                tones: presetData.tones
	            };
	        }
	        defaultPaletteData.heading = defaultPaletteData.heading || options.defaultPaletteHeading || this._getI18NText('defaultColorsHeading'); // No I18N
	        defaultPaletteData.name = 'themecolors'; // No I18N
	        this._data.defaultPalette = this._getPaletteTemplateData(defaultPaletteData);
	    }
	    _setPickerDim(width, height) {
	        this.element.css({
	            width,
	            height
	        });
	    }
	    _getPresetColors(name) {
	        return this.presetPalettes[name];
	    }
	    _updatePalettes() {
	        this._opts.otherPalettes = this._data.palettes.map((paletteTemplateData) => paletteTemplateData.paletteData);
	        this._updateUI(true);
	    }
	    _advPickerCancelHandler(orgEvent) {
	        this.close(orgEvent);
	    }
	    _advPickerBackHandler(orgEvent) {
	        this._switchToBasic(orgEvent);
	        // this.setFocus();
	    }
	    _focusMoreColors() {
	        // When back button is clicked More Colors Button should have the focus.
	        this._getById(this._data.moreColorBtn.id).focus();
	    }
	    _advPickerOkHandler(orgEvent, data) {
	        this._setValue(data.rgb, orgEvent, data, true);
	        if (this._floating) {
	            this.close(orgEvent);
	        } else {
	            this._addToRecentColors(orgEvent);
	        }
	    }
	    _advPickerColorfieldListChangeHandler(orgEvent, data) {
	        this._trigger('colorfieldlistchange', orgEvent, data); // No I18N
	    }
	    _advPickerSelectHandler(orgEvent, data) {
	        this._setValue(data.currentRGB, orgEvent, data, false, true);
	    }
	    _addToRecentColors(orgEvent) {
	        let options = this._opts;
	        if (options.otherUsedColors && !this._noFill && !this._defaultColor && !this._selectedPan.length) {
	            if (this._trigger('beforeotherusedcoloradd', orgEvent)) { // No I18N
	                options.otherUsedColorsList = this._addColors(this._data.otherUsedColors, this._selectedInstance.getColor(), options.otherUsedColorsHasLimit ? 0 : undefined);
	                this._trigger('otherusedcoloradd', orgEvent); // No I18N
	            }
	        }
	    }
	    _triggerChange(orgEvent, data) {
	        // if( !this._opts.opacity || fromuser ){
	        if (!this._avoidPickTrigger) {
	            if (this._fromInit || this._currentColor !== this._selectedInstance.getColor()) {
	                this._updateSelectedColor();
	                this._trigger('change', orgEvent, data); // No I18N
	            }
	            this._trigger('pick', orgEvent, data); // No I18N
	        }
	        // }
	    }
	    _triggerSelect(orgEvent, prevColor, data) {
	        if (prevColor !== this._currentColor) {
	            this._trigger('select', orgEvent, data); // No I18N
	        }
	    }
	    _updateSelection(data) {
	        let palettes = [ ...data.palettes ];
	        palettes.push(data.defaultPalette);
	        data.standardPalette && palettes.push(data.standardPalette);
	        data.otherUsedColors && palettes.push(data.otherUsedColors);
	        palettes.forEach((palette) => this._updateClrSelection(palette.colors));
	    }
	    _setAdvancedPickerValue(value) {
	        if(this._opts.advancedPicker){
	            this._data.advancedPicker.instance.setAttributes({
	                value
	            });
	            this._advPicker.removeClass('zcolorpicker'); // No I18N
	        }
	    }
	    /* Function to select a color */
	    _setValue(color, orgEvent, data, fromUser, selectFromAdvPicker) {
	        let isNoFill = color === 'none' || color === 'transparent'; // No I18N
	        let colorInstance = this._getClrInstance(isNoFill ? 'rgba(0,0,0,0)' : color); // No I18N
	        if (colorInstance.isValid()) {
	            colorInstance.initialColor = color;
	            let prevColor = this._currentColor;
	            this._colorInstance = colorInstance;
	            this._currentColor = colorInstance.getColor();
	            this._noFill = (data && data.noColorButtonClick) || isNoFill;
	            this._defaultColor = data && data.defaultColorButtonClick;
	            if (!selectFromAdvPicker) {
	                this._mustRender = true;
	                this._updateUI();
	                this._mustRender = false;
	            }
	            this._triggerSelect(orgEvent, prevColor, data);
	            if (!selectFromAdvPicker) {
	                this._triggerChange(orgEvent, data);
	                if (this._advPickerVisible) {
	                    this._setAdvancedPickerValue(colorInstance.getObject());
	                }
	                (fromUser || this._fromInit) && this._addToRecentColors(orgEvent);
	            }
	        }
	    }
	    _moreClrClickHandler() {
	        this._advPickerVisible = true;
	        this._setAdvancedPickerValue(this._currentColor);
	        this._setPickerDim(this._advPickerWd, this._advPickerHt);
	        this._makeSeen(this._advPicker);
	        this._setTransitionMargin('-' + this._pickerWd); // No I18N
	        this._reposition();
	    }
	    _switchToBasic() {
	        if (this._advPickerVisible) {
	            this._advPickerVisible = false;
	            this._setPickerDim(this._pickerWd, this._pickerHt);
	            this._makeSeen(this._basicPicker);
	            this._setTransitionMargin(0);
	            if (this._opened) {
	                this._reposition();
	            } else {
	                this._makeUnSeen(this._advPicker);
	            }
	            this._updateColorBoxTitle();
	        }
	    }
	    _addTransitionEvents(include = true) {
	        let container = this._showHideContainer;
	        if (include) {
	            this._addEvents({
	                pickerSwitch: ZC._transitionEnd
	            }, container);
	        } else {
	            this._removeEvents('', container); // No I18N
	        }
	    }
	    _setTransitionMargin(margin) {
	        this._basicPicker.css(this._opts.rtl ? 'margin-right' : 'margin-left', margin); // No I18N
	    }
	    _pickerSwitchHandler(orgEvent) {
	        if (this._showHideContainer.is($(orgEvent.currentTarget))) {
	            if (this._advPickerVisible) {
	                this._makeUnSeen(this._basicPicker);
	                this._data.advancedPicker.instance.setFocus();
	            } else {
	                if (this._opened) {
	                    this._focusMoreColors();
	                }
	                // Revert selection
	                this._setAdvancedPickerValue(this._selectedInstance.getObject());
	                this._makeUnSeen(this._advPicker);
	                this._avoidPickTrigger = true;
	                this._setValue(this._selectedInstance.initialColor, orgEvent);
	                this._avoidPickTrigger = false;
	            }
	            this._addTransitionEvents(false);
	            this._addTransitionClass(false);
	        }
	    }
	    _updateCurrentColor() {
	        this._colorInstance = this._selectedInstance;
	        this._currentColor = this._colorInstance.getColor();
	    }
	    _addTransitionClass(add = true) {
	        this.element[add ? 'addClass' : 'removeClass']('zcolorpicker--transition'); // No I18N
	    }
	    _reposition() {
	        if (!this._data.dragged && this._floating) {
	            this._addTransitionEvents();
	            this._addTransitionClass();
	            this._setPosition();
	        }
	    }
	    _onClose(orgEvent) {
	        // this._opts.opacity && this._triggerChange( orgEvent, true );
	        this._opened = false;
	        this._avoidPickTrigger = true;
	        this._switchToBasic(orgEvent);
	        this._setValue(this._selectedInstance.initialColor, orgEvent, null, true);
	        this._setAdvancedPickerValue(this._selectedInstance.getObject());
	        super._onClose(...arguments);
	        this._avoidPickTrigger = false;
	    }
	    _getPosition(positionSettings) {
	        positionSettings.computeElementDim = false;
	        let borderThickness = this._borderThickness;
	        let advPickerHt = parseInt(this._advPickerHt);
	        let advPickerWd = parseInt(this._advPickerWd);
	        let pickerHt = parseInt(this._pickerHt);
	        let pickerWd = parseInt(this._pickerWd);
	        positionSettings.callbacks = {
	            beforeComputingDir: {
	                dimensionModifier: (targetDim, elemDim) => {
	                    let elementWidth, elementHeight;
	                    if (this._advPickerVisible) {
	                        elementWidth = advPickerWd;
	                        elementHeight = advPickerHt;
	                    } else {
	                        elementWidth = Math.max(advPickerWd, pickerWd);
	                        elementHeight = Math.max(advPickerHt, pickerHt);
	                    }
	                    elemDim.width = elementWidth + borderThickness;
	                    elemDim.height = elementHeight + borderThickness;
	                }
	            },
	            beforeComputingPos: {
	                dimensionModifier: (targetDim, elemDim) => {
	                    if (!this._advPickerVisible) {
	                        elemDim.width = pickerWd + borderThickness;
	                        elemDim.height = pickerHt + borderThickness;
	                    }
	                }
	            }
	        }
	        return super._getPosition(positionSettings);
	    }
	    _destroy() {
	        // Incase of webcomponent the destroy method is called automatically when the element is removed.
	        if (!this.isCE) {
	            // Picker is destroyed
	            this._destroyPicker();
	            this._destroyComp(this._data.opacityField);
	        }
	        super._destroy(...arguments);
	    }
	    _destroyPicker() {
	        if (this._advPicker) {
	            this._data.advancedPicker.instance.destroy();
	            this._advPicker = undefined;
	        }
	    }
		_setClrFieldData  (data, options) {
		    if (data.colorField) {
		        // To avoid memory leak
		        this._getById(data.colorField.id).off();
		    }
		    data.colorField = false;
		    if (options.colorField) {
		        let colorFieldOptions = options.colorFieldOptions;
		        let colorMode = colorFieldOptions.colorMode;
		        data.colorField = {
		            colorMode: this._REGEX.colorMode.test(colorMode) ? colorMode : this._colorMode,
		            id: this._getID('colorfield'), // No I18N
		            label: this._getI18NText('colorField'), // No I18N
		            preview: colorFieldOptions.preview,
		            readonly: colorFieldOptions.readonly
		        }
		    }
		}
		_storeClrFieldRef  (colorField) {
		    this._colorBox = this._getById(colorField.id);
		    this._bindTextField(this._colorBox);
		}
		_storeAdvPickerRef  (data) {
		    let advancedPicker = data.advancedPicker;
		    let moreColorBtn = this._getById(data.moreColorBtn.id);
		    // this._handleFocus(moreColorBtn);
		    this._addEvents({
		        moreClrClick: 'click' // No I18N
		    }, moreColorBtn);
		    this._setMainEle(advancedPicker);
		    let advPicker = this._advPicker = $(advancedPicker.mainElement);
		    if (!this._advPickerVisible) {
		        this._makeUnSeen(advPicker);
		    }
		}
		_setMoreClrsData  (options, data) {
		    if (data.advancedPicker) {
		        this._getById(data.advancedPicker.id).off();
		    }
		    if (options.advancedPicker) {
		        let moreClrBtn = data.moreColorBtn = {
		            id: this._getID('morecolors'), // No I18N
		            label: options.advancedPickerButtonLabel || this._getI18NText('advancedPicker') // No I18N
		        };
		        ZC._getIconInfo(options.advancedPickerIconClassName || options.advancedPickerIconClass, options.advancedPickerSVGIconId, 'zc__svg--zcolorpicker-advancedpicker', 'zcolorpicker__icon zbutton__icon', moreClrBtn.icon = {});// No I18N
		        ZC._getIconInfo(options.advancedPickerArrowIconClassName || options.advancedPickerArrowIconClass, options.advancedPickerArrowSVGIconId, 'zc__svg--rightarrow', 'zcolorpicker__icon zh-arrowicon zh-alignright', data.rightArrow = {});// No I18N
		        this._setAdvPickerData(options, data);
		    } else {
		        this._destroyPicker();
		        data.advancedPicker = data.moreColorBtn = false;
		    }
		}
		_setOpacityLeft  (data) {
		    data.opacitySlider.left = this._getRTLBasedPercent(Math.round(this._colorInstance.getAlpha() * 100));
		}
		_setOpacityData  (data, options) {
		    if (options.opacity) {
		        data.opacity = true;
		        let isDecimal = options.opacityFieldType === 'decimal', // No I18N
		            max = 100,
		            suffix = '%', // No I18N
		            step,
		            decimalPlaces;
		        if (isDecimal) {
		            max = 1;
		            step = 0.01;
		            suffix = ''; // No I18N
		            decimalPlaces = 2;
		        }
		        let opacityChangeHandler = this._opacityChangeHandler.bind(this);
		        let opacityField = {
		            ...this._getBasicNumberFieldOptions(),
		            ...{
		                id: this._getID('opacityfield'), // No I18N
		                max: max,
		                suffix: suffix,
		                step: step,
		                decimalPlaces: decimalPlaces,
		                className: 'zcolorpicker__opacityfield', // No I18N
		                spin: opacityChangeHandler,
		                change: opacityChangeHandler,
		                input: opacityChangeHandler,
		                customAttributes: {
		                    'aria-label': this._getI18NText('opacityField') // No I18N
		                }
		            }
		        };
		        if (data.opacityField) {
		            data.opacityField.instance.setAttributes(opacityField);
		        } else {
		            data.opacityField = opacityField;
		        }
		        data.opacitySlider = {
		            id: this._getID('opacityslider'), // No I18N
		            rtl: data.rtl,
		            opacity: true,
		            thumbIcon: this._getThumbData(options.opacitySlider)
		        }
		    } else {
		        this._destroyComp(data.opacityField);
		        if (data.opacitySlider) {
		            this._getById(data.opacitySlider.id).off();
		        }
		        data.opacity = data.opacityField = data.opacitySlider = false;
		    }
		}
		_updateOpacityValues  () {
		    this._setOpacitySliderClr();
		    this._setOpacityField();
		}
		_setOpacitySliderClr  () {
		    let rgbObj = this._colorInstance.getObject();
		    let context = this._opacityCanvasContext;
		    context.beginPath();
		    let rgb = this._colorInstance.getColor('rgb', undefined, false); // No I18N
		    let canvas = context.canvas;
		    context.rect(0, 0, canvas.width, canvas.height);
		    context.clearRect(0, 0, canvas.width, canvas.height);
		    let gradient = context.createLinearGradient(0, 0, canvas.width, 0);
		    this._setGradientColors(gradient, [ `rgba(${rgbObj.r}, ${rgbObj.g}, ${rgbObj.b}, 0)`, rgb ]);
		    context.fillStyle = gradient;
		    context.fill();
		}
		_setOpacityField  () {
		    if (!this._skipAlphaFieldUpdate) {
		        let alpha = this._colorInstance.getAlpha();
		        this._data.opacityField.instance.setAttribute('value', this._opts.opacityFieldType === 'decimal' ? alpha : Math.round(alpha * 100)); // No I18N
		    }
		}
		_opacityChangeHandler  (orgEvent) {
		    let value = orgEvent.detail.value;
		    this._skipAlphaFieldUpdate = true;
		    this._setAlpha(this._opts.opacityFieldType === 'decimal' ? value : value / 100, orgEvent); // No I18N
		    this._skipAlphaFieldUpdate = false;
		}
		_setRecentColorsPalette  () {
		    let options = this._opts;
		    this._data.otherUsedColors = this._getPaletteTemplateData({
		        heading: options.otherUsedColorsHeading || this._getI18NText('otherUsedColorsHeading'), // No I18N
		        name: 'otherusedcolors', // No I18N
		        colors: options.otherUsedColorsList,
		        maxColorsCount: options.otherUsedColorsHasLimit && options.otherUsedColorsLimit
		    });
		}
		get presetPalettes (){
			return	 {
		    preset: {
		        colors: [ {
		            color: '#ffffff', // No I18N
		            tones: [ {
		                'function': 'shade', // No I18N
		                percent: 10
		            }, {
		                'function': 'shade', // No I18N
		                percent: 20
		            }, {
		                'function': 'shade', // No I18N
		                percent: 40
		            }, {
		                'function': 'shade', // No I18N
		                percent: 60
		            }, {
		                'function': 'shade', // No I18N
		                percent: 80
		            }, {
		                'function': 'shade', // No I18N
		                percent: 90
		            }, {
		                'function': 'shade', // No I18N
		                percent: 100
		            } ]
		        }, '#ef1616', '#ef8216', '#efb116', '#5dc35a', '#38d7bb', '#16d0ef', '#398ef3', '#c516ef', 'ef166f' ], // No I18N
		        tones: [ {
		            'function': 'tint', // No I18N
		            percent: 90
		        }, {
		            'function': 'tint', // No I18N
		            percent: 80
		        }, {
		            'function': 'tint', // No I18N
		            percent: 60
		        }, {
		            'function': 'tint', // No I18N
		            percent: 40
		        }, {
		            'function': 'tint', // No I18N
		            percent: 20
		        }, {
		            'function': 'shade', // No I18N
		            percent: 30
		        }, {
		            'function': 'shade', // No I18N
		            percent: 70
		        } ]
		    },
		    vga: {
		        colors: [ {
		            color: '000000' // No I18N
		            // title:"Black" //No I18N
		        }, {
		            color: '0000aa' // No I18N
		            // title:"Blue" //No I18N
		        }, {
		            color: '00aa00' // No I18N
		            // title:"Green" //No I18N
		        }, {
		            color: '00aaaa' // No I18N
		            // title:"Cyan" //No I18N
		        }, {
		            color: 'aa0000' // No I18N
		            // title:"Red" //No I18N
		        }, {
		            color: 'aa00aa' // No I18N
		            // title:"Magenta" //No I18N
		        }, {
		            color: 'aa5500' // No I18N
		            // title:"Brown" //No I18N
		        }, {
		            color: 'aaaaaa' // No I18N
		            // title:"Gray" //No I18N
		        }, {
		            color: '555555' // No I18N
		            // title:"Dark gray" //No I18N
		        }, {
		            color: '5555ff' // No I18N
		            // title:"Bright blue" //No I18N
		        }, {
		            color: '55ff55' // No I18N
		            // title:"Bright green" //No I18N
		        }, {
		            color: '#55ffff' // No I18N
		            // title:"Bright cyan"  //No I18N
		        }, {
		            color: '#ff5555' // No I18N
		            // title:"Bright red" //No I18N
		        }, {
		            color: '#ff55ff' // No I18N
		            // title:"Bright magenta" //No I18N
		        }, {
		            color: '#ffff55' // No I18N
		            // title:"Yellow" //No I18N
		        }, {
		            color: '#ffffff' // No I18N
		            // title:"White" //No I18N
		        } ]
		    },
		    'ms-office': { // No I18N
		        colors: [
		            [ 192, 0, 0 ],
		            [ 255, 0, 0 ],
		            [ 255, 192, 0 ],
		            [ 255, 255, 0 ],
		            [ 146, 208, 80 ],
		            [ 0, 176, 80 ],
		            [ 0, 176, 240 ],
		            [ 0, 112, 192 ],
		            [ 0, 32, 96 ],
		            [ 112, 48, 160 ]
		        ]
		    }
		}
		 }
  _setAttribute(optionName, value) {
		    if (value === 'valueColorModel') { // No I18N
		        this._changedAttrs.push('advancedPicker'); // No I18N
		        this._domChanged = true;
		    }
		    let response = super._setAttribute(optionName, value);
		    if (response === false) {
		        let regex = {
		            defaultColorButton: /^(defaultValue|defaultColorButton|defaultColorButtonLabel)$/,
		            noColorButton: /^(noColorButton|noColorButtonLabel|noColorIconClassName|noColorSVGIconId)$/,
		            palette: /^(defaultPaletteHeading|defaultPaletteType|customPalette|standardColors|standardColorsHeading|standardColorsPalette|paletteColumns|otherPalettes|otherUsedColors|otherUsedColorsHeading|otherUsedColorsList|otherUsedColorsHasLimit|otherUsedColorsLimit)$/,
		            colorField: /^(colorField|colorFieldOptions)$/,
		            opacity: /^(opacity|opacitySlider|opacityFieldType)$/,
		            advancedPicker: /^(advancedPicker|advancedPickerIconClassName|advancedPickerArrowIconClassName|advancedPickerSVGIconId|advancedPickerArrowSVGIconId|advancedPickerButtonLabel|advancedPickerOptions)$/
		        }
		        this._opts[optionName] = value;
		        for (let mod in regex) {
		            if (regex[mod].test(optionName)) {
		                this._changedAttrs.push(mod);
		                this._domChanged = true;
		                if (optionName === 'opacity') { // No I18N
		                    if (!value) {
		                        this._setValue(this._currentColor);
		                    }
		                }
		            }
		        }
		    }
		}
	}
	ZC.registerComponent('ZColorPicker', ZC.ZColorPickerBase, ZColorPicker); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zcolorpicker.Templates; 
let utilities = ZC.Templates.Utilities; 
let colorpickerBaseTemplate = ZC.zcolorpickerbase.Templates; 
template.WCChildren = (data) => { 
let returnTemplate = ZT.html `${data.hasCallout && ZT.html `<div class="zcolorpicker__pointer"></div>`} ${data.title && colorpickerBaseTemplate.WCTitle(data)} <div class="zcolorpicker__showhidecontainer"> <div class="zcolorpicker__default"> ${data.noColorBtn && template.WCNoColorBtn(data)} ${data.defaultColor && template.WCDefaultColorBtn(data)} ${data.defaultPalette && colorpickerBaseTemplate.WCPalette(data.defaultPalette)} ${data.standardPalette && colorpickerBaseTemplate.WCPalette(data.standardPalette)} ${data.palettes && data.palettes.map((paletteData) => colorpickerBaseTemplate.WCPalette(paletteData))} ${data.otherUsedColors && colorpickerBaseTemplate.WCPalette(data.otherUsedColors)} ${data.advancedPicker && ZT.html `<button id=${data.moreColorBtn.id} aria-label="${data.moreColorBtn.label}" role="button" type="button" class="zcolorpicker__navigatable zcolorpicker__actionbutton zbutton zcolorpicker__morecolorbutton zbutton--menu"> ${utilities.WCIcon(data.moreColorBtn.icon)} <span class="zbutton__text zcolorpicker__text">${data.moreColorBtn.label}</span> ${utilities.WCIcon(data.rightArrow)} </button>`} ${(data.colorField || data.opacity) && ZT.html `<div class="zcolorpicker__colorfieldcontainer"> ${data.colorField && template.WCColorField(data.colorField)} ${data.opacity && template.WCOpacity(data)} </div>`} </div> ${data.advancedPicker && ZC.createAdvancedColorPicker(data.advancedPicker)} </div> `; return returnTemplate; } 
template.WCColorField = (data) => { 
let returnTemplate = ZT.html `<div class="zcolorpicker__colorfield"> ${data.preview && ZT.html `<span class="zcolorpicker__colorfieldpreview zcolorpicker__transparentbg"> <div class="zcolorpicker__dynamiccolor" style="background-color: ${data.rgb};"></div> </span>`} <input id=${data.id} ?readonly=${data.readonly} aria-label="${data.label}" class="zcolorpicker__textbox zcolorpicker__navigatable ${data.readonly ? 'h-cursor' : ''}"> </div>`; return returnTemplate; } 
template.WCDefaultColorBtn = (data) => { 
let returnTemplate = ZT.html `<button id=${data.defaultColor.id} aria-label="${data.defaultColor.label}" role="button" type="button" class="zcolorpicker__navigatable zcolorpicker__actionbutton zbutton zcolorpicker__defaultcolorbutton"> <span class="zcolorpicker__icon" style="background-color: ${data.defaultColor.rgb};"></span> <span class="zbutton__text zcolorpicker__text">${data.defaultColor.label}</span> </button>`; return returnTemplate; } 
template.WCNoColorBtn = (data) => { 
let returnTemplate = ZT.html `<button id=${data.noColorBtn.id} aria-label="${data.noColorBtn.label}" role="button" type="button" class="zbutton zcolorpicker__navigatable zcolorpicker__actionbutton zbutton zcolorpicker__nocolorbutton"> ${utilities.WCIcon(data.noColorBtn.icon)} <span class="zbutton__text zcolorpicker__text">${data.noColorBtn.label}</span> </button>`; return returnTemplate; } 
template.WCOpacity = (data) => { 
let returnTemplate = ZT.html `<div class="zcolorpicker__opacitycontainer"> ${colorpickerBaseTemplate.WCSlider(data.opacitySlider)} ${ZC.createNumberField(data.opacityField)} </div>`; return returnTemplate; } }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zcolorpicker.Templates; 
let utilities = ZC.Templates.Utilities; 
let colorpickerBaseTemplate = ZC.zcolorpickerbase.Templates; 
template.children = (data) => { 
let returnTemplate = ZT.html `${data.hasCallout && ZT.html `<div class="zcolorpicker__pointer"></div>`} ${data.title && colorpickerBaseTemplate.title(data)} <div class="zcolorpicker__showhidecontainer"> <div class="zcolorpicker__default"> ${data.noColorBtn && template.noColorBtn(data)} ${data.defaultColor && template.defaultColorBtn(data)} ${data.defaultPalette && colorpickerBaseTemplate.palette(data.defaultPalette)} ${data.standardPalette && colorpickerBaseTemplate.palette(data.standardPalette)} ${data.palettes && data.palettes.map((paletteData) => colorpickerBaseTemplate.palette(paletteData))} ${data.otherUsedColors && colorpickerBaseTemplate.palette(data.otherUsedColors)} ${data.advancedPicker && ZT.html `<button id=${data.moreColorBtn.id} aria-label="${data.moreColorBtn.label}" role="button" type="button" class="zcolorpicker__navigatable zcolorpicker__actionbutton zbutton zcolorpicker__morecolorbutton zbutton--menu"> ${utilities.icon(data.moreColorBtn.icon)} <span class="zbutton__text zcolorpicker__text">${data.moreColorBtn.label}</span> ${utilities.icon(data.rightArrow)} </button>`} ${(data.colorField || data.opacity) && ZT.html `<div class="zcolorpicker__colorfieldcontainer"> ${data.colorField && template.colorField(data.colorField)} ${data.opacity && template.opacity(data)} </div>`} </div> ${data.advancedPicker && ZC.createAdvancedColorPicker(data.advancedPicker)} </div> `; return returnTemplate; } 
template.colorField = (data) => { 
let returnTemplate = ZT.html `<div class="zcolorpicker__colorfield"> ${data.preview && ZT.html `<span class="zcolorpicker__colorfieldpreview zcolorpicker__transparentbg"> <div class="zcolorpicker__dynamiccolor" style="background-color: ${data.rgb};"></div> </span>`} <input id=${data.id} ?readonly=${data.readonly} aria-label="${data.label}" class="zcolorpicker__textbox zcolorpicker__navigatable ${data.readonly ? 'h-cursor' : ''}"> </div>`; return returnTemplate; } 
template.defaultColorBtn = (data) => { 
let returnTemplate = ZT.html `<button id=${data.defaultColor.id} aria-label="${data.defaultColor.label}" role="button" type="button" class="zcolorpicker__navigatable zcolorpicker__actionbutton zbutton zcolorpicker__defaultcolorbutton"> <span class="zcolorpicker__icon" style="background-color: ${data.defaultColor.rgb};"></span> <span class="zbutton__text zcolorpicker__text">${data.defaultColor.label}</span> </button>`; return returnTemplate; } 
template.noColorBtn = (data) => { 
let returnTemplate = ZT.html `<button id=${data.noColorBtn.id} aria-label="${data.noColorBtn.label}" role="button" type="button" class="zbutton zcolorpicker__navigatable zcolorpicker__actionbutton zbutton zcolorpicker__nocolorbutton"> ${utilities.icon(data.noColorBtn.icon)} <span class="zbutton__text zcolorpicker__text">${data.noColorBtn.label}</span> </button>`; return returnTemplate; } 
template.opacity = (data) => { 
let returnTemplate = ZT.html `<div class="zcolorpicker__opacitycontainer"> ${colorpickerBaseTemplate.slider(data.opacitySlider)} ${ZC.createNumberField(data.opacityField)} </div>`; return returnTemplate; } }(ZComponents)); 
(function(ZC, $){
	class ZDateRangePicker extends ZC.ZDatePicker {
			get name(){
				return "zdaterangepicker";
			}
	    get attrs() {
	        return {
	            fromValue: null, // No I18N
	            toValue: null, // No I18N
	            monthsPerView: 2, // No I18N
	            selectionDirection: 'both', // No I18N
	            excludeWeekend: false, // No I18N
	            selectionType: 'continuous', // No I18N
	            rangeType: 'days', // No I18N
	            minDaysToSelect: null, // No I18N
	            maxDaysToSelect: null, // No I18N
	            fromLabel: null,
	            toLabel: null
	        }
	    }
	    get props() {
	        return {
	            labels: {
	                fromLabel: 'From', // No I18N
	                toLabel: 'To' // No I18N
	            }
	        }
	    }
	    get EVENTS() {
	        return [ 'fromvalueselect', 'tovalueselect' ]; // No I18N
	    }
	    get delegateList() {
	        return '.zdatetimepicker__date:not(.is-disabled):not(.zdatetimepicker--disabledreplica), .zdatetimepicker__adjacentmonthdate:not(.is-disabled):not(.zdatetimepicker--disabledreplica), .zdatetimepicker__monthview:not(.is-disabled), .zdatetimepicker__year:not(.is-disabled), .zdatetimepicker__decade:not(.is-disabled)'; // No I18N
	    }
	    _init(ele, opts) {
	        this._userOptions = $.extend({}, opts);
	        this._isSeparate = this._opts.selectionType === 'separate'; // No I18N
	        this._assignValues();
	        this._setTemplate();
	        super._init(...arguments);
	    }
	    _assignValues() {
	        let opts = this._opts;
	        [ 'from', 'to' ].forEach((part) => { // No I18N
	            part = part + 'Value'; // No I18N
	            this._parseValue(part, opts[part]);
	            if (this._opts.excludeWeekend && opts[part] && this._isWeekend(opts[part])) {
	                opts[part] = null;
	            }
	            if (opts[part]) {
	                let isFrom = part === 'fromValue'; // No I18N
	                this['_' + part] = this[isFrom ? '_lastFrom' : '_lastTo'] = new Date(+opts[part]); // No I18N
	                this['_' + part].setHours(0, 0, 0, 0); // No I18N
	                if (isFrom) { // No I18N
	                    let fromVal = this._fromValue;
	                    this._viewDate = new Date(+fromVal);
	                    if (!this._isSeparate) {
	                        this._opts.value = new Date(+fromVal);
	                        this._currentSelected = new Date(+fromVal);
	                    }
	                }
	            } else {
	                this['_' + part] = null; // No I18N
	            }
	        });
	        if (!opts.fromValue && !this._isSeparate) {
	            this._opts.value = undefined;
	            this._currentSelected = undefined;
	        }
	    }
	    _setTemplate() {
	        this._opts.templateName = 'zdate' + (this._isSeparate ? 'range' : '') + 'picker'; // No I18N
	    }
	    _bindEvents() {
	        super._bindEvents();
	        this._addOtherEvents();
	    }
	    _addOtherEvents() {
	        if (!this._isSeparate) { // No I18N
	            [ 'enter', 'leave' ].forEach((val) => this.element.on('mouse' + val + '.' + this.name, this.delegateList, this['_mouse' + (val === 'enter' ? 'over' : val) + 'Handler'].bind(this))); // No I18N
	        }
	    }
	    _postRender(elem, opts) {
	        super._postRender(...arguments);
	        opts.excludeWeekend && (this._data.className += ' zdatetimepicker__excludeweekend'); // No I18N
	    }
	    _resetDates() {
	        this._lastFrom = null;
	        this._lastTo = null;
	        this._unsetDates(true);
	        this._setUndefined([ 'fromValue', 'toValue' ], ''); // No I18N
	        this._setHours();
	        if (this._minDate || this._maxDate) {
	            this._checkViewDate(this._viewDate);
	        }
	        this._OK && this._OK.removeClass('is-disabled');
	    }
	    _assignViewDate() {
	        if (this._minDate || this._maxDate) {
	            this._checkViewDate(new Date());
	        }
	        if (this._isSeparate) {
	            this._setSeparateDates();
	        }
	    }
	    _checkValueValidity() {
	        let fromValue = this._opts.fromValue,
	            toValue = this._opts.toValue;
	        if (fromValue && !this._dateWithInRange(fromValue) || toValue && !this._dateWithInRange(toValue) || this._isGreater(fromValue, toValue)) {
	            this._resetDates();
	            return true;
	        }
	    }
	    _validateOpts(doNotCallSuper) {
	        let opts = this._opts,
	            fromValue = opts.fromValue,
	            toValue = opts.toValue;
	        this._validateMinMaxDays && this._validateMinMaxDays();
	        this._checkValueValidity();
	        !doNotCallSuper && super._validateOpts();
	        /* Should be changed if navigate and select is given like datepicker */
	        opts.todayButtonAction = 'navigate-only'; // No I18N
	        // Reassinging since the values may be reset because of the previous code
	        fromValue = opts.fromValue;
	        toValue = opts.toValue;
	        if (fromValue && toValue) {
	            // Revisit
	            let diff = +toValue - +fromValue,
	                days = (diff / (1000 * 3600 * 24)) + 1;
	            if (days > -1) {
	                if ((opts.minDaysToSelect && days < opts.minDaysToSelect) || (opts.maxDaysToSelect && days > opts.maxDaysToSelect)) {
	                    this._resetDates();
	                }
	            }
	        }
	        // This is executed after super call for the disabled dates to be processed
	        if ((!this._isNotSet && (fromValue && !toValue || !fromValue && toValue)) || this._isDisabledDate(fromValue) || this._isDisabledDate(toValue)) {
	            this._resetDates();
	        }
	    }
	    _isDisabledDate(date) {
	        if (date) {
	            let obj = this._getUniqueClass(date, ''); // No I18N
	            return obj && obj.class.indexOf('is-disabled') > -1; // No I18N
	        }
	        return false;
	    }
	    _unsetDates(unSet) {
	        let opts = this._opts;
	        // this._lastFrom = opts.fromValue;
	        // this._lastTo = opts.toValue;
	        if (unSet) {
	            opts.fromValue = this._lastFrom;
	            opts.toValue = this._lastTo;
	        } else {
	            opts.fromValue = this._fromValue ? new Date(+this._fromValue) : null;
	            opts.toValue = this._toValue ? new Date(+this._toValue) : null;
	        }
	        if (!opts.fromValue) {
	            this._opts.value = undefined;
	            this._currentSelected = undefined;
	        }
	        this._lastFrom = opts.fromValue;
	        this._lastTo = opts.toValue;
	    }
	    _updateOKClass(force) {
	        let from = this._fromValue,
	            to = this._toValue;
	        if (this._OK && (!this._opts.immediateCommit || force)) {
	            let disable;
	            if (from && to || (!from && !to)) {
	                disable = false;
	            } else if (!to || !from) {
	                disable = true;
	            }
	            this._disable(disable, this._OK);
	        }
	    }
	    _isMinOrMaxDaysPresent() {
	        let opts = this._opts;
	        return typeof opts.minDaysToSelect === 'number' && typeof opts.maxDaysToSelect === 'number'; // No I18N
	    }
	    _mousedownHandler(ev) {
	        let target = $(ev.target),
	            opts = this._opts;
	        if (!target.closest(this.delegateList).length || opts.excludeWeekend && target.closest('.zdatetimepicker--weekend').length) { // No I18N
	            return;
	        }
	        let isRangeTypeWeeks = opts.rangeType === 'weeks', // No I18N
	            isSeparate = this._isSeparate,
	            isDrilldown = this._isDrilldown,
	            isAdjacent = false,
	            part;
	        if (isSeparate) {
	            // Revisit
	            // part = this._setPart(ev);
	            // if (part === 'from' && this['_' + part + 'Value']) { // No I18N
	            //     return;
	            // }
	            part = this._setData(ev);
	            this._setPartMode(part);
	        }
	        this._dateSelect = true;
	        if (this._viewMode === 0 && isDrilldown || !isDrilldown) {
	            this._doesExist(this._clear) && this._traverseBtns('clearButton', 'is-disabled', false); // No I18N
	            target = target.closest('.zdatetimepicker__date'); // No I18N
	            if (!target.length) {
	                target = $(ev.target).closest('.zdatetimepicker__adjacentmonthdate'); // No I18N
	                isAdjacent = true;
	            }
	            let dateValue = this._getDateVal(target);
	            if (isAdjacent) {
	                this._viewDate = new Date(+dateValue);
	                this._buildData(true);
	                target = this._getDateElem(dateValue, isSeparate ? this._getPartEle() : undefined);
	            }
	            if (!isSeparate && this._fromValue && this._toValue) {
	                this._setUndefined([ 'fromValue', 'toValue', 'weekStart', 'weekEnd', 'lastHovered', 'currentSelected' ], ''); // No I18N
	                opts.immediateCommit && this._unsetDates(true);
	                this._clearDateClass();
	                if (isRangeTypeWeeks) {
	                    this._setWeekDates(this._getDateData(target).time);
	                }
	            }
	            this._lastHovered = target;
	            let currentTime = +dateValue,
	                switchDone = false;
	            if (isSeparate) {
	                this._separateMousedown(ev, part, target, dateValue);
	                this._dispatchEvent(part + 'valueselect', ev, this['get' + (part[0].toUpperCase() + part.slice(1)) + 'Value']()); // No I18N
	                return;
	            } else if (isRangeTypeWeeks) {
	                if (this._weekStart && this._weekEnd) {
	                    this._fromValue = this._weekStart;
	                    this._toValue = this._weekEnd;
	                }
	            } else if (this._fromValue) {
	                let newDate = new Date(currentTime);
	                if (currentTime > this._fromValue) {
	                    this._toValue = newDate;
	                } else {
	                    switchDone = true;
	                    this._toValue = new Date(+this._fromValue);
	                    this._fromValue = newDate;
	                }
	            } else {
	                this._fromValue = dateValue;
	            }
	            opts.value = new Date(+this._fromValue);
	            // Setting viewDate here produces issue when fromValue and toValue are different months during arrowclick
	            // if (!this._isSeparate) {
	            //     this._viewDate = new Date(+this._fromValue);
	            // }
	            this._updateOKClass();
	            let shouldUpdate = opts.selectionDirection !== 'both' || this._isMinOrMaxDaysPresent(); // No I18N
	            if (isRangeTypeWeeks || shouldUpdate) { // No I18N
	                this._updateObjects(undefined, shouldUpdate);
	            } else {
	                this._setDateClass(this._toValue ? ' is-selected ' + (switchDone ? ' is-start ' + (target.next().hasClass('is-disabled') ? ' zh-disabledahead' : '') : ' is-end' + (this._getDateData(target).text === 1 || this._isEndFirst(this._toValue) ? ' is-end-first' : '')) : ' is-selected', true, target); // No I18N
	            }
	            if (target.is('.zdatetimepicker--today')) { // No I18N
	                // removing the class without using setDateClass method because that classes are added using addClass/removeClass methods only in continuous module.
	                // target.removeClass('zdatetimepicker--todayinrange'); // No I18N
	                this._setDateClass('zdatetimepicker--todayinrange', false, target); // No I18N
	            }
	            /* since re-render happens after the above statements, this class removal is not working - ##revisit */
	            let segment = this._toValue && !switchDone || opts.selectionDirection === 'backward' && !this._toValue ? 'To' : 'From'; // No I18N
	            this._dispatchEvent(segment.toLowerCase() + 'valueselect', ev, this['get' + segment + 'Value']()); // No I18N
	            if (opts.immediateCommit && this._fromValue && this._toValue) {
	                this._OKClickHandler(ev);
	            }
	        } else {
	            super._mousedownHandler(ev);
	        }
	        this._dateSelect = false;
	    }
	    _getInRangeCls(date) {
	        let todayDate = new Date(),
	            newDate = new Date(+date);
	        todayDate.setHours(0, 0, 0, 0);
	        newDate.setHours(0, 0, 0, 0);
	        return ' zdatetimepicker--dateinrange' + (+todayDate === +newDate && this._todayHovered ? ' zdatetimepicker--todayinrange' : ''); // No I18N
	    }
	    _restoreValues(updateValue) {
	        let realFromVal = this._opts.fromValue,
	            realToVal = this._opts.toValue;
	        this._fromValue = new Date(+realFromVal);
	        this._toValue = new Date(+realToVal);
	        if (updateValue) {
	            this._opts.value = new Date(+realFromVal);
	        }
	        this._valueUpdate = true;
	        if (this._doesExist(this._clear)) {
	            this._traverseBtns('clearButton', 'is-disabled', false); // No I18N
	        }
	        this._removeOkDisabled();
	    }
	    _removeOkDisabled() {
	        this._OK && this._OK.removeClass('is-disabled');
	    }
	    _refreshPicker(part) {
	    // Updating part for the correct update of data when there is no event
	        if (this._isSeparate) {
	            this._part = part;
	            let isFrom = part === 'from', // No I18N
	                viewDate = this['_' + (isFrom ? 'start' : 'end') + 'Date'], // No I18N
	                value = new Date(+(this['_' + part + 'Value'] ? +this['_' + part + 'Value'] : +viewDate)); // No I18N
	            this._oldDate = new Date(+viewDate);
	            this._viewDate = value;
	            this._updateViewMode();
	        } else {
	            this._oldDate = new Date(+this._oldViewDate);
	        }
	        super._refreshPicker();
	        if (this._isSeparate && (this._valueRemoval || this._oldDate.getFullYear() === this._viewDate.getFullYear() && this._oldDate.getMonth() === this._viewDate.getMonth())) {
	            this._buildData(undefined, part);
	        }
	        this._valueRemoval = false;
	    }
	    _closePicker(ev) {
	        let fromValue = this._fromValue,
	            toValue = this._toValue,
	            opts = this._opts,
	            realFromVal = opts.fromValue,
	            realToVal = opts.toValue,
	            valueUpdate = this._valueUpdate,
	            setUndefined = this._setUndefined.bind(this);
	        if (this._isSeparate) {
	            this._valueUpdate = false;
	            this._separateCloseHandler(ev);
	            return;
	        }
	        this._oldViewDate = new Date(+this._viewDate);
	        // To make picker open with fromValue
	        this._viewDate = new Date(+this._fromValue);
	        if (realFromVal && realToVal) {
	            this._restoreValues(true);
	        } else if (fromValue && !toValue) {
	            this._valueUpdate = false;
	            setUndefined([ 'fromValue' ], ''); // No I18N
	            this._removeOkDisabled();
	        } else if (!valueUpdate) {
	            this._opts.value = null;
	            this._resetDates();
	            this._assignViewDate();
	        }
	        this._updateObjects();
	        super._closePicker();
	        this._valueUpdate = false;
	    }
	    _isEndFirst(date) {
	        let prev, addClass
	        if (this._opts.excludeWeekend) {
	            prev = new Date(+date);
	            prev.setDate(prev.getDate() - 1);
	            addClass = this._isWeekend(prev);
	        }
	        return addClass;
	    }
	    _checkWeekend(date) {
	        return this._opts.excludeWeekend && !this._isWeekend(date) || !this._opts.excludeWeekend;
	    }
	    _isNotAdjacent(classes) {
	        let adjacentDate = 'zdatetimepicker__adjacentmonthdate'; // No I18N
	        return this._prevClass && this._prevClass.indexOf(adjacentDate) < 0 && classes.indexOf(adjacentDate) < 0; // No I18N
	    }
	    _getClasses(date, secondDate, cell) {
	        let currentTime = +date,
	            classes = super._getClasses(date, secondDate),
	            timeToCompare,
	            opts = this._opts,
	            fromValue = this._fromValue,
	            toValue = this._toValue,
	            weekClassAdded = false,
	            time,
	            isValid = this._checkWeekend(date),
	            lastHovered = this._lastHovered,
	            tempClass = typeof classes === 'object' ? classes.class : classes, // No I18N
	            toDoesNotExist = fromValue && !toValue || opts.rangeType === 'weeks' && this._update; // No I18N
	        time = lastHovered && +$(lastHovered).attr('data-time');
	        if (opts.rangeType === 'weeks' && this._update) { // No I18N
	            timeToCompare = time;
	            if (timeToCompare) {
	                this._setWeekDates(timeToCompare);
	                if (currentTime >= +this._weekStart && currentTime <= +this._weekEnd && isValid) {
	                    weekClassAdded = true;
	                    tempClass += ' zdatetimepicker--weekselection'; // No I18N
	                }
	                if (currentTime === +this._weekEnd) {
	                    tempClass += ' zh-lastselection'; // No I18N
	                }
	            }
	        }
	        if (this._isSeparate) {
	            tempClass += this._addSeparateClasses(date, tempClass);
	        } else if ((fromValue && toValue || toDoesNotExist)) {
	            tempClass = this._setContinuousClasses(date, tempClass, timeToCompare, weekClassAdded, cell, time);
	        }
	        if (typeof classes === 'object') { // No I18N
	            classes.class = tempClass;
	        } else {
	            classes = tempClass;
	        }
	        this._prevClass = classes.class || classes;
	        return this._prevClass;
	    }
	    _OKClickHandler(ev) {
	        this._unsetDates();
	        this._valueUpdate = true;
	        let immediateCommit = this._opts.immediateCommit;
	        (this._opts.closeOnDateSelect && immediateCommit || !immediateCommit) && this._closePicker(ev);
	        this._dispatchEvent('change', ev, this._getSelectedValue()); // No I18N
	        this._OK && this._removeFocus(this._OK);
	    }
	    _dispatchEvent(eventName, eventObj, compData) {
	        if (eventName !== this._event) {
	            this._event = eventName;
	            return super._dispatchEvent(...arguments);
	        }
	    }
	    _getSelectedValue() {
	        return $.extend(true, {}, this.getFromValue(), this.getToValue());
	    }
	    _getDateVal(ele) {
	        return ele && ele.length ? new Date(+ele.attr('data-time')) : undefined; // No I18N
	    }
	    _setFromToValue() {
	        this._assignValues();
	        this._validateOpts();
	        this._assignViewDate();
	        if (this._isSeparate) {
	            this._viewDate = new Date(+(this['_' + (this._part === 'to' ? 'end' : 'start') + 'Date'])); // No I18N
	        }
	        this._buildData(true, undefined, true);
	    }
	    _getValueObj(value, part) {
	        let opts = this._opts,
	            stringVal = ZC.Date.formatDate(value, opts.format);
	        return {
	            [part + 'Value']: new Date(+value), // No I18N
	            options: opts,
	            [part + 'ValueString']: stringVal, // No I18N
	            element: this.element,
	            ['translated' + part[0].toUpperCase() + part.slice(1) + 'Value']: this._translateEToA(ZC.Date.formatDate(value, opts.format, opts.labels)) // No I18N
	        }
	    }
	    getFromValue() {
	        let fromValue = this._opts.fromValue;
	        if (fromValue) {
	            return this._getValueObj(fromValue, 'from'); // No I18N
	        }
	    }
	    getToValue() {
	        let toValue = this._opts.toValue;
	        if (toValue) {
	            return this._getValueObj(toValue, 'to'); // No I18N
	        }
	    }
	    setFromValue(value) {
	        this._opts.fromValue = value;
	        if (value && this._opts.toValue) {
	            this._setFromToValue();
	        }
	    }
	    setToValue(value) {
	        this._opts.toValue = value;
	        if (this._opts.fromValue && value) {
	            this._setFromToValue();
	        }
	    }
	    clearSelection() {
	        this._clearClickHandler(undefined, undefined, true); // revisit
	    }
	    _destroy() {
	        if (this._isSeparate && this._isDropdown) {
	            this._destroyDropdown();
	            this._destroyedDD = true;
	        }
	        this._isSeparate = false;
	        this._prevClass = undefined;
	        this._setUndefined([ 'fromValue', 'toValue' ], ''); // No I18N
	        super._destroy();
	    }
		_setClearBtnCls   (obj) {
		    super._setClearBtnCls(obj, !this._fromValue && !this._toValue, true);
		}
		_clearClickHandler   (orgEvent, doNotTrigger, forceClear) {
		    let opts= this._opts;
		    if (this._isSeparate) {
		        let arr = ['from', 'to']; // No I18N
		        let partVal = this._part;
		        for (let i = 0; i < arr.length; i++) {
		            let value = this['_' + arr[i] + 'Value']; // No I18N
		            this._part = arr[i];
		            if (value) {
		                this._select(false, this._getDateElem(value, this._getPartEle(arr[i])), true);
		            }
		        }
		        this._part = partVal;
		        this._setData(this._part);
		    } else {
		        this._clearDateClass();
		    }
		    if(opts.immediateCommit || forceClear){
		        this._lastFrom = null;
		        this._lastTo = null;
		        this._unsetDates(true);
		    }
		    this._setUndefined(['fromValue', 'toValue'], ''); // No I18N
		    if(forceClear) {
		        this._viewDate = new Date();
		        this._checkViewDate(this._viewDate);
		        this._buildData();
		    }
		    super._clearClickHandler(...arguments);
		    if (this._isSeparate || opts.rangeType === 'days' && opts.selectionDirection !== 'both' || this._isMinOrMaxDaysPresent()) {
		        this._reassignLimits();
		        this._buildData(!this._isSeparate, undefined, true);
		    }
		    this._updateOKClass(true);
		}
		_clearDateClass  () {
		    let data = this._data.month;
		    for (let i = 0; i < this._monthsPerView; i++) {
		        let dates = data[i].dates;
		        this._index = i;
		        for (let j = 0; j < dates.length; j++) {
		            let row = dates[j];
		            for (let k = 0, kLen = row.length; k < kLen; k++) {
		                row[k].class = row[k].class.replace(/zdatetimepicker--dateinrange|zdatetimepicker--todayinrange|is-selected|zdatetimepicker--weekselection|is-disabled zspecial|zdatetimepicker--disabledreplica|is-start|is-start-last|zh-lastrange|is-end-first|is-end/g, '');
		            }
		        }
		    }
		}
		_addEndClass  (classes, date, skipRangeClass) {
		    classes += (skipRangeClass ? ' ' : this._getInRangeCls(date)) + ' is-end'; // No I18N
		    if (!skipRangeClass && (date.getDate() === 1 && this._isNotAdjacent(classes) || this._isEndFirst(date))) {
		        classes += ' is-end-first'; // No I18N
		    }
		    return classes;
		}
		_updateObjects  (doNotRender, checkLimits) {
		    // Added for rangeType = 'weeks' type
		    this._update = true;
		    let opts = this._opts,
		        data = this._data.month,
		        direction = opts.selectionDirection,
		        fromValue = this._fromValue,
		        toValue = this._toValue;
		    if (opts.rangeType === 'days') {
		        if (direction !== 'both' && fromValue) { // No I18N
		            // Setting _viewDate produces issue when arrow click is done. Hence changing it to fromValue.
		            this._setLimits(() => this['_' + (opts.selectionDirection === 'backward' ? 'max' : 'min') + 'Date'] = new Date(+fromValue)); // No I18N
		        }
		        if (typeof opts.maxDaysToSelect === 'number') { // No I18N
		            this._setLimits(() => {
		                this._getInvalidRange(opts.maxDaysToSelect, +this._viewDate);
		                this._setLimitValues()
		            });
		            if (this._isDropdown) {
		                this._data.modifiedAttr = checkLimits ? 'minOrMax' : undefined;// No I18N
		                this._checkOptions();
		                this._data.modifiedAttr = undefined;
		            }
		        }
		    }
		    for (let i = 0; i < this._monthsPerView; i++) {
		        let dates = data[i].dates;
		        this._index = i;
		        for (let j = 0; j < dates.length; j++) {
		            let row = dates[j];
		            for (let k = 0, kLen = row.length; k < kLen; k++) {
		                let cell = row[k];
		                if (cell.text === '') {
		                    continue;
		                }
		                cell.class = this._getClasses(new Date(cell.time), new Date(+(this._data.month[i].dates[1][0].time)), cell);
		                if ((fromValue && toValue || (!fromValue && !toValue)) && (direction !== 'both' || typeof opts.maxDaysToSelect === 'number')) { // No I18N
		                    cell.class = this._clearSpecialCls(cell.class);
		                }
		            }
		        }
		    }
		    !doNotRender && this._render();
		    this._update = false;
		}
		_setContinuousClasses  (date, tempClass, timeToCompare, weekClassAdded, cell, time) {
		    let isNotAdjacent = this._isNotAdjacent(tempClass),
		        currentTime = +date,
		        opts = this._opts,
		        fromValue = this._fromValue,
		        toValue = this._toValue,
		        fromTime = +fromValue,
		        toTime = +toValue,
		        areNotEqual = fromTime !== toTime,
		        isValid = this._checkWeekend(date),
		        lastHovered = this._lastHovered,
		        isCurrentGreater = currentTime > fromTime,
		        toDoesNotExist = fromValue && !toValue || opts.rangeType === 'weeks' && this._update, // No I18N
		        lastDayOfWeek = (opts.firstDayOfWeek + 6 % 7);
		    timeToCompare = toValue || time;
		    if (toDoesNotExist) {
		        let direction = opts.selectionDirection,
		            noDisabledClass = tempClass.indexOf('is-disabled') < 0; // No I18N
		        if (noDisabledClass && (direction === 'forward' && currentTime < fromTime || direction === 'backward' && isCurrentGreater)) { // No I18N
		            tempClass += ' is-disabled zspecial' // No I18N
		        }
		        if (time) {
		            if (typeof opts.minDaysToSelect === 'number' && this._getInvalidRange(opts.minDaysToSelect, currentTime, true)) { // No I18N
		                tempClass += ' zdatetimepicker--disabledreplica'; // No I18N
		            }
		            if (noDisabledClass && typeof opts.maxDaysToSelect === 'number' && this._getInvalidRange(opts.maxDaysToSelect, currentTime)) { // No I18N
		                tempClass += ' is-disabled zspecial'; // No I18N
		            }
		        }
		    }
		    if (tempClass.indexOf('zdatetimepicker__adjacentmonthdate') < 0) {
		        tempClass = this._updateDisabledCls(currentTime, weekClassAdded, tempClass);
		        if (currentTime === fromTime || currentTime === toTime) {
		            tempClass += ' is-selected'; // No I18N
		            if (currentTime === fromTime) {
		                let skipRangeClass = false;
		                if (areNotEqual && (lastHovered && +this._getDateVal(lastHovered) !== fromTime || toValue)) {
		                    tempClass += this._getInRangeCls(date);
		                } else {
		                    skipRangeClass = true;
		                }
		                if (timeToCompare && currentTime > timeToCompare || opts.selectionDirection === 'backward' && !toValue) {
		                    tempClass = this._addEndClass(tempClass, date, skipRangeClass);
		                } else {
		                    tempClass += ' is-start'; // No I18N
		                    let nextDate = new Date(currentTime);
		                    nextDate.setDate(nextDate.getDate() + 1);
		                    if (date.getDay() === lastDayOfWeek || opts.excludeWeekend && this._isWeekend(nextDate) || new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate() === date.getDate() && isNotAdjacent) {
		                        tempClass += ' is-start-last'; // No I18N
		                    }
		                }
		            } else {
		                tempClass = this._addEndClass(tempClass, date);
		            }
		        } else if (areNotEqual && (isCurrentGreater && currentTime < toTime || (timeToCompare && !toValue && ((currentTime >= fromTime && currentTime <= timeToCompare) || (currentTime <= fromTime && currentTime >= timeToCompare))))) {
		            if (isValid && tempClass.indexOf('is-disabled') < 0) { // No I18N
		                tempClass += this._getInRangeCls(date);
		            }
		            let nextDate = new Date(currentTime),
		                prevDate = new Date(currentTime),
		                lastDate;
		            nextDate.setDate(nextDate.getDate() + 1);
		            prevDate.setDate(prevDate.getDate() - 1);
		            lastDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
		            if (+lastDate === currentTime || (timeToCompare && currentTime === +timeToCompare && isCurrentGreater) || date.getDay() === lastDayOfWeek || (opts.excludeWeekend && isNotAdjacent && ((this._isWeekend(nextDate) && +nextDate !== toTime) || (this._isWeekend(prevDate) && nextDate.getMonth() !== date.getMonth()))) || date.getDate() === 1 && date.getDay() === lastDayOfWeek && isNotAdjacent) {
		                tempClass += ' zh-lastrange'; // No I18N
		            }
		        } else {
		            tempClass = this._updateDisabledCls(currentTime, weekClassAdded, tempClass, true);
		        }
		    }
		    return tempClass;
		}
		_mouseoverHandler  (ev) {
		    if (!this._isSeparate) {
		        if (this._viewMode === 0) {
		            let target = $(ev.target),
		                opts = this._opts,
		                isRangeTypeWeeks = opts.rangeType === 'weeks', // No I18N
		                fromValue = this._fromValue,
		                toValue = this._toValue;
		            target = target.closest('.zdatetimepicker__date:not(.is-disabled):not(.zdatetimepicker--disabledreplica),.zdatetimepicker__adjacentmonthdate:not(.is-disabled):not(.zdatetimepicker--disabledreplica)'); // No I18N
		            if (!target.length || !isRangeTypeWeeks && (!fromValue || (fromValue && toValue))) {
		                return;
		            }
		            if (target.closest('.zdatetimepicker--today').length) {
		                this._todayHovered = true;
		            }
		            if (isRangeTypeWeeks || fromValue && !toValue) {
		                let currentTime = this._getDateData(target).time;
		                if (isRangeTypeWeeks) {
		                    if (fromValue && toValue && currentTime >= +fromValue && currentTime <= +toValue) {
		                        return;
		                    }
		                    this._lastHovered = target;
		                }
		                clearTimeout(this._timeout);
		                this._timeout = setTimeout(this._updateObjects(), 0);
		            }
		            this._lastHovered = target;
		        }
		    }
		}
		_mouseleaveHandler  (ev) {
		    if (!$(ev.relatedTarget).is('.zdatetimepicker__date')) { // No I18N
		        this._lastHovered = null;
		    }
		    /* This handling is done for a css issue due which range selection is broader than the today's border */
		    let target = $(ev.target),
		        todayCls = 'zdatetimepicker--todayinrange', // No I18N
		        todayEle = target.closest('.' + todayCls);
		    if (todayEle.length) {
		        this._todayHovered = false;
		        todayEle.removeClass(todayCls);
		    }
		    if (this._opts.rangeType === 'weeks') { // No I18N
		        this._clearWeekSelection();
		    }
		}
		_setLimitValues  () {
		    let startDate = this._tempSDate,
		        minDate = this._oldMinDate,
		        endDate = this._tempEDate,
		        maxDate = this._oldMaxDate,
		        minValue = (!minDate || startDate && +startDate > +minDate ? startDate : minDate),
		        maxValue = (!maxDate || endDate && +endDate < +maxDate ? endDate : maxDate);
		    this._minDate = minValue ? new Date(+minValue) : minValue;
		    this._maxDate = maxValue ? new Date(+maxValue) : maxValue;
		}
		_reassignLimits  () {
		    if (this._preserved) {
		        this._minDate = this._oldMinDate;
		        this._maxDate = this._oldMaxDate;
		        this._preserved = false;
		    }
		}
		_setLimits  (callback) {
		    let fromValue = this._fromValue,
		        toValue = this._toValue;
		    if (this._isSeparate || fromValue && !toValue) {
		        if (!this._preserved) {
		            this._preserved = true;
		            this._oldMaxDate = this._maxDate ? new Date(+this._maxDate) : null;
		            this._oldMinDate = this._minDate ? new Date(+this._minDate) : null;
		        }
		        callback();
		    } else {
		        this._reassignLimits();
		    }
		}
		_updateDisabledCls  (currentTime, weekClassAdded, tempClass, notInRange) {
		    let arr = [
		        'disabledDaysOfWeek', // No I18N
		        'disabledDates', // No I18N
		        'disabledMonths', // No I18N
		        'disabledYears'// No I18N
		    ].map((val) => !!this._opts[val].length);
		    if (arr.indexOf(true) > -1 && (this._fromValue || weekClassAdded)) {
		        let nextDate = new Date(currentTime);
		        nextDate.setDate(nextDate.getDate() + 1);
		        if (this._isDisabledDate(nextDate)) { // No I18N
		            if (currentTime === +this._fromValue) {
		                tempClass += ' zh-disabledahead'; // No I18N
		            } else if (this._opts.rangeType === 'weeks' && notInRange) {
		                tempClass += ' zh-lastselection'; // No I18N
		            } else if (tempClass.indexOf('zh-lastrange') < 0) { // No I18N
		                tempClass += ' zh-lastrange'; // No I18N
		            }
		        }
		    }
		    return tempClass
		}
		_clearSpecialCls  (className) {
		    if (className.indexOf('zspecial') > -1) { // No I18N
		        className = className.replace(/is-disabled|zspecial/g, '');
		    }
		    return className;
		}
		_handleDecadeMousedown   (orgEvent, mode, selectedVal) {
		    if (this._isSeparate) {
		        let index = this._getPartIndex(orgEvent),
		            value = '_' + (index === 0 ? 'start' : 'end') + 'Date'; // No I18N
		        this[value] = this[value].setFullYear(selectedVal);
		    }
		    super._handleDecadeMousedown(...arguments);
		}
		_getDrilldownData   (data, index, orgEvent) {
		    if (this._isSeparate) {
		        this._setData(orgEvent);
		        let view = data.view;
		        this['_' + view + 'EventBinded'] = this._data[this._part][view + 'EventBinded'];
		        let drilldown = super._getDrilldownData(...arguments);
		        this._data[this._part][view + 'Drilldown'] = this._data.month[view + 'Drilldown']; // No I18N
		        this._setPartMode();
		        return drilldown;
		    } else {
		        return super._getDrilldownData(...arguments);
		    }
		}
		_setDrilldownClass  (elem) {
		    if(this._isSeparate) {
		        let month = this._data[this._part].month[0],
		        type = elem.is('zdatetimepicker__year') ? 'year' : 'month'; // No I18N
		        if(month[type + 'Drilldown']){
		            month[type + 'Drilldown'].cells[elem.index()].class.replace(/is-selected/g, ''); // No I18N
		        }
		    }else {
		        super._setDrilldownClass(...arguments);
		    }
		}
		_buildDrilldownView   (data, index) {
		    super._buildDrilldownView(...arguments);
		    if (this._isSeparate) {
		        this._updateDrilldownEle();
		        let varName = data.view + 'EventBinded'; // No I18N
		        if (!this._data[this._part][varName]) {
		            this._data[this._part][varName] = true;
		        }
		    }
		}
		_drilldownClickHandler  (ev) {
		    this._isSeparate && (this._viewMode = this._toggleViewMode(ev));
		    super._drilldownClickHandler(ev);
		}
		_updateDrilldownEle   () {
		    if (this._viewMode !== 0) {
		        let arr = ['month', 'year', 'decade']; // No I18N
		        let partEle = this._getPartEle();
		        for (let i = 0, len = arr.length; i < len; i++) {
		            let ele = partEle.find('.zdatetimepicker__' + arr[i] + 'drilldown'); // No I18N
		            if (ele.length) {
		                this['_' + arr[i] + 'DrillDownElement'] = ele; // No I18N
		            }
		        }
		    }
		}
		_setPartMode   (part = this._part) {
		    if (this._isSeparate) {
		        this._data[part].viewMode = this._viewMode;
		    }
		}
		_toggleViewMode   (ev) {
		    return $(ev.target).closest('.zdatetimepicker__monthcontainer').index();
		}
		_bindDrillDownClickEvent   (view, elem) {
		    if (this._isSeparate) {
		        elem = this._getPartEle().find('.zdatetimepicker');
		    }
		    super._bindDrillDownClickEvent(view, elem);
		}
		_setViewMode   (viewMode, preventAnimation, element) {
		    if (this._isSeparate) {
		        element = this._getPartEle().find('.zdatetimepicker');
		    }
		    super._setViewMode(viewMode, preventAnimation, element);
		    this._setPartMode();
		}
		_checkPart   (part) {
		    let isSeparate = this._isSeparate;
		    return (isSeparate && this._part === part || !isSeparate) && this['_' + part + 'Value'];
		}
		_selectClickHandler  (ev) {
		    this._setData(ev);
		    super._selectClickHandler(...arguments);
		}
		_destroyDropdown  () {
		    if (this._isSeparate && !this._destroyedDD) {
		        this._removeDropdown('from'); // No I18N
		        this._removeDropdown('to'); // No I18N
		    }else if(!this._destroyedDD){
		        super._destroyDropdown(...arguments);
		    }
		}
		_removeDropdown  (part) {
		    if(part) {
		        this._setData(part);
		        this._updateDropdownEle('month', true); // No I18N
		        this._updateDropdownEle('year', true); // No I18N
		    }
		    super._destroyDropdown(...arguments);
		}
		_getInvalidRange  (offset, time, isMin) {
		    offset = offset - 1;
		    let fromTime = +this._fromValue,
		        validation,
		        sDate = this._getValidDate(-1, new Date(fromTime), offset),
		        eDate = this._getValidDate(1, new Date(fromTime), offset);
		    if (isMin) {
		        validation = time <= fromTime && time > +sDate || time >= fromTime && time < +eDate;
		    } else {
		        this._tempEDate = eDate;
		        this._tempSDate = sDate;
		        if (time) {
		            validation = time < +sDate || time > +eDate;
		        }
		    }
		    return validation;
		}
		_validateMinMaxDays  () {
		    let opts = this._opts;
		    if (this._isMinOrMaxDaysPresent() && opts.minDaysToSelect > opts.maxDaysToSelect) { // No I18N
		        opts.maxDaysToSelect = null;
		    }
		}
		_getSeparateRange  (orgValue, renderTo) {
		    let offset = renderTo ? 1 : -1;
		    let arr = [ 'min', 'max' ], // No I18N
		        returnVal = [];
		    for (let i = 0; i < arr.length; i++) {
		        let value = this._opts[arr[i] + 'DaysToSelect'], // No I18N
		            date = new Date(+orgValue);
		        if (typeof value === 'number') { // No I18N
		            value = value - 1;
		            date = this._getValidDate(offset, date, value, renderTo);
		        }
		        returnVal.push(date);
		    }
		    return returnVal;
		}
		_getValidDate  (offset, date, maxCount, renderTo) {
		    let count = 0;
		    date = new Date(date.getTime());
		    while (count !== maxCount) {
		        date.setDate(date.getDate() + offset);
		        // !$(this._getDateElem(date)[renderTo ? 1 : 0]).hasClass('is-disabled') &&
		        if (this._checkWeekend(date) && !this._getUniqueClass(date)) {
		            count++;
		        }
		    }
		    return date;
		}
		_getMonthClasses   (month) {
		    let fromValue = this._fromValue,
		        toValue = this._toValue,
		        viewDate = this._viewDate,
		        isSeparate = this._isSeparate,
		        classes = super._getMonthClasses(month);
		    if (!isSeparate && fromValue && toValue || isSeparate) {
		        if (this._checkPart('from') && fromValue.getMonth() === month && fromValue.getFullYear() === viewDate.getFullYear() || (this._checkPart('to') && toValue.getMonth() === month && viewDate.getFullYear() === toValue.getFullYear())) { // No I18N
		            classes += ' is-selected'; // No I18N
		        }
		    }
		    if (!this._isSeparate && this._opts.selectionDirection !== 'both') {  // No I18N
		        classes = this._updateDirectionCls(classes, month, 'month'); // No I18N
		    }
		    return classes;
		}
		_setmonthDropdownVal  (minYr, minMonth, maxYr, maxMonth, navBar) {
		    super._setmonthDropdownVal(...arguments);
		    if(!minMonth && !minYr && !maxYr && !maxMonth) {
		        let valArray = [];
		        navBar.monthSelect.options.forEach((val) => valArray.push(val.value));
		        if(valArray.length){
		            ZC.select(this._monthHeader).setOptionAttributes(valArray, 'disabled', false); // No I18N
		        }
		    }
		}
		_updateDirectionCls  (classes, value, type) {
		    let fromValue = this._fromValue;
		    let isForward = this._opts.selectionDirection === 'forward', // No I18N
		        shouldAdd;
		    if (fromValue && !this._toValue && classes.indexOf('is-disabled') < 0) {
		        if (type === 'month') { // No I18N
		            shouldAdd = this._viewDate.getFullYear() === fromValue.getFullYear() && (isForward && value < fromValue.getMonth() || !isForward && value > fromValue.getMonth());
		        } else if (type === 'year') { // No I18N
		            shouldAdd = isForward && value < fromValue.getFullYear() || !isForward && value > fromValue.getFullYear();
		        }
		        if (shouldAdd) {
		            classes += ' is-disabled zspecial'; // No I18N
		        }
		    } else {
		        classes = this._clearSpecialCls(classes);
		    }
		    return classes;
		}
		_separateMousedown   (ev, part, target, dateValue) {
		    let opts = this._opts;
		    let value = '_' + part + 'Value'; // No I18N
		    this._part = part;
		    if (this[value]) {
		        this._select(false, this._getDateElem(this[value], this._getPartEle(part)), true);
		    }
		    if (part === 'to' && target.hasClass('is-selected')) { // No I18N
		        this._toValue = null;
		    } else {
		        this[value] = dateValue;
		        this._viewDate = new Date(+dateValue);
		    }
		    this._buildData(true, part, target);
		    this._commitValues(ev);
		    this._dateSelect = false;
		}
		_commitValues  (ev) {
		    if (this._fromValue && this._toValue && this._opts.immediateCommit) {
		        this._OKClickHandler(ev);
		    }
		    this._updateOKClass();
		}
		_constructData   () {
		    let isSeparate = this._isSeparate,
		        isRendered = this._data.rendered;
		    if (isSeparate) {
		        if (isRendered && !this._reInit) {
		            this._constructPart(this._part);
		        } else {
		            if (!this._id) {
		                this._id = this._elementId;
		            }
		            this._monthsPerView = 1;
		            this._constructPart('from'); // No I18N
		            this._constructPart('to'); // No I18N
		            this._elementId = this._id;
		        }
		    } else {
		        super._constructData();
		    }
		}
		_constructPart   (part) {
		    this._setData(part);
		    this._part = part;
		    let partData = this._data[part];
		    if (partData) {
		        this._data.month = partData.month;
		    } else {
		        this._data.month[0] = null;
		    }
		    this._updateViewMode(part);
		    // typeof check added to avoid undefined cases
		    if (typeof this._viewMode === 'number' && this._viewMode !== 0) {
		        this._generateContent();
		    } else {
		        super._constructData();
		    }
		    this._storeData();
		}
		_arrowEventHandler   (ev) {
		    this._setData(ev);
		    super._arrowEventHandler(ev);
		}
		_bindArrowEvents   () {
		    let id;
		    if (this._isSeparate) {
		        id = this._id;
		        this._elementId = id + 'zfrom'; // No I18N
		        super._bindArrowEvents();
		        this._elementId = id + 'zto'; // No I18N
		    }
		    super._bindArrowEvents();
		    if (id) {
		        this._elementId = id;
		    }
		}
		_buildData   (shouldRender, part, eleOrRenderBoth) {
		    if (this._isSeparate && this._data.rendered && !this._reInit) {
		        part = part || this._part;
		        let nextPart = part === 'from' ? 'to' : 'from', // No I18N 
		            renderBoth = typeof eleOrRenderBoth === 'boolean', target; // No I18N
		        if (!renderBoth) {
		            target = eleOrRenderBoth;
		        }
		        // Updating viewDate for _arrowClickHandler cases
		        this[this._getSegment()] = new Date(+this._viewDate);
		        if (target) {
		            let dateIndex = this._getDateEleIndex(target);
		            let dateObj = this._data[part].month[0].dates[dateIndex[1]][dateIndex[2]];
		            if (this['_' + part + 'Value']) { // No I18N
		                dateObj.class = dateObj.class + ' is-selected'; // No I18N
		            } else if (target.hasClass('is-selected')) { // No I18N
		                dateObj.class = dateObj.class.replace(/is-selected/g, ''); // No I18N
		            }
		        }
		        if (eleOrRenderBoth) {
		            this._constructPart(nextPart);
		        }
		        if (!eleOrRenderBoth || this._fromValue && this._toValue || (renderBoth && eleOrRenderBoth)) {
		            this._constructPart(part);
		        }
		        if (!this._reInit) {
		            this._render();
		        }
		    } else {
		        if (this._isSeparate) {
		            this._assignViewDate();
		        }
		        super._buildData(...arguments);
		    }
		}
		_setSeparateDates  () {
		    this._startDate = new Date(+(this._fromValue || this._viewDate));
		    this._endDate = new Date(+(this._toValue || this._viewDate));
		    this._startDate.setHours(0, 0, 0, 0);
		    this._endDate.setHours(0, 0, 0, 0);
		}
		_updateLimits   (renderToValue) {
		    let fromValue = this._fromValue,
		        toValue = this._toValue,
		        maxDays = this._opts.maxDaysToSelect;
		    if (renderToValue && fromValue) {
		        this._setLimits(() => {
		            let returnVal = this._getSeparateRange(fromValue, renderToValue);
		            this._tempSDate = returnVal[0];
		            this._tempEDate = maxDays ? returnVal[1] : null;
		            this._setLimitValues();
		        });
		    } else if (!renderToValue && toValue) {
		        this._setLimits(() => {
		            let returnVal = this._getSeparateRange(toValue, renderToValue);
		            this._tempSDate = maxDays ? returnVal[1] : null;
		            this._tempEDate = returnVal[0];
		            this._setLimitValues();
		        });
		    } else {
		        this._reassignLimits();
		    }
		}
		_addSeparateClasses   (date, tempClass) {
		    let currentTime = +date,
		        classes = '',
		        fromValue = this._fromValue,
		        toValue = this._toValue,
		        renderTo = this._part === 'to'; // No I18N
		    if(tempClass.indexOf('zdatetimepicker__adjacentmonthdate') < 0){
		        if (fromValue && !toValue) {
		            if (!renderTo && currentTime === +fromValue) {
		                classes += ' is-selected'; // No I18N
		            }
		        } else if (fromValue && toValue) {
		            if (renderTo) {
		                if (currentTime === +toValue) {
		                    classes += ' is-selected'; // No I18N
		                }
		            } else if (currentTime === +fromValue) {
		                classes += ' is-selected'; // No I18N
		            }
		        }
		    }
		    return classes;
		}
		_setArrowLimits   (part) {
		    this._updateLimits(part === 'to'); // No I18N
		    this._elementId = this._id + 'z' + part; // No I18N
		    this._updateArrowState(this._data[part].viewDate);
		}
		_updateArrows   (nextPart) {
		    this._setArrowLimits(nextPart);
		    this._setArrowLimits(nextPart === 'to' ? 'from' : 'to'); // No I18N
		}
		_setPart   (part) {
		    if (this._isSeparate) {
		        // Check if the argument is an event
		        if (part.type && typeof part.type === 'string') {
		            part = this._getPartIndex(part);
		        }
		        if (typeof part === 'number') { // No I18N
		            part = part === 0 ? 'from' : 'to'; // No I18N
		        }
		        this._part = part;
		        this._elementId = this._id + 'z' + part; // No I18N
		        return part;
		    }
		}
		_updateDropdownEle   (type, forceSet) {
		    let part = this._data.month[0],
		        ele = $('#' + this._elementId + '-' + type + '-header'), // No I18N
		        navExists = part && part.navigationBar;
		    if (ele.length && (part || forceSet)) {
		        this['_' + type + 'Header'] = ele; // No I18N
		        if (navExists) {
		            part.navigationBar[type + 'Select'].mainElement = ele; // No I18N
		        }
		    }
		}
		_setData   (part) {
		    if (this._isSeparate && part && typeof part !== 'boolean') { // No I18N
		        part = this._setPart(part);
		        let isFrom = part === 'from'; // No I18N
		        if (this._data[part]) {
		            this._data.month = this._data[part].month;
		        }else {
		            this._data.month = [];
		        }        
		        this._updateLimits(!isFrom);
		        // End date is updated after limits are set
		        // this._skipReset variable is added to set viewDate to today's date when today button is clicked. Without that, the To Date's viewDate will be fromValue.
		        if (!this._skipReset && this._fromValue && !isFrom && +this._endDate < +this._fromValue) {
		            this._endDate = new Date(+this._minDate);
		        }
		        this._viewDate = new Date(+(isFrom ? this._startDate : this._endDate));
		        if (this._isDrilldown) {
		            this._updateDrilldownEle();
		        } else {
		            this._updateDropdownEle('month'); // No I18N
		            this._updateDropdownEle('year'); // No I18N
		        }
		        return part;
		    }
		}
		_fillDates   (date, dateVal, index) {
		    if (this._isSeparate) {
		        index = -1;
		    }
		    super._fillDates(date, dateVal, index);
		}
		_getDateData   () {
		    let partData = this._data[this._part];
		    if (this._isSeparate && partData) {
		        this._data.month = partData.month;
		    }
		    return super._getDateData(...arguments);
		}
		_getPartEle   (part = this._part) {
		    return $(this.element.find('.zdatetimepicker__list')[part === 'from' ? 0 : 1]); // No I18N
		}
		_updateViewMode   (part = this._part) {
		    if (this._isSeparate) {
		        let partData = this._data[part];
		        this._viewMode = partData && typeof partData.viewMode === 'number' ? partData.viewMode : this._getViewMode(); // No I18N
		    }
		}
		_getPartIndex   (ev) {
		    this._viewMode = this._toggleViewMode(ev);
		    return $(ev.target).closest('.zdatetimepicker__list').index(); // No I18N
		}
		_setArrowMainElement   () {
		    if (this._isSeparate) {
		        this._elementId = this._id + 'z' + this._part; // No I18N
		    }
		    super._setArrowMainElement(...arguments);
		}
		_getSegment   (part = this._part) {
		    return '_' + (part === 'from' ? 'start' : 'end') + 'Date'; // No I18N
		}
		_updateRange   () {
		    if (this._isSeparate) {
		        this[this._getSegment()] = new Date(+this._viewDate);
		    }
		}
		_callRender   (elem, data, part) {
		    this._setData(part);
		    super._postEachRender(elem);
		}
		_postEachRender   (elem, data) {
		    if (this._isSeparate) {
		        if(data.modifiedAttr === 'selectionType' || !data.rendered) { // No I18N
		            this._data.className += ' zdatetimepicker--group'; // No I18N
		        }
		        this._updateRange();
		        let lastSetValue = this._part,
		            modifiedAttr = this._data.modifiedAttr;
		        this._callRender(elem, data, lastSetValue === 'from' ? 'to' : 'from'); // No I18N
		        // Reassigning it since the value is set undefined at the end of first post render in date picker.
		        this._data.modifiedAttr = modifiedAttr;
		        this._callRender(elem, data, lastSetValue);
		    } else {
		        super._postEachRender(elem, data);
		    }
		}
		_storeData   () {
		    if (!this._data.rendered || this._reInit) {
		        let type = this._part;
		        this[this._getSegment()] = new Date(+this._viewDate);
		        let data = $.extend(true, {}, this._data.month[0]);
		        data.label = ZC.encodeHTML(this._opts[type + 'Label'] || this._getI18NText(type + 'Label')); // No I18N
		        this._data[type] = { month: [data] };
		    }
		}
		_resetSeparateType   () {
		    this._reassignLimits();
		    this._resetDates();
		    this._assignViewDate();
		}
		_separateCloseHandler   (ev) {
		    if (this._opts.fromValue && this._opts.toValue) {
		        this._restoreValues();
		    }
		    let fromValue = this._fromValue,
		        toValue = this._toValue;
		    let dateExists = fromValue || toValue;
		    if (fromValue && !toValue || !fromValue && toValue || !this._valueUpdate) {
		        this._valueRemoval = true;
		        this._select(false, this._getDateElem(fromValue || toValue, this._getPartEle(fromValue ? 'from' : 'to')), true); // No I18N
		        this.element.find('.is-selected').removeClass('is-selected');
		    }
		    if (!dateExists || this._valueRemoval) {
		        this._resetSeparateType();
		    }
		    this._refreshPicker('from'); // No I18N
		    this._refreshPicker('to'); // No I18N
		    this._closePickerHandler(ev);
		}
		_setAttribute   (optionName, value) {
		    let opts = this._opts;
		    opts[optionName] = value;
		    let domChanged = false, callSuper = false;
		    this._isNotSet = false;
		    let rangePickerOptions = ['selectionDirection', 'rangeType', 'excludeWeekend', 'minDaysToSelect', 'maxDaysToSelect', 'fromLabel', 'toLabel', 'selectionType', 'fromValue', 'toValue'], // No I18N
		        specialDays = ['disabledDaysOfWeek', 'specialDaysOfWeek', 'specialDates', 'disabledDates']; // No I18N
		    if (rangePickerOptions.indexOf(optionName) > -1) {
		        if (optionName === 'fromValue' || optionName === 'toValue') {  // No I18N
		            this._isNotSet = !opts.toValue || !opts.fromValue;
		            // this._validateOpts();
		            this._setFromToValue();
		        } else if (this._isSeparate && (optionName === 'fromLabel' || optionName === 'toLabel')) { // No I18N
		            let part = optionName.indexOf('from') > -1 ? 'from' : 'to'; // No I18N
		            this._data[part].month[0].label = value;
		            domChanged = true;
		        } else if (optionName === 'selectionType') { // No I18N
		            let isSeparate = this._isSeparate = value === 'separate'; // No I18N
		            this._emptyValues();
		            this._monthsPerView = isSeparate ? 1 : this._opts.monthsPerView;
		            this['_' + (isSeparate ? 'remove' : 'add') + 'OtherEvents'](); // No I18N
		            if (isSeparate) {
		                opts.value = null;
		            }
		            this._data.modifiedAttr = 'navBar'; // No I18N
		            this._setTemplate();
		            this._reInit = true;
		        } else if (optionName === 'excludeWeekend') { // No I18N
		            this._updateClass('zdatetimepicker__excludeweekend', !value); // No I18N
		        } else if (optionName === 'minDaysToSelect' || optionName === 'maxDaysToSelect') { // No I18N
		            this._validateMinMaxDays();
		        }
		    } else if (!this._isSeparate && specialDays.indexOf(optionName) > -1) {
		        super._setAttribute(...arguments);
		        this._updateObjects();
		    } else if (optionName === 'navigationBar') { // No I18N
		        if (this._id) {
		            this._elementId = this._id;
		        }
		        this._emptyValues(true);
		        callSuper = true;
		    }else if(optionName === 'todayButtonAction') { // No I18N
		        opts.todayButtonAction = 'navigate-only'; // No I18N
		    }else {
		        callSuper = true;
		    }
		    if (callSuper) {
		        super._setAttribute(...arguments);
		    }
		    if(["minDate", "maxDate"].indexOf(optionName) > -1){
		        let valueChanged = this._checkValueValidity();
		        valueChanged && this._dispatchEvent('change', undefined, this._getSelectedValue()); // No I18N
		    }
		    this._domChanged = this._domChanged || domChanged;
		}
		_emptyValues   (avoidHeaders) {
		    this._data.from = this._data.to = this._currentSelected = null;
		    this._data.month = [];
		    if(!avoidHeaders){
		         /* If navigationbar is set through setAttribute, calling emptyValues undefines these variables which disables the destroy of these elements in datepicker's destroydropdown */
		         /* Preventing it here since anyways it will be made undefined after destroying it. */
		        this._monthHeader = this._yearHeader = undefined; 
		    }
		}
		_removeOtherEvents   () {
		    ['enter', 'leave'].forEach((val) => this.element.off('mouse' + val + '.' + this.name, this.delegateList)); // No I18N
		}
		_todayClickHandler  (evData) {
		    if(this._isSeparate){
		        this._setData('from'); // No I18N
		        super._todayClickHandler(evData);
		        this._skipReset = true;
		        this._setData('to'); // No I18N
		    }
		    super._todayClickHandler(evData, this._isSeparate);
		    this._skipReset = false;
		}
		_setWeekDates  (time) {
		    let initialStart = new Date(time);
		    initialStart.setDate(initialStart.getDate() - initialStart.getDay());
		    this._weekStart = this._resetDateLimit(new Date(+initialStart), 1);
		    this._weekEnd = this._resetDateLimit(new Date(initialStart.getFullYear(), initialStart.getMonth(), initialStart.getDate() + 6), -1);
		}
		_resetDateLimit  (date, offset) {
		    let opts = this._opts,
		        excludeWeekend = this._opts.excludeWeekend,
		        ele = this._getDateElem(date);
		    /* isWeekend is called instead of class check because, if previous month's weekend comes, it cannot be checked since it will not be available in DOM */
		    while (ele.hasClass('is-disabled') || excludeWeekend && this._isWeekend(date)) { // No I18N
		        date.setDate(date.getDate() + offset);
		        ele = this._getDateElem(date);
		    }
		    if (opts.minDate && this._isGreater(opts.minDate, date)) {
		        date = new Date(+opts.minDate);
		    } else if (opts.maxDate && this._isGreater(date, opts.maxDate)) {
		        date = new Date(+opts.maxDate);
		    }
		    return date;
		}
		_clearWeekSelection  () {
		    let fromValue = this._fromValue,
		        toValue = this._toValue;
		    if (fromValue && toValue || (!fromValue && !toValue)) {
		        // To clear the extra hovered elements after selection of from and to dates
		        if (this.element.find('.zdatetimepicker--weekselection').length) { // No I18N
		            this._setUndefined([ 'weekStart', 'weekEnd' ], ''); // No I18N
		            this._updateObjects();
		        }
		    }
		}
		_getYearClasses   (year, index) {
		    let fromValue = this._fromValue,
		        toValue = this._toValue,
		        isSeparate = this._isSeparate,
		        classes = super._getYearClasses(...arguments);
		    if (!isSeparate && fromValue && toValue || isSeparate) {
		        if (this._checkPart('from') && fromValue.getFullYear() === year || this._checkPart('to') && toValue && toValue.getFullYear() === year) {
		            classes += ' is-selected'; // No I18N
		        }
		    }
		    if (!isSeparate && this._opts.selectionDirection !== 'both') { // No I18N
		        classes = this._updateDirectionCls(classes, year, 'year'); // No I18N
		    }
		    return classes;
		}
		_setyearDropdownVal  (minYr, minMonth, maxYr, maxMonth, navBar) {
		    let yearData = navBar.yearSelect.options,
		        viewDate = this._viewDate,
		        trueArray = [],
		        falseArray = [];
		    yearData.forEach((val) => {
		        val.disabled = minYr && val.value < minYr || (typeof minMonth === 'number' && val.value === minYr && viewDate.getMonth() < minMonth) || maxYr && val.value > maxYr || (typeof maxMonth === 'number' && val.value === maxYr && viewDate.getMonth() > maxMonth); // No I18N
		        (val.disabled ? trueArray : falseArray).push(val.value);
		    });
		    let comboInstance = ZC.combobox(this._yearHeader);
		    if (this._yearHeader) {
		        trueArray.length && comboInstance.setOptionAttributes(trueArray, 'disabled', true); // No I18N
		        falseArray.length && comboInstance.setOptionAttributes(falseArray, 'disabled', false); // No I18N
		        comboInstance.setAttribute('selectedValue', this._viewDate.getFullYear()); // No I18N
		    }
		}
	}
	ZC.registerComponent('ZDateRangePicker', ZC.ZDatePicker, ZDateRangePicker); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){
let template = ZC.zdaterangepicker.Templates, datepickerTemplate = ZC.zdatepicker.Templates, utilities = ZC.Templates.Utilities; 
template.WCChildren = (data) => ZT.html `${data.displayType === 'callout' && ZT.html `<div class='zdatetimepicker__pointer'></div>`} ${data.title && datepickerTemplate.WCTitle(data.title)} ${ZT.html `<ul class='zdatetimepicker__container'> ${template.WCDateLayout(data.from.month[0])} ${template.WCDateLayout(data.to.month[0])} </ul>`} ${data.cBar && !data.isCBar && utilities.WCCommandBar(data.cBar)}` 
template.WCDateLayout = (data) => ZT.html `<li class='zdatetimepicker__list'> <div class='zdatetimepicker__fromtolabel'> ${data.label} </div> <div class='zdatetimepicker zdatetimepicker--calendarsplit'> ${datepickerTemplate.WCMonth(data)} ${datepickerTemplate.WCDrilldownView(data)} </div> </li>` }(ZComponents)); 
 (function(ZC){
let template = ZC.zdaterangepicker.Templates, datepickerTemplate = ZC.zdatepicker.Templates, utilities = ZC.Templates.Utilities; 
template.children = (data) => ZT.html `${data.displayType === 'callout' && ZT.html `<div class='zdatetimepicker__pointer'></div>`} ${data.title && datepickerTemplate.title(data.title)} ${ZT.html `<ul class='zdatetimepicker__container'> ${template.dateLayout(data.from.month[0])} ${template.dateLayout(data.to.month[0])} </ul>`} ${data.cBar && !data.isCBar && utilities.commandBar(data.cBar)}` 
template.dateLayout = (data) => ZT.html `<li class='zdatetimepicker__list'> <div class='zdatetimepicker__fromtolabel'> ${data.label} </div> <div class='zdatetimepicker zdatetimepicker--calendarsplit'> ${datepickerTemplate.month(data)} ${datepickerTemplate.drilldownView(data)} </div> </li>` }(ZComponents)); 
(function(ZC, $){
	class ZDateTimeRangePicker extends ZC.ZDateRangePicker {
			get name(){
				return "zdatetimerangepicker";
			}
	    get attrs() {
	        return {
	            format: 'dd/MM/yyyy, hh:mm tt', // No I18N
	            fromTimeLabel: null,
	            toTimeLabel: null,
	            timeFieldType: 'input', // No I18N
	            timeMultipleSelectBoxType: 'h-m-t', // No I18N
	            timeLabelType: 'icon', // No I18N
	            hourStep: 1,
	            minuteStep: 5
	        }
	    }
	    get props() {
	        return {
	            labels: {
	                fromTimeLabel: 'Time', // No I18N
	                toTimeLabel: 'Time' // No I18N
	            }
	        }
	    }
	    get SELECTORS() {
	        return {
	            field: this.isCE ? 'z-input' : 'input' // No I18N
	        }
	    }
	    _init(ele, opts) {
	        this._checkTime = true;
	        this._initialFrom = opts.fromValue;
	        this._initialTo = opts.toValue;
	        super._init(...arguments);
	        this._assignTime();
	        this._buildTimeBar();
	        this._data.isCBar = true;
	        this._opts.closeOnDateSelect = false;
	    }
	    _postRender() {
	        super._postRender(...arguments);
	        this._data.className += ' zdatetimepicker--fromtocalendar zdatetimepicker--doublecalendar'; // No I18N
	    }
	    _setFormat() {
	        let format = this._opts.format,
	            hourIndex = Math.max(format.indexOf('h'), format.indexOf('H')), // No I18N
	            dateIndex = Math.min(Math.min(format.indexOf('d'), format.indexOf('M')), format.indexOf('y')), // No I18N
	            lastIndex, first;
	        this._is12HourFormat = format.indexOf('h') > -1;
	        if (hourIndex > dateIndex) {
	            this._timeFormat = format.substring(hourIndex); // No I18N
	            format = format.replace(this._timeFormat, '');// No I18N
	            lastIndex = Math.max(Math.max(format.lastIndexOf('d'), format.lastIndexOf('M')), format.lastIndexOf('y'));// No I18N
	            first = '_date';// No I18N
	        } else {
	            // if timeFormat comes before dateFormat
	            this._dateFormat = format.substring(dateIndex);
	            format = format.replace(this._dateFormat, '');// No I18N
	            lastIndex = Math.max(format.lastIndexOf('m'), format.lastIndexOf('t'));// No I18N
	            first = '_time';// No I18N
	        }
	        this[first + 'Format'] = format.substring(0, lastIndex + 1); // No I18N
	    }
	    _assignTime() {
	        [ 'From', 'To' ].forEach((val) => { // No I18N
	            let initialVal = this['_initial' + val]; // No I18N
	            if (initialVal) {
	                let value = ZC.Date.parseDate(initialVal, this._opts.format).date;
	                this._opts[val.toLowerCase() + 'Value'].setHours(value.getHours(), value.getMinutes()); // No I18N
	            }
	        });
	    }
	    _setTemplate() {
	        this._opts.templateName = 'zdatetimerangepicker'; // No I18N
	    }
	    _validateFormat() {
	        let format = this._opts.format;
	        this._invalidFormat = !((format.indexOf('d') > -1) && (format.indexOf('h') > -1 || format.indexOf('H') > -1));
	    }
	    _postEachRender() {
	        super._postEachRender(...arguments);
	        let id = this._isSeparate ? this._id : this._elementId;
	        if (!this._fromInstance || this._reInit) {
	            this._fromTimePicker = $('#' + id + '-timeinput1'); // No I18N
	            this._fromInstance = ZC.timeinput(this._fromTimePicker);
	            this._toTimePicker = $('#' + id + '-timeinput2'); // No I18N
	            this._toInstance = ZC.timeinput(this._toTimePicker);
	        }
	    }
	    _buildData() {
	        /* On reInit from setAttribute, timeBar is not properly built */
	        super._buildData(...arguments);
	        !this._doNotBuildTime && this._buildTimeBar();
	        this._doNotBuildTime = undefined;
	    }
	    _buildTimeBar() {
	        let timeProps = {},
	            opts = this._opts;
	        [ 'timeFieldType', 'timeMultipleSelectBoxType', 'minTime', 'maxTime', 'hourStep', 'minuteStep', 'timeLabelType', 'fixedTimeOptions', 'disabledTimeList', 'rtl' ].forEach((opt) => timeProps[opt] = opts[opt]);// No I18N
	        timeProps.isCE = this.isCE;
	        timeProps.templateRender = true;
	        timeProps.format = this._timeFormat;
	        this._data.isSeparate = this._isSeparate;
	        this._data.timeBarCls = 'zdatetimepicker__timebar h-aligncenter zdatetimepicker--twocolumn'; // No I18N
	        this._createTimeObj('from', timeProps); // No I18N
	        this._createTimeObj('to', timeProps); // No I18N
	    }
	    _createTimeObj(type, timeProps) {
	        let value = this._opts[type + 'Value'],
	            label = type + 'TimeLabel'; // No I18N
	        this._data[type + 'TimeProps'] = { // No I18N
	            ...timeProps,
	            id: (this._isSeparate ? this._id : this._elementId) + '-timeinput' + (type === 'from' ? '1' : '2'), // No I18N
	            timeLabel: this._opts[label] || this._getI18NText(label), // No I18N
	            timechange: this._timeChangeHandler.bind(this),
	            className: 'zdatetimepicker__' + (type === 'from' ? 'start' : 'end') + 'time' // No I18N
	        };
	        if (value) {
	            this._data[type + 'TimeProps'].selectedTime = new Date(+value); // No I18N
	        }
	        if (this._isSeparate) {
	            this._data[(type === 'from' ? 'max' : 'min') + 'Time'] = new Date(+(this._opts[(type === 'from' ? 'to' : 'from') + 'Value'])); // No I18N
	        }
	    }
	    _restoreValues() {
	        super._restoreValues(...arguments);
	        this._fromValue.setHours(0, 0, 0, 0);
	        this._toValue.setHours(0, 0, 0, 0);
	    }
	    _setDateValue(part) {
	        let tempValue = this['_' + part + 'Value'], // No I18N
	            value = this._opts[part + 'Value']; // No I18N
	        if (value) {
	            if (tempValue) {
	                value.setDate(tempValue.getDate());
	                value.setMonth(tempValue.getMonth());
	                value.setFullYear(tempValue.getFullYear());
	            } else {
	                this._opts[part + 'Value'] = null; // No I18N
	            }
	        }
	    }
	    _updateValues() {
	        super._updateValues(...arguments);
	        if (this._fromValue) {
	            this._viewDate = new Date(+this._fromValue);
	        }
	    }
	    _unsetDates(unSet) {
	        let opts = this._opts;
	        if (unSet) {
	            opts.fromValue = null;
	            opts.toValue = null;
	            this._initialFrom = null;
	            this._initialTo = null;
	        } else {
	            let tempFromValue = this._fromValue,
	                tempToValue = this._toValue,
	                toValue = opts.toValue;
	            if (opts.fromValue) {
	                this._setDateValue('from'); // No I18N
	            } else if (tempFromValue) {
	                opts.fromValue = new Date(+tempFromValue);
	            }
	            if (toValue) {
	                this._setDateValue('to'); // No I18N
	            } else if (tempToValue) {
	                opts.toValue = new Date(+tempToValue);
	            }
	        }
	        if (!opts.fromValue) {
	            this._opts.value = undefined;
	            this._currentSelected = undefined;
	        }
	    }
	    _closePicker() {
	        super._closePicker(...arguments);
	        this._fromInstance.setAttribute('valueUpdate', !!this._opts.fromValue); // No I18N
	        this._toInstance.setAttribute('valueUpdate', !!this._opts.toValue); // No I18N
	        this._setValueOnTimeInput();
	    }
	    _setValueOnTimeInput() {
	        let date = new Date(),
	            fromValue = this._opts.fromValue,
	            toValue = this._opts.toValue;
	        this._fromInstance.setTime(fromValue ? new Date(date.setHours(fromValue.getHours(), fromValue.getMinutes(), 0, 0)) : undefined);
	        this._toInstance.setTime(toValue ? new Date(date.setHours(toValue.getHours(), toValue.getMinutes(), 0, 0)) : undefined);
	    }
	    _OKClickHandler(ev) {
	        this._valueUpdate = true;
	        this._unsetDates();
	        let opts = this._opts,
	            from = opts.fromValue,
	            to = opts.toValue,
	            fromTime = this._fromInstance.getAttribute('selectedTime'), // No I18N
	            toTime = this._toInstance.getAttribute('selectedTime'); // No I18N
	        from && from.setHours(fromTime.getHours(), fromTime.getMinutes());
	        to && to.setHours(toTime.getHours(), toTime.getMinutes());
	        this._doNotDispatchSuperEvent = true;
	        super._OKClickHandler(...arguments);
	        this._doNotDispatchSuperEvent = false;
	        // Revisit - Temporarily commented
	        // if (from || to) {
	        this._dispatchEvent('change', ev, this._getSelectedValue()); // No I18N
	        // }
	    }
	    _dispatchEvent(eventName) {
	        if (!this._doNotDispatchSuperEvent && eventName === 'change' || eventName !== 'change') {
	            this._event = 'z' + eventName; // No I18N
	            return super._dispatchEvent(...arguments);
	        }
	    }
	    _isEqual(from, to) {
	        return from && to && ZC.Date.areDatesEqual(from, to);
	    }
	    _setMinMaxLimits() {
	        let from = this._fromValue,
	            to = this._toValue,
	            fromInstance = this._fromInstance,
	            toInstance = this._toInstance;
	        if (this._isEqual(from, to)) {
	            toInstance.setAttribute('minTime', fromInstance.getAttribute('selectedTime')); // No I18N
	            fromInstance.setAttribute('maxTime', toInstance.getAttribute('selectedTime')); // No I18N
	        } else {
	            fromInstance.setAttribute('maxTime', null); // No I18N
	            toInstance.setAttribute('minTime', null); // No I18N
	        }
	    }
	    _commitValues(ev) {
	        if (this._fromValue && this._toValue) {
	            let index = $(ev.target).closest('.zdatetimepicker__list').index();
	            this._setMinMaxLimits(this.element.find('.zdatetimepicker__' + (index === 0 ? 'start' : 'end') + 'time'), this['_' + (index === 0 ? 'from' : 'to') + 'Instance'].getAttribute('selectedTime')); // No I18N
	        }
	        super._commitValues(...arguments);
	    }
	    _timeChangeHandler(orgEvent, ui) {
	        let evData = ui || orgEvent.detail,
	            opts = this._opts;
	        this._valueUpdate = opts.immediateCommit;
	        if (evData.fromUI) {
	            this._fromInstance && this._toInstance && opts.immediateCommit && this._OKClickHandler(orgEvent && orgEvent.originalEvent, true);
	            this._setMinMaxLimits(evData.element, evData.selectedTime)
	        }
	    }
	    _getValueObj(value, part) {
	        let returnVal = super._getValueObj(value, part);
	        [ 'DateString', 'TimeString' ].forEach((valType) => { // No I18N
	            let str;
	            str = returnVal[part + valType] = ZC.Date.formatDate(value, valType === 'DateString' ? this._dateFormat : this._timeFormat); // No I18N
	            returnVal['translated' + part[0].toUpperCase() + part.slice(1) + valType] = this._translateEToA(str) // No I18N
	        })
	        return returnVal;
	    }
	    _destroy() {
	        this._fromInstance.destroy();
	        this._toInstance.destroy();
	        this._fromInstance = this._toInstance = undefined;
	        super._destroy();
	    }
		_clearClickHandler  (orgEvent, doNotTrigger, forceClear) {
		    this._fromInstance.clearTime();
		    this._fromInstance.refresh();
		    this._toInstance.clearTime();
		    this._toInstance.refresh();
		    super._clearClickHandler(...arguments);
		}
		_setAttribute  (optionName, value) {
		    let timeOptions = [ 'timeFieldType', 'timeLabelType', 'timeLabel', 'timeMultipleSelectBoxType', 'minTime', 'maxTime', 'hourStep', 'minuteStep', 'disabledTimeList', 'fixedTimeOptions' ], // No I18N
		        opts = this._opts,
		        fromInstance = this._fromInstance,
		        toInstance = this._toInstance;
		    opts[optionName] = value;
		    if(optionName === 'fromValue' || optionName === 'toValue') { // No I18N
		        this._initialFrom = opts.fromValue;
		        this._initialTo = opts.toValue;
		        (optionName === 'fromValue' ? fromInstance : toInstance).setAttribute('valueUpdate', true); // No I18N
		        super._setAttribute(...arguments);
		        this._assignTime();
		        this._setValueOnTimeInput();
		        this._domChanged = true;
		    }else if(timeOptions.indexOf(optionName) > -1) {
		        this._buildTimeBar();
		        fromInstance.setAttribute(optionName, value);
		        toInstance.setAttribute(optionName, value);
		    }else {
		        super._setAttribute(...arguments);
		        this._assignTime();
		        this._buildTimeBar();
		    }
		    if(optionName === 'rtl'){
		        fromInstance && fromInstance.setAttribute(...arguments);
		        toInstance && toInstance.setAttribute(...arguments);
		    }
		}
	}
	ZC.registerComponent('ZDateTimeRangePicker', ZC.ZDateRangePicker, ZDateTimeRangePicker); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){
let template = ZC.zdatetimerangepicker.Templates, dateRangePickerTemplate = ZC.zdaterangepicker.Templates, datepickerTemplate = ZC.zdatepicker.Templates, timeInput = ZC.createTimeInput, utilities = ZC.Templates.Utilities; 
template.WCChildren = (data) => ZT.html `${data.isSeparate ? ZT.html `${dateRangePickerTemplate.WCChildren(data)} ${template.WCTimeBar(data)}` : ZT.html `${datepickerTemplate.WCChildren(data)} ${template.WCTimeBar(data)}` } ${data.cBar && utilities.WCCommandBar(data.cBar)}` ; 
template.WCTimeBar = (data) => ZT.html `<div class=${data.timeBarCls}> ${timeInput(data.fromTimeProps)} ${timeInput(data.toTimeProps)} </div>`; }(ZComponents)); 
 (function(ZC){
let template = ZC.zdatetimerangepicker.Templates, dateRangePickerTemplate = ZC.zdaterangepicker.Templates, datepickerTemplate = ZC.zdatepicker.Templates, timeInput = ZC.createTimeInput, utilities = ZC.Templates.Utilities; 
template.children = (data) => ZT.html `${data.isSeparate ? ZT.html `${dateRangePickerTemplate.children(data)} ${template.timeBar(data)}` : ZT.html `${datepickerTemplate.children(data)} ${template.timeBar(data)}` } ${data.cBar && utilities.commandBar(data.cBar)}` ; 
template.timeBar = (data) => ZT.html `<div class=${data.timeBarCls}> ${timeInput(data.fromTimeProps)} ${timeInput(data.toTimeProps)} </div>`; }(ZComponents)); 
(function(ZC, $){
	ZC.$document.on('scroll.zpopover', (orgEvent) => {	// No I18N
	    if (ZC.openedPopover && ZC.openedPopover._opts.closeOnScroll && ZC.openedPopover.element.is(':visible')) {
	        ZC.openedPopover.close(orgEvent);
	    }
	});
	class ZPopover extends ZC.CoreComponent {
			get name(){
				return "zpopover";
			}
	    get attrs() {
	        return {
	            type: 'modeless', // No I18N
	            title: '', // No I18N
	            displayType: 'callout',	// No I18N
	            position: 'auto', // No I18N
	            closeButton: false,
	            closeOnBodyClick: true,
	            closeOnEsc: true,
	            closeOnScroll: false,
	            toggle: false,
	            positionAlterable: true,
	            removeOnClose: false,
	            detachable: false,
	            height: null,
	            width: null,
	            closeSVGIconId: null,
	            closeIconClass: null,
	            progressIndicatorIconClass: null,
	            progressIndicatorSVGIconId: null,
	            wrapAroundKeyboardNavigation: false,
	            forElement: null,
	            content: null,
	            appendTo: null,
	            isContentHTMLEncoded: false,
	            isTitleHTMLEncoded: false
	        }
	    }
	    get props() {
	        return {
	            closeIconClassName: null,
	            progressIndicatorIconClassName: null,
	            innerHTML: null,
	            margin: null,
	            offset: null,
	            delay: null,
	            animation: null,
	            messages: {
	                close: 'Close' // No I18N
	            }
	        }
	    }
	    get EVENTS() {
	        return [ 'beforeopen', 'open', 'beforeclose', 'close', 'dragstart', 'drag', 'dragend', 'beforefocus', 'contentload' ]; // No I18N
	    }
	    _init(element, opts) {
	        let content = opts.content || '',
	            isCallout = opts.displayType === 'callout'; // No I18N
	        this._forElement = $(opts.forElement);
	        element.attr({
	            'aria-haspopup': 'true',	// No I18N
	            'aria-expanded': 'false',	// No I18N
	            tabindex: element.attr('tabindex') || 0 // No I18N
	        });
	        if (!/^(top|bottom|right|left|top-left|top-right|bottom-left|bottom-right|auto|right-bottom|right-top|left-bottom|left-top|at-cursor)$/.test(opts.position)) {
	            opts.position = 'bottom';	 // No I18N
	        }
	        this._correctPosition();	// No I18N
	        let data = this._data;
	        data.closeButton = opts.closeButton || opts.type === 'modal'; // No I18N
	        if (opts.title || this.isCE || data.closeButton || opts.detachable) { // No I18N
	            this._setTitleBar();
	        }
	        this._data.callout = isCallout; // No I18N
	        this._isAjaxContent = opts.progressIndicator = content.URL;
	        data.closeButton && this._handleClose();
	        this._setContent(content);
	        let appendedTo = $(opts.appendTo);
	        if (appendedTo.length) {
	            element.appendTo(appendedTo);
	        }
	    }
	    _setContent(content, doNotCheckChild) {
	        let opts = this._opts,
	            data = this._data,
	            element = this.element;
	        if (!this._isAjaxContent && content) {
	            opts.content = opts.isContentHTMLEncoded ? content : ZC.encodeHTML(content); // No I18N
	        }
	        if (!doNotCheckChild) {
	            let contentEle = this.isCE ? element.find('z-pocontent').addClass('zpopover__content') : element[0].childNodes;
	            if (contentEle.length) {
	                if (this.isCE) {
	                    data.contentEle = contentEle[0]
	                } else {
	                    data.content = [ ...contentEle ];
	                }
	            }
	        }
	        if (!data.content && !data.contentEle || doNotCheckChild) {
	            data.content = opts.content;
	        }
	        data.isContentString = typeof data.content === 'string'; // No I18N
	    }
	    _postRender(element, opts) {
	        opts.detachable && this._handleDrag(true);
	        let find = element.find.bind(element);
	        this._titleBar = find('.zpopover__title'); // No I18N
	        this._contentEle = find('.zpopover__content'); // No I18N
	        this._data.className += ' zpopover'; // No I18N
	        if (opts.type === 'modal') { // No I18N
	            this._createOverlay();
	        }
	        this._data.closeButton && this._handleClose(null, true);
	    }
	    _bindEvents() {
	        if (this._opts.closeOnEsc) {
	            this._addEvents({
	                keydown: 'keydown' // No I18N
	            });
	        }
	    }
	    _keydownHandler(orgEvent) {
	        if (orgEvent.keyCode === ZC.keyCode.ESCAPE) {
	            this.close(orgEvent);
	            orgEvent.stopPropagation();
	        } else if (this._opts.wrapAroundKeyboardNavigation && orgEvent.keyCode === ZC.keyCode.TAB) {
	            orgEvent.stopPropagation(); // default tab behavior should not be prevented since focushandler will not handle inbetween elements tab flow now.
	        }
	    }
	    open(options) {
	        let opts = this._opts,
	            element = this.element,
	            data = this._data;
	        options = options || {};
	        if(opts.toggle && element.attr("aria-expanded") === "true"){    // No I18N
	            this.close();
	            return;
	        }
	        let _forElement = (options.forElement || this._opts.forElement);
	        if (_forElement) {
	            this._forElement = $(_forElement);
	        }
	        if (this._overlay) {
	            this._overlay.show();
	            this._forElement.addClass('zpopover--target'); // No I18N
	        }
	        ZC.openedPopover = this;
	        if (opts.detachable) {
	            data.closeButton = opts.closeButton || opts.type === 'modal';
	            data.callout = opts.displayType === 'callout'; // No I18N
	            this._setTitleBar(true);
	        }
	        if (opts.type !== 'modal' && ZC.bindDocumentEvents && opts.closeOnBodyClick) { // No I18N
	            ZC.bindDocumentEvents({
	                element,
	                forElement: this._forElement,
	                ctype: this.name,
	                closeMethodName: 'close', // No I18N
	                closeEvent: 'close' // No I18N
	            });
	        }
	        if (this._dispatchEvent('beforeopen', {}, {forElement:this._forElement})) { // No I18N
	            let delay = opts.delay;
	            if (delay) {
	                if (delay.openAfter) {
	                    clearTimeout(this._openTimer);
	                    this._openTimer = setTimeout(() => this._preprocessEle(options), delay.openAfter);
	                }
	                if (delay.closeAfter) {
	                    this._autoCloseEle();
	                }
	            } else {
	                this._preprocessEle(options);
	                ZC.animationHandler({
	                    action: 'open', // No I18N
	                    animation: opts.animation,
	                    callback: this._openHandler.bind(this),
	                    element,
	                    ctype: this.name
	                });
	            }
	        }
	        if (this._isAjaxContent) {
	            this._makeRequest();
	        }
	    }
	    _autoCloseEle() {
	        let delay = this._opts.delay;
	        let duration = delay.openAfter ? delay.openAfter + delay.closeAfter : delay.closeAfter;
	        clearTimeout(this._closeTimer);
	        this._closeTimer = setTimeout(() => this.close(), duration);
	    }
	    _preprocessEle(options) {
	        this._display().attr('aria-expanded', true); // No I18N
	        this._fixDimensions();
	        this._positionEle(options);
	    }
	    _openHandler() {
	        !this._opts.animation && this._display().attr('aria-expanded', 'true'); // No I18N
	        if (this._opts.wrapAroundKeyboardNavigation && ZC.FocusHandler) {
	            ZC.FocusHandler.init(this.element, '.zpopover__close'); // No I18N
	        } else if (this._dispatchEvent('beforefocus', {}, this.element)) { // No I18N
	            clearTimeout(this._openTimeout);
	            this._openTimeout = setTimeout(() => this.element.focus(), 100);
	        }
	        this._dispatchEvent('open', {}, {forElement:this._forElement}); // No I18N
	    }
	    _fixDimensions() {
	        let opts = this._opts;
	        if (opts.width) {
	            this.element.css('width', opts.width + 'px'); // No I18N
	        }
	        let contentEle = this._contentEle,
	            element = this.element,
	            value,
	            titleEle = element.find('.zpopover__title');
	        if (opts.height && contentEle) { // Computes height for content based on title and content children
	            value = opts.height - (titleEle.length ? titleEle.outerHeight(true) : 0) - (parseInt(contentEle.css('padding-top')) + parseInt(contentEle.css('padding-bottom'))) - (parseInt(element.css('border-top-width')) + parseInt(element.css('border-bottom-width'))); // No I18N
	            contentEle.height(value);
	        }
	        return value;
	    }
	    close(orgEvent) {
	        if (this.element.is(':visible') && this._dispatchEvent('beforeclose', orgEvent)) { // No I18N
	            if (this._opts.delay) {
	                this._closeHandler()
	            } else {
	                ZC.animationHandler({
	                    action: 'close', // No I18N
	                    callback: this._closeHandler.bind(this),
	                    element: this.element,
	                    animation: this._opts.animation,
	                    ctype: this.name
	                });
	            }
	        }
	    }
	    _closeHandler() {
	        ZC.openedPopover = undefined;
	        this._display(true).attr('aria-expanded', 'false'); // No I18N
	        if (this._overlay) {
	            this._overlay.hide();
	            this._forElement.removeClass('zpopover--target'); // No I18N
	        }
	        this._dispatchEvent('close'); // No I18N
	    }
	    _arrowCallback(element, direction) {
	        this.element.removeClass('zpopover--top zpopover--bottom zpopover--left zpopover--right').addClass('zpopover--' + direction); // No I18N
	    }
	    // Need to handle it commonly for all components - Revisit.
	    _positionEle() {
	        let opts = this._opts;
	        if (opts.offset) {
	            this.element.css(opts.offset);
	        } else if (opts.position !== 'page-center') {	// No I18N
	            this._setPosition(...arguments);
	        }
	    }
	    _correctPosition() {
	        let displayType = this._opts.displayType,
	            position = this._opts.position;
	        this._position = (displayType === 'box' ? (position.indexOf('-') > -1 ? position : ((position === 'top' || position === 'bottom') ? position + '-left' : position === 'auto' ? 'bottom-left' : position)) : position === 'auto' ? 'bottom' : position); // No I18N
	    }
	    repositionPopover() {
	        let container = this.element;
	        if (container) {
	            !container.is(':visible') && this._display(); // No I18N
	            this._positionEle();
	        }
	    }
	    _destroy() {
	        clearTimeout(this._openTimeout);
	        clearTimeout(this._openTimer);
	        clearTimeout(this._closeTimer);
	        this._titleBar = this._forElement = this._contentEle = null;
	        this._overlay && this._overlay.remove();
	        this._overlay = undefined;
	    }
		// Revisit Ajax case
		_makeRequest  (){
		    let contentOptions = this._opts.content || {},
		        baseObj = this,
		        _opts = this._tmpOpts;
		    _opts.progressIndicator = ZC._getIconInfo({
		        defaultIconClassName: 'zpopover__icon h-loading', // No I18N
		        iconClassName: _opts.progressIndicatorIconClassName,
		        SVGIconId: _opts.progressIndicatorSVGIconId,
		        defaultSVGIconId: 'zc__svg--loader zpopover__svg zpopover__loader zeffects--rotate' // No I18N
		    });
		    this._updData('zpopover--loader', 'container'); // No I18N
		    $.ajax({
		        dataType: contentOptions.dataType,
		        type: contentOptions.type,
		        URL: contentOptions.URL,
		        success(response){
		            baseObj._ajaxComplete(true, response);
		            baseObj._dispatchEvent('contentload'); // No I18N
		        },
		        error(){
		            baseObj._ajaxComplete(false);
		        }
		    });
		}
		_ajaxComplete  (isSuccess, response){
		    let content = this._opts.content,
		        functionName = isSuccess ? 'success' : 'fail'; // No I18N
		    this._content = typeof content[functionName] === 'function' ? content[functionName](response) : response; // No I18N
		    this._contentEle.append(this._opts.isContentHTMLEncoded ? this._content : ZC.encodeHTML(this._content));
		    $('#zpopover--loader').remove();
		    this._fixDimensions();
		    this._positionEle();
		}
		_handleClose  (updateConfig = true, initEvent) {
		    let closeEle = this.element.find('.zpopover__close')
		    if (updateConfig) {
		        let opts = this._opts;
		        this._data.closeButton = {
		            title: opts.closeButtonLabel || this._getI18NText('close'), // No I18N
		            className: 'zpopover__close', // No I18N
		            defaultIconClassName: 'zpopover__icon', // No I18N
		            iconClassName: opts.closeIconClassName,
		            SVGIconId: opts.closeSVGIconId,
		            templateRender: true,
		            mainElement: closeEle[0],
		            defaultSVGIconId: 'zc__svg--close zbutton__svg', // No I18N
		            customAttributes: {
		                tabindex: -1
		            }
		        };
		    }
		    if (initEvent) {
		        closeEle.on('click.' + this.name, (orgEvent) => { // No I18N
		            this.close(orgEvent)
		        });
		    }
		}
		_handleDrag  (isDetachable) {
		    let element = this.element,
		        opts = this._opts;
		    let titleBar = this.element.find('.zpopover__title');
		    if (isDetachable) {
		        !element.data('zdraggable') && ZC.draggable(element, { // No I18N
		            handle: titleBar,
		            container: 'window', // No I18N
		            cursor: 'default', // No I18N
		            start: this._onDragStart.bind(this),
		            drag: this._onDrag.bind(this),
		            end: this._onDragEnd.bind(this)
		        });
		    } else {
		        ZC.draggable(element).destroy();
		        titleBar.removeClass(this._data.headingClassName);
		        this._dragged = this._dragStart = this._dragEnd = false;
		    }
		    this._data.closeButton = this._dragEnd || opts.closeButton || opts.type === 'modal'; // No I18N
		    this._data.callout = opts.displayType === 'callout'; // No I18N
		}
		_onDragEnd  () {
		    this._dragEnd = true;
		    if (this._dragStart && this._dragged) {
		        this._data.headingClassName = ''; // No I18N
		        this._setTitleBar(this._data.closeButton = true);
		        ZC.unBindDocumentEvents(this.element);
		    }
		    this._fixDimensions();
		    if (this._dragged) {
		        this._dragged = undefined;
		        this._dispatchEvent('dragend'); // No I18N
		    }
		}
		_onDrag  () {
		    this._dragged = true;
		    this._dispatchEvent('drag'); // No I18N
		}
		_onDragStart  () {
		    this._data.closeButton = (this._opts.closeButton || this._opts.type === 'modal' || this._dragEnd) && !(this._data.headingClassName) ? this._data.closeButton : false; // No I18N
		    this._dragEnd = false;
		    this._data.callout = false;
		    this._render();
		    this._dragStart = true;
		    this._dispatchEvent('dragstart'); // No I18N
		}
		_createOverlay  () {
		    this._overlay = undefined;
		    $('body').find('.zpopover--overley').remove();
		    if (this._opts.type === 'modal') {
		        this._overlay = $("<div class='zpopover--overley' tabindex='1'></div>").appendTo('body').hide(); // No I18N
		        this._addEvents({
		            keydown: 'overlay' // No I18N
		        });
		    }
		}
		_overlayHandler  (orgEvent) {
		    if (orgEvent.keyCode === ZC.keyCode.TAB) {
		        orgEvent.preventDefault();
		    }
		}
		_getPosition  (options) {
		    let base = this,
		        arrowElement = this.element.find('.zpopover__pointer'), // No I18N
		        arrowPointer;
		    arrowPointer = arrowElement.length ? arrowElement : false;
		    if (ZC.Position) {
		        return ZC.Position.get(options ? (options.event || options.forElement || this._forElement) : this._forElement, this.element, {
		            rtl: this._opts.rtl,
		            direction: this._position,
		            positionAlterable: this._opts.positionAlterable,
		            arrow: {
		                element: arrowPointer,
		                callback: this._arrowCallback.bind(base),
		                margin: {
		                    left: -1,
		                    top: -1
		                }
		            }
		        });
		    }
		}
		_setPosition  (options) {
		    let opts = this._opts,
		        pointer = this.element.find('.zpopover__pointer'),
		        position = this._getPosition(options),
		        margin = opts.margin;
		    if (position) {
		        if (margin) {
		            position.elementPosition = this._getCorrectedPosition(position.elementPosition);
		            if (pointer.length) {
		                position.arrowPosition = this._getCorrectedPosition(position.arrowPosition, true);
		            }
		        }
		        this.element.css(position.elementPosition);
		        pointer.length && pointer.css(position.arrowPosition);
		    }
		}
		_getCorrectedPosition  (position, isCallout) {
		    let margin = this._opts.margin,
		        offset = isCallout ? -1 : 1,
		        top, left;
		    if (typeof margin === 'number') {	// No I18N
		        top = position.top + offset * margin;
		        left = position.left + offset * margin;
		    } else {
		        let marginLeft = margin.left;
		        left = marginLeft ? position.left + (offset * marginLeft * (this._opts.rtl ? -1 : 1)) : position.left;
		        top = margin.top ? position.top + offset * margin.top : position.top;
		    }
		    position.top = top < 0 ? position.top : top;
		    position.left = left < 0 ? position.left : left;
		    return position;
		}
		_setAttribute  (optionName, value) {
		    let element = this.element;
		    let opts = this._opts,
		        data = this._data,
		        titleOpts = [ 'title', 'closeButton', 'type', 'detachable', 'isTitleHTMLEncoded' ]; // No I18N
		    opts[optionName] = value;
		    if (optionName === 'height') {	// No I18N
		        element.height(opts.height);
		        this._fixDimensions();
		    } else if (optionName === 'width') {	// No I18N
		        element.width(opts.width);
		    } else if (optionName === 'position') {	// No I18N
		        this._correctPosition();
		        if (element.is(':visible')) { // No I18N
		            this._positionEle();
		        }
		    } else if (optionName === 'closeSVGIconId' || optionName === 'closeIconClassName') { // No I18N
		        this._handleClose();
		        this._setBtnValue(this._data.closeButton, this._data.closeButton); // No I18N
		    } else if (optionName === 'content') {	// No I18N
		        this._setContent(value, true);
		        if (this.isCE && element.find('z-pocontent').length) {
		            element.find('z-pocontent').html(this._data.content);
		            return;
		        }
		        this._isAjaxContent = (typeof value === 'object') && !(value instanceof $); // No I18N
		        this._domChanged = true;
		    } else if (titleOpts.indexOf(optionName) > -1) { // No I18N
		        if (optionName === 'title' && this.isCE && element.find('z-potitle').length) { // No I18N
		            return;
		        }
		        if (optionName === 'closeButton' || optionName === 'type') { // No I18N
		            this._data.closeButton = opts.closeButton || value === 'modal'; // No I18N
		            if (optionName === 'type') {
		                this._createOverlay();
		            }
		        }
		        if (optionName === 'detachable') { // No I18N
		            this._handleDrag(value);
		        }
		        this._setTitleBar(true);
		    } else if (optionName === 'displayType') {		// No I18N
		        this._correctPosition();
		        data.callout = value === 'callout'; // No I18N
		        this._domChanged = true;
		    } else if (optionName === 'margin' && element.is(':visible')) {	// No I18N
		        let ele = element[0];
		        let position = this._getCorrectedPosition({
		            left: +ele.offsetLeft,
		            top: +ele.offsetTop
		        });
		        element.css(position);
		        let arrow = this.element.find('.zpopover__pointer');
		        if (arrow.length) {
		            position = this._getCorrectedPosition({
		                left: +(arrow[0].offsetLeft), // No I18N
		                top: +(arrow[0].offsetTop) // No I18N
		            }, true);
		            arrow.css(position);
		        }
		    } else if (optionName === 'closeOnEsc') { // No I18N
		        if (value) {
		            this._bindEvents();
		        } else {
		            element.off('keydown.' + this.name); // No I18N
		        }
		    } else if (optionName === 'forElement') { // No I18N
		        this._forElement = $(value);
		    } else if (optionName === 'closeOnBodyClick') { // No I18N
		        !value && ZC.unBindDocumentEvents(element);
		    } else if (optionName === 'offset') {
		        this.element.css(value);
		    }
		}
		_setTitleBar  (isUpdate) {
		    let tmpOpts = this._opts,
		        data = this._data;
		    data.closeButton && this._handleClose();
		    let title = tmpOpts.title || ''; // No I18N
		    if (this.isCE) {
		        let titleEle = this.element.find('z-potitle');
		        data.titleEle = titleEle.length ? titleEle.addClass('zpopover__text')[0] : undefined;
		    }
		    if (!data.titleEle) {
		        title = title instanceof $ || title[0] === '#' || title[0] === '.' ? $(title)[0] : this._opts.isTitleHTMLEncoded ? title : ZC.encodeHTML(title);
		    }
		    if (typeof title === 'string') { // No I18N
		        data.title = title;
		    } else {
		        data.titleEle = title;
		    }
		    let hasTitle = !!data.titleEle || !!title,
		        headingClassName = ''; // No I18N
		    if (!hasTitle && !data.closeButton && tmpOpts.detachable) {
		        hasTitle = false;
		        headingClassName = 'zpopover__draggablearea'; // No I18N
		    }
		    data.titleBar = hasTitle || data.closeButton || tmpOpts.detachable;
		    data.headingClassName = headingClassName;
		    if (isUpdate) {
		        this._render();
		        this._titleBar = this.element.find('.zpopover__title'); // No I18N
		        this._handleDrag && this._handleDrag(tmpOpts.detachable);
		        // To bind event
		        data.closeButton && this._handleClose(true, true);
		    }
		}
	}
	ZC.registerComponent('ZPopover', ZPopover); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zpopover.Templates; 
template.WCChildren = (data) => ZT.html `${data.titleBar && ZT.html `<div id="zpopover__title" class="zpopover__title ${data.headingClassName}"> ${data.titleEle || data.title && ZT.html `<z-potitle role="heading" class="zpopover__text">${ZT.customHTML(data.title)}</z-potitle>`} ${data.closeButton && ZT.html `<div class="zpopover__action">${ZC.createButton(data.closeButton)}</div>`} </div>`} ${data.contentEle || ZT.html `<z-pocontent class="zpopover__content"> ${data.progressIndicator ? ZT.html `<div class="zpopover__loading" id="zpopover--loader"> <i class="zpopover__icon h-loading"> <svg class="zpopover__svg zpopover__loader zeffects--rotate"> <circle class="circle__track"></circle> <circle class="circle__load"></circle> </svg> </i> </div>` : data.isContentString ? ZT.customHTML(data.content) : data.content} </z-pocontent>`} ${data.callout && ZT.html `<div class="zpopover__pointer"></div>`}` }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zpopover.Templates; 
template.children = (data) => ZT.html `${data.titleBar && ZT.html `<div id="zpopover__title" class="zpopover__title ${data.headingClassName}"> ${data.titleEle || data.title && ZT.html `<div role="heading" class="zpopover__text">${ZT.customHTML(data.title)}</div>`} ${data.closeButton && ZT.html `<div class="zpopover__action">${ZC.createButton(data.closeButton)}</div>`} </div>`} ${data.contentEle || ZT.html `<div class="zpopover__content"> ${data.progressIndicator ? ZT.html `<div class="zpopover__loading" id="zpopover--loader"> <i class="zpopover__icon h-loading"> <svg class="zpopover__svg zpopover__loader zeffects--rotate"> <circle class="circle__track"></circle> <circle class="circle__load"></circle> </svg> </i> </div>` : data.isContentString ? ZT.customHTML(data.content) : data.content} </div>`} ${data.callout && ZT.html `<div class="zpopover__pointer"></div>`}` }(ZComponents)); 
(function(ZC, $){
	class ZPanel  extends ZC.CoreComponent{
			get name(){
				return "zpanel";
			}
	    get attrs() {
	        return {
	            // panel options were added temporarily.
	            heading: null, // No I18N
	            content: null, // No I18N
	            collapseIconClass: null, // No I18N
	            collapseSVGIconId: null, // No I18N
	            collapseText: null, // No I18N
	            expandIconClass: null, // No I18N
	            expandSVGIconId: null, // No I18N
	            expandText: null, // No I18N
	            isHeadingHTMLEncoded: false, // No I18N
	            isContentHTMLEncoded: false, // No I18N
	            zclassName: '', // No I18N
	            iconPosition: 'left', // No I18N
	            sortable: false, // No I18N
	            activeClass: 'is-selected', // No I18N
	            isActive: false, // No I18N
	            disabled: false, // No I18N
	            expandIconLabel: null, // No I18N
	            collapseIconLabel: null, // No I18N
	            display: 'block' // No I18N
	        }
	    }
	    get props() {
	        return {
	            collapseIconClassName: null, // No I18N
	            expandIconClassName: null, // No I18N
	            collapsedPanelsIndex: [], // No I18N
	            animation: null,
	            customAttributes: {}, // No I18N
	            labels: { // No I18N
	                expandIcon: 'Collapse', // No I18N
	                collapseIcon: 'Expand' // No I18N
	            }
	        }
	    }
	    get EVENTS() {
	        return [ 'beforeexpand', 'beforecollapse', 'expand', 'collapse' ]; // No I18N
	    }
	    _init(panel, options) {
	        if (!options.toggleButton) {
	            options.toggleOnHeaderClick = true;
	        }
	        let tagName = panel[0].tagName;
	        let isCE = tagName === 'Z-ACCITEM' || tagName === 'Z-COLLAPSIBLEPANEL';  // No I18N
	        if (isCE) {
	            let panelPar = panel.parent(),
	                containerOpts = ZC._getOpts(panelPar);
	            /* containerOpts is empty since panel's parent element is not registered yet. */
	            if (!containerOpts.length && options.isCE) {
	                let eleAttrs = panelPar[0].attributes,
	                    attr;
	                for (let i = 0; i < eleAttrs.length; i++) {
	                    attr = eleAttrs[i];
	                    containerOpts[ZC._getCamelCaseStr(attr.name)] = attr.value;
	                }
	            }
	            for (let optName in options) {
	                if (containerOpts[optName]) {
	                    options[optName] = containerOpts[optName];
	                }
	            }
	        }
	        this._buildPanel(panel, options);
	    }
	    _postRender(panel, options) {
	        let _CLASSES = this._CLASSES;
	        let headerClassName = '',
	            panelClassName = _CLASSES.panel; // No I18N
	        if (options.iconPosition === 'right') {
	            headerClassName += ' ' + _CLASSES.buttonPosition; // No I18N
	        }
	        if (options.showToggleButtonOnHover) {
	            headerClassName += ' ' + _CLASSES.toggleButtonOnHover; // No I18N
	        }
	        if (options.isActive && !options.disabled && !this._parent) { // parent check added to avoid is-selected added to accordion items since only one item has to be made visible there.
	            panelClassName += ' is-selected'; // No I18N
	        }
	        if (headerClassName !== '') {
	            this._getHeader().addClass(headerClassName);
	        }
	        this._data.className += ' ' + panelClassName; // No I18N
	        let cHght = options.contentHeight;
	        if (cHght) {
	            this._getContent()[0].style.height = cHght + (typeof cHght === 'string' ? '' : 'px'); // No I18N
	        }
	    }
	    _bindEvents() {
	        this._handleEvents(this._opts.expandOn);
	        //When a panel is disabled, it shouldnt be active.
	        if (this._opts.disabled) {
	            this._disable(undefined, undefined, true);
	        } else if (!this._opts.isActive) {
	            this.collapsePanel({}, false, undefined, true);
	        }
	    }
	    _buildPanel(panel, options) {
	        this._createContent(panel, options);
	        this._createHeader(panel, options);
	        if (options.display === 'none') { // No I18N
	            this._display(true, panel);
	        }
	        if (options.sortable) {
	            this._setSortable();
	        }
	    }
	    _createHeader(panel, options) {
	        let headingDOM = panel.children(this._SELECTORS.header);
	        if (options.isCE || headingDOM.length > 1 || headingDOM[0].tagName.indexOf("HEADING")) { //No I18N 
	            options.headingDOM = headingDOM[0];
	            $(headingDOM[0]).addClass(this._CLASSES.heading);
	        } else {
	            let heading = options.heading || '';
	            options.heading = options.isHeadingHTMLEncoded ? heading : ZC.encodeHTML(heading);
	        }
	    }
	    _getHeader() {
	        return this.element.children('.' + this._CLASSES.header); // No I18N
	    }
	    _getContent() {
	        return this.element.children('.' + this._CLASSES.content); // No I18N
	    }
	    _getToggleBtn() {
	        return this._getHeader().children('.' + this._CLASSES.togglebutton); // No I18N
	    }
	    _createContent(panel, options) {
	        let contentDOM = panel.children(this._SELECTORS.content);
	        if (!options.isCE) {
	            contentDOM = contentDOM.length > 1 ? $(contentDOM[1]) : contentDOM;
	        }
	        if (contentDOM && contentDOM.length) {
	            contentDOM.addClass(this._CLASSES.content);
	            options.contentDOM = contentDOM[0];
	        } else {
	            let contentObj = options.content || '';
	            if (typeof contentObj === 'object') { // No I18N
	                this._remoteContent();
	            } else {
	                contentDOM = contentObj.indexOf('#') === 0 ? $(contentObj).html() : contentObj; // No I18N
	                options.content = options.isContentHTMLEncoded ? contentDOM : ZC.encodeHTML(contentDOM);
	            }
	        }
	    }
	    _disable(state, ele, onInit) {
	        let panel = this.element,
	            disabled = this._opts.disabled;
	        if (disabled) {
	            this.collapsePanel({}, !onInit, undefined, onInit);
	        }
	        super._disable(disabled, panel);
	        this._handleIcon && this._handleIcon(true);
	    }
	    _openHandler(panel, state, event, doNotTriggerEvent) {
	        panel.attr('aria-expanded', (state === 'expand')); // No I18N
	        this._opts.contentHeight && this._setHeight();
	        !doNotTriggerEvent && this._dispatchEvent(state, event, {
	            panel: panel
	        });
	    }
	    expandPanel(event, doNotTriggerEvent, callback) {
	        this._open('expand', event, doNotTriggerEvent, callback); // No I18N
	    }
	    collapsePanel(event, doNotTriggerEvent, callback, onInit) {
	        this._open('collapse', event, doNotTriggerEvent, callback, onInit); // No I18N
	    }
	    _open(state, event, doNotTriggerEvent, callback, onInit) {
	        // panel = panel ? $(panel) : this.element;
	        let panel = this.element,
	            _opts = this._opts,
	            isActive = (panel.hasClass(_opts.activeClass)),
	            currentState = isActive || state === 'collapse' ? 'expand' : 'collapse'; // No I18N
	        if (state === null) {
	            state = isActive ? 'collapse' : 'expand'; // No I18N
	        }
	        if (doNotTriggerEvent || currentState !== state) {
	            if (doNotTriggerEvent || this._dispatchEvent('before' + state, event, { // No I18N
	                panel: panel
	            })) { // No I18N
	                let contentDOM = panel.children('.' + this._CLASSES.content); // No I18N
	                contentDOM.finish ? contentDOM.finish() : contentDOM.stop(true, true),
	                isActive = (state === 'expand'); // No I18N
	                if (ZC.animationHandler && _opts.animation) {
	                    this._animationHandler(contentDOM, isActive, panel, state, event);
	                } else if (onInit && !isActive) { // collapsing animation is removed for the initial render.
	                    contentDOM.hide();
	                    this._openHandler(panel, state, event);
	                } else {
	                    contentDOM[isActive ? 'slideDown' : 'slideUp'](300);    // No I18N
	                    setTimeout(() => { // No I18N
	                        // element might be destroyed inbetween. Thus this.element check added.
	                        this.element && this._openHandler(panel, state, event);
	                    },300);
	                }
	                this._updateClass(this._opts.activeClass, !isActive); // No I18N
	                _opts.isActive = isActive;
	                this._handleIcon && this._handleIcon(true);
	            }
	        }
	    }
	    _handleEvents(value) {
	        let componentName = '.' + this.name, // No I18N
	            panel = this.element,
	            dCls = 'is-disabled', // No I18N
	            header = this._getHeader(),
	            toggleOnHeaderClick = this._opts.toggleOnHeaderClick,
	            togglebutton = this._getToggleBtn(null, header);
	        this._updateClass(this._CLASSES.toggleableheader, !toggleOnHeaderClick, header);
	        header.attr('tabindex', (toggleOnHeaderClick ? 0 : -1)); // No I18N
	        togglebutton.attr('tabindex', (toggleOnHeaderClick ? -1 : 0)); // No I18N
	        togglebutton.off(componentName);
	        header.off(componentName);
	        let toggleElement = toggleOnHeaderClick ? header : togglebutton;
	        if (value === 'mouseover') { // No I18N
	            toggleElement.on('mouseover' + componentName, (event) => { // No I18N
	                if (!panel.hasClass(dCls)) {
	                    window.clearTimeout(this._timer);
	                    this._timer = window.setTimeout(() => {
	                        window.clearTimeout(this._timer);
	                        this._open(null, event);
	                    }, this._opts.mouseOverDelay);
	                }
	            }).on('mouseleave' + componentName, () => {
	                if (!panel.hasClass(dCls)) {
	                    this._timer && window.clearTimeout(this._timer);
	                }
	            });
	        } else {
	            toggleElement.on('click' + componentName + ' keydown' + componentName, (event) => { // No I18N
	                let keyCodes = ZC.keyCode,
	                    pressedKey = event.keyCode,
	                    isUP = (pressedKey === keyCodes.UP),
	                    isDown = (pressedKey === keyCodes.DOWN),
	                    isSubmit = (pressedKey === keyCodes.ENTER || pressedKey === keyCodes.SPACE),
	                    action = ''; // No I18N
	                if (event.type === 'click' || isSubmit) { // No I18N
	                    action = null;
	                } else if (pressedKey === keyCodes.RIGHT || isUP) {
	                    action = 'expand'; // No I18N
	                } else if (pressedKey === keyCodes.LEFT || isDown) {
	                    action = 'collapse'; // No I18N
	                }
	                if (action !== '' && !panel.hasClass(dCls)) { // No I18N
	                    if (this._isGroup && this._goto) {
	                        this._goto(action, event);
	                    } else {
	                        this._open(action, event);
	                    }
	                }
	                if (isSubmit) {
	                    event.stopPropagation();
	                    event.preventDefault();
	                }
	            });
	        }
	        this._handleFocus(toggleElement);
	    }
		_animationHandler  (contentDOM, isActive, panel, state, event) {
		    ZC.animationHandler({
		        'default': 'slide', // No I18N
		        action: (isActive ? 'show' : 'hide'), // No I18N
		        animation: this._opts.animation,
		        callback: this._openHandler.bind(this, panel, state, event),
		        element: contentDOM,
		        ctype: this.name
		    });
		}
		_destroy  (updateView){
		    let panel = this.element,
		        _CLASSES = this._CLASSES,
		        contentDOM = panel.children('.' + _CLASSES.content); // No I18N
		    contentDOM.finish ? contentDOM.finish() : contentDOM.stop(true, true);
		    panel.removeClass(_CLASSES.panel + ' is-selected').removeAttr('aria-expanded aria-disabled'); // No I18N
		    this._getHeader().removeClass(_CLASSES.header + ' ' + _CLASSES.toggleableheader + ' ' + _CLASSES.buttonPosition); // No I18N
		    contentDOM.removeClass(_CLASSES.content); // No I18N
		}
		enable  () {
		    this._opts.disabled = false;
		    this._disable();
		}
		disable  (disable) {
		    this._opts.disabled = disable || true;
		    this._disable();
		}
		_remoteContent  (updateView){
		    if (!options.lazyLoadContent) {
		        contentObj.cache = contentObj.cache ? contentObj.cache : this._opts.cacheContent;
		        contentObj.sourceURL = contentObj.url;
		        let thisObj = this;
		        ZC.AJAX.transport(contentObj, function(data) {
		            options.content = data;
		            thisObj._render();
		        });
		    }
		}
		_setAttribute  (optionName, value) {
		    this._handleAttribute(this.element, optionName, value);
		    this._opts[optionName] = value;
		}
		_handleAttribute  (panel, optionName, value) {
		    let _CLASSES = this._CLASSES,
		        data = this._opts;
		    data[optionName] = value;
		    if ([ 'collapseIconClassName', 'collapseIconClass', 'expandIconClassName', 'expandIconClass', 'collapseSVGIconId', 'expandSVGIconId', 'expandText', 'collapseText', 'toggleButton' ].indexOf(optionName) >= 0) { // No I18N
		        this._handleIcon(true);
		        if (data.expandText && data.collapseText) {
		            this._setAttribute('iconPosition', 'right'); // No I18N
		        }
		        if (optionName === 'toggleButton' && value !== true) {
		            this._setAttribute('toggleOnHeaderClick', true); // No I18N
		        }
		    } else {
		        switch (optionName) {
		            case 'iconPosition':
		                data.toggleButtonPosition = value;
		                this._updateClass(_CLASSES.buttonPosition, value === 'left', this._getHeader()); // No I18N
		                break;
		            case 'showToggleButtonOnHover':
		                this._setAttribute('iconPosition', value ? 'right' : data.toggleButtonPosition); // No I18N
		                this._updateClass(_CLASSES.toggleButtonOnHover, !value, this._getHeader());
		                break;
		            case 'toggleOnHeaderClick':
		            case 'expandOn':
		                this._handleEvents(value);
		                break;
		            case 'contentHeight':
		                this._setHeight();
		                break;
		            case 'sortable':
		                this._setSortable(true);
		                break;
		            case 'display':
		                this._display((value === 'none'), panel); // No I18N
		                break;
		            case 'isActive':
		                value ? this.expandPanel() : this.collapsePanel();
		                break;
		            case 'heading':
		                this._createHeader(panel, data);
		                break;
		            case 'content':
		                this._createContent(panel, data);
		                break;
		        }
		    }
		    return data;
		}
		_setSortable  (updateView){
		    let _opts = this._opts,
		        sortable = undefined;
		    if(_opts.sortable){
		        let defaultIconClass = this._CLASSES.grippy,
		            iconClass = (_opts.sortableIconClass || _opts.sortableIconClassName);
		        sortable = ZC._getIconInfo(iconClass, _opts.sortableSVGIconId, "zc__svg--grippy", defaultIconClass);    // No I18N
		        let iconDOM = this.element.find("."+defaultIconClass);
		        if(iconDOM.length){
		            sortable.mainElement = iconDOM;
		        }
		    }
		    this._data.sortable = sortable;
		    if(updateView){
		        this._render();
		    }
		}
	}
	ZC.registerComponent('ZPanel', ZPanel); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
	class ZCollapsiblePanel extends ZC.ZPanel {
			get name(){
				return "zcollapsiblepanel";
			}
	    get attrs() {
	        return {
	            toggleButton: true, // No I18N
	            toggleButtonPosition: 'left', // No I18N
	            toggleOn: 'click', // No I18N
	            isActive: true, // No I18N
	            toggleOnHeaderClick: false, // No I18N
	            showToggleButtonOnHover: false, // No I18N
	            mouseOverDelay: 200 // No I18N
	        }
	    }
	    get EVENTS() {
	        return [ 'beforepanelexpand', 'beforepanelcollapse', 'panelexpand', 'panelcollapse' ]; // No I18N
	    }
	    get CLASSES() {
	        return {
	            panel: 'zcollapsiblepanel', // No I18N
	            header: 'zcollapsiblepanel__header', // No I18N
	            toggleableheader: 'zcollapsiblepanel--toggleableheader', // No I18N
	            heading: 'zcollapsiblepanel__heading', // No I18N
	            content: 'zcollapsiblepanel__content', // No I18N
	            togglebutton: 'zcollapsiblepanel__togglebutton', // No I18N
	            toggleicon: 'zcollapsiblepanel__icon', // No I18N
	            toggleButtonOnHover: 'zcollapsiblepanel__togglebutton--onhover', // No I18N
	            togglesvg: 'zcollapsiblepanel__toggleicon', // No I18N
	            grippy: 'zcollapsiblepanel__grippy', // No I18N
	            buttonPosition: 'zcollapsiblepanel--buttonright' // No I18N
	        }
	    }
	    get SELECTORS() {
	        return {
	            header: this.isCE ? 'z-cpheading' : 'div', // No I18N
	            content: this.isCE ? 'z-cpcontent' : 'div' // No I18N
	        }
	    }
	    _buildPanel(panel, _opts) {
	        _opts.expandOn = _opts.toggleOn;
	        _opts.iconPosition = _opts.toggleButtonPosition;
	        if (_opts.showToggleButtonOnHover || (_opts.collapseText && _opts.expandText)) {
	            _opts.iconPosition = 'right'; // No I18N
	        }
	        super._buildPanel(panel, _opts);
	        if (_opts.toggleButton) {
	            this._handleIcon();
	        }
	    }
	    _dispatchEvent(eventName, event, _opts) {
	        eventName = 'panel'+eventName; // No I18N
	        return super._dispatchEvent(eventName.replace("panelbefore","beforepanel"), event, _opts); // No I18N
	    }
		_setAttribute  (optionName, value) {
		    let newName = optionName;
		    if (optionName === 'toggleOn') { // No I18N
		        newName = 'expandOn'; // No I18N
		    }
		    if (optionName === 'toggleButtonPosition') { // No I18N
		        newName = 'iconPosition'; // No I18N
		    }
		    this._handleAttribute(this.element, newName, value);
		    this._opts[optionName] = value;
		}
		_handleIcon  (updateView) {
		    let toggleButton,
		        _opts = this._opts,
		        title = '', // No I18N
		        toggleButtonDOM = this._getToggleBtn(),
		        tabindex = _opts.toggleOnHeaderClick ? -1 : 0;
		    if (_opts.toggleButton !== false) {
		        let _CLASSES = this._CLASSES,
		            text = null,
		            className = _CLASSES.togglebutton,
		            collapseText = _opts.collapseText,
		            expandText = _opts.expandText,
		            isActive = _opts.isActive,
		            currentState = isActive ? 'expand' : 'collapse'; // No I18N
		        title = _opts[currentState + 'IconLabel'] || this._getI18NText(currentState + 'Icon'); // No I18N
		        toggleButton = {
		            templateRender: true,
		            disabled: _opts.disabled,
		            isCE: _opts.isCE,
		            defaultIconClassName: _CLASSES.toggleicon,
		            iconClassName: _opts[currentState + 'IconClass'] || _opts[currentState + 'IconClassName'], // No I18N
		            defaultSVGIconId: 'zc__svg--arrow ' + _CLASSES.togglesvg, // No I18N
		            SVGIconId: _opts[currentState + 'SVGIconId'], // No I18N
		            customAttributes: {
		                tabindex: tabindex
		            }
		        };
		        if (expandText && collapseText) {
		            className = className + ' zcollapsiblepanel__textbutton'; // No I18N
		            text = isActive ? expandText : collapseText;
		            toggleButton.defaultIconClassName = null;
		            toggleButton.iconClassName = null;
		            toggleButton.SVGIconId = null;
		            toggleButton.defaultSVGIconId = null;
		        } else {
		            toggleButton.title = title;
		        }
		        toggleButton.text = text;
		        toggleButton.className = className;
		    }
		    this._data.toggleButton = toggleButton;
		    if (updateView) {
		        if (toggleButton && toggleButtonDOM.length) {
		            ZC.button(toggleButtonDOM[0]).setAttributes(toggleButton);
		            toggleButtonDOM.attr('title', title); // No I18N
		            toggleButtonDOM.attr('tabindex', tabindex); // No I18N
		        } else {
		            this._render();
		        }
		    }
		}
	}
	ZC.registerComponent('ZCollapsiblePanel', ZC.ZPanel, ZCollapsiblePanel); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zcollapsiblepanel.Templates; 
template.WCChildren = (data) => ZT.html `<div class="zcollapsiblepanel__header"> ${data.toggleButton && ZC.createButton(data.toggleButton)} ${data.headingDOM || ZT.html `<z-cpheading class="zcollapsiblepanel__heading">${data.heading}</z-cpheading>`} </div> ${data.contentDOM || ZT.html `<z-cpcontent class="zcollapsiblepanel__content">${data.content}</z-cpcontent>`}` }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zcollapsiblepanel.Templates; 
template.children = (data) => ZT.html `<div class="zcollapsiblepanel__header"> ${data.toggleButton && ZC.createButton(data.toggleButton)} ${data.headingDOM || ZT.html `<div class="zcollapsiblepanel__heading">${data.heading}</div>`} </div> ${data.contentDOM || ZT.html `<div class="zcollapsiblepanel__content">${data.content}</div>`}` }(ZComponents)); 
(function(ZC, $){
		ZC.createCollapsiblePanels = function(opts = {}) {
		    let panels = opts.panels,
		        len = panels && panels.length,
		        createEle = ZC.createElement,
		        isCE = opts.isCE,
		        container = createEle(opts, 'collapsiblepanels', true), // No I18N
		        item;
		    for (let i = 0; i < len; i++) {
		        item = panels[i];
		        item.isCE = isCE;
		        container.append(createEle(item, 'collapsiblepanel', true)); // No I18N
		    }
		    if (!isCE) {
		        ZC.collapsiblepanels(container, opts);
		    }
		    return container;
		}
	class ZCollapsiblePanels  extends ZC.CoreComponent{
			get name(){
				return "zcollapsiblepanels";
			}
	    get attrs() {
	        return {
	            toggleButton: true, // No I18N
	            toggleButtonPosition: 'left', // No I18N
	            toggleOn: 'click', // No I18N
	            toggleOnHeaderClick: false, // No I18N
	            showToggleButtonOnHover: false, // No I18N
	            collapseIconClass: null, // No I18N
	            collapseSVGIconId: null, // No I18N
	            collapseText: null, // No I18N
	            expandIconClass: null, // No I18N
	            expandSVGIconId: null, // No I18N
	            expandText: null, // No I18N
	            zclassName: '', // No I18N
	            sortable: false, // No I18N
	            activeClass: 'is-selected', // No I18N
	            disabled: false, // No I18N
	            mouseOverDelay: 200, // No I18N
	            expandIconLabel: null, // No I18N
	            collapseIconLabel: null, // No I18N
	            display: 'block', // No I18N
	            collapsedPanelsId: null, // No I18N
	            collapsedPanelsIndex: null // No I18N
	        }
	    }
	    get props() {
	        return {
	            collapseIconClassName: null, // No I18N
	            expandIconClassName: null, // No I18N
	            collapsedPanelsIndex: [], // No I18N
	            animation: 'slide', // No I18N
	            customAttributes: {}, // No I18N
	            labels: { // No I18N
	                expandIcon: 'Collapse', // No I18N
	                collapseIcon: 'Expand' // No I18N
	            },
	            panels: [] // No I18N
	        }
	    }
	    get SELECTORS() {
	        return {
	            panel: this.isCE ? 'z-collapsiblepanel' : 'div' // No I18N
	        }
	    }
	    _init(panel, options) {
	        if (!options.toggleButton) {
	            options.toggleOnHeaderClick = true;
	        }
	        if (options.showToggleButtonOnHover) {
	            options.toggleButtonPosition = 'right'; // No I18N
	        }
	    }
	    _render() {
	        let _opts = this._opts,
	            panels = this.element.children(this._SELECTORS.panel),
	            collapsedPanelsId = _opts.collapsedPanelsId || [],
	            collapsedPanelsIndex = _opts.collapsedPanelsIndex || [];
	        if (!_opts.isCE) {
	            for (let i = 0; i < panels.length; i++) {
	                let panel = $(panels[i]),
	                    data = $.extend({}, _opts, ZC._getOpts(panel)),
	                    isActive = Boolean(!data.disabled && data.isActive);
	                if (collapsedPanelsId.indexOf('#' + panel.id) > 0 || collapsedPanelsIndex.indexOf($(panel).index()) > 0) {
	                    isActive = false;
	                }
	                data.isActive = (isActive || true);
	                ZC.collapsiblepanel(panel, data);
	            }
	        }
	        this.element.attr('aria-multiselectable', true); // No I18N
	        this._panels = panels;
	    }
	    _postRender(panel, options) {
	        this._data.className += ' zcollapsiblepanel--group '; // No I18N
	        if (options.disabled) {
	            this._disable(options.disabled);
	        }
	    }
	    _handleOpen(elements, event, canExpand) {
	        let action = canExpand ? 'expand':'collapse';  // No I18N
	        elements = typeof elements === 'string' ? [ elements ] : elements; // No I18N
	        if (elements) {
	            for (let i = 0; i < elements.length; i++) {
	                ZC.collapsiblepanel(elements[i])[action + 'Panel'](event);
	            }
	        }
	    }
	    expandPanel(elements, event) {
	        this._handleOpen(this._getPanel(elements), event, true);
	    }
	    collapsePanel(elements, event) {
	        this._handleOpen(this._getPanel(elements), event);
	    }
	    collapseAllPanels(event) {
	        this._handleOpen(this._panels, event);
	    }
	    expandAllPanels(event) {
	        this._handleOpen(this._panels, event, true);
	    }
	    _getByIndex(expandPanel) {
	        let panels = this._getPanels(expandPanel);
	        panels = panels.map((i, panel) => $(panel).index());
	        return panels;
	    }
	    getCollapsedPanels() {
	        return this._getPanels();
	    }
	    getCollapsedPanelsIndex() {
	        return this._getByIndex();
	    }
	    getExpandedPanels() {
	        return this._getPanels(true)
	    }
	    getExpandedPanelsIndex() {
	        return this._getByIndex(true);
	    }
	    _getPanels(selectExpanded) {
	        let _CLASSES = this._CLASSES,
	            panelClass = '.' + _CLASSES.panel,
	            activeClass = '.' + _CLASSES.activeClass;
	        panelClass += selectExpanded ? '.' + activeClass : ':not(.' + activeClass + ')'; // No I18N
	        return this._getPanel(panelClass);
	    }
	    _getPanel(panel) {
	        let selector = panel;
	        if (typeof panel === 'number') { // No I18N
	            selector = this._SELECTORS.panel + ':eq(' + panel + ')'; // No I18N
	        }
	        return this.element.children(selector);
	    }
		addPanel  (panelObject){
		    if(panelObject instanceof Array){ 
		        let len = panelObject.length;
		        for(let i = 0; i < len; i++){
		            this._addPanel(panelObject[i]);
		        }
		    }
		    else{
		        this._addPanel(panelObject);
		    }
		    this._panels = this.element.children(this._CLASSES.panel);
		}
		_addPanel  (panelObject){
		    if(itemObject instanceof $ || itemObject.nodeType === 1){
		        ZC.collapsiblepanel(itemObject);
		    }
		    else{
		        let appendTo = this.element,
		            itemsLength = this._panels.length,
		            itemIndex = parseInt(itemObject.index) ;
		        if(itemsLength && (itemIndex === 0 || itemIndex < itemsLength)){
		            itemObject.insertBefore = true;
		            appendTo = $(this._panels[itemIndex+1]);
		        }
		        itemObject.appendTo = appendTo;
		        ZC.createCollapsiblePanel(accordionItem,callback);
		    }
		    if(callback){
		        callback(accordionItem, itemObject);
		    }
		    return accordionItem;
		}
		removePanel  (panels){
		    if(panels instanceof Array){ 
		        // removing multiple panels
		        let len = panels.length;
		        for(let i = 0; i < len; i++){
		            this._removePanel(panels[i]);
		        }
		    }else{ // removing single panel.
		        this._removePanel(panels);
		    }
		    this._panels = this.element.children(this._CLASSES.panel);
		}
		_removePanel  (panel){
		    if(typeof panel === "number"){ // No I18N
		        panel = this._panels[panel-1]; 
		    }
		    else if(typeof panel === "string"){  // No I18N
		        panel = this.element.children("#"+panel.replace("#",""));   // No I18N
		    }
		    ZC.collapsiblepanel(panel).destroy();
		    panel.remove();
		}
		_destroy  (enable) {
		    /*if(this._opts.sortable){
		        this._makeSortable();
		    } */
		    let _panels = this._panels, 
		        length = _panels.length;
		    if (!this.isCE) {
		        for (let i = 0; i < length; i++) {
		            ZC.collapsiblepanel($(_panels[i])).destroy();
		        }
		    }
		    this._panels = undefined;
		    this.element.removeAttr('aria-multiselectable').removeClass('zcollapsiblepanel--group'); // No I18N
		}
		enablePanel  (panel) {
		    this._disablePanel(panel, false);
		}
		_disablePanel  (panel, disable) {
		    ZC.collapsiblepanel(this._getPanel(panel)).disable(disable);
		}
		disablePanel  (panel) {
		    this._disablePanel(panel, true);
		}
		_handlePanel  (panel, optionName, value) {
		    panel = $(panel);
		    if (panel.length) {
		        ZC.collapsiblepanel(panel).setAttribute(optionName, value);
		    }
		}
		_setAttribute  (optName, value) {
		    let _panels = this._panels,
		        len = _panels.length,
		        opts = this._opts,
		        i;
		    if (optName === 'expandedPanelsIndex' || optName === 'expandedPanelsId' || optName === 'collapsedPanelsIndex' || optName === 'collapsedPanelsId') { // No I18N
		        this[optName.indexOf('collapsed') !== -1 ? 'collapsePanel' : 'expandPanel'](this._getPanels(value)); // No I18N
		    } else if (optName === 'rtl') { // No I18N
		        this._updateClass('zh-rtl', !value, this._panels); // No I18N
		    } else if (optName !== 'zclassName') { // No I18N{
		        for (i = 0; i < len; i++) {
		            this._handlePanel(_panels[i], optName, value);
		        }
		    }
		    opts[optName] = value;
		    if (optName === 'toggleButton' && !value) { // No I18N
		        opts.toggleOnHeaderClick = true;
		    } else if (optName === 'expandText' || optName === 'collapseText') { // No I18N
		        opts.iconPosition = 'right'; // No I18N
		    }
		}
		setPanelAttributes  (panel, optionName, value) {
		    this._handlePanel(this._getPanel(panel), optionName, value);
		}
		setPanelAttribute  (panel, optionName, value) {
		    this._handlePanel(this._getPanel(panel), optionName, value);
		}
	}
	ZC.registerComponent('ZCollapsiblePanels', ZCollapsiblePanels); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zcollapsiblepanels.Templates; 
template.WCChildren = (data) => ZT.html `${data.panels && data.panels.map((panel) => ZT.html `${ZC.createCollapsiblePanel(panel)}`)}` }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zcollapsiblepanels.Templates; 
template.children = (data) => ZT.html `${data.panels && data.panels.map((panel) => ZT.html `${ZC.createCollapsiblePanel(panel)}`)}` }(ZComponents)); 
(function(ZC, $){
	class ZAccItem extends ZC.ZPanel {
			get name(){
				return "zaccitem";
			}
	    get attrs() {
	        return {
	            headerContentType: 'icon-heading', // No I18N
	            expandOn: 'click', // No I18N
	            iconPosition: 'left', // No I18N
	            mouseOverDelay: 200 // No I18N
	        }
	    }
	    get CLASSES() {
	        return {
	            panel: 'zaccordionpanel', // No I18N
	            header: 'zaccordionpanel__header', // No I18N
	            toggleableheader: 'zaccordion--expandonhover', // No I18N
	            heading: 'zaccordionpanel__heading', // No I18N
	            content: 'zaccordionpanel__content', // No I18N
	            icon: 'zaccordionpanel__icon', // No I18N
	            togglebutton: 'zaccordionpanel__icon', // No I18N
	            grippy: 'zaccordionpanel__grippy', // No I18N
	            buttonPosition: 'zaccordion--iconright' // No I18N
	        }
	    }
	    get SELECTORS() {
	        return {
	            header: this.isCE ? 'z-accitemheading' : 'div', // No I18N
	            content: this.isCE ? 'z-accitemcontent' : 'div' // No I18N
	        }
	    }
	    _buildPanel(panel, options) {
	        super._buildPanel(panel, options);
	        panel.find('.' + this._CLASSES.content).on('scroll.' + this.name, (event) => { // No I18N
	            // scrolling the content produces causes the parent element to scroll. So preventing here.
	            event.stopPropagation();
	        });
	        if (options.headerContentType !== 'heading') { // No I18N
	            this._handleIcon();
	        }
	        this._isGroup = true;
	        this._parent = panel.parent();
	    }
	    _setHeight() {
	        let _CLASSES = this._CLASSES,
	            contentHeight = this._opts.contentHeight,
	            zaccordion = this._parent;
	        if (contentHeight && zaccordion.attr('height') !== 'auto') {
	            let contentDOM = this.element.children('.' + _CLASSES.content),
	                allPanels = zaccordion.children('.' + _CLASSES.panel);
	            let collapsedPanelHeight = this._getHeader().outerHeight(true),
	                // 1px because last item doesn't contain border.
	                // computed = this.element.outerHeight() - (2 * parseInt(this.element.css("border-top-width"))) - (collapsedPanelHeight * this.element.find(".zaccordionpanel").length) + 1;    // No I18N
	                computed = zaccordion.outerHeight() - 3 - (collapsedPanelHeight * allPanels.length);
	            // 3 pixel: 2 * parseInt(window.getComputedStyle(this.element.get(0), ":before").borderBottom)) + 1px bottom border width of selected accordion panel;
	            contentDOM.innerHeight(computed); // No I18N
	        }
	    }
	    _setAttribute(optionName, value) {
	        if (optionName === 'headerContentType') { // No I18N
	            this._opts[optionName] = value;
	            this._handleIcon(true);
	        } else {
	            this._handleAttribute(this.element, optionName, value);
	        }
	    }
		_handleIcon  (updateView){
		    let _opts = this._opts,
		        headingIcon = undefined;
		    if(_opts.headerContentType !== "heading"){ // No I18N
		        let isActive = (_opts.isActive || this.element.hasClass(_opts.activeClass)) ? true : false,
		            currentState = isActive ? "expand" : "collapse",    // No I18N
		            defaultIconClass = this._CLASSES.icon,
		            iconClass = _opts[currentState +"IconClass"],
		            iconClassName = _opts[currentState +"IconClassName"],
		            SVGIconId = _opts[currentState +"SVGIconId"];
		        headingIcon = ZC._getIconInfo((iconClass || iconClassName), SVGIconId, "#zc__svg--arrow zaccordionpanel__toggleicon zh-arrowicon", defaultIconClass); // No I18N
		        let iconDOM = this.element.find("."+defaultIconClass);
		        if(iconDOM.length){
		            headingIcon.mainElement = iconDOM;
		        }
		    }
		    this._data.headingIcon = headingIcon;
		    if(updateView){
		        this._render();
		    }
		}
		_goto  (action, event, element = this.element) {
		    let keyCode = ZC.keyCode,
		        gotoKeyIndex = [ keyCode.UP, keyCode.HOME, keyCode.DOWN, keyCode.END, keyCode.ENTER, keyCode.SPACE, keyCode.RIGHT, keyCode.LEFT ].indexOf(event.keyCode);
		    if (gotoKeyIndex > 3 || event.type === 'click') { // No I18N
		        this._open(action, event);
		    } else if (gotoKeyIndex > -1) {
		        let panel, nextIndex,
		            panelClsName = '.' + this._CLASSES.panel, // No I18N
		            pressedUp = gotoKeyIndex <= 1,
		            isModifierKey = (event.altKey || event.ctrlKey || event.metaKey || gotoKeyIndex === 1 || gotoKeyIndex === 3),
		            disSel = panelClsName + ':not(.is-disabled)'; // No I18N
		        if (isModifierKey) {
		            panel = this._parent.children(disSel + (pressedUp ? ':first' : ':last')); 	// No I18N
		        } else {
		            nextIndex = element.index() + (pressedUp ? -1 : 1);
		            panel = this._parent.children(panelClsName + ':eq(' + nextIndex + ')'); // No I18N
		            if (!panel.length) {
		                panel = this._parent.children(panelClsName + ':eq(' + (pressedUp ? this._parent.children(panelClsName).length : 0) + ')'); 	// No I18N
		            }
		            if (panel.is('.is-disabled')) { // disabled item focus handling
		                return this._goto(action, event, panel);
		            }
		        }
		        if (panel && panel.length) {
		            $(panel).children('.zaccordionpanel__header').focus();
		            event.stopPropagation();
		            event.preventDefault();
		        }
		    }
		}
	}
	ZC.registerComponent('ZAccItem', ZC.ZPanel, ZAccItem); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
		ZC.createAccordion = function(elementId, items, options) {
		    if (typeof elementId === 'object') { // No I18N
		        items = elementId.panels;
		        options = elementId;
		        elementId = elementId.id;
		    }
		    if ($(`#${elementId}`).data('zaccordion')) { // No I18N
		        return $(`#${elementId}`);
		    }
		    let accordionEle = ($(`#${elementId}`).length === 0) ? $('<ul></ul>') : $(`#${elementId}`), // No I18N
		        appendedTo = options && options.appendTo ? $(options.appendTo) : $('body');
		    if (options.customAttributes) {
		        accordionEle.attr(options.customAttributes);
		    }
		    if (elementId) {
		        accordionEle.attr('id', elementId); // No I18N
		    }
		    appendedTo.append(accordionEle);
		    options.panels = items;
		    accordionEle.zaccordion(options);
		    return accordionEle;
		}
	class ZAccordion  extends ZC.CoreComponent{
			get name(){
				return "zaccordion";
			}
	    get attrs() {
	        return {
	            activePanelId: null, // No I18N
	            activePanelIndex: 0, // No I18N
	            activeClass: 'is-selected', // No I18N
	            // "className": "", // No I18N
	            iconPosition: 'left', // No I18N
	            zclassName: '', // No I18N
	            collapseIconClass: null, // No I18N
	            collapseSVGIconId: null, // No I18N
	            expandIconClass: null, // No I18N
	            expandOn: 'click', // No I18N
	            expandSVGIconId: null, // No I18N
	            headerContentType: 'icon-heading', // No I18N
	            height: 'auto', // No I18N
	            isContentHTMLEncoded: false, // No I18N
	            isHeadingHTMLEncoded: false, // No I18N
	            lazyLoadContent: true, // No I18N
	            handleKeyboard: true, // No I18N
	            panels: null, // No I18N
	            sortable: false // No I18N
	        }
	    }
	    get props() {
	        return {
	            collapseIconClassName: null, // No I18N
	            expandIconClassName: null, // No I18N
	            animation: null // No I18N
	        }
	    }
	    get EVENTS() {
	        return [ 'beforepanelexpand', 'beforepanelcollapse', 'panelexpand', 'panelcollapse' ]; // No I18N
	    }
	    get SELECTORS() {
	        return {
	            panel: this.isCE ? 'z-accitem' : 'div' // No I18N
	        }
	    }
	    _render() {
	        let _opts = this._opts,
	            activePanel = 0,
	            panel, data, isActive, i, isEle,
	            panels = this.element.children(this._SELECTORS.panel), // No I18N
	            activePanelId = _opts.activePanelId || '', // No I18N
	            activePanelIndex = Number(_opts.activePanelIndex || 0), // No I18N
	            results = (panels.length && panels) || [];
	        if (!panels.length) {
	            panels = _opts.panels;
	        }
	        if (!_opts.isCE) {
	            for (i = 0; i < panels.length; i++) {
	                panel = panels[i];
	                isEle = panel.nodeType === 1;
	                data = $.extend({}, _opts, isEle ? ZC._getOpts(panel) : panel);
	                isActive = Boolean(!data.disabled && data.isActive);
	                delete data.className; // className and zclassName has to be removed since data is extended from _opts.
	                delete data.zclassName;
	                if (isEle) {
	                    ZC.accitem($(panel), data);
	                } else {
	                    results.push(this.addAccordionItem(data, undefined, true));
	                }
	                if (((activePanelId && panel.id && activePanelId === panel.id) || activePanelIndex === i || isActive) && !data.disabled) {
	                    activePanel = i;
	                }
	            }
	        }
	        this.element.addClass(this._data.parentClass + ' zaccordion '); // No I18N
	        if (_opts.height) {
	            this.element.css('height', _opts.height); // No I18N
	        }
	        if (results.length) {
	            this._panels = results;
	            panel = $(results[activePanel || 0]);
	            if (panel.is('.is-disabled')) { // No I18N
	                this.setPanelAttribute(panel, 'disabled', false); // No I18N
	            }
	            if (this.isCE) { // No I18N
	                customElements.whenDefined('z-accitem').then(() => { // No I18N
	                    this._openItem(panel, {}, true);
	                });
	            } else {
	                this._openItem(panel, {}, true);
	            }
	        }
	        if (_opts.sortable) {
	            this._makeSortable(_opts.sortable);
	        }
	        if (_opts.disabled) {
	            this._disable(_opts.disabled);
	        }
	    }
	    _setPanelHeight(panel) {
	        if (this._opts.height !== 'auto') { // No I18N
	            // 1px because last item doesn't contain border.
	            // computed = this.element.outerHeight() - (2 * parseInt(this.element.css("border-top-width"))) - (collapsedPanelHeight * this.element.find(".zaccordionpanel").length) + 1;    // No I18N
	            let computed = this.element.outerHeight() - 3 - (this._panelHeight * this._panels.length); // No I18N
	            panel.find('.zaccordionpanel__content').innerHeight(computed); // No I18N
	        }
	    }
	    _bindEvents() {
	        let panel,
	            element = this.element,
	            componentName = this.name,
	            eventPrefix = this.isCE ? 'z' : 'zaccitem'; // No I18N
	        element.on(eventPrefix + 'beforeexpand.' + componentName, (event) => { // No I18N
	            let eventDetail = event.detail;
	            panel = eventDetail && eventDetail.element;
	            if (element && element.children(panel)) {
	                this._setPanelHeight(panel);
	                this._collapsePanels(panel, event, true);
	                this._onExpand = false;
	                this._dispatchEvent('beforepanelexpand', event, eventDetail);    // No I18N
	                return true;
	            }
	        }).on(eventPrefix + 'expand.' + componentName, (event) => { // No I18N
	            let eventDetail = event.detail;
	            panel = eventDetail && eventDetail.element;
	            if (element && element.children(element)) {
	                this._onExpand = false;
	                this._dispatchEvent('panelexpand', event, eventDetail);    // No I18N
	            }
	        }).on(eventPrefix + 'collapse.' + componentName, (event) => { // No I18N
	            this._dispatchEvent('panelcollapse', event, event.detail);    // No I18N
	        }).on(eventPrefix + 'beforecollapse.' + componentName, (event) => { // No I18N
	            let eventDetail = event.detail;
	            panel = eventDetail && eventDetail.element;
	            if(element && element.children(panel)) {
	                let dispatchBeforePanelCollapse = true;
	                if (!this._onExpand){
	                    let activePanel = this._getActivePanel().first();
	                    if (activePanel && activePanel[0] === panel[0]) {
	                        dispatchBeforePanelCollapse = false;
	                        return false;
	                    }
	                }
	                if(dispatchBeforePanelCollapse){
	                    this._dispatchEvent('beforepanelcollapse', event, eventDetail);    // No I18N
	                }
	            }
	        });
	    }
	    _collapsePanels(element, event, canExpand) {
	        if (canExpand) {
	            let activePanels = this._getActivePanel();
	            if (activePanels.length) {
	                let panel;
	                for (let i = 0; i < activePanels.length; i++) {
	                    panel = $(activePanels[i]);
	                    if (panel[0] !== element[0]) {
	                        this._onExpand = true;
	                        this._closeItem(panel, event);
	                    }
	                }
	            }
	        } else {
	            this._closeItem(element, event);
	        }
	        return true;
	    }
	    _openItem(element, event, fromInit) {
	        if (fromInit) {
	            this._panelHeight = this.element.find('.zaccordionpanel .zaccordionpanel__header').outerHeight(true);
	            this._setPanelHeight(element);
	        }
	        this._opts.activePanelIndex = element.index();
	        this._opts.activePanelId = element[0].id;
	        ZC.accitem(element).expandPanel(event, true);
	    }
	    _closeItem(element, event) {
	        ZC.accitem(element).collapsePanel(event, null);
	    }
	    _getPanel(item) {
	        let selectorType = [ 'number', 'string' ].indexOf(typeof item); // No I18N
	        if (selectorType > -1) {
	            item = this.element.children(selectorType ? item : this._SELECTORS.panel + ':eq(' + item + ')'); // No I18N
	        }
	        return $(item);
	    }
	    _getActivePanel() {
	        return this._getPanel('.' + this._opts.activeClass); // No I18N
	    }
	    expandPanel(item, event) {
	        this._handleOpen(item, event, true);
	    }
	    collapsePanel(item, event) {
	        this._handleOpen(item, event, false);
	        return false;
	    }
	    _handleOpen(item, event, canExpand) {
	        item = this._getPanel(item);
	        if (item.length) {
	            this._collapsePanels(item, event, canExpand);
	            if (canExpand) {
	                this._openItem(item, event);
	            }
	            return true;
	        }
	    }
	    /*
	    collapseAllPanels(event){
	        let items = this._getPanel(this._SELECTORS.panel +":not(.is-disabled)"); // No I18N
	        for(let i = 0; i < items.length; i++){
	            this._handleOpen($(items[i]), event, "collapse"); // No I18N
	        }
	    } */
	    _handlePanel(panel, optionName, value) {
	        panel = $(panel);
	        if (panel.length) {
	            ZC.accitem(panel).setAttribute(optionName, value);
	        }
	    }
	    setPanelAttributes(panel, optionName, value) {
	        this._handlePanel(this._getPanel(panel), optionName, value);
	    }
	    setPanelAttribute(panel, optionName, value) {
	        this._handlePanel(this._getPanel(panel), optionName, value);
	    }
		addCustomTagItem  (item, callback) {
		    this.addAccordionItem(item, callback);
		}
		addAccordionItems  (accordionItemArray, callback) {
		    let items = [],
		        itemsArray = Object.create(accordionItemArray);
		    for (let i = 0; i < itemsArray.length; i++) {
		        items.push(this.addAccordionItem(itemsArray[i], callback));
		    }
		    return items;
		}
		addAccordionItem  (itemObject, callback, isInternal) {
		    let item = itemObject;
		    if (itemObject instanceof $ || itemObject.nodeType === 1) {
		        ZC.accitem(itemObject);
		    } else {
		        let appendTo = this.element,
		            itemsLength = this._panels && this._panels.length,
		            itemIndex = parseInt(itemObject.index);
		        if (itemsLength && (itemIndex === 0 || itemIndex < itemsLength)) {
		            itemObject.insertBefore = true;
		            appendTo = $(this._panels[itemIndex + 1]);
		        }
		        itemObject.appendTo = appendTo;
		        itemObject.isCE = this._opts.isCE;
		        itemObject = $.extend({}, this._opts, itemObject);
		        item = ZC.createAccItem(itemObject, callback);
		    }
		    if (callback) {
		        callback(itemObject, itemObject);
		    }
		    if (!isInternal && itemObject.isActive) {
		        this._openItem(item, {}, true);
		    }
		    return item;
		}
		_destroy  () {
		    let _panels = this._panels,
		        length = _panels.length;
		    if (!this.isCE) {
		        for (let i = 0; i < length; i++) {
		            ZC.accitem($(_panels[i])).destroy();
		        }
		    }
		    if (this._opts.sortable) {
		        this._makeSortable(false);
		    }
		    this._panels = undefined;
		    this.element.removeClass('zaccordion zc-sortable'); // No I18N
		}
		_setAttribute  (optionName, value){
		    let _panels = this._panels,
		        len = _panels.length;
		    if(["headerContentType","expandOn","height","iconPosition","sortable","collapseIconClassName","collapseIconClass","expandIconClassName","expandIconClass","collapseSVGIconId","expandSVGIconId"].indexOf(optionName) >= 0){ // No I18N
		        let panelOptionName = optionName;
		        if(optionName === "expandOn"){
		            this.element[value === "click" ? "removeClass" : "addClass"]("zaccordion--expandonhover"); // No I18N
		        }
		        else if(optionName === "sortable"){
		            this._makeSortable(value);
		        }
		        else if(optionName === "height"){   // No I18N
		            panelOptionName = "contentHeight";  // No I18N
		            this.element[value === "auto" ? "height" : "outerHeight"](value);   // No I18N
		        }
		        for(let i = 0; i < len; i++){
		            this._handlePanel(_panels[i], panelOptionName, value);
		        }
		    }
		    else if(optionName === "activePanelId" || optionName === "activePanelIndex"){   // No I18N
		        this.expandPanel(value);
		    }
		    // Handling updates is not required for expandMode, toggleable and animation options.
		    this._opts[optionName] = value; 
		}
		_makeSortable  (enable) {
		    if (ZC.sortable) {
		        if (enable) {
		            ZC.sortable(this.element, {
		                handle: '.zaccordionpanel__grippy', // No I18N
		                end(event, ui) {
		                    // thisObj._sorting = false;
		                    $(ui.value).closest('.zaccordionpanel').css('cursor', 'initial');
		                },
		                /* drag(){ // Firefox: preventing expanding of sorted item...
		                    thisObj._sorting = true;
		                }, */
		                region: 'parent' // No I18N
		            });
		        } else {
		            ZC.sortable(this.element).destroy();
		        }
		    }
		}
	}
	ZC.registerComponent('ZAccordion', ZAccordion); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zaccitem.Templates, utilities = ZC.Templates.Utilities; 
template.WCChildren = (data) => ZT.html `<div class="zaccordionpanel__header"> ${data.sortable && utilities.WCIcon(data.sortable)} ${data.headingIcon && utilities.WCIcon(data.headingIcon)} ${data.headingDOM || ZT.html `<z-accitemheading class="zaccordionpanel__heading">${ZT.customHTML(data.heading)}</z-accitemheading>`} </div> ${data.contentDOM || ZT.html `<z-accitemcontent class="zaccordionpanel__content">${ZT.customHTML(data.content)}</z-accitemcontent>`}` }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zaccitem.Templates, utilities = ZC.Templates.Utilities; 
template.children = (data) => ZT.html `<div class="zaccordionpanel__header"> ${data.sortable && utilities.icon(data.sortable)} ${data.headingIcon && utilities.icon(data.headingIcon)} ${data.headingDOM || ZT.html `<div class="zaccordionpanel__heading">${ZT.customHTML(data.heading)}</div>`} </div> ${data.contentDOM || ZT.html `<div class="zaccordionpanel__content">${ZT.customHTML(data.content)}</div>`}` }(ZComponents)); 
(function(ZC, $){
	/* eslint-disable no-unused-expressions */
	class ZDialog  extends ZC.CoreComponent{
			get name(){
				return "zdialog";
			}
	    get attrs() {
	        return {
	            buttonsAlignment: 'right', // No I18N
	            closeButton: true, // No I18N
	            closeOnEscKey: true, // No I18N
	            closeSVGIconId: null, // No I18N
	            closeButtonLabel: null, // No I18N
	            closeOnOverlayClick: false, // No I18N
	            content: null, // No I18N
	            draggable: true, // No I18N
	            height: null, // No I18N
	            isContentHTMLEncoded: false, // No I18N
	            isFooterHTMLEncoded: false, // No I18N
	            isTitleHTMLEncoded: false, // No I18N
	            overlayClassName: '', // No I18N
	            maximizable: false, // No I18N
	            maximizeIconClass: null, // No I18N
	            maximizeButtonLabel: null, // No I18N
	            maximizeRestoreIconClass: null, // No I18N
	            maximizeRestoreButtonLabel: null, // No I18N
	            maximizeRestoreSVGIconId: null, // No I18N
	            maximizeSVGIconId: null, // No I18N
	            minimizable: false, // No I18N
	            minimizeIconClass: null, // No I18N
	            minimizeButtonLabel: null, // No I18N
	            minimizeRestoreIconClass: null, // No I18N
	            minimizeRestoreButtonLabel: null, // No I18N
	            minimizeRestoreSVGIconId: null, // No I18N
	            minimizeSVGIconId: null, // No I18N
	            position: 'center', // No I18N
	            restoreIconClass: null, // No I18N
	            restoreSVGIconId: null, // No I18N
	            title: null, // No I18N
	            type: 'modal', // No I18N
	            autoOpen: false, // No I18N
	            width: null, // No I18N
	            defaultActionButton: '.zbutton--primary', // No I18N
	            excludeFocus: null, // No I18N
	            handleFocusNavigation: true, // No I18N
	            submitOnEnter: false // No I18N
	        }
	    }
	    get props() {
	        return {
	            closeIconClassName: null, // No I18N
	            maximizeIconClassName: null, // No I18N
	            minimizeIconClassName: null, // No I18N
	            minimizeRestoreIconClassName: null, // No I18N
	            maximizeRestoreIconClassName: null, // No I18N
	            restoreIconClassName: null, // No I18N
	            animation: false, // No I18N
	            buttons: null, // No I18N
	            footer: '', // No I18N
	            resizable: {}, // No I18N
	            labels: { // No I18N
	                minimize: 'Minimize', // No I18N
	                maximize: 'Maximize', // No I18N
	                minimizeRestore: 'Restore', // No I18N
	                maximizeRestore: 'Restore', // No I18N
	                close: 'Close' // No I18N
	            },
	            commandBar: {}
	        }
	    }
	    get _ALIGNMENTS() {
	        return {
	            right: '', // No I18N
	            left: 'zdialogfooter--invert', // No I18N
	            center: 'zh-center' // No I18N
	        }
	    }
	    get EVENTS() {
	        return ['drag', 'dragstart', 'dragend', 'resize', 'resizestart', 'resizeend', 'minimize', 'maximize', 'close', 'open', 'beforeclose', 'beforeopen', 'restore', 'actionbuttonclick']; // No I18N
	    }
	    _init(element) {
	        let data = this._data,
	            opts = this._opts,
	            content = opts.content || '', // No I18N
	            isCE = this.isCE;
	        this._isComponentInited = false;
	        let excludeSel = data.excludeFocus;
	        data.excludeFocus = (excludeSel ? excludeSel + ',' : '') + ' .zbutton--action'; // No I18N
	        if (isCE) {
	            let title = element.find('z-dialogtitle').addClass('zdialog__title zdialog__text'); // No I18N
	            if (title.length) {
	                data.titleEle = title[0];
	            }
	            data.contentEle = element.find('z-dialogcontent').addClass('zdialog__content')[0]; // No I18N
	            data.actionBar = element.find('z-dialogactionbar').addClass('zdialog__commandbar zdialog__footer')[0]; // No I18N
	        } else if (content && typeof content === 'object') { // No I18N
	            this._fetchAjaxCon(content);
	        } else {
	            this._setContent();
	        }
	        opts.id = this._getID(element); // to use in minimize/maximize creation
	        this._setTitleBarBtns && this._setTitleBarBtns(); // titlebar module func
	        opts.buttons && this._createButtonPanel();
	        opts.footer && this._setFootnote();
	        this._skipParent = true;
	    }
	    _setContent() {
	        let data = this._data,
	            opts = this._opts,
	            content = opts.content;
	        if (content) {
	            data.content = opts.isContentHTMLEncoded ? content : ZC.encodeHTML(content);
	        } else {
	            content = [...this.element[0].childNodes];
	            if (content.length) {
	                data.content = content;
	            }
	        }
	    }
	    _postRender() {
	        this._data.className += ' zdialog'; // No I18N
	        this.element.attr({
	            'aria-modal': this._opts.type === 'modal', // No I18N
	            tabIndex: -1,
	            role: 'dialog' // No I18N
	        });
	        let bodyEle = $(this._opts.appendTo || 'body'), // No I18N
	            parentEle = this.element[0].parentNode;
	        if (parentEle !== bodyEle[0]) {
	            bodyEle.append(this.element); // No I18N
	        }
	    }
	    _postEachRender(ele, data) {
	        let elem = this.element,
	            opts = this._opts,
	            rendered = this._data.rendered;
	        this._content = elem.find('.zdialog__content');
	        this._titleBar = elem.find('.zdialog__titlebar'); // No I18N
	        this._footer = elem.find('.zdialog__footnote'); // No I18N
	        this._actionGroup = elem.find('.zdialog__actiongroup'); // No I18N
	        let resizable = opts.resizable;
	        this._minimizeButton = $('#' + opts.id + 'minimize'); // No I18N
	        this._maximizeButton = $('#' + opts.id + 'maximize'); // No I18N
	        if (resizable && ZC.resizable) {
	            opts.resizable = typeof resizable === 'object' ? resizable : {}; // No I18N
	            this._initResize();
	        }
	        if (rendered && (data.modifiedAttr === 'minimizable' || data.modifiedAttr === 'maximizable' || data.modifiedAttr === 'closeButton') && this._data.titleBarButtons.length) { // No I18N
	            this._handleTBarActions();
	        }
	        if (opts.draggable && ZC.draggable) {
	            this._initDrag();
	        }
	        if (opts.buttons && (!rendered || data.modifiedAttr === 'buttons')) { // No I18N
	            this._setBtnProps();
	        }
	        (opts.minimizable || opts.maximizable) && this._titleBar.off('dblclick.zdialog').on('dblclick.zdialog', this._titleBarClickHandler.bind(this)); // No I18N
	        !rendered && opts.autoOpen && this.open();
	        data.modifiedAttr = undefined;
	    }
	    _findPosition() {
	        let elem = this.element;
	        this.actualPosition = elem.position(); // store the position only when the dialog is in its actual state.
	        this.bottomRightPosition = {
	            bottom: elem[0].style.bottom, // No I18N
	            right: elem[0].style.right // No I18N
	        };
	    }
	    _findHeightWidth() {
	        this.actualWidth = parseFloat(this.element.css('width')); // No I18N
	        this.actualHeight = this._content.height();
	    }
	    open(options) {
	        this._open(options);
	    }
	    close(data) {
	        this._closeDialog({}, data, undefined);
	    }
	    isMinimized() {
	        return this.element.is('.zdialog--minimized'); // No I18N
	    }
	    isMaximized() {
	        return this.element.is('.zdialog--maximized'); // No I18N
	    }
	    refreshContent(setFocus) {
	        /* Method to enable TAB Key Handling for the contents which is dynamically added. */
	        if (this._opts.handleFocusNavigation) {
	            return ZC.FocusHandler.refresh(this.element, this._opts.excludeFocus, setFocus);
	        }
	    }
	    _triggerEvent(ename, event, data = {}) {
	        data.dialog = this.element;
	        return this._dispatchEvent(ename, event, data);
	    }
	    _open(options) {
	        /* If dialog container element has width property set on it, same width will be used.(considering the case that width might be set by performing resize operation) */
	        if (this.isMinimized() || this.isMaximized()) {
	            this._toggleRestore();
	        }
	        let ele = this.element,
	            styleInfo = ele.attr('style'); // No I18N
	        if (!styleInfo || (styleInfo && styleInfo.indexOf('width') === -1)) { // No I18N
	            ele.css({
	                width: this._opts.width || 'auto' // No I18N
	            });
	        }
	        let returnValue = this._triggerEvent('beforeopen'); // No I18N
	        if (returnValue) {
	            let dOpacity = ele.css('opacity'); // No I18N
	            ele.css('opacity', 0); // No I18N
	            this._display(false);
	            if (!this._isComponentInited && ZC.init) {
	                this._isComponentInited = true;
	                ZC.init(ele);
	            }
	            ele.css('opacity', dOpacity); // No I18N
	            this._display(true);
	            if (this._opts.type === 'modal') { // No I18N
	                if (this._overlay) {
	                    this._overlay.show();
	                } else {
	                    this._createOverlay();
	                    this._positionDialog(options);
	                }
	            } else {
	                this._positionDialog(options);
	            }
	            options = options || {};
	            let animation = this._opts.animation || options.animation,
	                base = this;
	            if (animation) {
	                this._animateAction(animation, 'open', function () { // No I18N
	                    base._handleDialogOpen();
	                }, true);
	            } else {
	                this._handleDialogOpen();
	            }
	        }
	    }
	    _handleDialogOpen() {
	        this._display();
	        let zIndex = this._opts.zIndex,
	            element = this.element,
	            componentName = this.name;
	        ZC.zIndex = zIndex ? ZC.zIndex : ZC.zIndex + 1; // setting the zIndex for the dialog
	        element.css({
	            zIndex: zIndex ? parseInt(zIndex) : ZC.zIndex
	        });
	        this._opts.handleFocusNavigation && ZC.FocusHandler.init(element, this._opts.excludeFocus);
	        this._findPosition();
	        this._findHeightWidth();
	        element.attr('aria-expanded', true); // No I18N
	        this._triggerEvent('open', {}, { // No I18N
	            position: this.actualPosition
	        });
	        ZC.activeDialog = element;
	        let doIEHandle = !!(ZC.Browser.isIE && ZC.Browser.getIEVersion() <= 10);
	        ZC.$window.off('resize.' + componentName).on('resize.' + componentName, (event) => { // No I18N
	            if (!this._posModified) {
	                // compute the top and left for the dialog whenever window resize occurs.
	                if (this._opts.position === 'center' && event.originalEvent.type === 'resize' && !this.isMinimized() && !this.isMaximized()) { // No I18N
	                    this._positionDialog();
	                }
	                if (this.isMaximized() && doIEHandle) {
	                    // If dialog is in maximized state and browser is internet explorer, then we have to adjust width and height for content elements since flex-grow is not working there.
	                    this._adjustContentSize();
	                }
	            }
	        });
	    }
	    _closeDialog(event = {}, data, triggerEvent) {
	        // removing the restoring functionality because closing the dialog has fadeOut effect.
	        event = event || {};
	        // Don't close the dialog if beforeClose event returns false
	        let retVal = triggerEvent ? true : this._triggerEvent('beforeclose', event, data); // No I18N
	        if (retVal) {
	            if (this._opts.animation && (!data || data.animation === undefined || data.animation !== false)) {
	                let base = this;
	                this._animateAction(this._opts.animation, 'close', function () {
	                    base._handleDlgClose(event, data, triggerEvent); // hiding the dialog on animation complete function
	                });
	            } else {
	                this._handleDlgClose(event, data, triggerEvent);
	            }
	        }
	    }
	    _handleDlgClose(event, data, triggerEve) {
	        this._display(true); // hiding the dialog
	        let ele = this.element;
	        ele.attr('aria-expanded', false); // No I18N
	        // removing the focus related classes here since dialog close might take up time if dialog close has animation effects.
	        ele.find('.zdialog__commandbar .has-focus').removeClass('has-focus'); // No I18N
	        this.restore(false); // restore event is called here inorder to restore the dialog from minimize/maximize state since on next open, it should open correctly.
	        if (this._opts.type === 'modal' && this._overlay) { // No I18N
	            this._closeModalDlg(event, data, triggerEve);
	        } else if (!triggerEve) {
	            this._triggerEvent('close', event, data); // No I18N
	        }
	        ZC.zIndex = ZC.zIndex > 1000 ? ZC.zIndex - 1 : 1000;
	        if (ZC.activeDialog && ele && ZC.activeDialog[0] === ele[0]) {
	            ZC.activeDialog = undefined;
	        }
	        ZC.$window.off(`resize.${this.name}`);
	    }
	    _bindEvents() {
	        this._addEvents({
	            keydown: 'keydown', // No I18N
	            focus: 'focus' // No I18N
	        });
	        if (this._opts.type === 'modal') { // No I18N
	            this._preventModalDlgClick();
	        }
	        if (this._data.titleBarButtons.length) {
	            this._handleTBarActions();
	        }
	    }
	    _keydownHandler(event) {
	        let activeDlg = ZC.activeDialog,
	            ele = this.element;
	        if (activeDlg && activeDlg[0] !== ele[0]) {
	            ZC.activeDialog = ele;
	        }
	        if (event.keyCode === ZC.keyCode.ESCAPE && this._opts.closeOnEscKey) {
	            let cancelBtn = ele.find('.zdialog__footer .zbutton'); // No I18N
	            cancelBtn = cancelBtn.filter(function (index, item) { // retrieving the cancel button from the set of buttons.
	                if ($(item).data('handleClose')) { // handleClose data will be stored in button construction utility.
	                    return $(item);
	                }
	            });
	            if (cancelBtn.length) {
	                // Pressing Escape should trigger the click event on cancel button.
	                cancelBtn.focus();
	                cancelBtn.trigger('click'); // No I18N
	            } else {
	                this._closeDialog(event);
	            }
	            event.stopPropagation();
	        } else if (event.keyCode === ZC.keyCode.ENTER && (this._opts.submitOnEnter && ele.find('form').length)) {
	            // excludedList: "textarea, label, span, .ztokenfield, .zsuggestfield-element, .zselectbox, .zaccordion, .zcollapsiblepanel, .zbutton--menu"; // No I18N
	            let includedList = '.zbutton:not(.zbutton--menu),input:not(.ztokenfield__textbox):not(.zsuggestfield-element)'; // No I18N
	            // Dialog ENTER will trigger the primary action button click.
	            let target = $(event.target);
	            if (target.closest(includedList).length && !target.closest('.zdialog__commandbar').length) {
	                let primaryBtn = ele.find('.zdialog__footer').find(this._opts.defaultActionButton)[0]; // No I18N
	                if (primaryBtn && target.closest('button')[0] !== primaryBtn) {
	                    $(primaryBtn).focus().trigger('click'); // No I18N
	                    return false;
	                }
	            }
	        }
	    }
	    _focusHandler() {
	        let activeDlg = ZC.activeDialog;
	        if (activeDlg && activeDlg[0] !== this.element[0]) {
	            ZC.activeDialog = this.element;
	        }
	    }
	    _positionDialog(options) {
	        let top = 0,
	            left = 0,
	            ele = this.element,
	            opts = this._opts,
	            content = ele.find('.zdialog__content'), // No I18N
	            isVisible = ele.is(':visible'); // No I18N
	        if (!isVisible) {
	            this._display();
	        }
	        /* fixing the dialog height */
	        if (!this._dimModified && opts.height) {
	            ele.height(opts.height);
	            let dlgHeight = ele.outerHeight(true),
	                contHeight = parseInt(content.height()),
	                padTop = parseInt(content.css('padding-top').split('px')[0]), // No I18N
	                padBottom = parseInt(content.css('padding-bottom').split('px')[0]), // No I18N
	                titleBarHeight = this._titleBar === undefined ? 0 : parseInt(this._titleBar.outerHeight(true)),
	                btnPanel = ele.find('.zdialog__footer'), // No I18N
	                btnPanelHeight = btnPanel.length ? btnPanel.outerHeight(true) : 0,
	                footNote = ele.find('.zdialog__footnote'), // No I18N
	                footNoteHeight = footNote.length ? footNote.outerHeight(true) : 0; // No I18N
	            contHeight = dlgHeight - (padTop + padBottom + titleBarHeight + btnPanelHeight + footNoteHeight + parseInt(ele.css('border-top-width')) + parseInt(ele.css('border-bottom-width')) + parseInt(content.css('margin-top')) + parseInt(content.css('margin-bottom'))); // No I18N
	            content.height(contHeight);
	            ele.css('height', 'auto'); // No I18N
	        }
	        options = options || {};
	        let elemWidth = ele.outerWidth(true),
	            elemHeight = ele.outerHeight(true),
	            winWidth = ZC.windowObject.width,
	            winHeight = ZC.windowObject.height,
	            position = opts.position,
	            hasBottom = false;
	        opts.position = position = options.position || position;
	        // center align the dialog
	        top = (winHeight / 2 - elemHeight / 2) + (opts.type === 'modeless' ? window.pageYOffset : 0); // Adding the scrollY and scrollX values in modeless dialog otherwise it will be aligned to the top
	        left = (winWidth / 2 - elemWidth / 2) + (opts.type === 'modeless' ? window.pageXOffset : 0);
	        let tar = options.target;
	        if (tar) { // display the dialog nearer to target if target is specified.
	            let off = $(tar).offset();
	            top = off.top + $(tar).outerHeight(true);
	            left = off.left;
	        } else if (position === 'golden-mean') { // No I18N
	            let halfWin = winHeight / 2,
	                smallerPart = halfWin - (halfWin / 1.618);
	            top = smallerPart - parseFloat(elemHeight / 2) + window.pageYOffset; // scroll height is added.
	            left = winWidth / 2 + window.pageXOffset - parseFloat(elemWidth / 2); // scroll width is added.
	        } else if (typeof position === 'string' && position !== 'center') { // No I18N
	            let values = position.split(','); // No I18N
	            top = values[1] ? values[1] : top; // Position can also be given as "left,top"
	            left = values[0] ? values[0] : left;
	        }
	        if (typeof position === 'object') { // No I18N
	            // If custom position contains right and bottom values, top-left can be ignored and the given object can be placed as such.
	            if (!position.right && !position.bottom) {
	                top = position.top || top; // position as {left: offsetLeft, top : offsetTop}
	                left = position.left || left;
	            } else {
	                hasBottom = true;
	            }
	        } else {
	            let docObj = ZC.documentObject;
	            // handling the cases where left and top values are out of document boundaries.
	            if (top < 0) { // if top value is negative,then dialog portion is hidden and can't be viewed even by scrolling
	                top = 0;
	            } else if (top >= docObj.height) {
	                top = docObj.height - elemHeight;
	            }
	            if (left < 0) {
	                left = 0;
	            } else if (left > docObj.width) {
	                left = docObj.width - elemWidth;
	            }
	        }
	        if (!isVisible) {
	            this._display(true);
	        }
	        this._hasBottom = hasBottom;
	        let pos = hasBottom ? position : {
	            top: top,
	            left: left
	        };
	        ele.css(pos);
	    }
		_animateAction  (animation, action, callback, showElement) {
		    if (animation[action]) {
		        let effect, duration,
		            animationClass = animation[action].className;
		        if (typeof animation[action] === 'object') { // No I18N
		            effect = animation[action].name;
		            duration = animation[action].duration;
		        }
		        if (animationClass) { // animation properties are given in a class.
		            showElement && this._display();
		            this.element.addClass(animationClass).on(ZC._animationEnd, () => {
		                this.element.removeClass(animationClass); // removing the animation class.
		                callback && callback();
		                callback = undefined;
		            });
		        } else if (typeof effect === 'object') { // No I18N
		            // custom animation properties
		            showElement && this._display();
		            this.element.animate(effect, duration, callback);
		        } else { // predefined effects like slide and fade.
		            this.element[effect](duration, callback);
		        }
		    }
		}
		get _ALIGNMENTS (){
			return	 {
		    left: 'zdialogfooter--invert', // No I18N
		    right: '', // No I18N
		    center: 'zh-center' // No I18N
		}
		 }
  _getAlignCls  (btnAlign) {
		    return this._ALIGNMENTS[btnAlign];
		}
		_closeClickHandler  (event) {
		    this._resetPosition(this.element, true);
		    this._closeDialog(event, {
		        closeButton: true
		    });
		    return event.type !== 'keydown'; // No I18N
		}
		/* eslint-disable no-unused-expressions */
		_createCommandBar  () {
		    this._data.cols = {};
		    this._data.commands = [];
		    let opts = this._opts,
		        columnArray = [],
		        layout = opts.commandBar,
		        buttons = opts.buttons,
		        cols = {},
		        buttonObj, buttonNames,
		        i = 0;
		    layout.leftColumn && (columnArray.push('left'), cols.left = {}); // No I18N
		    layout.centerColumn && (columnArray.push('center'), cols.center = {}); // No I18N
		    layout.rightColumn && (columnArray.push('right'), cols.right = {}); // No I18N
		    let columnName = '',
		        columnConfig,
		        convertedObj;
		    cols.cname = 'zdialog'; // No I18N
		    for (let k = 0; k < columnArray.length; k++) {
		        columnName = columnArray[k];
		        columnConfig = layout[`${columnName}Column`];
		        buttonNames = columnConfig.commands;
		        columnConfig.className && (cols[columnName].className = columnConfig.className);
		        if (buttons) {
		            cols[columnName].buttons = [];
		            for (i = 0; i < buttonNames.length; i++) {
		                // eslint-disable-next-line no-loop-func
		                buttonObj = buttons.find((x) => {
		                    if (x.name === buttonNames[i]) {
		                        return x;
		                    }
		                });
		                if (typeof buttonObj === 'object') { // No I18N
		                    convertedObj = this._createButton(buttonObj);
		                    this._data.commands.push(convertedObj);
		                    cols[columnName].buttons.push(convertedObj);
		                }
		            }
		        }
		    }
		    this._data.cols = cols;
		}
		_destroy  () {
		    let ele = this.element,
		        opts = this._opts,
		        content = this._content;
		    this._closeModalDlg(null, undefined, true);
		    opts.handleFocusNavigation && ZC.FocusHandler.destroy(ele);
		    !this.isCE && $(opts.appendTo || 'body').append(ele.removeClass('zdialog zdialog--minimized zdialog--maximized')); // No I18N
		    let over = this._overlay;
		    if (over && over.length) {
		        over.remove();
		        this._overlay = undefined;
		    }
		    if (opts.title) {
		        ele.attr('title', opts.title); // No I18N
		    }
		    let eSuf = '.' + this.name; // No I18N
		    ele.off(eSuf).css({
		        width: 'auto', // No I18N
		        right: '' // No I18N
		    });
		    opts.resizable && ZC.resizable(ele).destroy();
		    opts.draggable && ZC.draggable(ele).destroy();
		    if (this.isCE) {
		        ele.off(eSuf);
		        ele.find('.zdialog__title').removeClass('zdialog__title');  // No I18N
		        ele.find('.zdialog__content, .zdialog__commandbar, .zdialog__footer, .zdialog__footnote').removeClass('zdialog__content zdialog__commandbar zdialog__footer zdialog__footnote'); // No I18N
		        ele.find('.zdialog__actiongroup, .zresizable__handle').remove(); // No I18N
		        ele.find('.zbutton').off(eSuf + ' .zbutton').removeClass('zbutton zbutton--primary is-disabled'); // No I18N
		    } else {
		        ele.removeAttr('role aria-modal aria-expanded'); // No I18N
		        ele[0].innerHTML = content[0].innerHTML;
		    }
		    this.element = this._footer = this._titleBar = this._content = undefined;
		    this._useParent = true;
		}
		_initDrag  () {
		    let base = this;
		    ZC.draggable(this.element, {
		        ignoreAsHandle: '.zdialog__actiongroup,.zresizable__handle', // No I18N
		        handle: '.zdialog__header', // No I18N
		        region: 'viewport', // No I18N
		        cursor: 'default', // No I18N
		        start: function(event, ui) {
		            base._posModified = true;
		            base._triggerEvent('dragstart', event, ui); // No I18N
		        },
		        end: function(event, ui) {
		            base._triggerEvent('dragend', event, ui); // No I18N
		        },
		        drag: function(event, ui) {
		            base._triggerEvent('drag', event, ui); // No I18N
		        }
		    });
		}
		_createButtonPanel  () {
		    if (ZC.isEmpty(this._opts.commandBar)) {
		        let buttons = this._opts.buttons || [],
		            commands = [],
		            buttonObj,
		            len = buttons.length;
		        for (let i = 0; i < len; i++) {
		            buttonObj = buttons[i];
		            typeof buttonObj === 'object' && commands.push(this._createButton(buttonObj)); // No I18N
		        }
		        this._data.commands = commands;
		    } else {
		        this._createCommandBar();
		    }
		    let btnAlign = this._opts.buttonsAlignment;
		    this._data.alignClassName = btnAlign === 'right' ? '' : this._getAlignCls(btnAlign); // No I18N
		}
		_createButton  (buttonObj) {
		    let btnid = buttonObj.id = buttonObj.id || this._getID(buttonObj, 'dlgbutton'), // No I18N
		        elem = btnid && $('#' + btnid);
		    if(!elem.length){
		        elem = undefined;
		    }
		    buttonObj.templateRender = true;
		    let action = buttonObj.action,
		        isActFunc = typeof action === 'function'; // No I18N
		    buttonObj.click = isActFunc ? action : this._clickHandler.bind(this);
		    buttonObj.mainElement = elem ? elem[0] : null;
		    buttonObj = ZC.ZButton.getBtnProps(buttonObj, elem);
		    if (!isActFunc) {
		        let custAttrs = buttonObj.attrs || {};
		        custAttrs['data-action'] = action; // No I18N
		        buttonObj.attrs = custAttrs;
		    }
		    return buttonObj;
		}
		_clickHandler  (event) {
		    let buttonEle = $(event.target).closest('.zbutton'); // No I18N
		    if (!buttonEle.hasClass('is-disabled') || buttonEle.find('.zbutton__loader').length) {
		        // If there is no action, don't close the dialog.
		        let action = buttonEle.attr('data-action'); // No I18N
		        if (action) { // string type actions will only be present here
		            if (action === 'CANCEL' || action === 'CLOSE') { // No I18N
		                this._closeDialog(event, {
		                    button: buttonEle
		                });
		            } else {
		                ZC._triggerFunction(action, buttonEle, [ event, {
		                    button: buttonEle,
		                    options: ZC._getOpts(buttonEle)
		                } ]);
		            }
		        }
		        this._triggerEvent('actionbuttonclick', event, { // No I18N
		            button: buttonEle
		        });
		    }
		}
		_setBtnProps  () {
		    let btnData = this._data.commands,
		        fPanel = this.element.find('.zdialog__footer'), // No I18N
		        btns = fPanel.find('.zbutton'), // No I18N
		        len = btns.length,
		        ele, data, $ele;
		    for (let i = 0; i < len; i++) {
		        ele = btns[i];
		        data = btnData[i];
		        ele.zbtndata = data;
		        $ele = $(ele);
		        if (data.attrs) {
		            delete data.attrs.class;
		            $ele.attr(data.attrs);
		        }
		        this._handleFocus($ele);
		    }
		    fPanel.off('click').on('click', '.zbutton', function(event) { // No I18N
		        let ele = $(event.target).closest('.zbutton'), // No I18N
		            data = ele[0].zbtndata;
		        data && data.click(event);
		    });
		}
		_setFootnote  (footer) {
		    let _opts = this._opts;
		    footer = footer || _opts.footer;
		    if (this.isCE) {
		        let ele = this.element.find('z-dialogfootnote').addClass('zdialog__footnote');
		        ele.length && (this._data.footerEle = ele);
		    } else if (footer && footer.trim() !== '') {
		        this._data.footer = _opts.isFooterHTMLEncoded ? footer : ZC.encodeHTML(footer);
		    }
		}
		maximize  () {
		    this._performMinMax('Maximize'); // No I18N
		}
		_toggleMaximize  (event, button, triggerEvent) {
		    this._toggleRestore(event, button, triggerEvent, 'maximize'); // No I18N
		}
		minimize  () {
		    this._performMinMax('Minimize'); // No I18N
		}
		_toggleMinimize  (event, button, triggerEvent) {
		    this._toggleRestore(event, button, triggerEvent, 'minimize'); // No I18N
		}
		restore  (triggerEvent) {
		    this._performMinMax('Minimize', true, triggerEvent); // No I18N
		    this._performMinMax('Maximize', true, triggerEvent); // No I18N
		}
		_performMinMax  (action, restore, triggerEvent) {
		    let isActive = this['is' + action + 'd'](), // No I18N
		        alower = action.toLowerCase(),
		        optName = alower.replace('e', 'able'), // No I18N
		        btnName = '_' + alower + 'Button', // No I18N
		        val = -1;
		    if (!isActive && !restore && this._opts[optName]) {
		        val = false;
		    } else if (isActive && restore) {
		        val = triggerEvent;
		    }
		    if (val !== -1) {
		        this['_toggle' + action]({}, this[btnName], val); // No I18N
		    }
		}
		_toggleReverse  (type, value, className, triggerEvent, callback, event) {
		    let restore = value + 'Restore', // No I18N
		        content = this._content, // No I18N
		        base = this;
		    let completeFunction = function() {
		        if (value === 'minimize') { // No I18N
		            if (!type) {
		                base.actualWidth = parseFloat(base.element.css('width')); // No I18N
		                base.actualHeight = base.element.height();
		            }
		            base._footer[type ? 'removeClass' : 'addClass']('zh-dnone'); // No I18N
		            content[type ? 'removeClass' : 'addClass']('zh-dnone'); // No I18N
		        }
		        base._updateClass(className, type);
		        if (ZC.draggable && base._opts.draggable) {
		            ZC.draggable(base.element).setAttribute('disabled', !type);
		        }
		        let titleText = base._opts[type ? value + 'ButtonLabel' : value + 'RestoreButtonLabel'] || base._getI18NText(type ? value : restore, base._opts.labels); // No I18N
		        base._changeIcon(titleText, type ? value : restore);
		        if (type) {
		            base.element.css(base._hasBottom ? base.bottomRightPosition : base.actualPosition).css({
		                width: base.actualWidth
		            });
		            if (value === 'maximize') { // No I18N
		                content.height(base.actualHeight);
		                content.css('width', ''); // No I18N
		            } else if (value === 'minimize') { // No I18N
		                base.enableButton('maximize'); // No I18N
		            }
		        } else if (value === 'maximize') { // No I18N
		            base._adjustContentSize();
		        } else if (value === 'minimize') { // No I18N
		            base.element.css({
		                width: ''
		            });
		            base.disableButton('maximize'); // No I18N
		        }
		        if (value === 'minimize') { // No I18N
		            if (base._overlay) {
		                base._overlay[type ? 'addClass' : 'removeClass']('zh-dnone'); // No I18N
		            }
		            let appendedElement = base._overlay ? base._overlay : $(base._opts.appendTo || 'body'); // No I18N
		            if (base._overlay && type) {
		                // resetting the z-index because on restoring the modal dialog from its minimized state, some other modeless dialogs can be opened.
		                ZC.zIndex += 1;
		                appendedElement.css('zIndex', ZC.zIndex); // No I18N
		                base.element.appendTo(appendedElement); // Revisit - appendTo
		            }
		            base.element[type ? 'removeClass' : 'addClass']('zdialog--minimized'); // No I18N
		            type || base._resetPosition(base.element);
		            base._overlay && base._hideDocumentScroll(!!type);
		            if (type) { // while restoring from the minimize state, active element stored while minimizing will be set focus.
		                base._triggerActiveElement();
		            }
		        }
		        if (triggerEvent) {
		            // triggering the maximize, minimize or restore event.
		            base._triggerEvent(type ? 'restore' : value, event, { // No I18N
		                from: value
		            });
		        }
		        // ZC.FocusHandler.init(base.element);
		        if (value === 'maximize') { // No I18N
		            base._triggerActiveElement();
		        }
		        callback && callback();
		    };
		    if (!type) {
		        this._findPosition();
		        this._findHeightWidth();
		    }
		    let props = {
		        top: '',
		        left: '',
		        right: ''
		    };
		    if (value === 'maximize') { // No I18N
		        props.width = ''
		        props.height = '';
		    }
		    this.element.css(props);
		    this._buttonAnimateHandler(type, value, completeFunction);
		}
		_adjustContentSize  () {
		    let content = this._content,
		        element = this.element,
		        header = element.find('.zdialog__header'), // No I18N
		        footer = element.find('.zdialog__footer'), // No I18N
		        headerHeight = header.length ? header.outerHeight(true) : 0,
		        footerHeight = footer.length ? footer.outerHeight(true) : 0,
		        footnoteHeight = this._footer.length ? this._footer.outerHeight(true) : 0, // No I18N
		        computed = Math.abs(ZC.windowObject.height - (headerHeight + footerHeight + footnoteHeight + parseInt(content.css('padding-top')) + parseInt(content.css('padding-bottom')) + parseInt(element.css('border-top-width')) + parseInt(element.css('border-bottom-width')))), // No I18N
		        computedWidth = ZC.windowObject.width - parseInt(content.css('padding-left')) - parseInt(content.css('padding-right')) - parseInt(content.css('margin-right')) - parseInt(content.css('margin-left')) - parseInt(element.css('border-left-width')) - parseInt(element.css('border-right-width')); // No I18N
		    // padding top and padding bottom of dialog is added & padding left and right of the dialog is subtracted to have the dialog in view port
		    content.width(computedWidth); // width and height is set individually in order to consider different box-sizing values for zdialog__content.
		    content.height(computed);
		}
		_triggerActiveElement  () {
		    let _activeElement = this._activeElement || '';
		    if (!_activeElement.length) {
		        _activeElement = this.element.find('.zdialog__header'); // No I18N
		    }
		    _activeElement.trigger('focus'); // No I18N
		    this._activeElement = undefined;
		}
		_toggleRestore  (event, button, triggerEvent, value) {
		    let isMaximized = this.isMaximized(),
		        isMinimized = this.isMinimized();
		    if (isMaximized || value === 'maximize') { // No I18N
		        this._toggleReverse(isMaximized, 'maximize', 'zdialog--maximized', triggerEvent, undefined, event); // No I18N
		    } else if (isMinimized || value === 'minimize') { // No I18N
		        this._toggleReverse(isMinimized, 'minimize', 'zdialog--minimized', triggerEvent, undefined, event); // No I18N
		    }
		    if (button && button.length && button[0].id === this._opts.id + 'minimize' && isMaximized) { // No I18N
		        this._toggleReverse(isMinimized, 'minimize', 'zdialog--minimized', triggerEvent, undefined, event); // No I18N
		    }
		}
		_changeIcon  (title, iconName) {
		    let btns = this._data.titleBarButtons,
		        relement = 'restore', // No I18N
		        nele = (iconName === 'minimize' || iconName === 'maximize') ? iconName : 'restore', // No I18N
		        baseObj = this;
		    if (iconName === 'minimizeRestore') { // No I18N
		        relement = 'minimize'; // No I18N
		    } else if (iconName === 'maximizeRestore') { // No I18N
		        relement = 'maximize'; // No I18N
		    }
		    relement = this._opts.id + relement;
		    let i = 0,
		        info, mainEle;
		    btns.forEach((element) => {
		        btns[i].mainElement = baseObj._actionGroup.find('#' + element.id);// No I18N
		        if (element.id === relement) {
		            mainEle = baseObj._actionGroup.find('#' + relement);// No I18N
		            btns[i] = baseObj._updateBtnInfo(nele, mainEle.length && mainEle);
		            btns[i].mainElement = undefined;
		            info = btns[i];
		            info.title = title;
		            info.actionName = nele;
		            info.zdaction = nele === 'restore' ? 'maximize' : nele; // No I18N
		        }
		        i++;
		    });
		    this._render(); // render is needed in order to reflect the min-max state icon changes
		    // this._setBtnValue(info, info);
		    if (info.mainElement) {
		        $(info.mainElement).attr('data-zdaction', info.actionName); // No I18N
		    }
		}
		_buttonAnimateHandler  (type, value, callback) {
		    let animInfo = this._opts.animation;
		    if (animInfo[value]) {
		        this._animateAction(animInfo, (type ? value + 'Restore' : value), callback); // No I18N
		    } else {
		        callback();
		    }
		}
		_minMaxClick  (zdaction, event, btn) {
		    this['_toggle' + zdaction[0].toUpperCase() + zdaction.substring(1)](event, btn, true); // No I18N
		    if (zdaction === 'restore') {
		        this._resetPosition(this.element, true);
		    }
		    if (event.type === 'keydown') { // No I18N
		        // preventing the event propagation since keydown event triggers click event further.
		        return false;
		    }
		}
		_resetPosition  (element, remove) {
		    ZC._minArr = ZC._minArr || [];
		    let index = ZC._minArr.indexOf(element);
		    if (remove) {
		        if (index > -1) {
		            ZC._minArr.splice(index, 1);
		        }
		    } else {
		        ZC._minArr.push(element);
		    }
		    // have to adjust all dialogs position
		    let len = ZC._minArr.length,
		        right, curr, prev,
		        propName = this._opts.rtl ? 'left' : 'right'; // No I18N
		    for (let i = len - 1; i > 0; i--) {
		        curr = $(ZC._minArr[i]);
		        prev = $(ZC._minArr[i - 1]);
		        right = parseFloat(prev.css(propName)) + prev.outerWidth();
		        curr.css(propName, right);
		    }
		    $(ZC._minArr[0]).css(propName, 0);
		}
		_titleBarClickHandler  (event) { // dblclick
		    // Perform Minimize, Maximize or Restore Operation while double clicking the titleBar
		    if (!$(event.target).closest('.zdialog__actiongroup').length) {
		        let action = (this.isMaximized() || this.isMinimized()) ? 'restore' : (this._opts.maximizable ? 'maximize' : (this._opts.minimizable ? 'minimize' : undefined)); // No I18N
		        action && this._toggleRestore(event, undefined, true, action); // No I18N
		        if (action === 'restore') { // No I18N
		            this._resetPosition(this.element, true);
		        }
		    }
		}
		_createOverlay  () {
		    ZC.zIndex += 1; // setting zindex for overlay to have the modal behavior
		    let opts = this._opts,
		        overlay = $(`<div class='zdialog--overlay ${opts.overlayClassName}' ></div>`).css('zIndex', ZC.zIndex); // No I18N
		    this._addedByComponent = true;
		    $(this._opts.appendTo || 'body').append(overlay.append(this.element)); // appending the dialog element to the overlay in order to correct the scroll behavior.
		    this._addedByComponent = false;
		    this._hideDocumentScroll(true);
		    //  Here tabindex is set in order to make the div element receive keydown event.
		    overlay.attr('tabindex', 1); // No I18N
		    this._overlay = overlay;
		    this._bindOverlayEvents();
		}
		_bindOverlayEvents  () {
		    this._addEvents({
		        overlayKey: 'keydown', // No I18N
		        overlayEveStop: 'click mousedown' // No I18N
		    }, this._overlay);
		}
		_overlayKeyHandler  (event) {
		    if (event.keyCode === ZC.keyCode.ESCAPE && this._opts.closeOnEscKey) { // Closing the model dialog when escape key is pressed.
		        this._closeDialog(event, {
		            overlay: true
		        });
		    }
		}
		_overlayEveStopHandler  (event) {
		    // preventing the propagation of mousedown/click because document mousedown handlers might close the already opened menu/popover.
		    if (!$(event.target).closest('.zdialog').length) { // No I18N
		        event.stopPropagation();
		        if (event.type === 'click' && this._opts.closeOnOverlayClick) { // No I18N
		            this._closeDialog(event, {
		                overlay: true
		            });
		        }
		    }
		}
		_unbindOverlayEvents  () {
		    this._removeEvents('keydown click mousedown', this._overlay); // No I18N
		}
		_hideDocumentScroll  (hide) {
		    $('body')[hide ? 'addClass' : 'removeClass']('zh-overflowhidden'); // No I18N
		}
		_closeModalDlg  (event, data, ignoreTrigger) {
		    let over = this._overlay,
		        isVisible = over ? over.is(':visible') : false; // No I18N
		    // Appending the dialog element to body and removing the overlay related codes are removed.
		    if (isVisible && (!data || data.animation === undefined || data.animation !== false)) { // No I18N
		        let base = this;
		        over.fadeOut(50, this._triggerCloseEvent.bind(base, event, data, ignoreTrigger));
		    } else {
		        isVisible && over.hide();
		        this._triggerCloseEvent(event, data, ignoreTrigger);
		    }
		}
		_triggerCloseEvent  (event, data, ignoreTrigger) {
		    if (!$('body').find('.zdialog--overlay:visible').length) {
		        this._hideDocumentScroll(false);
		    }
		    if (!ignoreTrigger) {
		        this._triggerEvent('close', event, data); // No I18N
		    }
		}
		_preventModalDlgClick  () {
		    this._addEvents({
		        overlayClk: 'click' // No I18N
		    });
		}
		_overlayClkHandler  (event) {
		    // propagation of click event is prevented since overlay click will close the dialog.
		    event.stopPropagation();
		}
		_fetchAjaxCon  (content) {
		    $.ajax(content).success((ajaxRes) => {
		        this._data.content = ajaxRes;
		        this._render();
		    });
		}
		get resizableDefaults (){
			return	 {
		    minHeight: 300, // No I18N
		    minWidth: 300, // No I18N
		    maxHeight: false, // No I18N
		    maxWidth: false, // No I18N
		    boundary: 'viewport', // No I18N
		    directions: 's,e,se' // No I18N
		}
		 }
  _initResize  () {
		    let base = this,
		        resizeOptions = this.resizableDefaults;
		    resizeOptions.boundary = this._opts.type === 'modal' ? 'parent' : resizeOptions.boundary; // No I18N
		    ZC.resizable(this.element, $.extend(true, {}, resizeOptions, {
		        relatedElements: this._content, // No I18N
		        rtl: this._opts.rtl, // No I18N
		        cues: [ 'ne', 'nw', 'se', 'sw' ], // No I18N
		        cueIcons: {
		            southEastSVGIconId: 'zc__svg--lines zresizable__svg', // No I18N
		            northEastSVGIconId: 'zc__svg--lines zresizable__svg', // No I18N
		            southWestSVGIconId: 'zc__svg--lines zresizable__svg', // No I18N
		            northWestSVGIconId: 'zc__svg--lines zresizable__svg' // No I18N
		        },
		        start: function(event, ui) {
		            if (event.detail.resizedDirection.indexOf('n') !== -1) { // No I18N
		                base._posModified = true;
		            }
		            base._dimModified = true; // dimension modified.
		            base._triggerEvent('resizestart', event, ui); // No I18N
		        },
		        end: function(event, ui) {
		            base.actualWidth = base.element.width();
		            base._triggerEvent('resizeend', event, ui); // No I18N
		            // width is setting as auto inorder to make the content area responsive during window resize.
		            base._content.css('width', 'auto'); // No I18N
		        },
		        resize: function(event, ui) {
		            base.element.css('height', 'auto'); // No I18N
		            base._triggerEvent('resize', event, ui); // No I18N
		        }
		    }, this._opts.resizable));
		}
		/* eslint-disable no-unused-expressions */
		_setAttribute  (optName, value) {
		    let opts = this._opts,
		        data = this._data,
		        isCE = opts.isCE;
		    if (optName === 'title') { // No I18N
		        if (value) {
		            data.title = data.isTitleHTMLEncoded ? value : ZC.encodeHTML(value);
		            isCE && this._titleBar.find('.zdialog__title').text(data.title); // No I18N
		        } else {
		            data.title = data.titleEle = null;
		        }
		    } else if (optName === 'content') { // No I18N
		        opts[optName] = value;
		        if (value) {
		            if (typeof value === 'object') { // No I18N
		                $.ajax(value).success((data) => {
		                    value = data;
		                });
		            }
		            data.content = data.isContentHTMLEncoded ? value : ZC.encodeHTML(value); // No I18N
		            isCE && this._content.html(data.content);
		        } else {
		            data.content = data.contentEle = null;
		        }
		    } else if (optName === 'closeOnEscKey') { // No I18N
		        value ? this._bindEvents() : this.element.off(`.${this.name}`);
		    } else if (optName === 'closeButton' || optName === 'closeSVGIconId' || optName === 'closeIconClassName' || optName === 'closeIconClass' || (opts.closeButton && (optName === 'minimizable' || optName === 'maximizable'))) { // No I18N
		        opts[optName] = value;
		        this._setTitleBarBtns();
		    } else if (optName === 'className') { // No I18N
		        this._updateClass(value, opts.className);
		    } else if (optName === 'width') { // No I18N
		        this.element.css({
		            width: value
		        });
		        this.actualWidth = parseInt(value);
		    } else if (optName === 'height') { // No I18N
		        this._content.css('height', value); // No I18N
		        this.actualHeight = parseInt(value);
		    } else if (optName === 'type' && this.element.is(':visible')) { // No I18N
		        // opts[optName] = value;
		        if (value === 'modal') { // No I18N
		            this._createOverlay(); // if dialog is a modal dialog, create the overlay
		            this._preventModalDlgClick();
		        } else {
		            $(this._opts.appendTo || 'body').append(this.element);  // No I18N // Appending the dialog element to the body.
		            this._overlay.remove();
		            this._overlay = undefined;
		            this.element.off('click.zdialog'); // No I18N
		            this._setTitleBarBtns();
		        }
		        this.element.attr('aria-modal', value === 'modal'); // No I18N
		    } else if (optName === 'overlayClassName' && this._overlay) { // No I18N
		        this._overlay.removeClass(opts.overlayClassName).addClass(value);
		    } else if (optName === 'resizable' && ZC.resizable) { // No I18N
		        opts.resizable = value;
		        if (this.element.data('zresizable') && value && typeof value === 'object') { // No I18N
		            if (Object.keys(value).length) {
		                ZC.resizable(this.element).setAttributes(value);
		            }
		        } else {
		            value ? this._initResize() : ZC.resizable(this.element).destroy();
		        }
		    } else if (optName === 'draggable') { // No I18N
		        value ? this._initDrag() : ZC.draggable(this.element).destroy();
		    } else if (optName === 'buttons' || optName === 'commandBar') { // No I18N
		        opts[optName] = value;
		        this._createButtonPanel();
		    } else if (optName === 'position') { // No I18N
		        opts.position = value;
		        this._positionDialog();
		    } else if (optName === 'footer') { // No I18N
		        this._setFootnote(value);
		    } else if (optName === 'buttonsAlignment') { // No I18N
		        this.element.find('.zdialog__footer').removeClass(this._ALIGNMENTS[opts.buttonsAlignment]).addClass(this._ALIGNMENTS[value]);
		    } else if (optName === 'closeOnOverlayClick' && this._overlay && this._overlay.length) { // No I18N
		        value ? this._bindOverlayClick() : this._overlay.off('click.zdialog'); // No I18N
		    } else if (optName === 'rtl' && opts.resizable) { // No I18N
		        this.element.zresizable('setAttribute', 'rtl', value); // No I18N
		    }
		    if (optName !== 'className') {
		        opts[optName] = data[optName] = value;
		    }
		    data.modifiedAttr = optName;
		    let noRenderItems = [ 'closeOnEscKey', 'className', 'closeOnOverlayClick', 'width', 'height', 'resizable', 'draggable', 'position', 'animation' ]; // No I18N
		    if (noRenderItems.indexOf(optName) < 0) {
		        this._domChanged = true;
		    }
		}
		setButtonAttributes  (ids, attrName, attrValue) {
		    let i = 0,
		        isIDObj = typeof ids !== 'string', // No I18N
		        isMulAttr = typeof attrName === 'object'; // No I18N
		        /* attrName -> {"text":"Button Label","disabled":true } */
		    if (isIDObj || isMulAttr) {
		        let src = isMulAttr ? attrName : ids,
		            value;
		        for (let key in src) {
		            value = src[key];
		            this.setButtonAttributes(isMulAttr ? ids : value.id, isMulAttr ? key : value, value);
		        }
		    }
		    ids = ids.split(','); // No I18N
		    let len = ids.length,
		        id;
		    for (i = 0; i < len; i++) {
		        id = ids[i];
		        this._changeBtnValues(id, attrName, attrValue);
		    }
		    if (len) {
		        this._data.modifiedAttr = 'buttons'; // No I18N
		        this._render();
		    }
		    this.refreshContent();
		}
		_changeBtnValues  (id, attrName, value) {
		    let btn = this.element.find(id);
		    if (!btn.length) {
		        return;
		    }
		    let btnData = btn[0].zbtndata;
		    btnData[attrName] = value;
		    btnData.className = btnData.className.replace(/zbutton--primary|zbutton--normal|zbutton--small|zbutton--medium|zbutton--large|zbutton--mini|is-disabled|zbutton/g, '');
		    btnData = ZC.ZButton.getBtnProps(btnData);
		    btn[0].zbtndata = btnData;
		    let commands = this._data.commands,
		        len = commands.length;
		    for (let i = 0; i < len; i++) {
		        if (commands[i].id && commands[i].id === id.slice(1)) {
		            this._data.commands[i] = btnData;
		        }
		    }
		    if (attrName === 'customAttributes') { // No I18N
		        btn.attr(value);
		    }
		}
		_setTitleBarBtns  () {
		    let opts = this._opts,
		        btns = [],
		        titleVal = opts.title,
		        btnInfo = this._updateBtnInfo.bind(this);
		    if (titleVal) {
		        this._data.title = opts.isTitleHTMLEncoded ? titleVal : ZC.encodeHTML(titleVal);
		    }
		    if (opts.minimizable && opts.type !== 'modal') { // No I18N
		        btns.push(btnInfo('minimize')); // No I18N
		    }
		    opts.maximizable && btns.push(btnInfo('maximize'));
		    opts.closeButton && btns.push(btnInfo('close'));
		    this._data.titleBarButtons = btns;
		}
		disableButton  (keyword) {
		    this._toggleButton(keyword, true);
		}
		enableButton  (keyword) {
		    this._toggleButton(keyword, false);
		}
		_toggleButton  (keyword, attrValue) {
		    let btn = this['_' + (keyword || 'close') + 'Button'];// No I18N
		    if (btn) {
		        this._disable(attrValue, btn);
		    }
		}
		_updateBtnInfo  (actionName, mainEle) {
		    let _opts = this._opts,
		        elem = $('#' + _opts.id + actionName),
		        custProps = {
		            id: _opts.id + actionName, // No I18N
		            title: _opts[actionName + 'ButtonLabel'] || this._getI18NText(actionName), // No I18N
		            className: 'zbutton--action zdialog__' + actionName, // No I18N
		            SVGIconId: _opts[actionName + 'SVGIconId'], // No I18N
		            SVGIconClassName: 'zbutton__svg', // No I18N
		            iconClassName: _opts[actionName + 'IconClassName'] || _opts[actionName + 'IconClass'], // No I18N
		            defaultSVGIconId: 'zc__svg--' + actionName + ' zbutton__svg', // No I18N
		            templateRender: true,
		            // isCE: _opts.isCE, If we render buttons as z-button, then while emptying the element via template rendering produces incorrect results since disconnected and connected callbacks will be invoked with loss in data.
		            mainElement: mainEle || (elem.length ? elem[0] : null),
		            customAttributes: {
		                'data-zdaction': actionName, // No I18N
		                tabindex: -1 // No I18N
		            }
		        };
		    return ZC.ZButton.getBtnProps(custProps);
		}
		_handleTBarActions  () {
		    let name = '.' + this.name, // No I18N
		        code;
		    let btnContainer = this.element.find('.zdialog__actiongroup'),
		        btns = btnContainer.find('.zbutton'),
		        tBarBtns = this._data.titleBarButtons,
		        len = tBarBtns.length,
		        attrs;
		    for (let i = 0; i < len; i++) {
		        attrs = tBarBtns[i].attrs;
		        if (attrs) {
		            $(btns[i]).attr(attrs);
		        }
		    }
		    // Revisit - use bindEleEvents
		    btnContainer.off('click' + name + ' keydown' + name).on('click' + name + ' keydown' + name, (event) => { // No I18N
		        /*
		            Shortcuts for Minimize Button
		            MAC OS: Cmd+M
		            Windows & Ubuntu OS: No direct shortcuts
		        */
		        code = event.keyCode;
		        if (event.type === 'click' || (code === ZC.keyCode.ENTER || code === ZC.keyCode.SPACE)) {
		            let btn = $(event.target).closest('.zbutton--action:not(.is-disabled)'), // No I18N
		                zdaction = btn.attr('data-zdaction'); // No I18N
		            if ([ 'maximize', 'minimize', 'restore' ].indexOf(zdaction) > -1) {
		                return this._minMaxClick(zdaction, event, btn);
		            } else if (zdaction === 'close') {
		                return this._closeClickHandler(event);
		            }
		        }
		    }).off('mousedown' + name).on('mousedown' + name, () => { // No I18N
		        // activeElement is stored to use while restoring from minimize state.
		        this._activeElement = this._activeElement || $(document.activeElement);
		    });
		}
	}
	ZC.registerComponent('ZDialog', ZDialog); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zdialog.Templates, button = ZC.zbutton.Templates.WCContainer; 
template.WCContainer = (data) => ZT.html `<z-dialog ?aria-label="${data.text}" ?id="${data.id}" ?role="${data.role}" class="zdialog ${data.className}">${data.children && template.WCChildren(data)}</z-dialog>`; 
template.WCChildren = (data) => ZT.html ` <div class="zdialog__header zdialog__titlebar zdraggable"> ${data.titleEle || data.title && ZT.html `<z-dialogtitle role="heading" class="zdialog__title zdialog__text">${ZT.customHTML(data.title)}</z-dialogtitle>`} ${data.titleBarButtons && ZT.html `<div class="zdialog__actiongroup zdialog__action">${data.titleBarButtons.map((value) => button(value))}</div>`} </div> ${data.contentEle || ZT.html `<z-dialogcontent class="zdialog__content"> ${data.content} </z-dialogcontent>`} ${data.actionBar || data.buttons && ZT.html `<z-dialogactionbar class="zdialog__commandbar zdialog__footer ${data.alignClassName}"> ${data.cols ? template.WCCommandBarCol(data.cols) : (data.commands && data.commands.map((value) => button(value)))} </z-dialogactionbar>`} ${data.footerEle || data.footer && ZT.html `<z-dialogfootnote class="zdialog__footnote">${ZT.customHTML(data.footer)}</z-dialogfootnote>`}`; 
template.WCCommandBarCol = (data) => ZT.html ` ${data.left && ZT.html `<div class="${data.cname}__commandbaractionsleft ${data.left.className || ''}">${data.left.buttons.map((value) => button(value))}</div>`} ${data.center && ZT.html `<div class="${data.cname}__commandbaractionscenter ${data.center.className || ''}"> ${data.center.buttons.map((value) => button(value))}</div>`} ${data.right && ZT.html `<div class="${data.cname}__commandbaractionsright ${data.right.className || ''}">${data.right.buttons.map((value) => button(value))}</div>`} 	`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zdialog.Templates, button = ZC.zbutton.Templates.container; 
template.container = (data) => ZT.html `<div ?aria-label="${data.text}" ?id="${data.id}" ?role="${data.role}" class="zdialog ${data.className}">${data.children && template.children(data)}</div>`; 
template.children = (data) => ZT.html ` <div class="zdialog__header zdialog__titlebar zdraggable"> ${data.titleEle || data.title && ZT.html `<div role="heading" class="zdialog__title zdialog__text">${ZT.customHTML(data.title)}</div>`} ${data.titleBarButtons && ZT.html `<div class="zdialog__actiongroup zdialog__action">${data.titleBarButtons.map((value) => button(value))}</div>`} </div> ${data.contentEle || ZT.html `<div class="zdialog__content"> ${data.content} </div>`} ${data.actionBar || data.buttons && ZT.html `<div class="zdialog__commandbar zdialog__footer ${data.alignClassName}"> ${data.cols ? template.commandBarCol(data.cols) : (data.commands && data.commands.map((value) => button(value)))} </div>`} ${data.footerEle || data.footer && ZT.html `<div class="zdialog__footnote">${ZT.customHTML(data.footer)}</div>`}`; 
template.commandBarCol = (data) => ZT.html ` ${data.left && ZT.html `<div class="${data.cname}__commandbaractionsleft ${data.left.className || ''}">${data.left.buttons.map((value) => button(value))}</div>`} ${data.center && ZT.html `<div class="${data.cname}__commandbaractionscenter ${data.center.className || ''}"> ${data.center.buttons.map((value) => button(value))}</div>`} ${data.right && ZT.html `<div class="${data.cname}__commandbaractionsright ${data.right.className || ''}">${data.right.buttons.map((value) => button(value))}</div>`} 	`; }(ZComponents)); 
(function(ZC, $){
	/* $Id$ */
	class ZTabPanel  extends ZC.CoreComponent{
			get name(){
				return "ztabpanel";
			}
	    get attrs() {
	        return {
	            tabAlignment: 'left', // No I18N
	            tabPosition: 'top', // No I18N
	            tabLabelType: 'text', // "icon"|"icon-text" //No I18N
	            openOn: 'click', // No I18N
	            activeTab: null,
	            lazyLoadContent: true,
	            cacheContent: true,
	            isTabLabelHTMLEncoded: false
	        }
	    }
	    get props() {
	        return {
	            tabAnimation: {},
	            tabs: null,
	            messages: {
	                serverError: 'Server request failed. Please try again later.' // No I18N
	            }
	        }
	    }
	    get EVENTS() {
	        return [
	            'tabadd', // No I18N
	            'tabremove', // No I18N
	            'beforeswitch', // No I18N
	            'switch', // No I18N
	            'tabshow', // No I18N
	            'tabhide', // No I18N
	            'tabclick', // No I18N
	            'init' // No I18N
	        ]
	    }
	    get SELECTORS() {
	        return {
	            TABPANEL: this.isCE ? 'z-tabpanel' : 'div', // No I18N
	            TABHEAD: this.isCE ? 'z-tabhead' : 'ul', // No I18N
	            TABITEM: this.isCE ? 'z-tab' : 'li', // No I18N
	            TABBODY: this.isCE ? 'z-tabbody' : 'div', // No I18N
	            TABCONTENT: this.isCE ? 'z-tabcontent' : 'div' // No I18N
	        }
	    }
	    _init(element, options) {
	        this._fromInit = true;
	        this._useParent = true;
	        let data = this._data;
	        this._id = element[0].id || this._getID();
	        let tabHeadDOM = data.tabHeadDOM = this._getTabHead();
	        let tabBodyDOM = data.tabBodyDOM = this._getTabBody();
	        let tabHeadClass = data.tabHeadClass = 'ztab__head'; // No I18N
	        let tabBodyClass = data.tabBodyClass = 'ztab__body'; // No I18N
	        if (tabHeadDOM) {
	            $(tabHeadDOM)
	                .addClass(tabHeadClass)
	                .attr('role', 'tablist'); // No I18N
	        }
	        if (tabBodyDOM) {
	            let tabContentDOMs = $(tabBodyDOM)
	                .addClass(tabBodyClass)
	                .children(this._SELECTORS.TABCONTENT);
	            tabContentDOMs.hide();
	            this._addAttrsToTabContent(tabContentDOMs);
	        }
	        this._setContentType(data, options);
	        this._initTabs(data, options);
	        data.widgetRender = true;
	    }
	    _addAttrsToTabContent(tabContentDOMs) {
	        tabContentDOMs
	            .addClass('ztab__content') // No I18N
	            .attr('role', 'panel');// No I18N
	        return tabContentDOMs;
	    }
	    _preRender(data) {
	        this._addedByComponent = true;
	        if (this._data.widgetRender) {
	            data = this._data;
	            data.widgetRender = true;
	            this._setRenderData(data, this._opts);
	        }
	        return data;
	    }
	    _bindEvents() {
	        if (this._keydownHandler) {
	            this._addEvents({
	                keydown: 'keydown' // No I18N
	            }, this.element);
	        }
	    }
	    _bindTabHead() {
	        let tabHeadDOM = $(this._data.tabHeadDOM);
	        let tabs = tabHeadDOM.children();
	        this._removeEvents('', tabs); // No I18N
	        this._addEvents({
	            'switch': this._opts.openOn === 'hover' ? 'mouseenter' : 'click' // No I18N
	        }, tabs);
	    }
	    _switchHandler(orgEvent) {
	        let tab = $(orgEvent.currentTarget);
	        orgEvent.preventDefault();
	        this._selectTab(tab, orgEvent);
	    }
	    _deselectTab(tab) {
	        let tabData = this._getTabData(tab || this._activeTab);
	        if (tabData) {
	            let actualTabData = tabData.actualData;
	            if (this._activeTab === tabData.element) {
	                this._activeTab = false;
	                this._opts.activeTab = 'none'; // No I18N
	            }
	            this._updateSelection(actualTabData, false);
	            this._display(this._getPanel(actualTabData), false);
	        }
	    }
	    _getPanel(actualData) {
	        return $('#' + actualData.panelId, this.element)[0]; // No I18N
	    }
	    _updateSelection(actualTabData, activate = true) {
	        let tabEle = $(actualTabData.element);
	        activate = activate || null;
	        actualTabData.active = activate;
	        tabEle[activate ? 'addClass' : 'removeClass']('is-selected'); // No I18N
	        tabEle.attr({
	            'aria-selected': activate, // No I18N
	            'data-selected': activate // No I18N
	        });
	    }
	    _selectTab(tab, orgEvent, skipFocus) {
	        if (tab === 'none') { // No I18N
	            return this._deselectTab();
	        }
	        let tabData = this._getTabData(tab);
	        let reponse;
	        if (tabData) {
	            let actualTabData = tabData.actualData;
	            if (!actualTabData.active && this._trigger('beforeswitch', tabData, orgEvent)) { // No I18N
	                if (!actualTabData.hidden && !actualTabData.disabled) {
	                    this._deselectTab(null, orgEvent);
	                    !skipFocus && this._focusTab(actualTabData.element);
	                    this._opts.activeTab = this._activeTab = actualTabData.element;
	                    this._updateSelection(actualTabData, true);
	                    let panel = this._loadPane(tabData);
	                    this._display(panel, true);
	                    // Commented because last scrollTop must be maintained.
	                    // panel.scrollTop = 0;
	                    this._trigger('switch', tabData, orgEvent); // No I18N
	                    reponse = true;
	                }
	            }
	            this._trigger('tabclick', tabData, orgEvent); // No I18N
	            return reponse;
	        }
	    }
	    _focusTab(tab) {
	        tab.querySelector('a').focus(); // No I18N
	    }
	    _toArr(datas) {
	        return Array.isArray(datas) ? datas : [ datas ];
	    }
	    _trigger(customevent, tabData, orgEvent, data) {
	        if (!this._fromInit) {
	            data = data || {};
	            data.activeTab = this._opts.activeTab;
	            if (tabData) {
	                data.tab = tabData.element;
	                data.tabData = $.extend(true, {}, tabData.actualData);
	                data.tabData.element = null;
	            }
	            return this._dispatchEvent(customevent, orgEvent, data, undefined, !!orgEvent);
	        }
	        return true;
	    }
	    _animate(element, animation, action, callback) {
	        let completeFn = () => {
	            this._display(element[0], action !== 'hide'); // No I18N
	            callback && callback();
	        }
	        if (animation && ZC.animationHandler && !$.isEmptyObject(animation)) {
	            let animationObject = {
	                element,
	                action,
	                animation,
	                callback: completeFn,
	                ctype: this.name
	            }
	            ZC.animationHandler(animationObject);
	        } else {
	            completeFn();
	        }
	    }
	    _setRenderData(data, options) {
	        data.alwaysSetAttrs = true;
	        let position = data.position = options.tabPosition;
	        data.isVertical = /^(left|right)$/.test(position);
	        data.isBottom = /^(right|bottom)$/.test(position);
	        let alignment = options.tabAlignment;
	        if (data.isVertical) {
	            if (!/^(top|bottom|middle)$/.test(alignment)) {
	                alignment = 'top'; // No I18N
	            }
	        } else if (!/^(left|right|center)$/.test(alignment)) {
	            alignment = 'left'; // No I18N
	        }
	        data.alignment = alignment;
	        this._setWdHt(data, options);
	    }
	    _renderTabs() {
	        let data = this._data;
	        this._addedByComponent = true;
	        if (data.tabHeadDOM) {
	            data.tabs.forEach((tabData) => {
	                if (!tabData.actualData.userEle) {
	                    tabData.element = null;
	                }
	            });
	            this._render(data.tabs, 'tabs', data.tabHeadDOM, true); // No I18N
	        }
	        this._addedByComponent = false;
	        this._setTabEle(data.tabs);
	        this._bindTabHead();
	    }
	    _setTabEle(tabs) {
	        tabs.forEach((tabData) => {
	            let tabEle = tabData.element;
	            let actualData = tabData.actualData;
	            if (!tabEle) {
	                tabEle = $('#' + tabData.id); // No I18N
	                let customAttrs = tabData.customAttrs;
	                if (customAttrs) {
	                    tabEle.attr(customAttrs);
	                }
	                tabData.element = actualData.element = tabEle[0];
	            }
	        });
	    }
	    _setInitial() {
	        let activeTab = this._opts.activeTab;
	        if (activeTab !== 'none') { // No I18N
	            activeTab = activeTab || this._initialTab || this._data.tabs.find((tabData) => (!tabData.hidden && !tabData.disabled));
	            if (activeTab) {
	                this._selectTab(activeTab);
	            } else {
	                this._opts.activeTab = 'none'; // No I18N
	            }
	        }
	    }
	    _postEachRender() {
	        let data = this._data;
	        if (data.widgetRender) {
	            data.widgetRender = false;
	            data.tabHeadDOM = this._getTabHead();
	            data.tabBodyDOM = this._getTabBody();
	            this._renderTabs();
	            this._setClassName(data, this._opts);
	            this._setPanelListHt();
	            if (this._fromInit) {
	                this._setInitial();
	                this._fromInit = false;
	                this._trigger('init'); // No I18N
	            }
	        }
	        this._addedByComponent = false;
	    }
	    _getTabHead() {
	        return this._data.tabHeadDOM || this.element[0].querySelector(this._SELECTORS.TABHEAD);
	    }
	    _getTabBody() {
	        return this._data.tabBodyDOM || this.element[0].querySelector(this._SELECTORS.TABBODY);
	    }
	    _setPanelListHt() {
	        let tabBodyDOM = this._getTabBody();
	        tabBodyDOM.style.height = '';// No I18N
	        if (!this._data.isVertical) {
	            tabBodyDOM.style.height = 'calc(100% - ' + $(this._getTabHead()).outerHeight(true) + 'px'; // No I18N
	        }
	    }
	    _setWdHt(data, options) {
	        let element = this.element;
	        let height = this._getValidSize(options.height);
	        let width = this._getValidSize(options.width);
	        let style = element.attr('style'); // No I18N
	        let styleObj = {};
	        if (style) {
	            style.split(';').forEach((s) => {
	                s = s.replace(/;/g, '').split(':'); // No I18N
	                styleObj[s[0]] = s[1];
	            });
	        }
	        if (height) {
	            styleObj.height = height;
	        }
	        if (width) {
	            styleObj.width = width;
	        }
	        data.attrs = {
	            style: this._getStyle(styleObj)
	        }
	    }
	    _setClassName(data, options) {
	        data.className = this._getClassName(data, options);
	    }
	    _getClassName(data, options) {
	        let className = 'ztabpanel ' + (options.className || options.zclassName || '') + (options.rtl ? ' zh-rtl' : '') + (options.tabLabelType === 'icon' ? ' ztabpanel--icononly' : '') + (data.isVertical ? ' ztabpanel--vertical' : ''); // No I18N
	        let positionClassName = ' ztabpanel--' + data.position + data.alignment; // No I18N
	        return className + positionClassName;
	    }
	    _setContentType(data, options) {
	        let labelType = options.tabLabelType;
	        data.hasIcon = data.hasText = false;
	        data.isCustom = options.tabLabelType === 'custom'; // No I18N
	        if (!data.isCustom) {
	            if (labelType.indexOf('icon') > -1) { // No I18N
	                data.hasIcon = true;
	            }
	            if (!data.hasIcon || labelType.indexOf('text') > -1) { // No I18N
	                data.hasText = true;
	            }
	        }
	    }
	    _initTabs(data, options, onlyDS) {
	        let tabDatas = [];
	        let selectors = this._SELECTORS;
	        if (data.tabHeadDOM && !onlyDS) {
	            let tabs = [ ...data.tabHeadDOM.querySelectorAll(selectors.TABITEM + ':not([data-custom=true]):not([data-zadded-by-template=true])') ]; // No I18N
	            tabDatas = tabs.map((tab) => this._getTabEleData(tab, data, options));
	        }
	        let tabs = options.tabs;
	        if (tabs && tabs.length) {
	            tabs = JSON.parse(JSON.stringify(tabs));
	            tabDatas.push(...tabs.map((actualData) => this._setTabData(actualData)));
	        }
	        if (!options.lazyLoadContent) {
	            tabDatas.forEach((tabData) => this._loadPane(tabData));
	        }
	        data.tabs = tabDatas;
	    }
	    _getValidSize(size) {
	        return size && size + (isNaN(size) ? '' : 'px'); // No I18N
	    }
	    _setTabData(actualTabData, tabData) {
	        let data = this._data;
	        let options = this._opts;
	        actualTabData = this._getCompleteTabData(actualTabData);
	        let tabEle = actualTabData.element;
	        let label, icon, customContent;
	        let hidden = actualTabData.hidden || null;
	        let disabled = actualTabData.disabled || null;
	        if (actualTabData.active && !hidden && !disabled) {
	            this._initialTab = actualTabData;
	        }
	        if (this._fromInit) {
	            actualTabData.active = false;
	        }
	        if (data.isCustom) {
	            customContent = actualTabData.zinnerHTML || actualTabData.innerHTML || actualTabData.labelHTML || actualTabData.label;
	        } else {
	            if (data.hasText) {
	                label = this._encodeLabel(actualTabData.label || actualTabData.labelHTML || ''); // No I18N
	            }
	            if (data.hasIcon) {
	                this._setIconData(actualTabData, icon = {});
	            }
	        }
	        let style = actualTabData.style || ''; // No I18N
	        if (hidden) {
	            style += ';display:none'; // No I18N
	        }
	        let width = this._getValidSize(actualTabData.width);
	        if (width) {
	            style += ';width:' + width; // No I18N
	        }
	        let newTabData = {
	            id: actualTabData.id,
	            role: 'tab', // No I18N
	            tabindex: -1,
	            className: 'ztab ' + (disabled ? ' is-disabled ' : '') + (actualTabData.active ? 'is-selected ' : '') + (actualTabData.zclassName || actualTabData.className || '') + ' ' + (actualTabData.origClass || ''), // No I18N
	            label,
	            icon,
	            customContent,
	            panelId: actualTabData.panelId,
	            hidden: hidden || null,
	            disabled: disabled || null,
	            active: actualTabData.active || null,
	            customAttrs: actualTabData.customAttributes,
	            element: tabEle,
	            linkTag: actualTabData.linkTag,
	            style,
	            actualData: actualTabData,
	            title: options.tabLabelType === 'icon' ? actualTabData.label : null // No I18N
	        }
	        if (tabData) {
	            Object.assign(tabData, newTabData);
	        } else {
	            tabData = newTabData;
	        }
	        this._updateTabEleAttrs(tabData);
	        return tabData;
	    }
	    _encodeLabel(label) {
	        return label && (this._opts.isTabLabelHTMLEncoded ? label : ZC.encodeHTML(label));
	    }
	    _getCompleteTabData(actualTabData) {
	        if (!actualTabData.zdone) {
	            if (typeof actualTabData === 'string') { // No I18N
	                actualTabData = {
	                    label: actualTabData
	                }
	            }
	            let id = actualTabData.id;
	            if (!id) {
	                id = this._getID(null, this._id + '-tab');// No I18N
	            }
	            actualTabData.id = id;
	            let panelId = actualTabData.panelId;
	            if (!panelId) {
	                panelId = this._getID(null, this._id + '-tabcontent'); // No I18N
	            }
	            panelId = actualTabData.panelId = panelId.replace(/^#/, ''); // No I18N
	        }
	        actualTabData.zdone = true;
	        return actualTabData;
	    }
	    _getTabEleData(tab) {
	        let optData = ZC._getOpts(tab);
	        let linkTag = tab.querySelector('a'); // No I18N
	        let label = optData.label;
	        let innerHTML = optData.innerHTML || (linkTag && linkTag.innerHTML || tab.innerHTML);
	        let labelHTML = !label && innerHTML;
	        if (linkTag) {
	            linkTag.textContent = ''; // No I18N
	            optData.panelId = optData.panelId || linkTag.getAttribute('href') // No I18N
	        }
	        return this._setTabData(Object.assign(optData, {
	            id: tab.id,
	            element: tab,
	            label,
	            hidden: optData.hidden || tab.style.display === 'none', // No I18N
	            labelHTML,
	            innerHTML,
	            linkTag: linkTag,
	            userEle: true,
	            origClass: tab.getAttribute('class') // No I18N
	        }));
	    }
	    _display(element, show = true) {
	        element.style.display = show ? '' : 'none'; // No I18N
	    }
	    _updateTabEleAttrs(tabData) {
	        this._addedByComponent = true;
	        let tab = tabData.element;
	        if (tab) {
	            let hidden = tabData.hidden;
	            let disabled = tabData.disabled;
	            let attrs = {};
	            Object.assign(attrs, {
	                title: tabData.title,
	                id: tabData.id,
	                role: 'tab', // No I18N
	                tabindex: -1,
	                'class': tabData.className, // No I18N
	                'data-panel-id': tabData.panelId, // No I18N
	                'data-hidden': hidden, // No I18N
	                'aria-hidden': hidden, // No I18N
	                'data-disabled': disabled, // No I18N
	                'aria-disabled': disabled, // No I18N
	                style: tabData.style
	            });
	            $(tab).attr(Object.assign(attrs, tabData.customAttrs || {}));
	            this._updateTabContent(tabData);
	        }
	        this._addedByComponent = false;
	    }
	    _updateTabContent(tabData) {
	        let linkTag = tabData.linkTag;
	        if (linkTag) {
	            this._render(tabData, 'anchorContent', linkTag, true); // No I18N
	        }
	        this._render(tabData, 'tabContent', tabData.element, true); // No I18N
	    }
	    _getTabData(tab) {
	        if (this._isNotNull(tab)) {
	            let matchedTabData;
	            let dataType = typeof tab;
	            if (dataType === 'string' || dataType === 'number') { // No I18N
	                if (!isNaN(tab)) {
	                    matchedTabData = this._data.tabs[tab];
	                    return matchedTabData;
	                }
	                tab = $(tab, this.element);
	            }
	            if (tab instanceof $) {
	                tab = tab[0];
	            }
	            if (tab) {
	                if (tab.nodeType) {
	                    matchedTabData = this._data.tabs.find((tabData) => tab.id === tabData.id);
	                } else if (typeof tab === 'object') { // No I18N
	                    return tab;
	                }
	                return matchedTabData;
	            }
	        }
	    }
	    /* Function to select next or previous tab */
	    _navNextPrevTab(isPrevious, startIndex, orgEvent) {
	        let tabs = this._data.tabs;
	        if (tabs.length) {
	            let tabData;
	            let factor = isPrevious ? -1 : 1;
	            if (startIndex === undefined) {
	                tabData = this._getTabData(this._activeTab);
	                if (tabData) {
	                    startIndex = tabs.indexOf(tabData);
	                } else {
	                    startIndex = -1;
	                }
	            } else {
	                startIndex -= (1 * factor);
	            }
	            let maxIndex = tabs.length - 1;
	            let currentIndex = startIndex;
	            let actualData;
	            do {
	                currentIndex = currentIndex + (1 * factor);
	                if (currentIndex < 0) {
	                    currentIndex = maxIndex;
	                }
	                if (currentIndex > maxIndex) {
	                    currentIndex = 0;
	                }
	                tabData = tabs[currentIndex];
	                actualData = tabData.actualData;
	            } while (currentIndex !== startIndex && (actualData.disabled || actualData.hidden));
	            if (currentIndex !== startIndex) {
	                this._selectTab(tabData, orgEvent);
	            }
	        }
	    }
	    _getNextPreviousTab(isPrevious) {
	        let tabs = this._getTabs();
	        let selectedIndex = tabs.index(this._opts.activeTab)
	        let nextTab = $(tabs[selectedIndex])[isPrevious ? 'prevAll' : 'nextAll'](`${this._SELECTORS.TABITEM}:not(.${this._CLASSES.DISABLED}):visible:first`); // No I18N
	        nextTab = nextTab.length ? nextTab : tabs.filter(':not(.' + this._CLASSES.DISABLED + '):visible'); // No I18N
	        return nextTab.filter(isPrevious ? ':last' : ':first'); // No I18N
	    }
	    _loadPane(tabData) {
	        if (tabData) {
	            let actualTabData = tabData.actualData;
	            let pane = this._getPanel(actualTabData);
	            let append = false;
	            if (!pane) {
	                pane = $(document.createElement(this._SELECTORS.TABCONTENT));
	                this._addAttrsToTabContent(pane);
	                pane = pane[0];
	                pane.id = actualTabData.panelId;
	                append = true;
	            }
	            let content = actualTabData.panelContent;
	            if (content && (!actualTabData.contentLoaded || (!this._opts.cacheContent && content.URL))) {
	                actualTabData.contentLoaded = true;
	                if (content instanceof $) {
	                    content = content[0];
	                }
	                if (content) {
	                    if (content.nodeType) {
	                        pane.innerHTML = content.outerHTML;
	                    } else if (typeof content === 'string') { // No I18N
	                        pane.innerHTML = actualTabData.isPanelContentHTMLEncoded ? content : ZC.encodeHTML(content);
	                    } else if (content.URL) {
	                        this._initAjaxLoad(actualTabData, content.URL, content.queryParam, pane, content.success, content.errorMessage, content.fail);
	                    }
	                }
	            }
	            if (append) {
	                this._data.tabBodyDOM.appendChild(pane);
	            }
	            return pane;
	        }
	    }
	    _setAttribute(optionName, value) {
	        if (optionName === 'activeTab') { // No I18N
	            this._selectTab(value);
	        } else {
	            this._setAdvAttribute(optionName, value);
	        }
	    }
	    openTab(tab) {
	        this._selectTab(tab);
	        return this.getActiveTab();
	    }
	    openNextTab() {
	        this._navNextPrevTab();
	        return this.getActiveTab();
	    }
	    openPreviousTab() {
	        this._navNextPrevTab(true);
	        return this.getActiveTab();
	    }
	    getActiveTab() {
	        return this._opts.activeTab;
	    }
	    deselectAllTabs() {
	        this._deselectTab();
	    }
		_addTabs  (tabDatas, action, rtab) {
		    let newTabDatas = [];
		    let data = this._data;
		    let tabs = data.tabs;
		    let index = tabs.length;
		    (this._toArr(tabDatas)).forEach((tab) => {
		        if (tab instanceof $) {
		            tab = tab[0];
		        }
		        if (tab) {
		            let newTabData;
		            if (tab.nodeType) {
		                newTabData = this._getTabEleData(tab);
		            } else {
		                if (typeof tab === 'string') { // No I18N
		                    tab = {
		                        label: tab
		                    }
		                }
		                if (typeof tab === 'object') { // No I18N
		                    newTabData = this._setTabData(tab);
		                }
		            }
		            if (newTabData) {
		                newTabDatas.push(newTabData);
		            }
		        }
		    });
		    if (rtab && (/^(after|before)$/.test(action))) {
		        rtab = $(rtab, data.tabHeadDOM);
		        if (rtab.hasClass('ztab')) { // No I18N
		            let refTabData = this._getTabData(rtab[0]);
		            index = tabs.indexOf(refTabData);
		            if (action === 'after') { // No I18N
		                index++;
		            }
		        }
		    }
		    if (newTabDatas.length) {
		        tabs.splice(index, 0, ...newTabDatas);
		        this._renderTabs();
		        return newTabDatas.map((newTabData) => {
		            this._trigger('tabadd', newTabData); // No I18N
		            return newTabData.element;
		        });
		    }
		}
		_deleteTab  (tabs, removeTabContents, fromCE) {
		    if (this._isNotNull(tabs)) {
		        let tabsToBeRemoved = [];
		        let startIndex;
		        (this._toArr(tabs))
		            .forEach((tab) => {
		                let tabData = this._getTabData(tab);
		                if (tabData) {
		                    tabsToBeRemoved.push(tabData);
		                    let tabs = this._data.tabs;
		                    let index = tabs.indexOf(tabData);
		                    tabs.splice(index, 1);
		                    let actualTabData = tabData.actualData;
		                    if (actualTabData.active) {
		                        startIndex = index;
		                        this._deselectTab(tabData);
		                    }
		                }
		            });
		        !fromCE && this._renderTabs();
		        tabsToBeRemoved.forEach((tabData) => {
		            removeTabContents && $(this._getPanel(tabData.actualData)).remove();
		            this._trigger('tabremove', tabData); // No I18N
		        });
		        if (startIndex !== undefined) {
		            this._navNextPrevTab(false, startIndex);
		        }
		    }
		}
		addTab  () {
		    return this._addTabs(...arguments);
		}
		removeTab  (tabs, removeTabContents) {
		    return this._deleteTab(tabs, removeTabContents);
		}
		_initAjaxLoad  (actualTabData, url, data, pane, successFn, errorMessage, failureFn) {
		    $.ajax({
		        url: url,
		        data: data,
		        success: (content) => {
		            if (typeof successFn === 'function') { // No I18N
		                content = successFn.call(actualTabData.element, content);
		            }
		            pane.innerHTML = content;
		        },
		        error: () => {
		            let failureContent;
		            if (typeof failureFn === 'function') { // No I18N
		                failureContent = failureFn.call(arguments);
		            }
		            actualTabData.contentLoaded = false;
		            pane.innerHTML = failureContent || errorMessage || this._getI18NText('serverError'); // No I18N
		        }
		    });
		}
		_destroy  () {
		    let data = this._data;
		    let tabHeadDOM = $(data.tabHeadDOM);
		    let tabBodyDOM = $(data.tabBodyDOM).removeAttr('style'); // No I18N
		    this._removeEvents('', tabHeadDOM); // No I18N
		    tabBodyDOM.children().show().removeClass('ztab__content'); // No I18N
		    let tabs = tabHeadDOM.children();
		    this._removeEvents('', tabs); // No I18N
		    tabs
		        .toArray()
		        .forEach((tab) => {
		            let tabData = this._getTabData(tab).actualData;
		            let $tab = $(tab);
		            if ($tab.attr('data-zd-created')) { // No I18N
		                $tab.remove();
		            } else {
		                $tab.show()
		                    .attr('class', tabData.origClass || '') // No I18N
		                    .find('i.ztabpanel__icon') // No I18N
		                    .remove();
		            }
		        });
		    this.element.removeClass('ztabpanel'); // No I18N
		}
		_setIconData  (actualTabData, icon) {
		    ZC._getIconInfo(actualTabData.iconClassName || actualTabData.iconClass, actualTabData.SVGIconId, null, 'ztabpanel__icon', icon); // No I18N
		}
		/* Function to handle keypress events */
		_keydownHandler  (orgEvent) {
		    if (!orgEvent.shiftKey || orgEvent.metaKey || orgEvent.ctrlKey || orgEvent.keyCode === 16) {
		        return;
		    }
		    if (document.activeElement.parentElement.parentElement === this._getTabHead()) {
		        let keyCode = orgEvent.keyCode || orgEvent.charCode;
		        let isVertical = this._data.isVertical;
		        let keyCodeToMoveToNextTab = ZC.keyCode[ isVertical ? 'DOWN' : 'RIGHT' ]; // No I18N
		        let keyCodeToMoveToPrevTab = ZC.keyCode[ isVertical ? 'UP' : 'LEFT' ]; // No I18N
		        switch (keyCode) {
		            case keyCodeToMoveToNextTab:
		                this._navNextPrevTab(false, undefined, orgEvent);
		                orgEvent.preventDefault();
		                break;
		            case keyCodeToMoveToPrevTab:
		                this._navNextPrevTab(true, undefined, orgEvent);
		                orgEvent.preventDefault();
		                break;
		            case ZC.keyCode.HOME:
		                this._navNextPrevTab(false, this._data.tabs.length, orgEvent);
		                orgEvent.preventDefault();
		                break;
		            case ZC.keyCode.END:
		                this._navNextPrevTab(true, 0, orgEvent);
		                orgEvent.preventDefault();
		                break;
		            default:
		        }
		    }
		}
		_setAdvAttribute  (optionName, value) {
		    let data = this._data;
		    let options = this._opts;
		    this._addedByComponent = true;
		    switch (optionName) {
		        case 'openOn': // No I18N
		            options[optionName] = value;
		            this._bindTabHead();
		            break;
		        case 'tabPosition': // No I18N
		            options[optionName] = value;
		            this._domChanged = data.widgetRender = true;
		            break;
		        case 'tabAlignment': // No I18N
		            options[optionName] = value;
		            this._setRenderData(data, options);
		            this._setClassName(data, options);
		            break;
		        case 'tabLabelType': // No I18N
		            options[optionName] = value;
		            this._setContentType(data, options);
		            data.tabs.forEach((tabData) => this._setTabData(tabData.actualData, tabData));
		            this._setClassName(data, options);
		            break;
		        case 'tabs': // No I18N
		            options[optionName] = value;
		            this._initTabs(data, options, true);
		            this._domChanged = data.widgetRender = true;
		            break;
		        case 'width': // No I18N
		        case 'height': // No I18N
		        case 'className': // No I18N
		        case 'zclassName': // No I18N
		            options[optionName] = value;
		            this._domChanged = data.widgetRender = true;
		            break;
		        case 'cacheData': // No I18N
		        case 'lazyLoadContent': // No I18N
		        case 'tabAnimation': // No I18N
		            options[optionName] = value;
		            break;
		        case 'isTabLabelHTMLEncoded': // No I18N
		            options[optionName] = value;
		            this._data.tabs.forEach((tabData) => {
		                this._setTabData(tabData.actualData, tabData);
		            });
		            break;
		    }
		    this._addedByComponent = false;
		}
		_setTabAttribute  (tabData, optionName, value) {
		    if (tabData) {
		        let actualTabData = tabData.actualData;
		        let tab = actualTabData.element;
		        if (optionName === 'disabled') { // No I18N
		            return this._disableTab(tabData, value);
		        } else if (optionName === 'hidden') { // No I18N
		            return this._hideTab(tabData, value);
		        } else if (optionName === 'active') { // No I18N
		            return value ? this._selectTab(tabData) : this._deselectTab(tabData);
		        } else if (optionName === 'panelId' || optionName === 'panelContent') { // No I18N
		            actualTabData.contentLoaded = false;
		            if (this._activeTab === tab) {
		                if (optionName === 'panelId') { // No I18N
		                    this._display(this._getPanel(actualTabData), false);
		                }
		                actualTabData[optionName] = value;
		                let pane = this._loadPane(tabData);
		                this._display(pane, true);
		            }
		        }
		        actualTabData[optionName] = value;
		        this._resetTabData = true;
		    }
		}
		setTabAttributes  (tabs, optionName, value) {
		    this._addedByComponent = true;
		    if (tabs) {
		        (this._toArr(tabs)).forEach((tab) => {
		            this._resetTabData = false;
		            let tabData = this._getTabData(tab);
		            if (tabData) {
		                if (typeof optionName === 'object' && !$.isEmptyObject(optionName)) { // No I18N
		                    for (let key in optionName) {
		                        this._setTabAttribute(tabData, key, optionName[key]);
		                    }
		                } else {
		                    this._setTabAttribute(tabData, optionName, value);
		                }
		                this._resetTabData && this._setTabData(tabData.actualData, tabData);
		            }
		        });
		    }
		    this._addedByComponent = false;
		}
		_disableTab  (tabs, disable = true) {
		    this._toArr(tabs).forEach((tab) => {
		        let tabData = this._getTabData(tab);
		        if (tabData) {
		            let actualTabData = tabData.actualData;
		            let tabEle = $(actualTabData.element);
		            if (disable && actualTabData.active) {
		                this._navNextPrevTab();
		                this._deselectTab(tabData);
		            }
		            actualTabData.disabled = disable = disable || null;
		            tabEle[disable ? 'addClass' : 'removeClass']('is-disabled'); // No I18N
		            tabEle.attr({
		                'aria-disabled': disable, // No I18N
		                'data-disabled': disable // No I18N
		            });
		        }
		    });
		}
		disableTab  (tab) {
		    this.setTabAttributes(tab, 'disabled', true); // No I18N
		}
		enableTab  (tab) {
		    this.setTabAttributes(tab, 'disabled', false); // No I18N
		}
		_hideTab  (tabs, hide = true) {
		    hide = hide || null;
		    let startIndex;
		    this._toArr(tabs).forEach((tab) => {
		        let tabData = this._getTabData(tab);
		        let tabEle;
		        let hideCallback = () => {
		            this._addedByComponent = true;
		            tabEle.attr({
		                'aria-hidden': hide, // No I18N
		                'data-hidden': hide // No I18N
		            });
		            this._trigger(hide ? 'tabhide' : 'tabshow', tabData); // No I18N
		            this._addedByComponent = false;
		        }
		        if (tabData) {
		            let actualTabData = tabData.actualData;
		            actualTabData.hidden = hide;
		            tabEle = $(actualTabData.element);
		            let hidden = tabEle[0].style.display === 'none'; // No I18N
		            if (hidden !== hide) {
		                if (hide && actualTabData.active) {
		                    let tabs = this._data.tabs;
		                    let index = tabs.indexOf(tabData);
		                    startIndex = index;
		                    this._deselectTab(tabData);
		                }
		                actualTabData.hidden = hide;
		                this._animate(tabEle, this._opts.tabAnimation, hide ? 'hide' : 'show', hideCallback); // No I18N
		            }
		        }
		    });
		    if (startIndex !== undefined) {
		        this._navNextPrevTab(false, startIndex);
		    }
		}
		showTab  (tab) {
		    this.setTabAttributes(tab, 'hidden', false); // No I18N
		}
		hideTab  (tab) {
		    this.setTabAttributes(tab, 'hidden', true); // No I18N
		}
	}
	ZC.registerComponent('ZTabPanel', ZTabPanel); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.ztabpanel.Templates, utilities = ZC.Templates.Utilities; 
template.WCChildren = (data) => { 
let responseTemplate = ZT.html ` ${!data.isBottom && template.WCTabHead(data)} ${data.tabBodyDOM || ZT.html `<z-tabbody class="${data.tabBodyClass}"> </z-tabbody>`} ${data.isBottom && template.WCTabHead(data)} `; return responseTemplate; } 
template.WCTabHead = (data) => { 
let responseTemplate = data.tabHeadDOM || ZT.html `<z-tabhead role=tablist class="${data.tabHeadClass}"> ${template.WCTabs(data.tabs)} </z-tabhead>`; return responseTemplate; } 
template.WCTabs = (data) => { 
let responseTemplate = data.map((tab) => template.WCTab(tab)); return responseTemplate; } 
template.WCTab = (data) => { 
let responseTemplate = data.element || ZT.html `<z-tab data-zd-created=true role="tab" ?title=${data.title} tabindex=-1 ?id="${data.id}" class="${data.className}" ?style="${data.style}" data-panel-id=${data.panelId} ?aria-disabled="${data.disabled ? 'true' : ''}" ?data-disabled=${data.disabled ? 'true' : ''} ?aria-hidden=${data.hidden ? 'true' : ''} ?data-hidden=${data.hidden ? 'true' : ''}>${template.WCTabContent(data)} </z-tab>`; return responseTemplate; } 
template.WCTabContent = (data) => { 
let responseTemplate = data.linkTag || ZT.html `<a tabindex="-1" href=#${data.panelId} > ${template.WCAnchorContent(data)} </a>`; return responseTemplate; }; 
template.WCAnchorContent = (data) => { 
let responseTemplate = ZT.html ` ${ZT.customHTML('')} ${data.customContent && ZT.customHTML(data.customContent)} ${data.icon && utilities.WCIcon(data.icon)} ${data.label && ZT.html `<span class="ztabpanel__text">${ZT.customHTML(data.label)}</span>`}`; return responseTemplate; } }(ZComponents)); 
 (function(ZC){ 
let template = ZC.ztabpanel.Templates, utilities = ZC.Templates.Utilities; 
template.children = (data) => { 
let responseTemplate = ZT.html ` ${!data.isBottom && template.tabHead(data)} ${data.tabBodyDOM || ZT.html `<div class="${data.tabBodyClass}"> </div>`} ${data.isBottom && template.tabHead(data)} `; return responseTemplate; } 
template.tabHead = (data) => { 
let responseTemplate = data.tabHeadDOM || ZT.html `<ul role=tablist class="${data.tabHeadClass}"> ${template.tabs(data.tabs)} </ul>`; return responseTemplate; } 
template.tabs = (data) => { 
let responseTemplate = data.map((tab) => template.tab(tab)); return responseTemplate; } 
template.tab = (data) => { 
let responseTemplate = data.element || ZT.html `<li data-zd-created=true role="tab" ?title=${data.title} tabindex=-1 ?id="${data.id}" class="${data.className}" ?style="${data.style}" data-panel-id=${data.panelId} ?aria-disabled="${data.disabled ? 'true' : ''}" ?data-disabled=${data.disabled ? 'true' : ''} ?aria-hidden=${data.hidden ? 'true' : ''} ?data-hidden=${data.hidden ? 'true' : ''}>${template.tabContent(data)} </li>`; return responseTemplate; } 
template.tabContent = (data) => { 
let responseTemplate = data.linkTag || ZT.html `<a tabindex="-1" href=#${data.panelId} > ${template.anchorContent(data)} </a>`; return responseTemplate; }; 
template.anchorContent = (data) => { 
let responseTemplate = ZT.html ` ${ZT.customHTML('')} ${data.customContent && ZT.customHTML(data.customContent)} ${data.icon && utilities.icon(data.icon)} ${data.label && ZT.html `<span class="ztabpanel__text">${ZT.customHTML(data.label)}</span>`}`; return responseTemplate; } }(ZComponents)); 
(function(ZC, $){
		class ZAdvancedTabPanel extends ZC.ZTabPanel {
			get name(){
				return "zadvancedtabpanel";
			}
		    get attrs() {
		        return {
		            closeableTabs: false,
		            reorderableTabs: false,
		            collapsible: false,
		            tabWidth: 'auto',	// No I18N
		            overflow: 'scroll', // No I18N
		            editable: false,
		            previousButtonIconClassName: null,
		            previousButtonSVGIconId: null,
		            nextButtonIconClassName: null,
		            nextButtonSVGIconId: null
		        }
		    }
		    get props() {
		        return {
		            overflowScrollSettings: {
		                distance: 100,
		                duration: 200
		            },
		            labels: {
		                nextButton: 'Next', // No I18N
		                previousButton: 'Previous'// No I18N
		            }
		        }
		    }
		    _getClassName() {
		        let className = super._getClassName(...arguments);
		        return 'zadvancedtabpanel ' + className; // No I18N
		    }
		    _postEachRender() {
		        let data = this._data;
		        if (this._overflowRender) {
		            let tabHeadDOM = data.tabHeadDOM;
		            tabHeadDOM.style.width = ''; // No I18N
		            if (data.exceeded) {
		                let actionBtnsData = data.actionButtons;
		                let actionBtnElement = this._getById(actionBtnsData.id);
		                let $tabHeadDOM = $(tabHeadDOM);
		                let actionBtnOffset = actionBtnElement.position();
		                let elementWidth = this.element.width();
		                tabHeadDOM.style.width = 'calc(100% - ' + (elementWidth - actionBtnOffset.left) + 'px)'; // No I18N
		                let prevBtn = this._getById(actionBtnsData.prevBtn.id);
		                let nextBtn = this._getById(actionBtnsData.nextBtn.id);
		                this._addEvents({
		                    prevBtnDown: 'mousedown' // No I18N
		                }, prevBtn);
		                this._addEvents({
		                    nextBtnDown: 'mousedown' // No I18N
		                }, nextBtn);
		                this._addEvents({
		                    navBtnUp: 'mouseup' // No I18N
		                }, this.element)
		                this._tabHeadProps = {
		                    width: $tabHeadDOM.outerWidth(),
		                    offset: $tabHeadDOM.offset(),
		                    scrollWidth: tabHeadDOM.scrollWidth - 2
		                }
		                this._storeAdvRef();
		                this._updateNavBtnsState();
		            }
		        } else {
		            super._postEachRender(...arguments);
		            if (!this._fromInit || data.widgetRender) {
		                this._updateOverFlowSettings();
		            }
		        }
		    }
		    _focusTab(tab) {
		        if (!this._skipFocus) {
		            super._focusTab(...arguments);
		        }
		    }
		    _selectTab(tab, orgEvent) {
		        if (super._selectTab(tab, orgEvent, true)) {
		            let tab = this._activeTab;
		            if (this._opts.overflow === 'scroll') {	// No I18N
		                this._moveTabHead(undefined, $(tab));
		            }
		            return tab;
		        }
		    }
		    _prevBtnDownHandler() {
		        this._scrollStarted = true;
		        this._currentDir = 'left'; // No I18N
		        // console.log('left');
		        this._moveTabHead(this._currentDir);
		    }
		    _nextBtnDownHandler() {
		        this._scrollStarted = true;
		        this._currentDir = 'right'; // No I18N
		        // console.log('right');
		        this._moveTabHead(this._currentDir);
		    }
		    _navBtnUpHandler() {
		        this._scrollStarted = false;
		    }
		    _moveTabHead(direction, tab, animate) {
		        if (tab || this._currentDir === direction) {
		            // console.log('scroll:', direction);
		            animate = animate === undefined ? true : animate;
		            let distance = this._opts.overflowScrollSettings.distance * (direction === 'left' ? -1 : 1); // No I18N
		            let tabHeadDOM = this._data.tabHeadDOM;
		            let $tabHeadDOM = $(tabHeadDOM);
		            if (this._opts.overflow === 'scroll' && this._data.exceeded) {	// No I18N
		                let scrollLeft,
		                    tabHeadProps = this._getBarDimensions();
		                if (tab) {
		                    var tableft = tab.offset().left - tabHeadProps.offset.left + tabHeadProps.scrollLeft;
		                    var hiddenL = tabHeadProps.scrollLeft - tableft;
		                    if (hiddenL > 0) {
		                        scrollLeft = tableft;
		                    } else {
		                        var hiddenR = Math.round((tableft + tab.outerWidth()) - (tabHeadProps.ulwidth + tabHeadProps.scrollLeft));
		                        if (hiddenR > 0) {
		                            scrollLeft = tabHeadProps.scrollLeft + hiddenR;
		                        } else {
		                            return;
		                        }
		                    }
		                } else {
		                    scrollLeft = tabHeadProps.scrollLeft + Number(distance);
		                }
		                if (animate) {
		                    $tabHeadDOM.finish().animate({
		                        scrollLeft: scrollLeft
		                    }, parseInt(this._opts.overflowScrollSettings.duration) || 'fast', 'linear', () => {	// No I18N
		                        if (tab) {
		                            this._focusTab(tab[0]);
		                        } else if (this._scrollStarted) {
		                            // console.log('scrollLeft', scrollLeft);
		                            if (direction === 'left' ? (scrollLeft > 0) : (scrollLeft < tabHeadProps.ulwidth)) { // No I18N
		                                this._moveTabHead(direction);
		                            }
		                        }
		                        this._updateNavBtnsState();
		                    });
		                } else {
		                    $tabHeadDOM.finish().scrollLeft(scrollLeft);
		                    if (tab) {
		                        this._focusTab(tab[0]);
		                    }
		                    this._updateNavBtnsState();
		                }
		            }
		        }
		    }
		    _storeAdvRef() {
		        let data = this._data;
		        this._prevBtnEle = this._getById(data.actionButtons.prevBtn.id);
		        this._nextBtnEle = this._getById(data.actionButtons.nextBtn.id)
		    }
		    _disableNavBtn(btn, disable = true) {
		        let disabled = btn.prop('disabled'); // No I18N
		        if (disabled !== disable) {
		            btn.prop('disabled', disable)[disable ? 'addClass' : 'removeClass']('is-disabled'); // No I18N
		        }
		    }
		    _updateNavBtnsState() {
		        let scrollLeft = this._data.tabHeadDOM.scrollLeft;
		        let tabHeadProps = this._tabHeadProps;
		        let disablePrevBtn = false;
		        let disableNextBtn = false;
		        if (scrollLeft) {
		            let scrollWidth = scrollLeft + tabHeadProps.width;
		            if (scrollWidth >= tabHeadProps.scrollWidth) {
		                disableNextBtn = true;
		            }
		        } else {
		            disablePrevBtn = true;
		        }
		        this._disableNavBtn(this._prevBtnEle, disablePrevBtn);
		        this._disableNavBtn(this._nextBtnEle, disableNextBtn);
		    }
		    _getBarDimensions() {
		        let dim = {};
		        let tabHeadDOM = this._data.tabHeadDOM;
		        let tabHeadProps = this._tabHeadProps;
		        dim.scrollWidth = tabHeadProps.scrollWidth; /* scrollWidth is 2px greater than the element width */
		        dim.ulwidth = tabHeadProps.width;
		        dim.offset = tabHeadProps.offset;
		        dim.scrollLeft = tabHeadDOM.scrollLeft;
		        dim.scrollRight = dim.scrollWidth - dim.scrollLeft - dim.ulwidth;
		        return dim;
		    }
		    _getById(id) {
		        return this.element.find('[id=' + id + ']'); // No I18N
		    }
		    _updateOverFlowSettings() {
		        let data = this._data;
		        let overflow = this._opts.overflow;
		        data.actionButtons = {
		            overflow,
		            id: this._getKeyID('actionBtns') // No I18N
		        };
		        let prevValue = !!this._data.exceeded;
		        let exceeded = this._data.exceeded = this._isExceeded();
		        if (exceeded && overflow === 'scroll') { // No I18N
		            data.actionButtons.prevBtn = ZC.ZButton.getBtnProps(this._getNavBtnProps('previousButton')); // No I18N
		            data.actionButtons.nextBtn = ZC.ZButton.getBtnProps(this._getNavBtnProps('nextButton')); // No I18N
		        }
		        if (prevValue !== exceeded) {
		            this._overflowRender = true;
		            this._render();
		            this._overflowRender = false;
		        }
		    }
		    _getNavBtnProps(name) {
		        let options = this._opts;
		        let SVGIconId = options[name + 'SVGIconId']; // No I18N
		        let iconClassName;
		        if (!SVGIconId) {
		            iconClassName = options[name + 'IconClassName'] || options[name + 'IconClass']; // No I18N
		            if (!iconClassName) {
		                SVGIconId = name === 'previousButton' ? 'zc__svg--arrowleft' : 'zc__svg--arrowright'; // No I18N
		            }
		        }
		        return ZC.ZButton.getBtnProps({
		            id: this._getKeyID(name),
		            rtl: this._opts.rtl,
		            templateRender: true,
		            ctype: 'button', // No I18N
		            className: 'ztabpanel__navbutton', // No I18N
		            iconClassName,
		            SVGIconId,
		            defaultIconClassName: 'ztabpanel__navbuttonicon', // No I18N
		            title: this._getI18NText(name)
		        });
		    }
		    _getKeyID(key) {
		        return 'z' + this._id + '-' + key; // No I18N
		    }
		    _isExceeded() {
		        let tabHead = this._data.tabHeadDOM;
		        let visibleWidth = tabHead.offsetWidth;
		        let actualWidth = tabHead.scrollWidth;
		        return actualWidth > visibleWidth;
		    }
		}
	ZC.registerComponent('ZAdvancedTabPanel', ZC.ZTabPanel, ZAdvancedTabPanel); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zadvancedtabpanel.Templates; 
template.WCChildren = (data) => { 
let responseTemplate = ZT.html ` ${!data.isBottom && template.WCTabHead(data)} ${data.exceeded && template.WCActionButtons(data.actionButtons)} ${data.tabBodyDOM || ZT.html `<zt-tabbody class="${data.tabBodyClass}"> </zt-tabbody>`} ${data.isBottom && template.WCTabHead(data)} `; return responseTemplate; } 
template.WCActionButtons = (data) => { 
let responseTemplate = ZT.html `<div id=${data.id} class="ztabpanel__navbuttons"> ${ZC.zbutton.Templates.WCContainer(data.prevBtn)} ${ZC.zbutton.Templates.WCContainer(data.nextBtn)} </div>`; return responseTemplate; } }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zadvancedtabpanel.Templates; 
template.children = (data) => { 
let responseTemplate = ZT.html ` ${!data.isBottom && template.tabHead(data)} ${data.exceeded && template.actionButtons(data.actionButtons)} ${data.tabBodyDOM || ZT.html `<zt-tabbody class="${data.tabBodyClass}"> </zt-tabbody>`} ${data.isBottom && template.tabHead(data)} `; return responseTemplate; } 
template.actionButtons = (data) => { 
let responseTemplate = ZT.html `<div id=${data.id} class="ztabpanel__navbuttons"> ${ZC.zbutton.Templates.container(data.prevBtn)} ${ZC.zbutton.Templates.container(data.nextBtn)} </div>`; return responseTemplate; } }(ZComponents)); 
(function(ZC, $){
		class ZColorBase  extends ZC.CoreComponent{
			get name(){
				return "zcolorbase";
			}
		    get attrs() {
		        return {
		            value: 'rgba(0,0,0,1)', // No I18N
		            colorModel: 'auto', // No I18N
		            pickerId: null,
		            pickerType: 'basic', // No I18N
		            forElement: null,
		            disabled: false,
		            // util options
		            appliedFor: 'fill', // No I18N
		            arrowIconClass: null,
		            arrowSVGIconId: null,
		            previewBorderStyle: null,
		            previewBorderWidth: null,
		            resetPickerOptions: false,
		            icon: false,
		            width: null,
		            iconClass: null,
		            SVGIconId: null,
		            rtl: null,
		            locale: null,
		            tabIndex: null
		        }
		    }
		    get props() {
		        return {
		            iconClassName: null,
		            arrowIconClassName: null,
		            pickerOptions: {},
		            labels: {
		                noStroke: 'No Stroke', // No I18N
		                noColor: 'No Fill', // No I18N
		                'aria-label': 'Current selected color is #value#' // No I18N
		            }
		        }
		    }
		    get CLASSES() {
		        return {
		            CONTAINER: 'zcolorbase', // No I18N
		            ACTIVE: 'is-active', // No I18N
		            PREVIEW: 'zcolorbutton__preview', // No I18N
		            ICON: 'zbutton__icon', // No I18N
		            ARROW: 'zcolorfield__arrow' // No I18N
		        }
		    }
		    get EVENTS() {
		        return [
		            'change', // No I18N
		            'select', // No I18N
		            'pick', // No I18N
		            'beforepickeropen', // No I18N
		            'pickeropen', // No I18N
		            'beforepickerclose', // No I18N
		            'pickerclose', // No I18N
		            'colorpanmouseover', // No I18N
		            'colorpanmouseout', // No I18N
		            'colorpanclick', // No I18N
		            'beforefocus', // No I18N
		            'focus', // No I18N
		            'blur', // No I18N
		            'click' // No I18N
		        ]
		    }
		    _init(element, options) {
		        this._fromInit = true;
		        this._id = this._getID();
		        this._namespace = '.zcolorbase'; // No I18N
		        options.value = options.value || element[0].value;
		        this._setInitial();
		        this._fromInit = false;
		    }
		    _postEachRender() {
		        let data = this._data;
		        let options = this._opts;
		        if (!data.rendered || this._domChanged) {
		            let width = options.width || (!this._useParent && this.element[0].style.width);
		            if (width) {
		                this.container[0].style.width = isNaN(width) ? width : (width + 'px'); // No I18N
		            }
		        }
		        this._storeRef(data, options);
		        this._setClassName(data, options);
		        this._updateElementValue(data, options);
		        if (this._reopen) {
		            this._open();
		            this._reopen = false;
		        }
		    }
		    _preRender() {
		        this._setRenderData(this._data, this._opts, this.element);
		        return this._data;
		    }
		    _setRenderData(data, options, element) {
		        let selectedInstance = this._selectedInstance;
		        data.opened = this._opened;
		        data.nofill = !options.icon && this._noFill;
		        data.color = selectedInstance.getColor();
		        let attrs = data.attrs = data.attrs || {};
		        attrs['aria-label'] = this._getI18NText('aria-label').replace(/#value#/g, selectedInstance.getColor('hexa')) // No I18N
		        if (!data.rendered || this._domChanged) {
		            let colorMode = data.colorMode = options.colorModel;
		            if (!ZC.ColorUtil.REGEX.colorMode.test(colorMode)) {
		                data.colorModel = this._getClrInstance(options.value).format;
		                options.colorModel = 'auto'; // No I18N
		            }
		            data.alwaysSetAttrs = true;
		            data.pickerId = options.pickerId;
		            data.disabled = options.disabled || element[0].disabled;
		            attrs.tabindex = !data.disabled && (options.tabIndex || element[0].tabIndex);
		            data.rtl = options.rtl;
		            data.stroke = options.appliedFor === 'stroke'; // No I18N
		            data.icon = data.arrow = data.previewStyleAttr = false;
		            // Valid for icon
		            if (options.icon) {
		                ZC._getIconInfo(options.iconClassName || options.iconClass, options.SVGIconId, null, null, data.icon = {}); // No I18N
		            }
		            if (!this.isCE) {
		                // let style = element
		                //     .attr('style')// No I18N
		                //     .replace(/(?<=;|^)(\s)*(width|height|display)(\s)*:(\s)*[^;]*;?/g, ''); // No I18N
		                // attrs.style = style;
		                attrs.title = element.attr('title'); // No I18N
		            }
		            // Arrow Data
		            if (options.arrowIcon) {
		                data.arrow = {
		                    disabled: data.disabled,
		                    rtl: data.rtl,
		                    isCE: this.isCE
		                }
		                this._setArrowData(data, options);
		            }
		        }
		        // Valid for stroke
		        if (data.stroke || data.icon) {
		            data.previewStyleAttr = this._getStyle({
		                'border-color': data.color, // No I18N
		                'border-style': options.previewBorderStyle || 'solid', // No I18N
		                'border-width': options.previewBorderWidth || (data.icon ? '0px 0px 2px 0px' : '3px') // No I18N
		            });
		        }
		        this._setTogglerData(attrs, options);
		    }
		    _setArrowData(data, options) {
		        let CLASSES = this._CLASSES;
		        ZC._getIconInfo(options.arrowIconClassName || options.arrowIconClass, options.arrowSVGIconId, 'zc__svg--downarrow ' + CLASSES.ARROWSVGICON, ((CLASSES.ICON || '') + ' ' + (CLASSES.ARROW || '')), data.arrow); // No I18N
		    }
		    _setTogglerData(attrs, options) {
		        Object.assign(attrs, {
		            'aria-owns': options.pickerId, // No I18N
		            'aria-haspopup': true, // No I18N
		            'aria-expanded': this._opened // No I18N
		        });
		    }
		    _setClassName(data, options, className = '') { // No I18N
		        let CLASSES = this._CLASSES;
		        let addClass = (classToAdd) => {
		            if (classToAdd) {
		                className += (' ' + classToAdd); // No I18N
		            }
		        }
		        addClass(CLASSES.CONTAINER);
		        addClass(options.zclassName || options.className);
		        if (this._opened) {
		            addClass(CLASSES.ACTIVE);
		        }
		        if (data.disabled) {
		            addClass('is-disabled');// No I18N
		        }
		        if (data.rtl) {
		            addClass('zh-rtl'); // No I18N
		        }
		        data.className = className;
		    }
		    _bindEvents() {
		        this._addEvents({
		            focus: 'focusin', // No I18N
		            blur: 'focusout', // No I18N
		            click: 'click' // No I18N
		        }, this.container);
		        this._addEvents({
		            toggleBtnClick: 'mousedown', // No I18N
		            toggleBtnKeydown: 'keydown' // No I18N
		        }, this._toggler);
		    }
		    _toggleBtnClickHandler(orgEvent) {
		        if (!orgEvent.button) {
		            this._togglePicker(orgEvent);
		        }
		    }
		    _toggleBtnKeydownHandler(orgEvent) {
		        let code = orgEvent.keyCode,
		            keyCodes = ZC.keyCode;
		        if (code === keyCodes.ENTER || code === keyCodes.SPACE || (code === keyCodes.DOWN && this._data.arrow)) {
		            this._togglePicker(orgEvent);
		            if (code === keyCodes.DOWN) {
		                orgEvent.preventDefault();
		            }
		        }
		    }
		    _focusHandler(orgEvent) {
		        clearTimeout(this._blurTimer);
		        if (!this._focussed) {
		            this._trigger('focus', orgEvent); // No I18N
		        }
		        this._focussed = true;
		    }
		    _blurHandler(orgEvent) {
		        clearTimeout(this._blurTimer);
		        this._blurTimer = setTimeout(() => {
		            this._focussed = false;
		            this._trigger('blur', orgEvent); // No I18N
		        });
		    }
		    _clickHandler(orgEvent) {
		        if (!this._opts.disabled) {
		            this._trigger('click', orgEvent); // No I18N
		        }
		    }
		    _storeRef(data, options) {
		        if (!data.rendered || this._domChanged) {
		            this._previewBox = false;
		            let CLASSES = this._CLASSES,
		                container = this.container;
		            let previewBox = container.find('.' + CLASSES.PREVIEW); // No I18N
		            if (previewBox.length) {
		                this._previewBox = previewBox;
		            }
		            this._toggler = container;
		        }
		    }
		    _setInitial() {
		        let options = this._opts;
		        let colorInstance = this._getClrInstance(options.value);
		        if (options.value !== 'none' && options.value !== 'transparent' && !colorInstance.isValid()) { // No I18N
		            options.value = this._DEFAULTS.value;
		        }
		        this._setValue(options.value);
		    }
		    _getClrInstance(color) {
		        return ZC.ColorUtil.getColorInstance(color);
		    }
		    _setPickerAttributes(orgEvent) {
		        let options = this._opts;
		        let data = this._data;
		        let currentField = this._currentClrField;
		        let pickerOptions = data.picker;
		        let pickerComp = 'colorpicker'; // No I18N
		        let createMethod = 'createColorPicker';// No I18N
		        if (options.pickerType === 'advanced') {// No I18N
		            pickerComp = 'advancedcolorpicker';// No I18N
		            createMethod = 'createAdvancedColorPicker';// No I18N
		        }
		        if (!pickerOptions) {
		            let pickerId = options.pickerId || 'picker-' + this._id; // No I18N
		            pickerOptions = data.picker = {
		                ...{
		                    noColorButtonLabel: this._getI18NText(data.stroke ? 'noStroke' : 'noColor'), // No I18N
		                    forElement: this._opts.forElement || this.container
		                },
		                ...(options.pickerOptions || {}),
		                ...{
		                    valueColorModel: options.colorModel,
		                    type: 'popup', // No I18N
		                    rtl: options.rtl,
		                    locale: options.locale,
		                    isCE: options.isCE,
		                    id: pickerId,
		                    ctype: pickerComp,
		                    beforedestroy: this._pickerDestroyHandler.bind(this)
		                }
		            };
		            this._toggler.attr('aria-owns', pickerId); // No I18N
		        }
		        let picker = this._picker = $('#' + pickerOptions.id); // No I18Ns
		        pickerOptions.value = this._noFill ? 'transparent' : this.getValue(); // No I18N
		        if (picker && picker.length) {
		            let componentName = this._getPickerName();
		            if (componentName) {
		                let pickerInstance = ZC[componentName](picker);
		                if (!this._opened) {
		                    pickerInstance.close(orgEvent);
		                }
		                if (pickerComp === componentName) {
		                    if (options.pickerId) {
		                        if (options.resetPickerOptions) {
		                            pickerOptions = $.extend(true, {}, pickerInstance._DEFAULTS, pickerOptions);
		                        }
		                        if (componentName === 'colorpicker') { // No I18N
		                            let advancedPickerOptions = pickerOptions.advancedPickerOptions = pickerOptions.advancedPickerOptions || {};
		                            advancedPickerOptions.currentColorField = currentField;
		                        } else {
		                            pickerOptions.currentColorField = currentField;
		                        }
		                        pickerInstance.setAttributes(pickerOptions);
		                    } else if (this._updateAdvPicker) {
		                        pickerInstance.setAttributes(pickerOptions);
		                        this._updateAdvPicker = false;
		                    }
		                    return;
		                }
		                this._destroyPicker();
		            }
		        }
		        this._picker = picker = $(ZC[createMethod](pickerOptions));
		        pickerOptions.instance = ZC[pickerComp](picker);
		    }
		    _pickerDestroyHandler() {
		        this._picker = this._opened = false;
		        this._updateUI();
		    }
		    _destroyPicker() {
		        if (this._picker) {
		            let picker = this._picker;
		            this._callPickerMethod('destroy'); // No I18N
		            if (this.isCE) {
		                picker.remove();
		            }
		        }
		    }
		    _bindPickerEvents() {
		        let picker = this._picker;
		        let pickerNamespace = 'z' + this._data.picker.ctype; // No I18N
		        let prefix = this.isCE ? 'z' : pickerNamespace; // No I18N
		        let namespace = '.' + this.name + '.' + pickerNamespace; // No I18N
		        picker.off(namespace);
		        [
		            'select', // No I18N
		            'pick', // No I18N
		            'close', // No I18N
		            'beforeClose', // No I18N
		            'open', // No I18N
		            'beforeOpen', // No I18N
		            'colorPanMouseOver', // No I18N
		            'colorPanMouseOut', // No I18N
		            'colorPanClick', // No I18N
		            'focus' ]// No I18N
		            .forEach((eventName) => {
		                picker.on(prefix + eventName.toLowerCase() + namespace, this._pickerCallback.bind(this, this['_' + eventName + 'Handler'])); // No I18N
		            });
		    }
		    _pickerCallback(callback, orgEvent) {
		        let data = orgEvent.detail;
		        orgEvent = orgEvent.originalEvent;
		        if (this.isCE) {
		            data = orgEvent.detail;
		            orgEvent = orgEvent.originalEvent;
		        }
		        callback.call(this, orgEvent, data);
		    }
		    _colorPanMouseOverHandler(orgEvent, data) {
		        this._trigger('colorpanmouseover', orgEvent, data); // No I18N
		    }
		    _colorPanMouseOutHandler(orgEvent, data) {
		        this._trigger('colorpanmouseout', orgEvent, data); // No I18N
		    }
		    _colorPanClickHandler(orgEvent, data) {
		        this._trigger('colorpanclick', orgEvent, data); // No I18N
		    }
		    _openHandler(orgEvent, data) {
		        this._opened = true;
		        this._updateUI();
		        this._trigger('pickeropen', orgEvent, data); // No I18N
		    }
		    _beforeOpenHandler() {
		        // this._callPickerMethod('setValue', this._noFill ? 'transparent' : this.getValue()); // No I18N
		    }
		    _closeHandler(orgEvent, data) {
		        this._opened = false;
		        this._currentClrField = data.options.currentColorField;
		        this._updateUI();
		        if (!orgEvent || orgEvent.currentTarget === document) {
		            this._blurHandler(orgEvent);
		        } else {
		            this.setFocus(orgEvent);
		        }
		        this._removeEvents('', this._picker); // No I18N
		        this._trigger('pickerclose', orgEvent, data); // No I18N
		    }
		    _beforeCloseHandler(orgEvent, data) {
		        return this._trigger('beforepickerclose', orgEvent, data); // No I18N
		    }
		    _open(orgEvent) {
		        if (this._trigger('beforepickeropen', orgEvent)) { // No I18N
		            this._setPickerAttributes(orgEvent);
		            this._bindPickerEvents();
		            this._callPickerMethod('open', undefined, orgEvent); // No I18N
		        }
		    }
		    _close(orgEvent) {
		        this._opened && this._callPickerMethod('close', orgEvent); // No I18N
		    }
		    _selectHandler(orgEvent, data) {
		        if (this._opened) {
		            if (data.fromUI) {
		                this._trigger('select', orgEvent, data); // No I18N
		            }
		        }
		    }
		    _pickHandler(orgEvent, data) {
		        if (this._opened) {
		            if (data.fromUI) {
		                this._setValue(data.rgb, orgEvent, data, false);
		                this._trigger('pick', orgEvent, data); // No I18N
		            }
		        }
		    }
		    _setValue(color, orgEvent, data, updatePicker = true) {
		        let isNoFill = color === 'none' || color === 'transparent'; // No I18N
		        let colorInstance = this._getClrInstance(isNoFill ? 'transparent' : color); // No I18N
		        if (colorInstance.isValid()) {
		            let prevColor = this._selectedInstance && this._selectedInstance.getColor();
		            this._selectedInstance = colorInstance;
		            this._noFill = data && data.noColorButtonClick || isNoFill;
		            this._updateUI();
		            let currentColor = colorInstance.getColor();
		            if (prevColor !== currentColor) {
		                if (this._opened && updatePicker) {
		                    this._callPickerMethod('setValue', currentColor); // No I18N
		                } else {
		                    this._updateAdvPicker = updatePicker;
		                }
		                this._trigger('change', orgEvent, data); // No I18N
		            }
		        }
		    }
		    _updateElementValue(data, options) {
		        options.value = this._noFill ? 'transparent' : this._selectedInstance.getColor(data.colorMode, undefined, this._opts.colorModel === 'auto'); // No I18N
		    }
		    _trigger(customEvent, orgEvent, data) {
		        if (!this._fromInit) {
		            let selectedInstance = this._selectedInstance;
		            let picker = this._picker;
		            data = data || {};
		            data.value = data.color = this.getValue();
		            data.rgb = selectedInstance.getColor();
		            data.opacity = selectedInstance.getAlpha();
		            data.colorData = selectedInstance.getObject(this._data.colorMode);
		            data.picker = picker && picker[0];
		            orgEvent = orgEvent && orgEvent.originalEvent ? orgEvent.originalEvent : undefined;
		            return this._dispatchEvent(customEvent, orgEvent, data, undefined, !!orgEvent);
		        }
		        return true;
		    }
		    _togglePicker(orgEvent) {
		        if (!this._opts.disabled) {
		            if (this._opened) {
		                (!orgEvent || orgEvent.type !== 'keydown') && this._close(orgEvent); // No I18N
		            } else {
		                this._open(orgEvent);
		            }
		        }
		    }
		    _callPickerMethod(methodName, arg1, arg2) {
		        ZC[this._getPickerName()](this._picker)[methodName](arg1, arg2);
		    }
		    _getPickerName() {
		        let pickerData = this._picker.data();
		        return pickerData.zcolorpicker ? 'colorpicker' : pickerData.zadvancedcolorpicker ? 'advancedcolorpicker' : undefined; // No I18N
		    }
		    _updateUI() {
		        if (this._data.rendered && !this._domChanged) {
		            this._render();
		        }
		    }
		    _disable(value) {
		        this._domChanged = true;
		        super._disable(value);
		        this.closePicker();
		    }
		    _setAdvAttribute(optionName, value) {
		        let options = this._opts;
		        if (/^(pickerId|pickerType|pickerOptions|appliedFor|rtl|locale|forElement|colorModel)$/.test(optionName)) {
		            options[optionName] = value;
		            this._reopen = this._opened;
		            this._domChanged = this._updateAdvPicker = true;
		            if (optionName === 'pickerId') {// No I18N
		                this.closePicker();
		            }
		            this._data.picker = false;
		        } else if (/^(icon|iconClassName|iconClass|SVGIconId|arrowIconClassName|arrowIconClass|arrowSVGIconId|previewBorderWidth|previewBorderStyle|tabIndex|width)$/.test(optionName)) {
		            options[optionName] = value;
		            this._domChanged = true;
		        }
		    }
		    _setAttribute(optionName, value) {
		        let response;
		        this._addedByComponent = true;
		        if (optionName === 'value') {// No I18N
		            this._domChanged = true;
		            this.setValue(value);
		        } else {
		            response = this._setAdvAttribute(optionName, value);
		        }
		        this._addedByComponent = false;
		        return response;
		    }
		    setFocus(orgEvent) {
		        if (this._trigger('beforefocus', orgEvent)) { // No I18N
		            this._toggler.focus();
		        }
		    }
		    openPicker(orgEvent) {
		        this._open(orgEvent);
		    }
		    closePicker(orgEvent) {
		        this._close(orgEvent);
		    }
		    getValue() {
		        return this._opts.value;
		    }
		    setValue(color, orgEvent) {
		        this._setValue(color, orgEvent);
		    }
		    _destroy() {
		        this._destroyPicker();
		        clearTimeout(this._focusTimer);
		        clearTimeout(this._blurTimer);
		        this.element.empty();
		    }
		}
	ZC.registerComponent('ZColorBase', ZColorBase); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
		class ZColorChooser extends ZC.ZColorBase {
			get name(){
				return "zcolorchooser";
			}
		    get CLASSES() {
		        return {
		            CONTAINER: 'zcolorchooser', // No I18N
		            ACTIVE: 'is-selected' // No I18N
		        }
		    }
		    _render() {
		        this._useParent = true;
		        this._preRender();
		        this._postEachRender();
		        this._data.rendered = true;
		    }
		    _storeRef() {
		        this._toggler = this.container = this.element;
		    }
		}
	ZC.registerComponent('ZColorChooser', ZC.ZColorBase, ZColorChooser); 
})(ZComponents, ZComponents.DOMUtil);
(function(ZC, $){
		class ZColorSelect extends ZC.ZColorBase {
			get name(){
				return "zcolorselect";
			}
		    get attrs() {
		        return {
		            tabIndex: 0,
		            arrowIcon: true
		        }
		    }
		    get CLASSES() {
		        return {
		            CONTAINER: 'zselectbox zcolorselect zselectbox--icononly', // No I18N
		            ICON: 'zselectbox__icon', // No I18N
		            PREVIEW: 'zcolorselect__preview', // No I18N
		            ARROWSVGICON: 'zselectbox__arrow' // No I18N
		        }
		    }
		    _bindEvents() {
		        super._bindEvents();
		        this._handleFocus(this.container);
		    }
		    _setRenderData() {
		        super._setRenderData(...arguments);
		        this._data.attrs.role = 'button'; // No I18N
		    }
		    _setClassName(data, options) {
		        super._setClassName(data, options, data.arrow ? '' : 'zcolorselect--withoutarrow'); // No I18N
		    }
		    _setAttribute(optionName, value) {
		        if (/^(arrowIcon)$/.test(optionName)) { // No I18N
		            this._opts[optionName] = value;
		            this._domChanged = true;
		        } else {
		            super._setAttribute(optionName, value);
		        }
		    }
		}
	ZC.registerComponent('ZColorSelect', ZC.ZColorBase, ZColorSelect); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zcolorselect.Templates; 
let utilities = ZC.Templates.Utilities; 
template.WCContainer = (data) => ZT.html `<div>${data.children && template.WCChildren(data)}</div>`; 
template.WCChildren = (data) => ZT.html `<div class="zselectbox__selected"> ${ data.nofill ? ZT.html `<span class="zcolorbutton__preview zh-nofill"></span>` : (data.icon || data.stroke) ? ZT.html `<span class="zcolorselect__preview" style="${data.previewStyleAttr}">${data.icon && utilities.WCIcon(data.icon)}</span>` : ZT.html `<span class="zcolorselect__preview zh-transparentbg"><canvas style="background-color: ${data.color};"></canvas></span>` } </div> ${data.arrow && utilities.WCIcon(data.arrow)}`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zcolorselect.Templates; 
let utilities = ZC.Templates.Utilities; 
template.container = (data) => ZT.html `<div>${data.children && template.children(data)}</div>`; 
template.children = (data) => ZT.html `<div class="zselectbox__selected"> ${ data.nofill ? ZT.html `<span class="zcolorbutton__preview zh-nofill"></span>` : (data.icon || data.stroke) ? ZT.html `<span class="zcolorselect__preview" style="${data.previewStyleAttr}">${data.icon && utilities.icon(data.icon)}</span>` : ZT.html `<span class="zcolorselect__preview zh-transparentbg"><canvas style="background-color: ${data.color};"></canvas></span>` } </div> ${data.arrow && utilities.icon(data.arrow)}`; }(ZComponents)); 
(function(ZC, $){
		class ZColorButton extends ZC.ZColorBase {
			get name(){
				return "zcolorbutton";
			}
		    get CLASSES() {
		        return {
		            CONTAINER: 'zbutton zcolorbutton', // No I18N
		            ACTIVE: 'is-selected' // No I18N
		        }
		    }
		    _bindEvents() {
		        super._bindEvents();
		        this._handleFocus(this._toggler);
		    }
		}
	ZC.registerComponent('ZColorButton', ZC.ZColorBase, ZColorButton); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zcolorbutton.Templates; 
let utilities = ZC.Templates.Utilities; 
template.WCContainer = (data) => ZT.html `<button>`; 
template.WCChildren = (data) => ZT.html `${ data.nofill ? ZT.html `<span class="zcolorbutton__preview zh-nofill"></span>` : (data.icon || data.stroke) ? ZT.html `<span class="zcolorbutton__preview" style="${data.previewStyleAttr}">${data.icon && utilities.WCIcon(data.icon)}</span>` : ZT.html `<span class="zcolorbutton__preview zh-transparentbg"><canvas style="background-color: ${data.color};"></canvas></span>` 	}`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zcolorbutton.Templates; 
let utilities = ZC.Templates.Utilities; 
template.container = (data) => ZT.html `<button>`; 
template.children = (data) => ZT.html `${ data.nofill ? ZT.html `<span class="zcolorbutton__preview zh-nofill"></span>` : (data.icon || data.stroke) ? ZT.html `<span class="zcolorbutton__preview" style="${data.previewStyleAttr}">${data.icon && utilities.icon(data.icon)}</span>` : ZT.html `<span class="zcolorbutton__preview zh-transparentbg"><canvas style="background-color: ${data.color};"></canvas></span>` 	}`; }(ZComponents)); 
(function(ZC, $){
		class ZColorSplitButton extends ZC.ZColorBase {
			get name(){
				return "zcolorsplitbutton";
			}
		    get CLASSES() {
		        return {
		            ARROW: 'zcolorfield__arrow', // No I18N
		            ARROWSVGICON: 'zbutton__svg zbutton__splitarrow', // No I18N
		            CONTAINER: 'zcolorsplitbutton zbutton--split zbutton--splitnormal', // No I18N
		            ACTIVE: 'is-selected' // No I18N
		        }
		    }
		    get EVENTS() {
		        return [
		            'arrowclick' // No I18N
		        ]
		    }
		    _bindEvents() {
		        super._bindEvents();
		        let button = this.container.find('button'); // No I18N
		        this._handleFocus($(button[0]));
		        this._handleFocus($(button[1]));
		        this._addEvents({
		            previewClick: 'mousedown' // No I18N
		        }, $(button[0]));
		    }
		    _setRenderData(data, options, element) {
		        options = {
		            ...options,
		            ...{
		                arrowIcon: true,
		                tabindex: -1
		            }
		        }
		        super._setRenderData(data, options, element);
		    }
		    _setArrowData(data, options) {
		        let SVGIconId = options.arrowSVGIconId;
		        let iconClassName;
		        if (!SVGIconId) {
		            iconClassName = options.arrowIconClassName || options.arrowIconClass;
		            if (!iconClassName) {
		                SVGIconId = 'zc__svg--downarrow'; // No I18N
		            }
		        }
		        if (SVGIconId) {
		            SVGIconId += (' ' + this._CLASSES.ARROWSVGICON); // No I18N
		        }
		        data.arrow = ZC.ZButton.getBtnProps({
		            ...data.arrow,
		            ...{ // object.assign doesn't assign the properties present inside proto object. (ie. Creating objects via Object.create )
		                id: this._id + 'arrow', // No I18N
		                templateRender: true,
		                iconClassName,
		                SVGIconId,
		                defaultIconClassName: this._CLASSES.ARROW
		            }
		        });
		    }
		    _setTogglerData(attrs, options) {
		        attrs = this._data.arrow.customAttributes = {};
		        super._setTogglerData(attrs, options);
		        attrs.zclassName = 'zcolormenubutton'; // No I18N
		        if (this._toggler) {
		            this._toggler[this._opened ? 'addClass' : 'removeClass']('is-selected'); // No I18N
		        }
		    }
		    _toggleBtnClickHandler(orgEvent) {
		        if (!orgEvent.button) {
		            this._trigger('arrowclick', orgEvent, { // No I18N
		                arrowClick: true
		            });
		            super._toggleBtnClickHandler(orgEvent);
		        }
		    }
		    _previewClickHandler(orgEvent) {
		        this.closePicker(orgEvent);
		    }
		    _storeRef(data, options) {
		        if (!data.rendered || this._domChanged) {
		            super._storeRef(...arguments);
		            let arrow = data.arrow;
		            this._toggler = arrow.mainElement = this.container.find('.' + this._CLASSES.ARROW).parent(); // No I18N
		        }
		    }
		}
	ZC.registerComponent('ZColorSplitButton', ZC.ZColorBase, ZColorSplitButton); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zcolorsplitbutton.Templates; 
let utilities = ZC.Templates.Utilities; 
template.WCContainer = (data) => ZT.html `<div>${data.children && template.WCChildren(data)}</div>`; 
template.WCChildren = (data) => { 
let responseTemplate = ZT.html ` <button ?disabled=${data.disabled} ?aria-disabled=${data.disabled} role="button" type="button" class="zcolorbutton zbutton zbutton--icononly ${data.disabled ? 'is-disabled' : ''}"> ${data.nofill ? ZT.html `<span class="zcolorbutton__preview zh-nofill"></span>` : (data.icon || data.stroke) ? ZT.html `<span class="zcolorbutton__preview" style="${data.previewStyleAttr}">${data.icon && utilities.WCIcon(data.icon)}</span>` : ZT.html `<span class="zcolorbutton__preview zh-transparentbg"><canvas style="background-color: ${data.color};"></canvas></span>` } </button> ${ZC.zbutton.Templates.WCContainer(data.arrow)}`; return responseTemplate; } }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zcolorsplitbutton.Templates; 
let utilities = ZC.Templates.Utilities; 
template.container = (data) => ZT.html `<div>${data.children && template.children(data)}</div>`; 
template.children = (data) => { 
let responseTemplate = ZT.html ` <button ?disabled=${data.disabled} ?aria-disabled=${data.disabled} role="button" type="button" class="zcolorbutton zbutton zbutton--icononly ${data.disabled ? 'is-disabled' : ''}"> ${data.nofill ? ZT.html `<span class="zcolorbutton__preview zh-nofill"></span>` : (data.icon || data.stroke) ? ZT.html `<span class="zcolorbutton__preview" style="${data.previewStyleAttr}">${data.icon && utilities.icon(data.icon)}</span>` : ZT.html `<span class="zcolorbutton__preview zh-transparentbg"><canvas style="background-color: ${data.color};"></canvas></span>` } </button> ${ZC.zbutton.Templates.container(data.arrow)}`; return responseTemplate; } }(ZComponents)); 
(function(ZC, $){
		/* $Id$ */
		class ZCarousel  extends ZC.CoreComponent{
			get name(){
				return "zcarousel";
			}
		    get attrs() {
		        return {
		            autoPlay: false,
		            transitionDuration: 500,
		            autoPlayInterval: 2000,
		            pauseOnHover: true,
		            showArrowIcon: true,
		            pagination: true,
		            filmStrip: true,
		            infoButton: false,
		            showImageCount: true,
		            slideShow: true,
		            effect: 'default',	// No I18N
		            display: 'dialog',	// Option to be provided inline|dialog 	//No I18N
		            labels: {
		                next: 'Next',	// No I18N
		                previous: 'Previous',	// No I18N
		                closeButton: 'Ok, Got it',	// No I18N
		                fullScreen: 'Full Screen', // No i18n
		                close: 'Close', // No i18n
		                info: 'Info', // No i18n
		                slideshow: 'SlideShow', // No i18n
		                filmstrip: 'Filmstrip View', // No i18n
		                showFilmStrip: 'Show Filmstrip', // No i18n
		                hideFilmStrip: 'Hide Filmstrip', // No i18n
		                play: 'Play', // No i18n
		                pause: 'Pause', // No i18n
		                morefilesselected: '{0} images selected.', // No i18n
		                selectedimageposition: '{0} of {1}', // No i18n
		                notFound: 'Image not Found', // No I18N
		                unableToLoad: 'Unable to Load Image. Please try again', // No I18N
		                imageResolution: 'Resolution', // No I18N
		                imageSize: 'Size', // No I18N
		                retry: 'Retry' // No I18N
		            }
		        }
		    }
		    get EVENTS() {
		        return [ 'open', 'beforechange', 'afterchange', 'close' ]	// No I18N
		    }
		    _init(element, _opts) {
		        let data = this._data,
		            slideContainer = this.element.children().first(),
		            slidesCount;
		        data.pagination = _opts.pagination;
		        data.slideCount = slidesCount = slideContainer.children().length;
		        this._autoPlayTimer = undefined;
		        element.addClass('zcarousel zcarousel--' + _opts.display);	// No I18N
		        slideContainer.addClass('zcarousel-slides');	// No I18N
		        if (slidesCount) {
		            if (_opts.showArrowIcon) {
		                data.arrow = ZC._getIconInfo(_opts.arrowIconClassName || _opts.arrowIconClass, _opts.arrowSVGIconId, '#zc__svg--downarrow zcarousel__svg', 'zcarousel__icon');	// No I18N
		                data.prevLabel = this._getI18NText('previous');	// No I18N
		                data.nextLabel = this._getI18NText('next'); // No I18N
		            }
		            data.bullets = [];
		            for (let i = 0; i < slidesCount; i++) {
		                data.bullets.push({
		                    className: (_opts.bulletClassName || _opts.bulletClass || '')
		                });	// No I18N
		            }
		        }
		        this._createThumbnail();
		        this._createFooterButtons();
		    }
		    _createThumbnail() {
		        let elements = this.element.children().children(),
		            data = this._data;
		        data.thumbnail = [];
		        if (!this._opts.thumbnail && elements) {
		            for (let ele of elements) {
		                data.thumbnail.push({
		                    src: $(ele).find('img')[0].getAttribute('src')
		                });
		            }
		        }
		    }
		    _createFooterButtons() {
		        let opts = this._opts,
		            data = this._data, footerButtons = [];
		        opts.filmStrip && footerButtons.push(this._getBtnProps('filmstrip'));
		        opts.infoButton && footerButtons.push(this._getBtnProps('info'));
		        opts.slideShow && footerButtons.push(this._getBtnProps('slideshow'));
		        data.footerButtons = footerButtons;
		    }
		    _getBtnProps(name, type) {
		        return ZC.ZButton.getBtnProps({
		            title: this._getI18NText(name),
		            type: 'icon' || type, // No I18N
		            className: `zcarousel__button zcarousel--${name}`, // No I18N
		            iconClassName: this._opts[`${name}iconClassName`], // No I18N
		            SVGIconId: this._opts[`${name}SVGIconId`], // No I18N
		            defaultSVGIconId: `zsg-${name}-icon`, // No I18N
		            templateRender: true
		        });
		    }
		    _render() {
		        let mainElement = this.element,
		            _opts = this._opts;
		        if (_opts.display === 'dialog') {	// No I18N
		            let dialogWidth = mainElement.outerWidth(true),
		                dialogHeight = mainElement.outerHeight(true),
		                dialogLeft = ((window.innerWidth - dialogWidth) / 2),
		                dialogTop = (window.innerHeight - dialogHeight) / 3;
		            mainElement.zdialog({
		                position: [ dialogLeft, dialogTop ],
		                width: dialogWidth,
		                height: dialogHeight,
		                className: 'zcarousel__dialog',	// No I18N
		                resizable: false,
		                handleFocusNavigation: false,
		                type: 'modal',	// No I18N
		                buttons: [
		                    {
		                        text: this._getI18NText('closeButton'), // No I18N
		                        action: (orgEvent) => {
		                            this.close(orgEvent);
		                        },
		                        id: 'zcarousel-button'	// No I18N
		                    }
		                ],
		                open: (orgEvent) => {
		                    this._dispatchEvent('open', orgEvent);	// No I18N
		                }
		            });
		            mainElement.zdialog('open');	// No I18N
		            mainElement = mainElement.find('.zdialog__content');
		        }
		        this._preview = mainElement;
		        this._data.slidesDOM = mainElement.find('.zcarousel-slides')[0];	// No I18N
		        super._render(this._data, null, mainElement[0]);
		    }
		    _postEachRender() {
		        let mainElement = this._preview,
		            _opts = this._opts,
		            previewEle = mainElement.children().first();
		        this._preview = previewEle;
		        this._slides = previewEle.children();
		        if (_opts.showArrowIcon) {
		            this._prevEle = mainElement.find('.zcarousel__previous');	// No I18N
		            this._nextEle = mainElement.find('.zcarousel__next');	// No I18N
		            this._preview.css('padding-left', this._nextEle.outerWidth());	// No I18N
		        }
		        this._counter = mainElement.find('.zcarousel__text');   // No I18N
		        let pageElement = mainElement.find('.zcarousel__pagination');	// No I18N
		        this._bullets = pageElement.find('.zcarousel__bullets');	// No I18N
		        pageElement.on('click', (orgEvent) => {	// No I18N
		            let _currPage = $(orgEvent.target);
		            if (_currPage.is('span')) {	// No I18N
		                this._moveSlide(_currPage.index(), orgEvent)
		            }
		        });
		        if (this._opts.autoPlay) {
		            this._resetTimer();
		        }
		        this._setAnimationSpeed();
		    }
		    _autoPlay() {
		        this._autoPlayTimer = setTimeout(() => {
		            this.next();
		            this._autoPlay();
		        }, this._opts.autoPlayInterval);
		    }
		    _clearTimer() {
		        if (this._autoPlayTimer) {
		            clearTimeout(this._autoPlayTimer);
		        }
		    }
		    _resetTimer() {
		        this._clearTimer();
		        if (this._opts.autoPlay) {
		            this._autoPlay();
		        }
		    }
		    _openAnim() {
		        this._currSlide = this._slides.first();
		        this._currSlide.show();
		        $(this._bullets[0]).addClass('is-selected');	// No I18N
		        this._preview.css('width', this._currSlide.outerWidth() * this._slides.length);	// No I18N
		    }
		    _bindEvents() {
		        ZC.$window.on('keydown.zcarousel', (orgEvent) => {	// No I18N
		            if (orgEvent.keyCode === 39) {
		                this.next(orgEvent);
		            } else if (orgEvent.keyCode === 37) {
		                this.previous(orgEvent);
		            }
		        });
		        if (this._opts.showArrowIcon) {
		            this._nextEle.on('click.zcarousel', (orgEvent) => {	// No I18N
		                this.next(orgEvent);
		            });
		            this._prevEle.on('click.zcarousel', (orgEvent) => {	// No I18N
		                this.previous(orgEvent);
		            });
		        }
		        this._openAnim();
		        if (this._opts.pauseOnHover) {
		            this._slides.on('mouseenter', () => {	// No I18N
		                this._clearTimer();
		            }).on('mouseleave', () => {	// No I18N
		                this._autoPlay();
		            });
		        }
		    }
		    next(orgEvent) {
		        this._moveSlide('next', orgEvent);	// No I18N
		    }
		    previous(orgEvent) {
		        this._moveSlide('previous', orgEvent);	// No I18N
		    }
		    _moveSlide(moveTo, orgEvent) {
		        this._clearTimer();
		        let slideElement = null,
		            currSlide = this._currSlide;
		        if (typeof moveTo === 'string') {	// No I18N
		            slideElement = currSlide[ moveTo === 'next' ? 'next' : 'prev']();	// No I18N
		        } else {
		            slideElement = $(this._slides[ moveTo ]);
		        }
		        if (!slideElement.length) {
		            slideElement = this._slides[ moveTo === 'next' ? 'first' : 'last']();	// No I18N
		        }
		        let _data = {
		            currentSlide: currSlide,
		            action: moveTo,
		            nextSlide: slideElement
		        };	// No I18N
		        let canProceed = this._dispatchEvent('beforechange', orgEvent, _data);	// No I18N
		        if (canProceed !== false && slideElement.length) {
		            let nextSlideIndex = slideElement.index();
		            this._preview.css('margin-left', '-' + (currSlide.outerWidth() * nextSlideIndex) + 'px');	// No I18N
		            $(this._bullets[ currSlide.index() ]).removeClass('is-selected');	// No I18N
		            $(this._bullets[ nextSlideIndex ]).addClass('is-selected');	// No I18N
		            this._currSlide = slideElement;
		            if(this._opts.showImageCount){
		                this._counter.text(this._getI18NText('selectedimageposition', [nextSlideIndex+1, this._slides.length]));    // No I18N
		            }
		            setTimeout(() => {
		                _data = {
		                    currentSlide: this._currSlide,
		                    action: moveTo,
		                    nextSlide: slideElement
		                };	// No I18N
		                this._dispatchEvent('afterchange', orgEvent, _data);	// No I18N
		            }, this._opts.transitionDuration);
		        }
		    }
		    close(orgEvent) {
		        this._clearTimer();
		        if (this._opts.display === 'dialog') {	// No I18N
		            this.element.zdialog('destroy');	// No I18N
		            this._dispatchEvent('close', orgEvent);	// No I18N
		        }
		    }
		    _setAnimationSpeed() {
		        let speedText = 'margin ' + this._opts.transitionDuration + 'ms';	// No I18N
		        this._preview.css({
		            '-webkit-transition': speedText,	// No I18N
		            '-moz-transition': speedText,	// No I18N
		            transition: speedText	// No I18N
		        });
		    }
		}
	ZC.registerComponent('ZCarousel', ZCarousel); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zcarousel.Templates, utilities = ZC.Templates.Utilities, button = ZC.zbutton.Templates.WCContainer; 
template.WCChildren = (data) => ZT.html `${data.slidesDOM} <div class="zcarousel__previous"> <span class="zcarousel__arrow" title="${data.prevLabel}">${utilities.WCIcon(data.arrow)}</span> </div> <div class="zcarousel__next"> <span class="zcarousel__arrow" title="${data.nextLabel}">${utilities.WCIcon(data.arrow)}</span> </div> <div class="zcarousel__footer"> <div class="zcarousel__toolbar"> ${data.footerButtons && data.footerButtons.map((value) => button(value))} </div> <div class = "zcarousel__text"> 1 of ${data.slideCount} </div> <div class = "zcarousel__footer__userinfo"> ${data.userinfo && ZT.html `<img src = "${data.userinfo.src}" class = "zcarousel__userphoto" />`} </div> <div class="zcarousel__thumbnail"> ${data.thumbnail && data.thumbnail.map((value, n) => template.WCThumbnailEle(value, n))} </div> <div class="zcarousel__gradient--left"> </div> <div class="zcarousel__gradient--right"> </div> </div> ${data.pagination && ZT.html `<div class = "zcarousel__pagination" > ${data.bullets.map((bulletInfo) => ZT.html `<span class="zcarousel__bullets ${bulletInfo.className}"></span>`)} </div>`}` 
template.WCThumbnailEle = (data, n) => ZT.html ` <div class="zcarousel__thumbnail_images ${n === 0 && 'zcarousel__thumbnail__selected'}" > <div class="zcarousel__thumbnail__imageContainer"> <img src="${data.src}" alt="Image ${n}" thumbnail="${n}" /> </div> </div>` }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zcarousel.Templates, utilities = ZC.Templates.Utilities, button = ZC.zbutton.Templates.container; 
template.children = (data) => ZT.html `${data.slidesDOM} <div class="zcarousel__previous"> <span class="zcarousel__arrow" title="${data.prevLabel}">${utilities.icon(data.arrow)}</span> </div> <div class="zcarousel__next"> <span class="zcarousel__arrow" title="${data.nextLabel}">${utilities.icon(data.arrow)}</span> </div> <div class="zcarousel__footer"> <div class="zcarousel__toolbar"> ${data.footerButtons && data.footerButtons.map((value) => button(value))} </div> <div class = "zcarousel__text"> 1 of ${data.slideCount} </div> <div class = "zcarousel__footer__userinfo"> ${data.userinfo && ZT.html `<img src = "${data.userinfo.src}" class = "zcarousel__userphoto" />`} </div> <div class="zcarousel__thumbnail"> ${data.thumbnail && data.thumbnail.map((value, n) => template.thumbnailEle(value, n))} </div> <div class="zcarousel__gradient--left"> </div> <div class="zcarousel__gradient--right"> </div> </div> ${data.pagination && ZT.html `<div class = "zcarousel__pagination" > ${data.bullets.map((bulletInfo) => ZT.html `<span class="zcarousel__bullets ${bulletInfo.className}"></span>`)} </div>`}` 
template.thumbnailEle = (data, n) => ZT.html ` <div class="zcarousel__thumbnail_images ${n === 0 && 'zcarousel__thumbnail__selected'}" > <div class="zcarousel__thumbnail__imageContainer"> <img src="${data.src}" alt="Image ${n}" thumbnail="${n}" /> </div> </div>` }(ZComponents)); 
(function(ZC, $){
		/* eslint-disable no-inner-declarations */
		/* $Id$ */
		class ZPreview  extends ZC.CoreComponent{
			get name(){
				return "zpreview";
			}
		    get attrs() {
		        return {
		            rtl: false,
		            canAnnotate: true,
		            header: true,
		            appendToEle: 'body', // No I18N
		            showFilmstripByDefault: false,
		            multipleSelection: false,
		            keyBoardShortCut: true,
		            clickOutsideImageToClose: false,
		            loop: false,
		            closeOnEsc: true,
		            showImageCount: true,
		            showImageName: true,
		            initialImage: 1,
		            slideShowTransistionTime: 4000,
		            moreOptions: [],
		            carousel: null,
		            minWidth: null,
		            maxWidth: null,
		            minHeight: null,
		            maxHeight: null,
		            height: null,
		            width: null,
		            showArrowIcon: true,
		            pagination: false,
		            filmStrip: true,
		            infoButton: true,
		            slideShow: true,
		            shareButton: true,
		            printButton: true,
		            downloadButton: true,
		            uploadButton: true,
		            fullscreenButton: true,
		            moreButton: true,
		            closeButton: true,
		            userInfo: null,
		            effect: 'default', // No I18N
		            display: 'inline' // Option to be provided inline|dialog 	//No I18N
		        };
		    }
		    get props() {
		        return {
		            imageEditOptions: {
		                isContinuousDraw: false,
		                canReplaceImage: true
		            },
		            imgDetails: null,
		            keys: {
		                'download.label': 'Download', // No i18n
		                'print.label': 'Print', // No i18n
		                'share.label': 'Share', // No i18n
		                'uploadToCloud.label': 'Upload to Cloud', // No i18n
		                'edit.label': 'Edit', // No i18n
		                'fullScreen.label': 'Full Screen', // No i18n
		                'more.label': 'More', // No i18n
		                'close.label': 'Close', // No i18n
		                'next.label': 'Next', // No i18n
		                'previous.label': 'Previous', // No i18n
		                'info.label': 'Info', // No i18n
		                'slideShow.label': 'SlideShow', // No i18n
		                'filmStrip.label': 'Filmstrip View', // No i18n
		                'showFilmStrip.label': 'Show Filmstrip', // No i18n
		                'hideFilmStrip.label': 'Hide Filmstrip', // No i18n
		                'play.label': 'Play', // No i18n
		                'pause.label': 'Pause', // No i18n
		                'morefilesselected.label': '{0} images selected.', // No i18n
		                'selectedimageposition.label': '{0} of {1}', // No i18n
		                'notFound.label': 'Image not Found', // No I18N
		                'unableToLoad.label': 'Unable to Load Image. Please try again', // No I18N
		                'imageResolution.label': 'Resolution', // No I18N
		                'imageSize.label': 'Size', // No I18N
		                'retry.label': 'Retry' // No I18N
		            }
		        };
		    }
		    get EVENTS() {
		        return [ 'beforechange','afterchange','change' ]; // No I18N
		    }
		    _init(element, _opts) {
		        this._slideShowTimer = undefined;
		        this.isfilmstrip = _opts.showFilmstripByDefault;
		        this._previousPosition = 0;
		        let data = this._data,
		            slideContainer = this.element.children().first() || null,
		            slidesCount;
		        data.currentPosition = _opts.initialImage || 1;
		        data.previousButton = data.nextButton = [];
		        data.pagination = _opts.pagination;
		        data.header = _opts.header;
		        data.multipleSelection = _opts.multipleSelection;
		        data.loop = _opts.loop = _opts.multipleSelection ? false : _opts.loop;
		        data.imgDetails = _opts.imgDetails;
		        data.showImageName = _opts.showImageName;
		        data.showArrowIcon = _opts.showArrowIcon;
		        data.userInfo = _opts.userInfo;
		        data.slideCount = slidesCount = data.imgDetails ? data.imgDetails.length : slideContainer.children().length;
		        this._selectURL(data.imgDetails);
		        this._autoPlayTimer = undefined;
		        element.addClass('zpreview zpreview--' + _opts.display); // No I18N
		        slideContainer && slideContainer.addClass('zpreview-slides'); // No I18N
		        if (slidesCount) {
		            if (_opts.showArrowIcon) {
		                data.arrow = ZC._getIconInfo(_opts.arrowIconClassName || _opts.arrowIconClass, _opts.arrowSVGIconId, '#zc__svg--downarrow zpreview__svg', 'zpreview__icon'); // No I18N
		                data.prevLabel = this._getString('previous.label'); // No I18N
		                data.nextLabel = this._getString('next.label'); // No I18N
		            }
		            data.bullets = [];
		            for (let i = 0; i < slidesCount; i++) {
		                data.bullets.push({
		                    className: (_opts.bulletClassName || _opts.bulletClass || '')
		                }); // No I18N
		            }
		        }
		        this._createThumbnail(this._opts.imgDetails);
		        _opts.header && this._createToolBarButtons();
		        data.previousButton = this._getbuttonProps('navigationprevious', 'previous', 'top'); // No i18n
		        data.nextButton = this._getbuttonProps('navigationnext', 'next', 'top'); // No i18n
		        this._createFooterButtons();
		        this._createFilmStripButtons();
		    }
		    _selectURL(imgDetails) {
		        if (imgDetails) {
		            let data = this._data,
		                ext;
		            imgDetails = imgDetails[data.currentPosition - 1];
		            data.selectedURL = imgDetails.src;
		            data.userInfo = imgDetails.userInfo;
		            ext = imgDetails.type || 'img'; // No i18n
		            data.fileIsNotImage = data.iframe = ext === 'other'; // No i18n
		        }
		    }
		    _createToolBarButtons() {
		        let opts = this._opts,
		            data = this._data;
		        data.toolbarButtons = data.closeButton = [];
		        opts.shareButton && data.toolbarButtons.push(this._getbuttonProps('share', null, 'bottom'));
		        opts.printButton && data.toolbarButtons.push(this._getbuttonProps('print'));
		        opts.downloadButton && data.toolbarButtons.push(this._getbuttonProps('download'));
		        opts.uploadButton && data.toolbarButtons.push(this._getbuttonProps('upload', 'uploadToCloud'));
		        opts.canAnnotate && data.toolbarButtons.push(this._getbuttonProps('edit'));
		        opts.fullscreenButton && data.toolbarButtons.push(this._getbuttonProps('fullscreen', 'fullScreen'));
		        opts.moreButton && data.toolbarButtons.push(this._getbuttonProps('more'));
		        data.closeButton = this._getbuttonProps('close'); // No i18n
		    }
		    _createThumbnail(source) {
		        let elements = source || this.element.children().children(),
		            data = this._data;
		        data.thumbnail = [];
		        if (!this._opts.thumbnail && elements) {
		            for (let i = 0; i < elements.length; i++) {
		                data.thumbnail.push({
		                    src: elements[i].src || $(elements[i]).find('img')[0].getAttribute('src') // No i18n
		                });
		            }
		            data.title = elements[data.currentPosition - 1].name || elements[data.currentPosition - 1].firstElementChild.innerText;
		        }
		    }
		    _createFooterButtons() {
		        let opts = this._opts,
		            data = this._data;
		        data.footerButtons = [];
		        opts.slideShow && data.footerButtons.push(this._getbuttonProps('slideshow', 'slideShow')); // No i18n
		        opts.infoButton && data.footerButtons.push(this._getbuttonProps('info')); // No i18n
		        opts.filmStrip && data.footerButtons.push(this._getbuttonProps('filmstrip', 'filmStrip')); // No i18n
		        this._updateImageInfo();
		    }
		    _createFilmStripButtons() {
		        let data = this._data,
		            playButton = this._getbuttonProps('slideshow__pause', 'pause'); // No i18n
		        data.filmStripButton = [];
		        playButton.label = 'pause'; // No i18n
		        playButton.id = 'zpreview--playpause'; // No i18n
		        data.filmStripButton.push(this._getbuttonProps('slideshow__previous', 'previous')); // No i18n
		        data.filmStripButton.push(playButton); // No i18n
		        data.filmStripButton.push(this._getbuttonProps('slideshow__next', 'next')); // No i18n
		    }
		    _getString(name) {
		        return ZC.getI18NText('zpreview', name, null, this._opts.key); // No i18n
		        // return FCUtil.getI18NString('zpreview', key, replaceArray, this._opts.keys); //No I18N
		    }
		    _getbuttonProps(name, label, position, type) {
		        let title = label || name,
		            id = `zbtn--${name}`;
		        let object = ZC.ZButton.getBtnProps({
		            title: this._getString(title + '.label'), // No I18N
		            type: 'icon' || type, // No I18N
		            className: `zpreview__button zpreview--${name}`, // No I18N
		            iconClassName: this._opts[`${name}iconClassName`], // No I18N
		            SVGIconId: this._opts[`${name}SVGIconId`], // No I18N
		            defaultSVGIconId: `zc__svg--${name} zpreview__${name}icon`, // No I18N
		            templateRender: true
		        });
		        object.id = id;
		        // object.customAttributes = {'data-title-position':'bottom','data-action':`${name}Action`};   // No i18n
		        return object;
		    }
		    _render() {
		        let mainElement = this.element,
		            _opts = this._opts;
		        if (_opts.display === 'dialog') { // No I18N
		            let dialogWidth = mainElement.outerWidth(true),
		                dialogHeight = mainElement.outerHeight(true),
		                dialogLeft = ((window.innerWidth - dialogWidth) / 2),
		                dialogTop = (window.innerHeight - dialogHeight) / 3;
		            mainElement.zdialog({
		                position: [ dialogLeft, dialogTop ],
		                width: dialogWidth,
		                height: dialogHeight,
		                className: 'zpreview__dialog', // No I18N
		                resizable: false,
		                handleFocusNavigation: false,
		                type: 'modal', // No I18N
		                buttons: [ {
		                    text: this._getString('closeButton.label'), // No I18N
		                    action: (orgEvent) => {
		                        this.close(orgEvent);
		                    },
		                    id: 'zpreview-button' // No I18N
		                } ],
		                open: (orgEvent) => {
		                    this._dispatchEvent('open', orgEvent); // No I18N
		                }
		            });
		            mainElement.zdialog('open'); // No I18N
		            mainElement = mainElement.find('.zdialog__content');
		        }
		        this._previewEle = mainElement;
		        this._data.slidesDOM = mainElement.find('.zpreview-slides')[0]; // No I18N
		        super._render(this._data, null, mainElement[0]);
		    }
		    _showHideFilmStrip(show) {
		        let childHeight = parseInt(this._thumbnailContainer.outerHeight());
		        this._footerEle.height((show ? (childHeight + 50) : 50));
		        this.isfilmstrip = show;
		        this._data.imgDetails && this._setImageDimension();
		        this._updateErrorContainer();
		    }
		    _postEachRender() {
		        let mainElement = this._previewEle,
		            _opts = this._opts,
		            data = this._data,
		            base = this,
		            previewEle = mainElement.children().first();
		        this._previewEle = previewEle;
		        this._slides = previewEle.children();
		        if (_opts.showArrowIcon) {
		            this._prevEleObj = mainElement.find('.zpreview--navigationprevious'); // No I18N
		            this._nextEleObj = mainElement.find('.zpreview--navigationnext'); // No I18N
		            this._previewEle.css('padding-left', this._nextEleObj.outerWidth()); // No I18N
		        }
		        // let pageElement = mainElement.find('.zpreview__pagination'); // No I18N
		        this._imageContainer = mainElement.find('.zpreview--container'); // No I18N
		        this._imageContent = this._imageContainer.find('.zpreview--content'); // No I18N
		        this._thumbnail = mainElement.find('.zpreview__thumbnail');
		        this._header = this.element.find('.zpreview--header'); // No I18N
		        let footerEle = this._footerEle = mainElement.find('.zpreview--footer'); // No I18N
		        this._fullScreenButton = mainElement.find('.zpreview--fullscreen'); // No I18N
		        this._slideShowButton = footerEle.find('.zpreview--slideshow'); // No I18N
		        this._filmstripButton = footerEle.find('.zpreview--filmstrip'); // No I18N
		        this._filmstripContainer = this.element.find('.zpreview__filmstripactions'); // No18n
		        this._infoButton = footerEle.find('.zpreview--info'); // No I18N
		        this._infoButtonEle = footerEle.find('.zpreview--imagedetails'); // No I18N
		        this._popoverEle = base._footerEle.find('.zpreview--popover'); // No I18N
		        this._thumbnailContainer = footerEle.find('.zpreview__thumbnailContainer');// No I18N
		        this._errorContainer = this._imageContent.find('.zpreview__errormessage'); // No I18N
		        this._loader = this.element.find('.zpreview--loader'); // No I18N
		        footerEle.find('.zpreview__userphoto').off('click.zpreview').on('click.zpreview', function() { // No I18N
		            base._isNone(base._popoverEle); // No I18N
		        })
		        // pageElement.off('click.zpreview').on('click.zpreview', (orgEvent) => { // No I18N
		        //     let _currPage = $(orgEvent.target);
		        //     if (_currPage.is('span')) { // No I18N
		        //         base._moveSlide(_currPage.index(), orgEvent)
		        //     }
		        // });
		        this.element.off('click.zpreview').on('click.zpreview', function(orgEvent) { // No I18N
		            let target = $(orgEvent.target);
		            if (target.hasClass('zpreview') && base._opts.clickOutsideImageToClose) { // No I18N
		                base._close();
		            } else if (target.hasClass('zpreview--close') || target.hasClass('zpreview__closeicon')) { // No I18N
		                base._close();
		            }
		        });
		        this._footerEle.find('.zpreview__gradient').off('click.zpreview').on('click.zpreview', function(e) { // No I18N
		            let ele = $(e.target);
		            if (ele.hasClass('zpreview__filmStripGradientLeft')) { // No I18N
		                base._gradientClickHandler(true);
		            } else if (ele.hasClass('zpreview__filmStripGradientRight')) { // No I18N
		                base._gradientClickHandler();
		            }
		        });
		        if (this._opts.autoPlay) {
		            this._resetTimer();
		        }
		        this._setAnimationSpeed();
		        this._showHideFilmStrip(_opts.showFilmstripByDefault);
		        let imageEle = this._imageContainer.find('.zpreview__image'); // No I18N
		        if (data.fileIsNotImage) {
		            let previewEle = this._imageContainer.find('.zpreview__frame'); // No I18N
		            previewEle.on('load.blank', function(e) { // No I18N
		                previewEle.off('load.blank');	// No I18N
		                previewEle.attr('src', data.imgDetails[data.currentPosition - 1].src);	// No I18N
		            })
		            previewEle.attr('src','about:blank');   //No I18N
		            previewEle.off('load.zpreview').on('load.zpreview',function(e){ //No I18N
		                if(this.contentDocument !== null){
		                    clearTimeout(base.loaderTimeoutInstance);
		                    base._updateErrorContainer();
		                    base._setImageDimension(true);
		                }
		            });
		            imageEle.off('load.zpreview, error.zpreview'); // No I18N
		            this._visibility(imageEle);
		        } else {
		            this._visibility(imageEle, true);
		            imageEle.off('load.zpreview, error.zpreview').on('load.zpreview', function() { // No i18n
		                clearTimeout(base.loaderTimeoutInstance);
		                base._updateErrorContainer();
		                base._setImageDimension(true);
		            }).on('error.zpreview', function() {
		                base._handleError();
		            });
		        }
		        imageEle.off('click.zpreview').on('click.zpreview', function() { // No i18n
		            let scrollLeft, scrollTop, previousWidth, zoomTo;
		            scrollLeft = event.pageX - $(this).offset().left;
		            scrollTop = event.pageY - $(this).offset().top;
		            previousWidth = $(this).width();
		            zoomTo = base._imageContent.hasClass('zpreview--fittowidth'); // No i18n
		            base._handleZoom(zoomTo, true);
		            if (zoomTo === true) {
		                let currentWidth, ratio, windowWidth, windowHeight;
		                currentWidth = $(this).width();
		                ratio = currentWidth / previousWidth;
		                windowWidth = $(window).width();
		                windowHeight = $(window).height();
		                base._imageContainer.scrollTop(scrollTop * ratio - (windowHeight / 2));
		                base._imageContainer.scrollLeft(scrollLeft * ratio - (windowWidth / 2))
		            }
		        });
		        let imageInfo = data.imgDetails[data.currentPosition - 1],
		            print = imageInfo.print === false,
		            download = imageInfo.download === false,
		            edit = data.fileIsNotImage && imageInfo.editable === false;
		        this._isDisable('.zpreview--download', download)// No I18N
		        this._isDisable('.zpreview--print', print)// No I18N
		        this._isDisable('.zpreview--edit', edit)// No I18N
		        this._bindEvents();
		        this.checkAndExitFromZoomedState();
		    }
		    _postRender() {
		        if (this._opts.moreOptions.length > 1) {
		            this._createMenuItem('zpreview__more--menu', this._opts.moreOptions); // No I18N
		        }
		    }
		    _isDisable(name, value) {
		        this._header.find(name)[value ? 'addClass' : 'removeClass']('is-disabled').attr('disabled', value); // No i18n
		    }
		    _isNone(ele, left) {
		        let show = ele.hasClass('zh-dnone'); // No I18N
		        ele[show ? 'removeClass' : 'addClass']('zh-dnone'); // No I18N
		        if (show && left) {
		            let button = this.element.find('#zbtn--info'); // No I18N
		            ele.css('right', ($(window).outerWidth() - (button.offset().left + button.outerWidth()))); // No I18N
		        }
		    }
		    _handleReload() {
		        clearTimeout(this.loaderTimeoutInstance);
		        this._visibility(this._loader);
		        if (navigator.onLine) {
		            let data = this._data;
		            data.selectedURL = null;
		            this._render(data, 'zpreview', 'imageContainer', null, null, { // No i18n
		                skipParent: true
		            });
		            this._moveSlide(data.currentPosition);
		        } else {
		            this._handleError();
		        }
		    }
		    _handleError() {
		        let data = this._data,
		            base = this,
		            checkConnection = navigator.onLine,
		            text = checkConnection ? 'notFound' : 'unableToLoad',	// No I18N
		            svg = checkConnection ? '#zc__svg--notfound' : '#zc__svg--unableload'; // No I18N
		        data.errorMessage = {
		            SVGIconId: svg,
		            text: this._getString(text + '.label'), // No I18N
		            SVGIconClassName: 'zpreview__errormessage--svg' // No i18n
		        };
		        if (!checkConnection) {
		            data.errorButton = ZC.ZButton.getBtnProps({
		                label: base._getString('retry.label'), // No I18N
		                type: 'text', // No I18N
		                className: 'zpreview--retrybutton', // No I18N
		                templateRender: true
		            });
		        }
		        this._data = data;
		        this._render(data, 'zpreview', 'imageContainer', null, null, { // No I18N
		            skipParent: true
		        });
		        if (this._errorContainer.length) {
		            this._updateErrorContainer();
		            clearTimeout(this.loaderTimeoutInstance);
		            this._visibility(this._loader);
		            function clearConnectionInveral() {
		                // eslint-disable-next-line block-scoped-var
		                clearInterval(checkConnectivity);
		            }
		            if (!navigator.onLine) {
		                // eslint-disable-next-line no-var
		                var checkConnectivity = setInterval(function() {
		                    if (navigator.onLine) {
		                        clearConnectionInveral();
		                        !data.fileIsNotImage && base._handleReload();
		                    }
		                }, 3000);
		            }
		        }
		    }
		    _gradientClickHandler(left) {
		        let data = this._data,
		            scrollLeft = this._thumbnailContainer.scrollLeft() + (left ? 0 : $(window).width()),
		            currentPosition = data.currentPosition,
		            thumbnailImagesWidth = parseFloat(this._thumbnail.css('width')); // No i18n
		        currentPosition = parseInt(scrollLeft / thumbnailImagesWidth);
		        if (left) {
		            currentPosition = currentPosition <= 0 ? 1 : currentPosition;
		        } else {
		            currentPosition = currentPosition >= data.slideCount ? data.slideCount : currentPosition;
		        }
		        if (currentPosition !== data.currentPosition) {
		            this._data.currentPosition = currentPosition;
		            this._moveSlide(currentPosition);
		        }
		    }
		    _autoPlay() {
		        this._autoPlayTimer = setTimeout(() => {
		            this.next();
		            this._autoPlay();
		        }, this._opts.autoPlayInterval);
		    }
		    _clearTimer() {
		        if (this._autoPlayTimer) {
		            clearTimeout(this._autoPlayTimer);
		        }
		    }
		    _resetTimer() {
		        this._clearTimer();
		        if (this._opts.autoPlay) {
		            this._autoPlay();
		        }
		    }
		    _openAnim() {
		        this._currSlide = this._slides.first();
		        // this._currSlide.show();
		        if (this._data.imgDetails) {
		            this._previewEle.css({
		                width: 658,
		                height: 500
		            });
		        } else {
		            this._previewEle.css('width', this._currSlide.outerWidth() * (this._slides.length + 1)); // No I18N
		        }
		    }
		    _bindEvents() {
		        let base = this;
		        $(document).off('mozfullscreenchange.zpreview webkitfullscreenchange.zpreview fullscreenchange.zpreview MSFullscreenChange.zpreview').on('mozfullscreenchange.zpreview webkitfullscreenchange.zpreview fullscreenchange.zpreview MSFullscreenChange.zpreview', function() {
		            base.fullscreenHandler = true;
		            if (document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement !== null) {
		                if (base.slideShowButtonClicked === true) {
		                    base._startSlideShow();
		                    base._filmstripContainer.find('.zpreview--slideshow__pause').attr('title', base._getString('pause.label')) // No i18n
		                    base.SlideShowRunning = true;
		                    base.slideShowButtonClicked = false;
		                } else if (base.fullScreenBtnClicked === true) {
		                    base.fullScreenMode = true;
		                    base.hideItemsBeforeFullScreen();
		                    base.fullScreenBtnClicked = false;
		                } else {
		                    base.fullScreenMode = false;
		                    base._stopSlideShow();
		                    base._setImageDimension(true);
		                    base._updateErrorContainer();
		                    base.checkAndExitFromZoomedState();
		                }
		            }
		        });
		        ZC.$window.off('keydown.zpreview').on('keydown.zpreview', (orgEvent) => { // No I18N
		            if (orgEvent.keyCode === 27 && base._opts.closeOnEsc) {
		                base.close();
		            } else if (base._opts.keyBoardShortCut) {
		                let data = base._data;
		                if (orgEvent.keyCode === 37 && (data.loop || data.currentPosition > 1)) {
		                    base.previous(orgEvent);
		                } else if (orgEvent.keyCode === 39 && (data.loop || data.currentPosition < data.slideCount)) {
		                    base.next(orgEvent);
		                }
		            }
		        }).off('resize.zpreview').on('resize.zpreview', function() { // No I18N
		            !base.fullScreenMode && base._setImageDimension(true); // No I18N
		        });
		        this._openAnim();
		        if (this._opts.pauseOnHover) {
		            this._slides.on('mouseenter', () => { // No I18N
		                this._clearTimer();
		            }).on('mouseleave', () => { // No I18N
		                this._autoPlay();
		            });
		        }
		        this._thumbnail.off('click.zpreview').on('click.zpreview', function() { // No I18N
		            let currentPosition = base._data.currentPosition,
		                position = parseInt($(this).find('img').attr('thumbnail')) || currentPosition; // No I18N
		            if (position !== currentPosition) {
		                base._moveSlide(position);
		            }
		        })
		        this.element.find('.zbutton').off('click.zpreview').on('click.zpreview', function(event) { // No I18N
		            let ele = $(event.target).closest('.zbutton'); // No I18N
		            if (ele.hasClass('zpreview--slideshow')) { // No I18N
		                base.slideShowButtonClicked = true;
		                base.toggleFullScreen();
		            } else if (ele.hasClass('zpreview--fullscreen')) { // No I18N
		                base.fullScreenBtnClicked = true;
		                base.checkAndExitFromZoomedState();
		                base.toggleFullScreen();
		            } else if (ele.hasClass('zpreview--navigationnext') || ele.hasClass('zpreview--slideshow__next')) { // No I18N
		                base._moveSlide('next', event); // No i18n
		            } else if (ele.hasClass('zpreview--navigationprevious') || ele.hasClass('zpreview--slideshow__previous')) { // No I18N
		                base._moveSlide('previous', event); // No i18n
		            } else if (ele.hasClass('zpreview--filmstrip')) { // No I18N
		                let filmstrip = base._opts.showFilmstripByDefault = !base._opts.showFilmstripByDefault;
		                base._showHideFilmStrip(filmstrip);
		            } else if (ele.hasClass('zpreview--info')) { // No I18N
		                base._isNone(base._infoButtonEle, true);
		            } else if (ele.hasClass('zpreview--slideshow__pause')) { // No I18N
		                base.slideShowPlayPause();
		            } else if (ele.hasClass('zpreview--retrybutton')) { // No I18N
		                base._handleReload();
		            } else if (ele.hasClass('zpreview--more')) { // No I18N
		                $('#zpreview__more--menu').zmenu('show', { // No I18N
		                    forElement: base._header.find('.zpreview--more'), // No I18N
		                    direction: 'bottom-left',	// No I18N
		                    event: event,
		                    preventHover: true // No I18N
		                });
		            } else if (ele.hasClass('zpreview--edit')) { // No I18N
		                base._header.addClass('zimageeditor__transistionHeaderHide').css('animation-duration', '0.2s'); // No I18N
		                if (ZC.Browser.isIE) {
		                    setTimeout(function() {
		                        setTimeout(function() {
		                            base.initImageAnnotator();
		                        }, 300)
		                    }, 200);
		                } else {
		                    base._header.on('webkitAnimationEnd oanimationend msAnimationEnd animationend', function() { // No I18N
		                        base._header.hide();
		                        base.initImageAnnotator();
		                    });
		                }
		            }
		        });
		    }
		    initImageAnnotator() {
		        let imageInfo = this._currentImageInfo(),
		            data = this._data,
		            base = this,
		            currentImage = this._imageContent.find('.zpreview__image'), // No I18N
		            ImageEle = currentImage[0],
		            imagePositions = data.currentPosition - 1; // No I18N
		        this._header.off('webkitAnimationEnd oanimationend msAnimationEnd animationend').removeClass('zimageeditor__transistionHeaderHide'); // No I18N
		        this._showElements();
		        // eslint-disable-next-line no-undef
		        ZAnnotator.init({
		            // target: 'zpreview__image', //No I18N
		            imageURL: ImageEle.src || ImageEle.dataset.src || ImageEle.currentSrc,
		            isContinuousDraw: base._opts.imageEditOptions.isContinuousDraw,
		            imageName: data.imgDetails[imagePositions].name,
		            showImageName: true,
		            width: currentImage.prop('naturalWidth'), // No I18N
		            height: currentImage.prop('naturalHeight'), // No I18N
		            onSuccess: function(orgEvent) {
		                if (typeof base._opts.onEditDone === 'function') {
		                    base._opts.onEditDone({
		                        imageData: orgEvent.imageSource,
		                        imageId: imageInfo
		                    });
		                }
		                if (base._opts.imageEditOptions.canReplaceImage === true) {
		                    currentImage.attr('src', orgEvent.imageSource); // No i18n
		                    data.imgDetails[imagePositions].src = orgEvent.imageSource;
		                    base._thumbnailContainer.find('.zpreview__thumbnail:nth-of-type(' + data.currentPosition + ')').children().children('img').attr('src', orgEvent.imageSource); // No I18N
		                }
		                base._showElements(true)
		            },
		            onCancel: function() {
		                if (typeof base._opts.onEditCancel === 'function') {
		                    base._opts.onEditCancel();
		                }
		                base._showElements(true);
		                base._imageContent.find('.zpreview__image').show();
		            },
		            onLoad: function() {
		                base._visibility(base.element, true);
		                setTimeout(function() {
		                    base._imageContent.find('.zpreview__image').hide().removeClass('zpreview__trans--fadeOut').off('webkitAnimationEnd oanimationend msAnimationEnd animationend'); // No i18n
		                }, 200);
		            },
		            onClose: function() {
		                base._showElements(true);
		            }
		        });
		    }
		    _showElements(value) {
		        this._header[value ? 'show' : 'hide'](); // No i18n
		        this._footerEle[value ? 'show' : 'hide'](); // No i18n
		        this._visibility(this.element, value);
		    }
		    _updateErrorContainer() {
		        let imgEle = this._imageContent.find(`.zpreview__${this._data.fileIsNotImage ? 'frame' : 'image'}`); // No i18n
		        if (this._errorContainer.length > 0) {
		            this._visibility(imgEle);
		            this._imageContent.css({
		                height: '100%',
		                width: '100%'
		            }); // No i18n
		        } else {
		            this._visibility(imgEle, true);
		        }
		        this._visibility(this._loader);
		        this._visibility(this._imageContent, true);
		    }
		    _visibility(ele, show) {
		        ele.css('visibility', show ? 'visible' : 'hidden'); // No I18N
		    }
		    next(orgEvent) {
		        this._moveSlide('next', orgEvent); // No I18N
		    }
		    previous(orgEvent) {
		        this._moveSlide('previous', orgEvent); // No I18N
		    }
		    _moveSlide(moveTo, orgEvent) {
		        let data = this._data,
		            base = this,
		            currentPosition = data.currentPosition,
		            position = 1,
		            slideElement = null,
		            currSlide = this._currSlide;
		        data.errorMessage = data.errorButton = null;
		        this._visibility(this._loader);
		        this._clearTimer();
		        if (typeof moveTo === 'string') { // No I18N
		            slideElement = currSlide[moveTo === 'next' ? 'next' : 'prev'](); // No I18N
		            position = currentPosition + (moveTo === 'next' ? 1 : -1); // No i18n
		        } else {
		            slideElement = $(this._slides[moveTo]);
		            position = moveTo;
		        }
		        if (!slideElement.length && typeof moveTo === 'string') { // No I18N
		            slideElement = this._slides[moveTo === 'next' ? 'first' : 'last'](); // No I18N
		        }
		        let _data = {
		            currentSlide: currSlide,
		            action: moveTo,
		            nextSlide: slideElement
		        }; // No I18N
		        let canProceed = this._dispatchEvent('beforechange', orgEvent, _data); // No I18N
		        this.loaderTimeoutInstance = setTimeout(function() {
		            base._visibility(base._loader, true);
		            base._visibility(base._imageContent);
		            base._visibility(base._imageContent.find(`.zpreview__${base._data.fileIsNotImage ? 'frame' : 'image'}`)); // No I18N
		        }, 10);
		        if (canProceed !== false && (slideElement.length || data.imgDetails)) {
		            if (data.imgDetails) {
		                let imgDetail = data.imgDetails,
		                    imglength = imgDetail.length,
		                    currentImage;
		                data.currentPosition = position = (imglength >= position && position >= 1) ? position : (moveTo === 'next' ? 1 : imglength); // No i18n
		                currentImage = imgDetail[data.currentPosition - 1];
		                data.title = currentImage.name;
		                data.userInfo = currentImage.userInfo;
		                this._selectURL(imgDetail);
		                this._render(data, 'zpreview', 'imageContainer', null, null, { // No i18n
		                    skipParent: true
		                });
		                this._render(data, 'zpreview', 'title', null, null, { // No i18n
		                    skipParent: true
		                });
		            } else {
		                data.currentPosition = slideElement.index() + 1;
		                this._previewEle.css('margin-left', '-' + (currSlide.outerWidth() * slideElement.index()) + 'px'); // No I18N
		            }
		            this._currSlide = slideElement;
		            this._updateImageInfo();
		            this._render(data, 'zpreview', 'footer', null, null, { // No i18n
		                skipParent: true
		            });
		            setTimeout(() => {
		                _data = {
		                    currentSlide: this._currSlide,
		                    action: moveTo,
		                    nextSlide: slideElement
		                };
		                this._dispatchEvent('afterchange', orgEvent, _data); // No I18N
		            }, this._opts.transitionDuration);
		            if (!this._opts.loop && !this.fullScreenMode && !this.SlideShowRunning) {
		                this._checkNavBtnVisibility();
		            }
		            let thumbnailWidth = this._thumbnail.outerWidth(),
		                width = Math.round($(window).width() / thumbnailWidth),
		                leftValue = ((parseInt((currentPosition === 1 ? currentPosition : currentPosition - 1) / width)) * width) * thumbnailWidth;
		            this._thumbnailContainer.scrollLeft(leftValue);
		        }
		    }
		    _close(orgEvent) {
		        this._clearTimer();
		        if (this._opts.display === 'dialog') { // No I18N
		            this.element.zdialog('destroy'); // No I18N
		            this._dispatchEvent('close', orgEvent); // No I18N
		        }
		        this.element.removeClass('zpreview zpreview--inline'); // No I18N
		        this.destroy();
		    }
		    close() {
		        this._close();
		    }
		    _updateImageInfo() {
		        let data = this._data,
		            imgDetails = {};
		        data.imgDetails && (imgDetails = data.imgDetails[data.currentPosition - 1]);
		        if (imgDetails) {
		            let dimension = imgDetails.dimension,
		                size = imgDetails.size,
		                width = dimension.width,
		                height = dimension.height;
		            data.imageInfoText = this._getString('imageResolution.label') + ': ' + width + ' x ' + height + ', ' + this._getString('imageSize.label') + ': ' + size; // No I18N
		        }
		    }
		    _setAnimationSpeed() {
		        let speedText = 'margin ' + this._opts.transitionDuration + 'ms'; // No I18N
		        this._previewEle.css({
		            '-webkit-transition': speedText, // No I18N
		            '-moz-transition': speedText, // No I18N
		            transition: speedText // No I18N
		        });
		    }
		    _setImageDimension(canChangeDimensions) { // revisit
		        this.initLoadEvent = !this.initLoadEvent;
		        let _opts = this._opts,
		            _data = this._data,
		            imageInfo = _opts.imgDetails[_data.currentPosition - 1],
		            windowWidth = window.innerWidth,
		            windowHeight = window.innerHeight,
		            fileIsNotImage = _data.fileIsNotImage,
		            imgEle = this._previewEle.find(`.zpreview__${fileIsNotImage ? 'frame' : 'image'}`), // No I18N
		            _imageWidth = windowWidth,
		            _imageHeight = windowHeight,
		            isfilmstrip = this.isfilmstrip,
		            bottomBandHeight = 0,
		            filmStripHeight = 0,
		            topBandHeight;
		        if (!fileIsNotImage) {
		            _imageWidth = this._imageWidth = imageInfo.displayWidth || imgEle[0].naturalWidth;
		            _imageHeight = this._imageHeight = imageInfo.displayHeight || imgEle[0].naturalHeight;
		        }
		        topBandHeight = parseFloat(this._header.css('height')); // No i18n
		        bottomBandHeight += parseFloat(this._footerEle.find('.zpreview__paginationtext').css('height')); // No I18N
		        let paddingLeft = 110,
		            paddingRight = 110,
		            paddingTop = 35,
		            paddingBottom = 0,
		            maximumWidth = windowWidth - (paddingLeft + paddingRight),
		            maximumHeight = windowHeight - (paddingBottom + paddingTop + topBandHeight + bottomBandHeight);
		        if (isfilmstrip) {
		            filmStripHeight = this._thumbnailContainer.outerHeight() || 0; // No i18n
		            maximumHeight -= filmStripHeight;
		        }
		        if (this.SlideShowRunning === true || this.fullScreenMode === true) {
		            maximumWidth = windowWidth;
		            maximumHeight = windowHeight;
		        }
		        maximumHeight > _imageHeight && (maximumHeight = _imageHeight);
		        maximumWidth > _imageWidth && (maximumWidth = _imageWidth);
		        let ratio = Math.min(maximumWidth / _imageWidth, maximumHeight / _imageHeight);
		        if (this._imageContent.hasClass('zpreview--actualsize') === true && canChangeDimensions === true) { // No i18n
		            ratio = 1;
		        }
		        let contentWidth = (_imageWidth * ratio),
		            contentHeight = (_imageHeight * ratio);
		        contentWidth = contentWidth < 0 ? 0 : contentWidth;
		        contentHeight = contentHeight < 0 ? 0 : contentHeight;
		        paddingLeft = (windowWidth - (contentWidth + paddingLeft + paddingRight)) / 2;
		        paddingTop = (windowHeight - (contentHeight + bottomBandHeight + paddingTop + paddingBottom)) / 2;
		        if (this.isfilmstrip === true) {
		            paddingTop -= (filmStripHeight / 2);
		        }
		        let cssProps = {};
		        if (this.SlideShowRunning === true || this.fullScreenMode === true) {
		            if (contentHeight === windowHeight) {
		                cssProps.top = '-45px'; // No I18N
		            } else {
		                cssProps.top = ((windowHeight - contentHeight) / 2) - topBandHeight;
		            }
		            if (windowWidth === contentWidth) {
		                cssProps.top = ((windowHeight - contentHeight) / 2) - topBandHeight;
		            }
		        } else {
		            cssProps = {
		                left: (paddingLeft > 0 ? paddingLeft : 0),
		                top: paddingTop > 0 ? paddingTop : 0
		            };
		        }
		        if (canChangeDimensions === true) {
		            cssProps.width = ' ';
		            cssProps.height = ' ';
		        }
		        this._imageContainer.css(cssProps);
		        cssProps = {
		            width: contentWidth,
		            height: contentHeight
		        };
		        this._imageContent.css(cssProps);
		        imgEle.css(cssProps);
		        let dimensionObj = {
		            width: '',
		            height: ''
		        };
		        if (contentWidth > contentHeight) {
		            dimensionObj.width = contentWidth;
		        } else {
		            dimensionObj.height = contentHeight;
		        }
		        if (canChangeDimensions !== true) {
		            this._isDimensionChanged = ((_imageHeight !== contentHeight) || (_imageWidth !== contentWidth));
		            this._imageContent[(this._isDimensionChanged && !this._data.errorMessage) ? 'addClass' : 'removeClass']('zpreview--fittowidth'); // No I18N
		        }
		    }
		    checkAndExitFromZoomedState() {
		        if (this._imageContent.hasClass('zpreview--actualsize')) {
		            this._handleZoom(this._imageContent.hasClass('zpreview--fittowidth'), true); // No i18n
		        }
		    }
		    _handleZoom(inZoomedState, canChangeState) {
		        let imageEle = this._imageContainer.find('.zpreview__image'); // No i18n
		        if (inZoomedState) {
		            if (this.isfilmstrip) {
		                let filmStripHeight = this._thumbnail.outerHeight() || 0;
		                let textHeight = parseFloat(this._footerEle.find('.zpreview__paginationtext').css('height')) + filmStripHeight; // No I18N
		                imageEle.css('padding-bottom', textHeight); // No I18N
		            }
		        } else {
		            imageEle.css('padding-bottom', '0px'); // No i18n
		        }
		        if (this._isDimensionChanged && canChangeState !== false) {
		            let imageWidth = this._imageWidth,
		                imageHeight = this._imageHeight,
		                windowHeight = $(window).height(),
		                topBandHeight = parseFloat(this._header.css('height')), // No i18n
		                top = 0;
		            if (imageHeight < windowHeight) {
		                top = (windowHeight - imageHeight) / 2 - (topBandHeight / 2);
		                if (this.isfilmstrip) {
		                    top -= (this.filmStripHeight / 2)
		                }
		            }
		            let obj = {
		                width: '',
		                height: ''
		            };
		            this._imageContent.css(obj);
		            imageEle.css(obj);
		            obj.left = 0;
		            obj.top = top;
		            this._imageContainer.css(obj);
		            if (inZoomedState && canChangeState !== false) {
		                this.element.addClass('zpreview--fullview'); // No i18n
		                this._imageContent.attr('class', 'zpreview--content zpreview--actualsize'); // No i18n
		                this._imageContent.css({
		                    width: imageWidth,
		                    height: imageHeight
		                })
		            } else {
		                if (canChangeState !== false) {
		                    this.element.removeClass('zpreview--fullview'); // No i18n
		                    this._imageContent.attr('class', 'zpreview--content zpreview--fittowidth'); // No i18n
		                }
		                this._setImageDimension();
		            }
		        }
		    }
		    _stopSlideShow() {
		        this._visibility(this._filmstripContainer);
		        this.showItemsAfterFullScreen()
		        this.SlideShowRunning = false;
		        clearTimeout(this._slideShowTimer);
		        if (document.cancelFullScreen) {
		            document.cancelFullScreen();
		        } else if (document.mozCancelFullScreen) {
		            document.mozCancelFullScreen();
		        } else if (document.webkitCancelFullScreen) {
		            document.webkitCancelFullScreen();
		        }
		        this._slideShowTimer = undefined;
		        this._filmstripContainer.find('.zpreview--slideshow__play').removeClass('zpause_slide_show_class'); // No I18N
		    }
		    playSlideShow() {
		        let base = this;
		        this.checkAndExitFromZoomedState();
		        this._slideShowTimer = setInterval(function() {
		            base._data.currentPosition === base._data.slideCount && base._stopSlideShow();
		            base._moveSlide('next'); // No i18n
		        }, this._opts.slideShowTransistionTime);
		    }
		    resetSlideShowTime() {
		        window.clearTimeout(this._slideShowTimer);
		        this.playSlideShow();
		    }
		    slideShowPlayPause() {
		        let playButton = this.element.find('#zpreview--playpause'); // No i18n
		        if (playButton.data('action') === 'pause') { // No i18n
		            window.clearTimeout(this._slideShowTimer);
		            this.slideShowPaused = true;
		            playButton.data('action', 'play').attr('title', this._getString('play.label')); // No i18n
		            playButton.find('use').attr('xlink:href', '#zc__svg--slideshow__play'); // No I18N
		            playButton.find('svg').css({
		                width: '12px', // No I18N
		                height: '14px' // No I18N
		            })
		        } else if (this.slideShowPaused === true) {
		            this.playSlideShow();
		            this.slideShowPaused = false;
		            playButton.data('action', 'pause').attr('title', this._getString('pause.label')); // No i18n
		            playButton.find('use').attr('xlink:href', '#zc__svg--slideshow__pause') // No I18N
		            playButton.find('svg').css({
		                width: '10px', // No i18n
		                pause: '14px' // No i18n
		            });
		        }
		    }
		    _startSlideShow() {
		        this.slideShowPaused = false;
		        let element = this._filmstripContainer.find('.zpreview--slideshow__pause'); // No i18n
		        element.data('action', 'pause'); // No i18n
		        element.children().children().children().attr('xlink:href', '#zc__svg--slideshow__pause') // No I18N
		        element.css({
		            width: '10px', // No I18N
		            pause: '13px' // No I18N
		        })
		        this._visibility(this._filmstripContainer, true);
		        this.hideItemsBeforeFullScreen();
		        if (this._slideShowTimer === undefined) {
		            this.playSlideShow();
		            this._filmstripContainer.find('.zpreview--slideshow__play').addClass('zpause_slide_show_class'); // No i18n
		        } else {
		            this._stopSlideShow();
		        }
		        this.toggleSlideShowButton();
		    }
		    currentImageInfo() {
		        return this._currentImageInfo();
		    }
		    _currentImageInfo() {
		        return this._data.imgDetails[this._data.currentPosition - 1];
		    }
		    removeImage(arg) {
		        if (this._removeImage(arg)) {
		            this._refreshContainer('footer'); // No i18n
		        }
		    }
		    addImage(arg) {
		        if (this._addImage(arg)) {
		            this._refreshContainer('footer'); // No i18n
		        }
		    }
		    _addImage(arg) {
		        let data = this._data,
		            opts = this._opts,
		            imgDetails = data.imgDetails,
		            imglength = imgDetails.length;
		        arg = Array.isArray(arg) ? arg : [ arg ];
		        for (let i = 0; i < arg.length; i++) {
		            if (arg[i].src) {
		                imgDetails[imglength++] = arg[i]
		            }
		        }
		        opts.imgDetails = imgDetails;
		        data.slideCount = imglength;
		        return true;
		    }
		    _removeImage(arg) {
		        let data = this._data,
		            opts = this._opts,
		            imgDetails = data.imgDetails,
		            position = data.currentPosition;
		        arg = Array.isArray(arg) ? arg : [ arg ];
		        for (let i = 0; i < arg.length; i++) {
		            if (arg[i].uid) {
		                // eslint-disable-next-line eqeqeq
		                imgDetails = imgDetails.filter((item) => item.uid != arg[i].uid);
		                let userid = this._currentImageInfo().uid;
		                opts.imgDetails = data.imgDetails = imgDetails;
		                // eslint-disable-next-line eqeqeq
		                if (userid == arg[i].uid) {
		                    imgDetails.length <= position && position--;
		                    data.currentPosition = position;
		                    this._selectURL(imgDetails);
		                    this._refreshContainer('imageContainer'); // No i18n
		                }
		            }
		        }
		        data.currentPosition = position;
		        data.slideCount = imgDetails.length;
		        return true;
		    }
		    _refreshContainer(name) {
		        name === 'footer' && this._createThumbnail(this._data.imgDetails); // No i18n
		        this._render(this._data, 'zpreview', name, null, null, { // No i18n
		            skipParent: true
		        });
		    }
		    toggleSlideShowButton() {
		        this._nextEleObj.prop('disabled', (this._data.currentPosition >= this._data.slideCount)); // No i18n
		        this._prevEleObj.prop('disabled', (this._data.currentPosition === 1)); // No i18n
		    }
		    hideItemsBeforeFullScreen() {
		        this.element.addClass('zpreview--fullscreenMode'); // No I18N
		        this._footerEle.hide();
		        this.element.find('.zpreview--header, .zpreview--navigation, .zpreview--navigation button').css('visibility', 'hidden'); // No I18N
		    }
		    showItemsAfterFullScreen() {
		        this.element.removeClass('zpreview--fullscreenMode'); // No I18N
		        this._footerEle.show();
		        this.element.find('.zpreview--header, .zpreview--navigation, .zpreview--navigation button').css('visibility', 'visible'); // No I18N
		        if (!this._opts.loop) {
		            this._checkNavBtnVisibility();
		        }
		    }
		    _checkNavBtnVisibility() {
		        let prevBtn = this._prevEleObj,
		            nextBtn = this._nextEleObj,
		            currentPosition = this._data.currentPosition;
		        if (currentPosition === 1) {
		            this._visibility(prevBtn);
		        } else if (prevBtn.is(':hidden') === false) {
		            this._visibility(prevBtn, true);
		        }
		        if (currentPosition === this._data.slideCount) {
		            this._visibility(nextBtn);
		        } else if (nextBtn.is(':hidden') === false) {
		            this._visibility(nextBtn, true);
		        }
		    }
		    toggleFullScreen() {
		        this.hideItemsBeforeFullScreen();
		        let element = this.element;
		        if ((document.fullScreenElement && document.fullScreenElement !== null) ||
		            (!document.mozFullScreen && !document.webkitIsFullScreen)) {
		            if (document.documentElement.requestFullScreen) {
		                document.documentElement.requestFullScreen();
		            } else if (document.documentElement.mozRequestFullScreen) {
		                document.documentElement.mozRequestFullScreen();
		            } else if (element[0].webkitRequestFullScreen) {
		                element[0].webkitRequestFullScreen();
		            }
		        }
		    }
		    addButton(arg) {
		        arg = Array.isArray(arg) ? arg : [ arg ];
		        for (let i = 0; i < arg.length; i++) {
		            this._createButton(arg[i])
		        }
		    }
		    _createButton(object) {
		        let data = this._data,
		            target = object.target,
		            newButton; // No I18N
		        newButton = ZC.ZButton.getBtnProps({
		            title: object.title,
		            id: object.id || ZC.getID('zpreview-'), // No i18n
		            type: 'icon' || object.type, // No I18N
		            text: object.text,
		            className: `zpreview__button ${object.class}`, // No I18N
		            iconClassName: object.iconClassName,
		            SVGIconId: object.SVGIconId,
		            templateRender: true
		        });
		        if (target === 'header') { // No I18N
		            data.toolbarButtons[object.position === 'first' ? 'unshift' : 'push'](newButton); // No I18N
		            this._refreshContainer('header'); // No i18n
		        } else {
		            data.footerButtons[object.position === 'first' ? 'unshift' : 'push'](newButton); // No I18N
		            this._refreshContainer('footer'); // No i18n
		        }
		        this._opts.toolbarButtons = data.toolbarButtons;
		        this._opts.footerButtons = data.footerButtons;
		    }
		    addMenuActions(menuDetails) {
		        this._createMenuItem('zpreview__more--menu', menuDetails); // No i18n
		    }
		    _createMenuItem(menuID, menuArray) {
		        let base = this;
		        ZC.createMenu(menuID, menuArray, { // No I18N
		            contentType: 'text', // No I18N
		            type: 'list', // No I18N
		            className: 'zpreview__menu', // No I18N
		            menuClass: menuID, // No I18N
		            direction: 'bottom-left' // No I18N
		        });
		        $('#zpreview__more--menu').on('zmenubeforehide', function() {
		            base._header.find('.zpreview--edit').removeClass('zpreview__button--hover');
		        }).on('zmenubeforeshow', function() {
		            base._header.find('.zpreview--edit').addClass('zpreview__button--hover');
		        });
		    }
		}
	ZC.registerComponent('ZPreview', ZPreview); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zpreview.Templates, Utilities = ZC.Templates.Utilities, button = ZC.zbutton.Templates.WCContainer; 
template.WCChildren = (data) => ZT.html `${data.imgDetails ? template.WCImageContainer(data) : data.slidesDOM} ${data.header && template.WCHeader(data)} ${data.showArrowIcon && template.WCNavigation(data)} ${template.WCFooter(data)} ${template.WCFilmStrip(data)} ${data.pagination && template.WCPagination(data)}`; 
template.WCErrorContainer = (data) => ZT.html `${data.errorMessage && ZT.html `<div class="zpreview__errormessage"> ${Utilities.WCIcon(data.errorMessage)} <p>${data.errorMessage.text}</p> ${data.errorButton && button(data.errorButton)} </div>`}`; 
template.WCLoader = () => ZT.html `<div class="zprogress zprogress--circle zpreview--loader"><svg class="zprogress__loader h-determinate zeffects--rotate"><circle class="circle__track" cx="24" cy="24" r="20" stroke-dasharray="0" stroke-dashoffset="0" stroke-width="4"></circle><circle class="circle__load" cx="24" cy="24" r="20" stroke-dasharray="94.29" stroke-dashoffset="55" stroke-width="4"></circle></svg></div>`; 
template.WCPopover = (data) => ZT.html `<div class='zpreview--popover zh-dnone'>${data.userInfo.name}<br>${data.userInfo.email}</div>`; 
template.WCImageContainer = (data) => ZT.html `<div class="zpreview--container"><div class='zpreview--content${data.errorMessage ? ' zpreview--errorcontainer' : ' zpreview--fittowidth'}' > ${data.iframe && ZT.html `<iframe class='zpreview__frame' id="zpreview__frame" scrolling='auto' frameborder='0' onerror='${data.errorCallBack}' >`} <img class='zpreview__image' src='${data.selectedURL}' /> ${template.WCErrorContainer(data)}${template.WCLoader()} ${data.iframe && ZT.html `</iframe>`} </div></div>`; 
template.WCNavigation = (data) => ZT.html `<div class="zpreview--navigation"> ${button(data.previousButton)} ${button(data.nextButton)}</div>`; 
template.WCPagination = (data) => ZT.html `<div class="zpreview__pagination" > ${data.bullets.map((bulletInfo) => ZT.html `<span class="zpreview__bullets ${bulletInfo.className}"></span>`)} </div>`; 
template.WCHeader = (data) => ZT.html `<div class="zpreview--header"> ${data.showImageName && template.WCTitle(data)} <div class="zpreview__toolbar" > ${data.toolbarButtons && data.toolbarButtons.map((value) => button(value))} </div> ${button(data.closeButton)} </div>`; 
template.WCTitle = (data) => ZT.html ` <h3 class="zpreview__title">${data.title}</h3> `; 
template.WCThumbnailEle = (data, n, initialImage) => ZT.html ` <div class="zpreview__thumbnail ${initialImage === n && 'is-selected'}" > <div class="zpreview__thumbnail__imageContainer"> <img src="${data.src}" alt="Image ${n}" thumbnail="${n}" /> </div> </div>`; 
template.WCFilmStrip = (data) => ZT.html `<div class="zpreview__filmstripactions" style="visibility:hidden" > ${data.filmStripButton && data.filmStripButton.map((value) => button(value))} </div>`; 
template.WCFooter = (data) => ZT.html `<div class="zpreview--footer"> <div class="zpreview__toolbar" > ${data.footerButtons && data.footerButtons.map((value) => button(value))} <div class='zpreview--imagedetails zh-dnone'> ${data.imageInfoText}</div> </div> <div class="zpreview__paginationtext"> ${data.currentPosition} of ${data.slideCount} </div> <div class="zpreview__userinfo" > ${data.userInfo && ZT.html `<img src = "${data.userInfo.src}" class = "zpreview__userphoto"></img> ${template.WCPopover(data)}`} </div> <div class="zpreview__thumbnailContainer" > ${data.thumbnail && data.thumbnail.map((value, n) => template.WCThumbnailEle(value, n + 1, data.currentPosition))} </div> <div class="zpreview__gradient zpreview__filmStripGradientLeft" ></div> <div class="zpreview__gradient zpreview__filmStripGradientRight" ></div> </div>`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zpreview.Templates, Utilities = ZC.Templates.Utilities, button = ZC.zbutton.Templates.container; 
template.children = (data) => ZT.html `${data.imgDetails ? template.imageContainer(data) : data.slidesDOM} ${data.header && template.header(data)} ${data.showArrowIcon && template.navigation(data)} ${template.footer(data)} ${template.filmStrip(data)} ${data.pagination && template.pagination(data)}`; 
template.errorContainer = (data) => ZT.html `${data.errorMessage && ZT.html `<div class="zpreview__errormessage"> ${Utilities.icon(data.errorMessage)} <p>${data.errorMessage.text}</p> ${data.errorButton && button(data.errorButton)} </div>`}`; 
template.loader = () => ZT.html `<div class="zprogress zprogress--circle zpreview--loader"><svg class="zprogress__loader h-determinate zeffects--rotate"><circle class="circle__track" cx="24" cy="24" r="20" stroke-dasharray="0" stroke-dashoffset="0" stroke-width="4"></circle><circle class="circle__load" cx="24" cy="24" r="20" stroke-dasharray="94.29" stroke-dashoffset="55" stroke-width="4"></circle></svg></div>`; 
template.popover = (data) => ZT.html `<div class='zpreview--popover zh-dnone'>${data.userInfo.name}<br>${data.userInfo.email}</div>`; 
template.imageContainer = (data) => ZT.html `<div class="zpreview--container"><div class='zpreview--content${data.errorMessage ? ' zpreview--errorcontainer' : ' zpreview--fittowidth'}' > ${data.iframe && ZT.html `<iframe class='zpreview__frame' id="zpreview__frame" scrolling='auto' frameborder='0' onerror='${data.errorCallBack}' >`} <img class='zpreview__image' src='${data.selectedURL}' /> ${template.errorContainer(data)}${template.loader()} ${data.iframe && ZT.html `</iframe>`} </div></div>`; 
template.navigation = (data) => ZT.html `<div class="zpreview--navigation"> ${button(data.previousButton)} ${button(data.nextButton)}</div>`; 
template.pagination = (data) => ZT.html `<div class="zpreview__pagination" > ${data.bullets.map((bulletInfo) => ZT.html `<span class="zpreview__bullets ${bulletInfo.className}"></span>`)} </div>`; 
template.header = (data) => ZT.html `<div class="zpreview--header"> ${data.showImageName && template.title(data)} <div class="zpreview__toolbar" > ${data.toolbarButtons && data.toolbarButtons.map((value) => button(value))} </div> ${button(data.closeButton)} </div>`; 
template.title = (data) => ZT.html ` <h3 class="zpreview__title">${data.title}</h3> `; 
template.thumbnailEle = (data, n, initialImage) => ZT.html ` <div class="zpreview__thumbnail ${initialImage === n && 'is-selected'}" > <div class="zpreview__thumbnail__imageContainer"> <img src="${data.src}" alt="Image ${n}" thumbnail="${n}" /> </div> </div>`; 
template.filmStrip = (data) => ZT.html `<div class="zpreview__filmstripactions" style="visibility:hidden" > ${data.filmStripButton && data.filmStripButton.map((value) => button(value))} </div>`; 
template.footer = (data) => ZT.html `<div class="zpreview--footer"> <div class="zpreview__toolbar" > ${data.footerButtons && data.footerButtons.map((value) => button(value))} <div class='zpreview--imagedetails zh-dnone'> ${data.imageInfoText}</div> </div> <div class="zpreview__paginationtext"> ${data.currentPosition} of ${data.slideCount} </div> <div class="zpreview__userinfo" > ${data.userInfo && ZT.html `<img src = "${data.userInfo.src}" class = "zpreview__userphoto"></img> ${template.popover(data)}`} </div> <div class="zpreview__thumbnailContainer" > ${data.thumbnail && data.thumbnail.map((value, n) => template.thumbnailEle(value, n + 1, data.currentPosition))} </div> <div class="zpreview__gradient zpreview__filmStripGradientLeft" ></div> <div class="zpreview__gradient zpreview__filmStripGradientRight" ></div> </div>`; }(ZComponents)); 
(function(ZC, $){
		/* eslint-disable no-undef */
		/* $Id$ */
		class ZFontlibrary  extends ZC.CoreComponent{
			get name(){
				return "zfontlibrary";
			}
		    get attrs() {
		        return {
		            rtl: false,
		            previewText: null,
		            updateTo: null,
		            searchByName: null,
		            type: 'modeless' // No i18n   [modal|modeless]
		        };
		    }
		    get props() {
		        return {
		            keys: {
		                'yes.label': 'Yes', // No I18N
		                'no.label': 'No', // No I18N
		                'category.label': 'Category', // No I18N
		                'search.label': 'Search', // No I18N
		                'removeall.label': 'Remove All', // No I18N
		                'removeallwarning.label': 'Are you sure you want to remove all the fonts?', // No I18N
		                'removesearch.label': 'Remove search', // No I18N
		                'selectfonttoviewmore.label': 'Select a font to view more details.', // No I18N
		                'fontlibrary.label': 'Font Library', // No I18N
		                'alllanguages.label': 'All languages', // No I18N
		                'myFonts.label': 'My Fonts', // No I18N
		                'allFonts.label': 'All Fonts', // No I18N
		                'fontType1.label': 'Serif', // No I18N
		                'fontType2.label': 'Sans Serif', // No I18N
		                'fontType3.label': 'Fixed width', // No I18N
		                'fontType4.label': 'Display', // No I18N
		                'fontType5.label': 'Decorative', // No I18N
		                'fontType6.label': 'Handwritten', // No I18N
		                'fontType7.label': 'Calligraphy', // No I18N
		                'fontType8.label': 'Others', // No I18N
		                'cursive.label': 'Cursive', // No I18N
		                'cartoon.label': 'Cartoon', // No I18N
		                'gothic.label': 'Gothic', // No I18N
		                'typewriter.label': 'Typewriter', // No I18N
		                'comic.label': 'Comic', // No I18N
		                'retro.label': 'Retro', // No I18N
		                'fontSize.label': 'Font Size', // No I18N
		                'alphabets.label': 'Aa', // No I18N
		                'fontInfo.label': 'Font Info', // No I18N
		                'noFonts.label': 'No Fonts', // No I18N
		                'thin.label': 'Thin', // No I18N
		                'thinitalic.label': 'Thin Italic', // No I18N
		                'extralight.label': 'ExtraLight', // No I18N
		                'ultralight.label': 'Ultra Light', // No I18N
		                'ultralightitalic.label': 'Ultra Light Italic', // No I18N
		                'light.label': 'Light', // No I18N
		                'lightitalic.label': 'Light Italic', // No I18N
		                'normal.label': 'Normal', // No I18N
		                'italic.label': 'Italic', // No I18N
		                'medium.label': 'Medium', // No I18N
		                'mediumitalic.label': 'Medium Italic', // No I18N
		                'semibold.label': 'Semi Bold', // No I18N
		                'semibolditalic.label': 'Semi Bold Italic', // No I18N
		                'bold.label': 'Bold', // No I18N
		                'bolditalic.label': 'Bold Italic', // No I18N
		                'extrabold.label': 'Extra Bold', // No I18N
		                'extrabolditalic.label': 'Extra Bold Italic', // No I18N
		                'black.label': 'Black', // No I18N
		                'blackitalic.label': 'Black Italic', // No I18N
		                'addToLibrary.label': 'Add to My Fonts', // No I18N
		                'removeFromLibrary.label': 'Remove from My Fonts', // No I18N
		                'remove.label': 'Remove', // No I18N
		                'defaultSentence.label': 'ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789', // No I18N
		                'fontfamily.label': 'Font Family', // No I18N
		                'fontvariants.label': 'Font Variants', // No I18N
		                'fontvariant.label': 'Font Variant', // No I18N
		                'language.label': 'Languages', // No I18N
		                'randomSentence1.label': 'A quick brown fox jumps over the lazy dog.', // No I18N
		                'randomSentence2.label': 'Mr. Jock, TV quiz PhD, bags few lynx.', // No I18N
		                'randomSentence3.label': 'The five boxing wizards jump quickly.', // No I18N
		                'randomSentence4.label': 'Pack my box with five dozen liquor jugs.', // No I18N
		                'randomSentence5.label': 'Jackdaws love my big sphinx of quartz.', // No I18N
		                'randomSentence6.label': 'Jack amazed a few girls by dropping the antique onyx vase.', // No I18N
		                'randomSentence7.label': 'A quick movement of the enemy will jeopardize six gunboats.', // No I18N
		                'updateerror.label': 'Sorry! Unable to update My Fonts list due to an unknown error.', // No I18N
		                'unknownerror.label': 'Sorry! We are unable to get My Fonts list due to an unknown error. Please try to again after some time.' // No I18N
		            }
		        };
		    }
		    get EVENTS() {
		        return [ 'open', 'close', 'beforeclose', 'restore', 'minimize', 'update' ]; // No I18N
		    }
		    _close() {
		        this._opts.isDialogOpen = false;
		        this._triggerEvent(this._EVENTS.ONCLOSE);
		        this._container.zdialog('destroy'); // No I18N
		        $('.zfontlibrary__lazyload, .zfontlibrary__fontBackground').remove(); // No I18N
		        this._container.remove();
		        $(document).off('mouseenter.zfl mouseleave.zfl click.zfl keydown.zfl'); // No I18N
		        this._textArea.off('keyup.zfl, keydown.zfl'); // No I18N
		        // this._searchBox.off('keyup.zfl'); // No I18N
		    }
		    _init(element, opts) {
		        this._getFontList();
		        let base = this;
		        this._fontPath = opts.hostName || FCWebFont.hostName || location.protocol + '//webfonts.zohostatic.com/'; // No I18N
		        this._baseArray = [];
		        this._tempArray = [];
		        this._reqArray = [];
		        this._displayCount = this._lazyLoadCount = opts.lazyLoadCount || 30;
		        this._pushCount = 0;
		        this._toRefresh = true;
		        this._currLangVal = this._getString('alllanguages.label'); // No I18N
		        this._currTextVal = ZFontsUtil.currentSearch = ZFontsUtil.currentLanguage = -1;
		        this._myFontsCount = 0;
		        this._addToOptGroup = false;
		        this._isIE9 = ZC.Browser.isIE && ZC.Browser.getIEVersion === 9;
		        if (opts.updateTo !== '' && opts.updateTo !== undefined) {
		            this._fontCombo = $('#' + opts.updateTo.split(',')[0]);
		            this._fontOptGroup = this._fontCombo;
		            if (opts.updateTo.split(',')[1] !== undefined) {
		                this._fontOptGroup = $('#' + opts.updateTo.split(',')[1]);
		                this._addToOptGroup = true;
		            }
		        }
		        this.fontWeights = ZFontsUtil.getFontVariants();
		        this._onlyWeights = [ '100', '200', '300', '400', '500', '600', '700', '800', '900' ]; // No I18N
		        this._variantNames = ZFontsUtil.getVariantNames();
		        this._italicWeights = [ '100i', '200i', '300i', '400i', '500i', '600i', '700i', '800i', '900i' ]; // No I18N
		        if (navigator.appVersion.indexOf('MSIE 9.') !== -1) {
		            this._isIE9 = true;
		        }
		        this._myFontLoadedStatus = false;
		        this._createObjects();
		        this._data.searchBox = {
		            icon: this._createIcons('search'), // No I18N
		            closeIcon: this._createIcons('close'), // No I18N
		            placeholder: base._getString('search.label'), // No I18N
		            title: base._getString('removesearch.label') // No I18N
		        }
		        this._data.myfonts = this._getString('myFonts.label'); // No I18N
		        this._data._noFonts = this._getString('noFonts.label'); // No I18N
		        this._data.fontSize = this._getString('fontSize.label'); // No I18N
		        this._data.alphabets = this._getString('alphabets.label'); // No I18N
		        this._data.selectmorefont = this._getString('selectfonttoviewmore.label'); // No I18N
		        this._data.fontInfo = this._getString('fontInfo.label'); // No I18N
		        this._initFontsCSS();
		    }
		    _createIcons(name) {
		        return {
		            iconClassName: `zfontlibrary__${name}icon`, // No I18N
		            SVGIconId: `#zc__svg--${name}`, // No I18N
		            SVGIconClassName: ''
		        }
		    }
		    _createObjects() {
		        let styles = document.getElementById('ui-zfl-styles');
		        this._fontTypeArray = {
		            myfonts: {
		                isMyFonts: true,
		                label: this._getString('myFonts.label'), // No I18N
		                importCount: 0
		            },
		            allfonts: {
		                label: this._getString('allFonts.label'), // No I18N
		                importCount: 0
		            },
		            serif: {
		                label: this._getString('fontType1.label'), // No I18N
		                importCount: 0
		            },
		            sansserif: {
		                label: this._getString('fontType2.label'), // No I18N
		                importCount: 0
		            },
		            fixedwidth: {
		                label: this._getString('fontType3.label'), // No I18N
		                importCount: 0
		            },
		            display: {
		                label: this._getString('fontType4.label'), // No I18N
		                importCount: 0
		            },
		            decorative: {
		                label: this._getString('fontType5.label'), // No I18N
		                importCount: 0
		            },
		            handwritten: {
		                label: this._getString('fontType6.label'), // No I18N
		                importCount: 0
		            },
		            calligraphy: {
		                label: this._getString('fontType7.label'), // No I18N
		                importCount: 0
		            },
		            others: {
		                label: this._getString('fontType8.label'), // No I18N
		                importCount: 0
		            }
		        };
		        this._otherCategoryTypes = {
		            cartoon: {
		                label: this._getString('cartoon.label') // No I18N
		            },
		            gothic: {
		                label: this._getString('gothic.label') // No I18N
		            },
		            typewriter: {
		                label: this._getString('typewriter.label') // No I18N
		            },
		            comic: {
		                label: this._getString('comic.label') // No I18N
		            },
		            cursive: {
		                label: this._getString('cursive.label') // No I18N
		            },
		            retro: {
		                label: this._getString('retro.label') // No I18N
		            }
		        };
		        this._styleElt = styles === null ? $('<style id="ui-zfl-styles">') : $(styles); // No I18N
		        if (styles === null) {
		            $('head').prepend(this._styleElt); // No I18N
		        }
		        this._data.fontTypeLabel = [];
		        for (let type in this._fontTypeArray) {
		            this._data.fontTypeLabel.push(type);
		        }
		        this._data.fontTypeArray = this._fontTypeArray;
		        this._data.otherCategoryTypes = this._otherCategoryTypes;
		        this._data.listboxOption = {
		            multiple: true
		        };
		        this._previewText = [
		            this._getString('randomSentence1.label'), // No I18N
		            this._getString('randomSentence2.label'), // No I18N
		            this._getString('randomSentence3.label'), // No I18N
		            this._getString('randomSentence4.label'), // No I18N
		            this._getString('randomSentence5.label'), // No I18N
		            this._getString('randomSentence6.label'), // No I18N
		            this._getString('randomSentence7.label')
		        ];
		        this._setPreviewText();
		        this._data.previewList = [ 48, 36, 26, 20, 16, 14, 12, 10 ];
		        this._pushCount = 0;
		        this._createFontList(this._pushCount);
		        this._createFontInfo(ZFontsUtil.getWebFont(this._data.fontlist[0].label));
		    }
		    _createFontInfo(fontObj) {
		        if (fontObj) {
		            let fontName = fontObj.name,
		                fontType = fontObj.type ? fontObj.type : 'others', // No I18N
		                fontTypetext = (!this._fontTypeArray[fontType]) ? this._otherCategoryTypes[fontType].label : this._fontTypeArray[fontType].label;
		            let variant = this._creaetFontVarients(null, fontObj);
		            // eslint-disable-next-line no-useless-escape
		            variant = variant.toString().replace(/\,/g, ', '); // No I18N
		            this._data.fontDetails = [
		                {
		                    label: this._getString('fontfamily.label'),
		                    value: fontName
		                },
		                {
		                    label: this._getString('category.label'),
		                    value: fontTypetext
		                },
		                {
		                    label: this._getString('fontvariants.label'),
		                    value: variant + '.',
		                    wordwrap: 'break-word' // No I18N
		                },
		                {
		                    label: this._getString('language.label'),
		                    value: (fontObj.languages || 'English') + '.' // No I18N
		                }
		            ];
		            return true;
		        }
		        return false;
		    }
		    _createLanguageCombo() {
		        let languages = ZFontsUtil.getLanguages();
		        this._data.languages = [];
		        languages.forEach((label) => {
		            this._data.languages.push({
		                label: label,
		                value: label.toLowerCase()
		            });
		        });
		        return true;
		    }
		    _getFontList(fromUser) {
		        let baseObj = this;
		        let callbacks = {
		            success(serverResponse) {
		                baseObj._myFontLoadedStatus = true;
		                if (serverResponse.myFonts !== undefined) {
		                    if (baseObj._updateMyFonts(serverResponse)) {
		                        ZComponents.listbox('#ui-zfl-fontlist-ul').setAttribute('values', baseObj._selectedFonts); // No I18N
		                        baseObj._myFontsCountContainer.find('.zfontlibrary__myfontscount').text(baseObj._selectedFonts.length); // No I18N
		                    }
		                    fromUser ? baseObj._updateFont() : baseObj._initLayout();
		                }
		            },
		            fail() {
		                dialogOpen = false;
		                !fromUser && baseObj._initLayout();
		                baseObj._showError(undefined, true);
		            }
		        };
		        FCUtil.ajaxUtil('getfontlist.do', 'GET', null, callbacks); // No I18N
		    }
		    _initLayout() {
		        this._showPreLoader();
		        this._createFontPreviewContainer();
		    }
		    _postRender() {
		        let base = this;
		        let container = this._container = this.element.find('#ui-zfl-container'); // No I18N
		        this._createDialog();
		        this._preloader = container.find('.zfontlibrary__preloader'); // No I18N
		        this._fontFilter = container.find('.zfontlibrary__fontfilter'); // No I18N
		        this._fontTypesList = container.find('#ui-zfl-category'); // No I18N
		        this._fontList = container.find('.zfontlibrary__fontlist'); // No I18N
		        this._fontListGroup = container.find('.zfontlibrary__fontlistgroup'); // No I18N
		        this._searchBox = container.find('.zfontlibrary__searchbox input'); // No I18N
		        this._searchtoggleIcon = container.find('.zfontlibrary__elementcollapse'); // No I18N
		        this._previewContainer = container.find('.zfontlibrary__previewer'); // No I18N
		        this._fontPreviewer = container.find('.zfontlibrary__previewarea'); // No I18N
		        this._noPreviewContainer = container.find('.zfontlibrary__nopreview'); // No I18N
		        this._noPreview = container.find('.zfontlibrary__viewmoredetails'); // No I18N
		        this._selectedLabel = container.find('.ui-zfl-selection_content'); // No I18N
		        this._textArea = container.find('#ui-textArea-id'); // No I18N
		        this._fontSizeButton = container.find('.zfontlibrary__fontsizebutton'); // No I18N
		        this._returnBackDiv = container.find('.zfontlibrary__curve'); // No I18N
		        this._fontInfo = container.find('.zfontlibrary__infobutton'); // No I18N
		        this._fontSizeDiv = container.find('.zfontlibrary__fontsizecontainer'); // No I18N
		        this._varFontSize = container.find('.zfontlibrary__fontsizepreview'); // No I18N
		        this._noFontsMsgDiv = container.find('.zfontlibrary__nofontcontainer'); // No I18N
		        this._fontType = container.find('.zfontlibrary__fonttype'); // No I18N
		        this._backgroundSubjDiv = container.find('.zfontlibrary__textarea'); // No I18N
		        this._hiddenDiv = container.find('#ui-hiddenDiv-id'); // No I18N
		        this._returnBackIcon = container.find('.zfontlibrary__infobutton.is-selected'); // No I18N
		        this._myFontsCountContainer = container.find('.zfontlibrary__counts'); // No I18N
		        if (this._createLanguageCombo()) {
		            ZC.createComboBox({
		                id: 'fontLanguageMenu', // No I18N
		                appendTo: base._fontFilter,
		                className: 'language__combo', // No I18N
		                tabindex: '10002', // No I18N
		                options: base._data.languages,
		                selectedIndex: 0,
		                width: '140px', // No I18N
		                dataMapping: {
		                    label: 'label', // No I18N
		                    value: 'value' // No I18N
		                },
		                search: {
		                    criteria: 'contains', // No I18N
		                    by: 'value', // No I18N
		                    highlightKeyword: true
		                },
		                dropdownList: {
		                    height: 350
		                },
		                placeholder: this._getString('language.label') // No I18N
		            });
		        }
		        this._setPreviewText();
		        this._pushCount = 0;
		        if (this._data.fontlist) {
		            ZC.createListBox({
		                id: 'ui-zfl-fontlist-ul', // No I18N
		                appendTo: base._fontListGroup,
		                multiple: true,
		                className: 'zfontlibrary--listbox', // No I18N
		                contentType: 'image-text-asc', // No I18N
		                tabindex: '10004', // No I18N
		                // data: base._data.fontlist,
		                dataSource: {
		                    URL: '../source/js/feature-library/fcomponents/js/zfontslist.json' // No I18N
		                },
		                checkedIcon: true,
		                checkboxPosition: 'right', // No I18N
		                selectorToIgnoreSelection: '*',
		                selectOnENTERKeyPress: false,
		                // clearButton: true,
		                values: base._selectedFonts,
		                width: '230px', // No I18N
		                height: '100%', // No I18N
		                searchField: base._searchBox,
		                dataMapping: {
		                    text: 'name', // No I18N
		                    value: 'name' // No I18N
		                },
		                viewPerPage: 20,
		                search: {
		                    criteria: 'contains', // No I18N
		                    by: 'name' // No I18N
		                },
		                // customSearch: function(query, records) {
		                //     return records.filter((record) => {
		                //         if (record.type && record.name) {
		                //             return record.name.indexOf(query) !== -1;
		                //         } else if (true) {
		                //             console.log(record.type, record.name)
		                //         }
		                //     });
		                // },
		                change: function(e) {
		                    base._changeHandler(e);
		                },
		                itemfocus: function(e) {
		                    base._itemFocusHandler(e);
		                }
		            });
		            this._fontGroup = this._fontListGroup.find('.zfontlibrary--listbox'); // No I18N
		        }
		        this._currFont = this._fontGroup.find('li:first'); // No I18N
		        if (this._creaetFontVarients(this._currFont.data('label'))) {
		            ZC.createSelect({
		                id: 'ui-zfl-variant-combo', // No I18N
		                appendTo: container.find('.zfontlibrary__fontadder'), // No I18N
		                tabindex: '10005', // No I18N
		                options: base._data.fontVariaents,
		                width: '140px', // No I18N
		                dropdownList: {
		                    width: '140px' // No I18N
		                }
		            });
		        }
		        this._bindEvents();
		        this._initialType();
		        this._initLayout();
		    }
		    _initialType() {
		        if (this._isIE9) {
		            this._searchBox.width(116);
		        }
		        this._currFontType = this._fontTypesList.children(':nth-child(2)').addClass('zfontlibrary__selectedcategory'); // No I18N
		        this._fontTypesList.children(':nth-child(2)').addClass('has-focus').find('a').focus(); // No I18N
		        this._changeTabIndex(this._currFontType.find('a'), 10001); // No I18N
		        this._changeTabIndex(this._fontTypesList.children(':first').find('a'), -1); // No I18N
		        ZFontsUtil.currentType = this._currentType = this._currFontType.data('label'); // No I18N
		        let length = (this._selectedFonts && this._selectedFonts.length) || 0;
		        // this._data.currentCount = length;
		        // this._render(this._data, 'fontCount', this._myFontsCountContainer[0], null); // No I18N
		        this._myFontsCountContainer.find('.zfontlibrary__myfontscount').text('' + length + ''); // No I18N
		        (length >= 10) && this._myFontsCountContainer.width(30);
		    }
		    _createFontObject(fname) {
		        fname = ZFontsUtil.getWebFont(fname);
		        let name = fname.name,
		            clsname = name.toLowerCase();
		        clsname = clsname.replace(/ +/g, '');
		        return {
		            value: name,
		            label: name,
		            className: `zfc-${clsname}`,
		            customAttribute: {
		                'data-preview': clsname // No I18N
		            }
		        };
		    }
		    _createFontList(count) {
		        this._displayCount = this._lazyLoadCount;
		        let tcount = 0,
		            base = this,
		            initialCount = count * this._displayCount;
		        this._data.fontlist = [];
		        ZFontsUtil.forEachWebFont(function(aWebFont) {
		            tcount++;
		            let fname = base._createFontObject(aWebFont.name);
		            base._data.fontlist.push(fname);
		            if (tcount >= initialCount + base._displayCount) {
		                return 0;
		            }
		        });
		        return true;
		    }
		    _creaetFontVarients(label, object) {
		        let variantArr = [];
		        let fontObj = object || ZFontsUtil.getWebFont(label);
		        if (fontObj && fontObj.variants) {
		            for (let j in fontObj.variants) {
		                variantArr.push(this.fontWeights[j]);
		            }
		            if (variantArr.indexOf(this.fontWeights['700']) === -1) { // No I18N
		                variantArr.push(this.fontWeights['700']); // No I18N
		            }
		            if (variantArr.indexOf(this.fontWeights['400i']) === -1) { // No I18N
		                variantArr.push(this.fontWeights['400i']); // No I18N
		            }
		            if (variantArr.indexOf(this.fontWeights['700i']) === -1) { // No I18N
		                variantArr.push(this.fontWeights['700i']); // No I18N
		            }
		        }
		        this._data.fontVariaents = variantArr;
		        return variantArr;
		    }
		    _bindEvents() {
		        let base = this,
		            container = this._container,
		            thread, timeout1, timeout2,
		            animTime = 500;
		        this._langCombo = container.find('#fontLanguageMenu'); // No I18N
		        this._initCategoryClickEvents();
		        // this._searchBox.on('keyup.zfl', function(event) { // No I18N
		        //     if (event.keyCode === ZComponents.keyCode.TAB) {
		        //         return;
		        //     }
		        //     let searchVal = $(this).val();
		        //     if (base._currTextVal !== searchVal) {
		        //         clearTimeout(thread);
		        //         if (!base._noFontsShown) {
		        //             base._fontList.add($(base._previewContainer));
		        //         }
		        //         base._currFont.add($(base._currFontType));
		        //         base._resetDivs(true);
		        //         if (searchVal !== '') {
		        //             base._searchtoggleIcon.attr('class', 'zfontlibrary__searchloader').html(''); // No I18N
		        //             base._beforeSearchFontType = base._currFontType;
		        //             base._toRefresh = true;
		        //             base._addElt = 'search'; // No I18N
		        //             base._pushCount = 0;
		        //             thread = setTimeout(function() {
		        //                 base._addElements(base._addElt, base._pushCount, undefined, true);
		        //             }, 200);
		        //         } else {
		        //             thread = setTimeout(function() {
		        //                 base._clearTextBox();
		        //             }, 200);
		        //         }
		        //         base._currTextVal = searchVal;
		        //     }
		        // });
		        this._searchtoggleIcon.click(function() {
		            if ($(this).html() !== '') { // No I18N
		                setTimeout(function() {
		                    base._clearTextBox();
		                }, 200);
		            }
		        });
		        this._langCombo.on('zcomboboxchange', function(e, ui) { // No I18N
		            let lanVal = ui.value,
		                thread;
		            if (base._currLangVal !== lanVal) {
		                clearTimeout(thread);
		                if (!base._noFontsShown) {
		                    base._fontList.add($(base._previewContainer));
		                }
		                // base._currFont.add($(base._currFontType));
		                base._resetDivs(true);
		                if (lanVal !== '') { // No I18N
		                    base._beforeSearchFontType = base._currFontType;
		                    base._toRefresh = true;
		                    base._addElt = 'language'; // No I18N
		                    base._pushCount = 0;
		                    thread = setTimeout(function() {
		                        // base._addElements(base._addElt, base._pushCount, undefined, true);
		                    }, 200);
		                }
		                base._currLangVal = lanVal;
		            }
		        });
		        container.find('#ui-zfl-variant-combo').on('zselectchange', function(e) { // No I18N
		            let fontStyle = 'normal'; // No I18N
		            if ((e.detail.value).indexOf('i') > -1) { // No I18N
		                fontStyle = 'italic'; // No I18N
		            }
		            let fontFamilyText = base._currFont.length && base._currFont.data('label').toLowerCase(); // No I18N
		            base._textArea.add(base._varFontSize.find('span')).css({ // No I18N
		                'font-family': fontFamilyText, // No I18N
		                'font-weight': parseInt(e.detail.value), // No I18N
		                'font-style': fontStyle // No I18N
		            });
		        });
		        this._textArea.on('focus.zfl', function() { // No I18N
		            base._textArea.select();
		            base._textArea.mouseup(function() {
		                base._textArea.off('mouseup'); // No I18N
		                return false;
		            });
		            base._textAreaVal = base._textArea.val();
		        }).on('keydown.zfl', function(e) { // No I18N
		            if (e.keyCode === 27) {
		                e.preventDefault();
		                e.stopPropagation();
		                base._textArea.val(base._textAreaVal);
		            }
		            base._hideTextarea();
		        }).on('keyup.zfl', function() { // No I18N
		            base._hideTextarea();
		        });
		        this._fontSizeButton.on('click', function() { // No I18N
		            if (!base._fontSizeButton.hasClass('ui-zfl-btn-disable')) { // No I18N
		                setTimeout(function() {
		                    base._showPreview();
		                    if (!base._lesserText) {
		                        base._fontSizeButton.addClass('ui-zfl-btn-disable'); // No I18N
		                    }
		                }, 10);
		            }
		        }).on('dblclick', function(e) { // No I18N
		            e.stopPropagation();
		            e.preventDefault();
		        });
		        this._returnBackDiv.on('click', function() { // No I18N
		            base._restorePreview();
		        });
		        this._fontInfo.off('click').on('click', function() { // No I18N
		            // base._fontPreviewer.css({
		            //     overflow: 'hidden' // No I18N
		            // });
		            if (timeout1) {
		                clearTimeout(timeout1);
		            }
		            if (base._isIE9) {
		                base._fontPreviewer.clearQueue().animate({
		                    opacity: 0.1,
		                    left: '-340px' // No I18N
		                }, animTime);
		                base._hiddenDiv.clearQueue().show().animate({
		                    opacity: 1,
		                    left: '30px' // No I18N
		                }, animTime);
		            } else {
		                base._fontPreviewer.addClass('zfontlibrary__previewareaanimate'); // No I18N
		                base._hiddenDiv.show();
		                timeout1 = setTimeout(function() {
		                    base._hiddenDiv.addClass('zfontlibrary__fontdetailsanimate'); // No I18N
		                }, 50);
		            }
		            base._fontInfo.css('display', 'none'); // No I18N
		            base._returnBackIcon.css('display', 'inline-block').focus(); // No I18N
		            base._fontInfoShown = true;
		        });
		        this._hiddenDiv.on('scroll.zfl', function(e) {
		            let ele = base._hiddenDiv;
		            if ($(e.target).scrollTop() && (ele.outerHeight() + ele.scrollTop() < ele[0].scrollHeight)) {
		                ele.addClass('zfontlibrary__fontdetailsshadow'); // No I18N
		            } else {
		                ele.removeClass('zfontlibrary__fontdetailsshadow'); // No I18N
		            }
		        });
		        this._returnBackIcon.off('click').on('click', function() { // No I18N
		            if (timeout2) {
		                clearTimeout(timeout2);
		            }
		            let ele = base._hiddenDiv;
		            if (base._isIE9) {
		                ele.clearQueue().animate({
		                    opacity: 0,
		                    left: '330px' // No I18N
		                }, animTime, function() {
		                    $(this).hide();
		                });
		                base._fontPreviewer.clearQueue().animate({
		                    opacity: 1,
		                    left: '0px' // No I18N
		                }, animTime);
		            } else {
		                ele.removeClass('zfontlibrary__fontdetailsanimate'); // No I18N
		                base._fontPreviewer.removeClass('zfontlibrary__previewareaanimate'); // No I18N
		                timeout2 = setTimeout(function() {
		                    ele.hide();
		                }, animTime);
		            }
		            base._fontInfo.css('display', 'inline-block').focus(); // No I18N
		            base._returnBackIcon.css('display', 'none'); // No I18N
		            base._fontInfoShown = false;
		        });
		        this._fontPreviewer.click(function(e) {
		            if ((e.target !== base._textArea) && base._textArea.val() === '') {
		                base._textArea.val(base._defaultValue);
		                base._backgroundSubjDiv.hide();
		            }
		        });
		        this._container.on('keyup.zfl', function(e) { // No i18n
		            // base._keyEvents(e);
		        });
		    }
		    _previewHandler(isSelected) {
		        if (isSelected) {
		            this._previewContainer.removeClass('zh-dnone'); // No I18N
		            this._noPreviewContainer.addClass('zh-dnone'); // No I18N
		            this._fontPreviewer.removeClass('zh-dnone'); // No I18N
		            this._fontInfo.removeClass('zh-dnone'); // No I18N
		        } else {
		            this._noPreviewContainer.removeClass('zh-dnone'); // No I18N
		            this._previewContainer.addClass('zh-dnone'); // No I18N
		            this._fontPreviewer.addClass('zh-dnone'); // No I18N
		            this._fontInfo.addClass('zh-dnone'); // No I18N
		        }
		    }
		    _itemFocusHandler(event) {
		        this._currFont.removeClass('zfontlibrary__selectedcategory'); // No I18N
		        let currentLI = $(event.detail.targetItem);
		        if (this._currFont.data('label') !== currentLI.data('label')) {
		            this._currFont = currentLI.addClass('zfontlibrary__selectedcategory'); // No I18N
		            this._fontTypesList.find('li.has-focus').removeClass('has-focus'); // No I18N
		            this._fontGroup.addClass('zfontlibrary__textnoselect'); // No I18N
		            this._previewHandler(true);
		            this._refreshComponents(currentLI);
		        } else {
		            this._currFont.addClass('zfontlibrary__selectedcategory'); // No I18N
		        }
		    }
		    _changeHandler(event) {
		        let textselect,
		            hiddenSpanCount = this._myFontsCountContainer.children(':first'), // No I18N
		            hiddenSpanCount1 = this._myFontsCountContainer.children(':last'), // No I18N
		            base = this,
		            currentLI = $(event.detail.targetItem),
		            setTimeoutDiv,
		            animTime = 500,
		            len = base._fontGroup.find('ul').children().length,
		            closeElement = currentLI.find('input'); // No I18N
		        this._css = ''; // No I18N
		        this._fontTypesList.find('li.has-focus').removeClass('has-focus'); // No I18N
		        this._countAnimation = true;
		        this._increaseVal = false;
		        this._fontGroup.addClass('zfontlibrary__textnoselect'); // No I18N
		        if (this._currentType === 'myfonts') { // No I18N
		            thisObj.remove();
		            this._myFontsCount = this._myFontsCount - 1;
		        } else if (!event.detail.targetItemMappedData.selected) { // No I18N
		            closeElement.attr('title', this._getString('addToLibrary.label')); // No I18N
		            this._myFontsCount = this._myFontsCount - 1;
		        } else if (event.detail.targetItemMappedData.selected) { // No I18N
		            closeElement.attr('title', this._getString('removeFromLibrary.label')); // No I18N
		            this._myFontsCount = this._myFontsCount + 1;
		            this._increaseVal = true;
		        }
		        let fontName = ZFontsUtil.getWebFont(currentLI.data('label')); // No I18N
		        if (fontName) {
		            if (this._increaseVal) {
		                this._selectedFonts.push(fontName.getFontName());
		            } else {
		                let fontIndex = this._selectedFonts.indexOf(fontName.getFontName());
		                if (fontIndex > -1) {
		                    this._selectedFonts.splice(fontIndex, 1);
		                }
		            }
		        }
		        this._updateFontList(currentLI);
		        this._myFontsCountContainer.show();
		        if (setTimeoutDiv) {
		            clearTimeout(setTimeoutDiv);
		        }
		        setTimeout(function() {
		            if (this._myFontsCount < 10) {
		                base._myFontsCountContainer.width(20);
		            } else if (base._myFontsCount >= 10) {
		                base._myFontsCountContainer.width(30);
		            }
		            if (base._increaseVal) {
		                hiddenSpanCount1.text(base._myFontsCount).attr('class', 'zfontlibrary__myfontscount zfontlibrary__myfontscountincrease').css('top', 0).clearQueue().animate({ // No I18N
		                    top: -18
		                }, animTime);
		                hiddenSpanCount.text(base._myFontsCount - 1).attr('class', 'zfontlibrary__myfontscount zfontlibrary__myfontscountincrease').css('top', 0).clearQueue().animate({ // No I18N
		                    top: -18
		                }, animTime);
		            } else {
		                hiddenSpanCount.text(base._myFontsCount).attr('class', 'zfontlibrary__myfontscount zfontlibrary__myfontscountdecrease').css('top', -18).clearQueue().animate({ // No I18N
		                    top: 0
		                }, animTime);
		                hiddenSpanCount1.text(base._myFontsCount + 1).attr('class', 'zfontlibrary__myfontscount zfontlibrary__myfontscountdecrease').css('top', -18).clearQueue().animate({ // No I18N
		                    top: 0
		                }, animTime);
		            }
		        }, 100);
		        setTimeoutDiv = setTimeout(function() {
		            $(hiddenSpanCount).add($(hiddenSpanCount1)).attr('class', 'zfontlibrary__myfontscount'); // No I18N
		        }, 1500);
		        if (len === 0) { // No I18N
		            base._noFonts();
		        }
		        clearTimeout(textselect);
		        textselect = setTimeout(function() {
		            base._fontGroup.removeClass('zfontlibrary__textnoselect'); // No I18N
		            currentLI.removeClass('animate'); // No I18N
		        }, 500);
		        this._previewHandler(this._fontGroup.find('li.has-focus')); // No I18N
		    }
		    _createDialog() {
		        this._opts.isDialogOpen = true;
		        let base = this;
		        let dialogLeft = (window.innerWidth - 765) / 2;
		        let dialogTop = (window.innerHeight - 460) / 3;
		        // this._mainDiv = $('<div>').attr({
		        //     id: 'ui-zfl-main',
		        //     'class': 'zfontlibrary__wrapper'
		        // }).appendTo(this._container); // No I18N
		        this._container.zdialog({
		            type: base._opts.type,
		            autoOpen: true,
		            minimizable: base._opts.type === 'modeless', // No I18N
		            position: {
		                left: dialogLeft,
		                top: dialogTop
		            },
		            width: 785,
		            resizable: false,
		            className: 'zfontlibrary', // No I18N
		            title: base._getString('fontlibrary.label'), // No I18N
		            excludeFocus: 'li', // No I18N
		            beforeclose() {
		                base._triggerEvent(base._EVENTS.ONBEFORECLOSE);
		            },
		            close() {
		                base._close();
		            }
		        });
		        this._dialog = this._container.parent();
		        let documentObj = $(document);
		        this._container.on('zdialogminimize', function() { // No I18N
		            if (base._fontNameSpan) {
		                base._fontNameSpan.hide();
		            }
		            base._triggerEvent(base._EVENTS.ONMINIMIZE);
		            documentObj.off('keydown.zfl'); // No I18N
		        }).on('zdialogrestore', function() { // No I18N
		            if (base._fontNameSpan) {
		                base._fontNameSpan.show();
		            }
		            base._triggerEvent(base._EVENTS.ONRESTORE);
		            documentObj.on('keydown.zfl', function(e) { // No i18n
		                // base._keyEvents(e);
		            }).on('click.zfl', function() {
		                // base._removeFocus();
		            });
		        });
		        this._fontPreviewDiv = $('<div>').attr('class', 'zfontlibrary__lazyload').text('ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789').appendTo('body'); // No I18N
		        this._triggerEvent(this._EVENTS.ONOPEN);
		    }
		    _removeFocus() {
		        let ele = this._container.find(':focus');
		        if (!ele.hasClass('zfontlibrary__fontlist') && !ele.closest('li').attr('data-font')) {
		            this._fontGroup.find('li.zfontlibrary__selectedcategory').removeClass('has-focus').trigger('mouseleave.zfl'); // No I18N
		        }
		    }
		    _removeButton(create) {
		        if (create === true && this._selectedFonts.length > 0 && !this._selectContainer) {
		            let base = this;
		            this._fontList.addClass('zfontlibrary__myfontswidth');
		            this._selectContainer = $('<div class="zfontlibrary__selectcontainer">').prependTo(this._fontList);
		            let removeallBtn = $('<button class="zfontlibrary__button">').text(this._getString('removeall.label')).appendTo(this._selectContainer);
		            removeallBtn.off('click.zfl').on('click.zfl', function() { // No I18N
		                ZAlertDialog.open({
		                    type: 'warning', // No I18N
		                    primaryMessage: base._getString('removeallwarning.label'), // No I18N
		                    buttons: [ {
		                        text: FCUtil.getString('no.label', base.keys), // No I18N
		                        isCancel: true
		                    },
		                    {
		                        text: FCUtil.getString('yes.label', base.keys), // No I18N
		                        appearance: 'primary', // No I18N
		                        isCancel: false
		                    }
		                    ],
		                    position: 'center', // No I18N
		                    buttonsOrder: 'mac', // No I18N
		                    buttonsAlignment: 'right', // No I18N
		                    close(e, ui) {
		                        if (ui.buttonOptions && !ui.buttonOptions.isCancel) {
		                            let callbacks = {
		                                progress() {
		                                    // Request progress
		                                },
		                                success() {
		                                    if (base._fontCombo && base._fontCombo.data('zselect')) { // No I18N
		                                        base._fontCombo.zselect('removeOption', base._selectedFonts.map(function(x) { // No I18N
		                                            return x.toLowerCase();
		                                        }));
		                                    }
		                                    let ui = {};
		                                    base._myFontsCount = 0;
		                                    base._myFontsCountContainer.find('div').text('0'); // No I18N
		                                    base._noFonts();
		                                    ui.fonts = base._selectedFonts;
		                                    ui.fontAction = 'removeall'; // No I18N
		                                    base._triggerEvent(base._EVENTS.ONUPDATE, ui);
		                                    base._selectedFonts = [];
		                                    base._fontTypesList.find('li:first').addClass('has-focus').find('a').focus(); // No I18N
		                                },
		                                fail(serverResponse) {
		                                    removeallBtn.focus();
		                                    base._showError(base._getString('updateerror.label'), true); // No I18N
		                                }
		                            };
		                            base._editMyFonts({
		                                fontAction: 'removeall' // No I18N
		                            }, callbacks);
		                        } else {
		                            removeallBtn.focus();
		                        }
		                    }
		                });
		            });
		            // this._handleScroll();
		        } else if (!create && this._selectContainer && this._selectContainer.length > 0) {
		            this._selectContainer.remove();
		            this._selectContainer = undefined;
		            this._fontList.removeClass('zfontlibrary__myfontswidth'); // No I18N
		            // this._handleScroll();
		        }
		    }
		    _initFontsCSS() {
		        let base = this,
		            _containerDiv = '';
		        ZFontsUtil.filterWebFonts(function(aWebFont) {
		            let splitString = base._fontTypeArray[aWebFont.type] && aWebFont.type || 'others'; // No I18N
		            base._fontTypeArray[splitString].importCount++;
		            if (base._fontTypeArray[splitString].importCount > base._lazyLoadCount) {
		                return 1;
		            }
		            let fontWeight = aWebFont[FCWebFont.PROP_DEFAULT_VARIANT];
		            base._fontTypeArray[splitString].importCount++;
		            if (base._fontTypeArray[splitString].importCount <= base._lazyLoadCount) {
		                _containerDiv += '<span style="font-family: ' + aWebFont.name + ';">ABCDEFGHIJKLMNOPQRSTUVXYZ</span>'; // No I18N
		                let fontPath = base._fontPath + aWebFont.getFontVariantName(fontWeight);
		                let firstFontLoaded = base._fontTypeArray[splitString].importCount !== 1;
		                base._createFontFaceCSS(aWebFont.name, fontPath, fontWeight, 'normal', ((firstFontLoaded && aWebFont.preview != false) ? firstFontLoaded : false)); // No I18N
		                ZFontsUtil.getWebFont(aWebFont.name).setProperty('import', !((firstFontLoaded && aWebFont.preview != false) ? firstFontLoaded : false)); // No I18N
		            }
		        });
		        $('<ul class = "zfontlibrary__fontBackground">').appendTo($('body')).append(_containerDiv); // No I18N
		        this._styleElt.append(this._css);
		    }
		    _initCategoryClickEvents() {
		        let base = this,
		            typeValue, tempList;
		        this._fontTypesList.children('li').off('click.zfl').on('click.zfl', function(e) { // No I18N
		            tempList = [];
		            let currentLI = $(this);
		            base._noPreviewContainer.show();
		            base._fontInfo.hide();
		            base._resetTextarea();
		            if ($(base._currFontType)[0] !== currentLI[0] || base._searchBox.val() !== '' || base._doRefresh) { // No I18N
		                base._fontTypesList.find('li').removeClass('has-focus zfontlibrary__selectedcategory'); // No I18N
		                base._changeTabIndex(base._fontTypesList.find('a'), -1) // No I18N
		                base._resetDivs();
		                base._previewContent();
		                base._toRefresh = true;
		                let title = ZFontsUtil.currentType = base._currentType = currentLI.data('label'); // No I18N
		                currentLI.addClass('has-focus zfontlibrary__selectedcategory'); // No I18N
		                base._changeTabIndex(currentLI.find('a'), 10001);
		                base._pushCount = 0;
		                base._addElt = (title === 'allfonts' || title === 'myfonts') ? title : 'type'; // No I18N
		                typeValue = base._addElt === 'type' ? title : ''; // No I18N
		                // setTimeout(function() {
		                //     base._addElements(base._addElt, base._pushCount, base._addElt !== 'type' ? '' : title, true); // No I18N
		                // }, 50);
		                let listElement = ZComponents.listbox('#ui-zfl-fontlist-ul'); // No I18N
		                if (base._addElt === 'allfonts') {
		                    listElement.setAttribute('data', null); // No I18N
		                    listElement.setAttribute('dataSource', {
		                        URL: '../source/js/feature-library/fcomponents/js/zfontslist.json' // No I18N
		                    }); // No I18N
		                } else {
		                    ZFontsUtil.filterWebFonts(function(aWebFont) {
		                        if (base._addElt === 'type' && (aWebFont.type || 'others') === typeValue) { // No I18N
		                            tempList.push(aWebFont);
		                        } else if (base._addElt === 'myfonts' && base._selectedFonts.indexOf(aWebFont.name) !== -1) {
		                            tempList.push(aWebFont);
		                        }
		                    });
		                    setTimeout(function() {
		                        listElement.setAttribute('dataSource', {
		                            URL: null
		                        }); // No I18N
		                        listElement.setAttribute('data', tempList); // No I18N
		                    }, 500);
		                }
		                base._currFontType = currentLI;
		            } else {
		                currentLI.addClass('has-focus'); // No I18N
		            }
		            base._fontFamily = base._currFont && base._currFont.data('label'); // No I18N
		            base._doRefresh = false;
		            base._handleScroll(null, this._varFontSize, true);
		        });
		    }
		    _noFonts() {
		        if (!this._noFontsShown) {
		            this._fontList.addClass('zfontlibrary__borderrtransparent').children().hide(); // No I18N
		            this._previewContainer.add($(this._fontInfo));
		            this._fontInfo.hide();
		            this._noFontsMsgDiv.show();
		            this._noPreview.hide();
		            this._noPreviewContainer.hide();
		            this._fontPreviewer.hide();
		            this._noFontsShown = true;
		            $('<span>').text(this._getString('noFonts.label')).attr({ // No I18N
		                id: 'ui-zfl-no-fonts' // No I18N
		            }).appendTo(this._noFontsMsgDiv);
		            if (this._currentType === 'myfonts') { // No I18N
		                this._fontList.removeClass('zfontlibrary__myfontswidth'); // No I18N
		                this._selectContainer && this._selectContainer.hide();
		            }
		            // this._handleScroll();
		            this._showPreLoader();
		        }
		    }
		    _resetNoFonts() {
		        this._noFontsMsgDiv.hide();
		        this._noPreview.show();
		        this._noFontsMsgDiv.find('#ui-zfl-no-fonts').remove(); // No I18N
		        this._fontList.removeClass('zfontlibrary__borderrtransparent').children().show(); // No I18N
		        // this._handleScroll();
		        this._noFontsShown = false;
		        this._resetMyfonts();
		    }
		    _resetMyfonts() {
		        if (this._currentType === 'myfonts' && this._fontGroup.find('li').length > 0) { // No I18N
		            this._selectContainer && this._selectContainer.show();
		            this._fontList.addClass('zfontlibrary__myfontswidth'); // No I18N
		            // this._handleScroll();
		            this._addbutton = false;
		        }
		    }
		    _previewContent(label) {
		        if (!label) {
		            this._noPreview.show();
		            this._selectedLabel.hide();
		        } else {
		            this._noPreview.hide();
		            this._selectedLabel.show();
		        }
		        if (this._fontGroup.children().length > 0) {
		            this._noPreviewContainer.show();
		        }
		    }
		    _createFontPreviewContainer() {
		        let base = this,
		            textselect;
		        // this._previewContainer = $('<div>').addClass('zfontlibrary__previewer').appendTo(this._mainDiv); // No I18N
		        // this._fontPreviewer = $('<div>').addClass('zfontlibrary__previewarea zfontlibrary__transition').appendTo(this._previewContainer); // No I18N
		        // this._noPreviewContainer = $('<div class="zfontlibrary__nopreview">').appendTo(this._previewContainer); // No I18N
		        // this._noPreview = $('<span class="zfontlibrary__viewmoredetails ">').text(this._getString('selectfonttoviewmore.label')).appendTo(this._noPreviewContainer); // No I18N
		        // this._selectedLabel = $('<span class="ui-zfl-selection_content">').appendTo(this._noPreviewContainer); // No I18N
		        // let fontAdder = $('<div>').addClass('zfontlibrary__fontadder').appendTo(this._fontPreviewer); // No I18N
		        // let fontWeightSelector = $('<select>').attr({ // No I18N
		        //     id: 'ui-zfl-variant-combo', // No I18N
		        //     tabindex: 10005,
		        //     title: this._getString('fontvariant.label') // No I18N
		        // }).appendTo(fontAdder);
		        // fontWeightSelector.on('zselectchange', function(e, ui) { // No I18N
		        //     let fontStyle = 'normal'; // No I18N
		        //     if ((ui.value).indexOf('i') > -1) { // No I18N
		        //         fontStyle = 'italic'; // No I18N
		        //     }
		        //     let fontFamilyText = base._currFont.length && base._currFont.data('fontfamily').toLowerCase(); // No I18N
		        //     base._textArea.add(base._backgroundSubjDiv).add(base._varFontSize.find('span')).css({ // No I18N
		        //         'font-family': fontFamilyText, // No I18N
		        //         'font-weight': parseInt(ui.value), // No I18N
		        //         'font-style': fontStyle // No I18N
		        //     });
		        // });
		        // let fontSize = $('<div>').addClass('zfontlibrary__fontsize').appendTo(this._fontPreviewer); // No I18N
		        // this._fontSizeButton = $('<button>').attr({ // No I18N
		        //     title: FCUtil.getString('fontSize.label', this.keys), // No I18N
		        //     tabindex: 10006
		        // }).addClass('zfontlibrary__fontsizebutton').text(this._getString('alphabets.label')).appendTo(fontSize); // No I18N
		        // let fontPreview = $('<div>').addClass('zfontlibrary__fontpreview').appendTo(this._fontPreviewer); // No I18N
		        // this._textArea = $('<textarea>').attr({ // No I18N
		        //     id: 'ui-textArea-id', // No I18N
		        //     spellcheck: false,
		        //     tabindex: 10007
		        // }).appendTo(fontPreview);
		        // this._backgroundSubjDiv = $('<textarea>').css('position', 'absolute').hide(); // No I18N
		        // this._textArea.before(this._backgroundSubjDiv);
		        // this._setPreviewText();
		        // this._fontInfo = $('<button>').attr({ // No I18N
		        //     title: this._getString('fontInfo.label'), // No I18N
		        //     tabindex: 10008
		        // }).addClass('zfontlibrary__infobutton').text('i').appendTo(this._previewContainer).hide(); // No I18N
		        // let hiddenDiv = $('<div>').attr('id', 'ui-hiddenDiv-id').addClass('zfontlibrary__fontdetails zfontlibrary__transition').appendTo(this._previewContainer); // No I18N
		        // this._fontPreviewer.after(hiddenDiv);
		        // this._noFontsMsgDiv = $('<div class="zfontlibrary__nofontcontainer">').css('cursor', 'zfontlibrary__elementcollapse').appendTo(this._previewContainer).hide(); // No I18N
		        // this._fontPreviewer.after(this._noFontsMsgDiv);
		        // this._fontSizeDiv = $('<div>').addClass('zfontlibrary__fontsizecontainer').appendTo(fontPreview); // No I18N
		        // this._varFontSize = $('<div>').addClass('zfontlibrary__fontsizepreview').appendTo(this._fontSizeDiv); // No I18N
		        // this._handleScroll(true, this._varFontSize);
		        // let setTimeoutDiv = ''; // No I18N
		        // for (let k = 0; k <= 7; k++) {
		        //     if (!this._varFontSize.children('.zscroll__container').children('.zscroll__content').length) { // No I18N
		        //         $('<div>').addClass('zscroll__content').appendTo(this._varFontSize); // No I18N
		        //     }
		        //     this._varFontSize.children('.zscroll__container').children('.zscroll__content').append('<span></span>'); // No I18N
		        // }
		        // if (!this._currFontType) {
		        //     // NeedToRevisit
		        //     this._currFontType = this._fontTypesList.children(':nth-child(2)').addClass('zfontlibrary__selectedcategory'); // No I18N
		        //     this._changeTabIndex(this._fontTypesList.children(':nth-child(2)').find('a'), 10001); // No I18N
		        // }
		        let title = this._currFontType.data('label'); // No I18N
		        this._addElt = (title === 'allfonts' || title === 'myfonts') ? title : 'type'; // No I18N
		        // let initialImportCount = 0;
		        // fontWeightSelector.append('<option></option>'); // No I18N
		        // this._addElements(this._addElt, 0, this._addElt !== 'type' ? '' : title, true); // No I18N
		        // fontWeightSelector.zselect({
		        //     width: '140px' // No I18N
		        // });
		        // let hiddenSpanCount = $('<div>').text('' + this._myFontsCount + '').after('<br/>').addClass('zfontlibrary__myfontscount').appendTo(this._myFontsCountContainer); // No I18N
		        // let hiddenSpanCount1 = $('<div>').addClass('zfontlibrary__myfontscount').appendTo(this._myFontsCountContainer); // No I18N\
		        // if (this._selectedFonts && this._selectedFonts.length >= 10) {
		        //     this._myFontsCountContainer.width(30);
		        // }
		        // let updatedFont;
		        // let animTime = 500;
		        // $('#ui-zfl-fontlist-ul').off('click.zfl').on('click.zfl', function(e, enterPressed) { // No I18N
		        //     base._css = ''; // No I18N
		        //     let thisObj = updatedFont = $(e.target).closest('li'), // No I18N
		        //         isIcon = $(e.target).is('i'); // No I18N
		        //     if (!thisObj.length) {
		        //         return;
		        //     }
		        //     base._fontTypesList.find('li.has-focus').removeClass('has-focus'); // No I18N
		        //     let len = base._fontGroup.children().length,
		        //         currentLI = $(e.target).closest('li'), // No I18N
		        //         closeElement = $(e.target).closest('i'); // No I18N
		        //     if (currentLI.length > 0 && base._addElt !== 'myfonts' && !isIcon) { // No I18N
		        //         base._fontPreviewer.css('visibility', 'hidden').show(); // No I18N
		        //     }
		        //     if (!isIcon) {
		        //         thisObj.addClass('has-focus zfontlibrary__selectedcategory'); // No I18N
		        //         base._changeTabIndex(thisObj.find('a'), 10004); // No I18N
		        //         base._currFont.trigger('mouseleave'); // No I18N
		        //     }
		        //     if (closeElement.length > 0 || enterPressed) {
		        //         let closeLi = closeElement.closest('li'); // No I18N
		        //         let closeSpan = closeLi.find('span'); // No I18N
		        //         base._countAnimation = true;
		        //         base._increaseVal = false;
		        //         !isIcon && base._fontInfo.show();
		        //         base._fontGroup.addClass('zfontlibrary__textnoselect'); // No I18N
		        //         if (base._currentType === 'myfonts') { // No I18N
		        //             thisObj.remove();
		        //             base._myFontsCount = base._myFontsCount - 1;
		        //             if (isIcon && closeLi.hasClass('zfontlibrary__selectedcategory')) { // No I18N
		        //                 base._noPreviewContainer.show();
		        //                 base._fontPreviewer.hide();
		        //                 base._fontInfo.hide();
		        //             }
		        //         } else if (closeLi.hasClass('zfontlibrary__deselectedicon')) { // No I18N
		        //             closeLi.addClass('zfontlibrary__selectedicon').removeClass('zfontlibrary__deselectedicon'); // No I18N
		        //             closeElement.html(base._plusSVG).attr('title', base._getString('addToLibrary.label')).css('visibility', 'visible'); // No I18N
		        //             closeSpan.attr('visibility', 'hidden'); // No I18N
		        //             base._myFontsCount = base._myFontsCount - 1;
		        //         } else if (closeLi.hasClass('zfontlibrary__selectedicon')) { // No I18N
		        //             closeLi.removeClass('zfontlibrary__selectedicon').addClass('zfontlibrary__deselectedicon'); // No I18N
		        //             closeElement.html(base._minusSVG).attr('title', base._getString('removeFromLibrary.label')).css('visibility', 'visible'); // No I18N
		        //             closeSpan.attr('visibility', 'visible'); // No I18N
		        //             base._myFontsCount = base._myFontsCount + 1;
		        //             base._increaseVal = true;
		        //         }
		        //         let fontName = ZFontsUtil.getWebFont(updatedFont.data('fontfamily')); // No I18N
		        //         if (fontName) {
		        //             if (base._increaseVal) {
		        //                 base._selectedFonts.push(fontName.getFontName());
		        //             } else {
		        //                 let fontIndex = base._selectedFonts.indexOf(fontName.getFontName());
		        //                 if (fontIndex > -1) {
		        //                     base._selectedFonts.splice(fontIndex, 1);
		        //                 }
		        //             }
		        //         }
		        //         base._updateFontList(updatedFont);
		        //         base._myFontsCountContainer.show();
		        //         if (setTimeoutDiv) {
		        //             clearTimeout(setTimeoutDiv);
		        //         }
		        //         setTimeout(function() {
		        //             if (base._myFontsCount < 10) {
		        //                 base._myFontsCountContainer.width(20);
		        //             } else if (base._myFontsCount >= 10) {
		        //                 base._myFontsCountContainer.width(30);
		        //             }
		        //             if (base._increaseVal) {
		        //                 hiddenSpanCount1.text(base._myFontsCount).attr('class', 'zfontlibrary__myfontscount zfontlibrary__myfontscountincrease').css('top', 0).clearQueue().animate({ // No I18N
		        //                     top: -18
		        //                 }, animTime);
		        //                 hiddenSpanCount.text(base._myFontsCount - 1).attr('class', 'zfontlibrary__myfontscount zfontlibrary__myfontscountincrease').css('top', 0).clearQueue().animate({ // No I18N
		        //                     top: -18
		        //                 }, animTime);
		        //             } else {
		        //                 hiddenSpanCount.text(base._myFontsCount).attr('class', 'zfontlibrary__myfontscount zfontlibrary__myfontscountdecrease').css('top', -18).clearQueue().animate({ // No I18N
		        //                     top: 0
		        //                 }, animTime);
		        //                 hiddenSpanCount1.text(base._myFontsCount + 1).attr('class', 'zfontlibrary__myfontscount zfontlibrary__myfontscountdecrease').css('top', -18).clearQueue().animate({ // No I18N
		        //                     top: 0
		        //                 }, animTime);
		        //             }
		        //         }, 100);
		        //         setTimeoutDiv = setTimeout(function() {
		        //             $(hiddenSpanCount).add($(hiddenSpanCount1)).attr('class', 'zfontlibrary__myfontscount'); // No I18N
		        //         }, 1500);
		        //         if (base._currentType !== 'myfonts' && !isIcon) { // No I18N
		        //             base._noPreviewContainer.hide();
		        //             base._fontPreviewer.css('visibility', 'visible').show(); // No I18N
		        //             if (base._selectedFonts.length <= 0) {
		        //                 base._previewContainer.show();
		        //                 base._fontList.removeClass('zfontlibrary__myfontswidth').css('width', 'auto'); // No I18N
		        //                 base._handleScroll();
		        //             }
		        //         }
		        //     } else {
		        //         base._noPreviewContainer.hide();
		        //         base._fontPreviewer.css('visibility', 'visible').show(); // No I18N
		        //         base._fontInfo.show();
		        //     }
		        //     if ($(base._currFont)[0] !== $(this)[0] && len > 0 && !isIcon) {
		        //         base._resetTextarea();
		        //         base._currFont && base._currFont.removeClass('has-focus zfontlibrary__selectedcategory') && base._changeTabIndex(base._currFont.find('a'), -1); // No I18N
		        //         base._fontFamily = thisObj.text();
		        //         base._currFont = thisObj;
		        //         base._handleScroll();
		        //         base._refreshComponents(base._currFont);
		        //     } else {
		        //         base._currFont.find('a').focus(); // No I18N
		        //     }
		        //     if (base._fontGroup.children().length === 0) { // No I18N
		        //         base._noFonts();
		        //     } else if (!isIcon) {
		        //         base._resetDivs();
		        //     }
		        //     clearTimeout(textselect);
		        //     textselect = setTimeout(function() {
		        //         base._fontGroup.removeClass('zfontlibrary__textnoselect'); // No I18N
		        //         currentLI.removeClass('animate'); // No I18N
		        //     }, 500);
		        //     updatedFont = '';
		        //     base._removeFocus();
		        // }).on('mouseenter.zfl', 'li', function(e) { // No I18N
		        //     base._mouseActions($(e.target).closest('li'), true); // No I18N
		        //     let ele = $(e.target).find('a'); // No i18n
		        //     if (ele.length && ele[0].offsetWidth < ele[0].scrollWidth) {
		        //         ele.attr('title', ele.text()); // No i18n
		        //     }
		        // }).on('mouseleave.zfl', 'li', function(e) { // No I18N
		        //     base._mouseActions($(e.target).closest('li')); // No I18N
		        // });
		        // this._container.on('keyup.zfl', function(e) { // No i18n
		        //     base._keyEvents(e);
		        // });
		        // let categoryObject = {};
		        // let fontInfoDiv = $('<div>').addClass('ui-zfl-fontDetails').appendTo(hiddenDiv); // No I18N
		        // this._returnBackIcon = $('<button>').addClass('zfontlibrary__infobutton is-selected').text('i').insertBefore(hiddenDiv).hide(); // No I18N
		        // let titleDiv = $('<li>').appendTo(fontInfoDiv); // No I18N
		        // let titleSpan = $('<span>').text(this._getString('fontfamily.label')).appendTo(titleDiv); // No I18N
		        // let fontfamilyName = this._currFont && this._currFont.data('fontfamily'); // No I18N
		        // title = $('<b>').text(fontfamilyName || '').appendTo(titleDiv); // No I18N
		        // let typeDiv = $('<li>').appendTo(fontInfoDiv); // No I18N
		        // let typeTitle = $('<span>').text(this._getString('category.label')).appendTo(typeDiv); // No I18N
		        // let type = $('<b>').appendTo(typeDiv); // No I18N
		        // let varianceDiv = $('<li>').appendTo(fontInfoDiv); // No I18N
		        // let varianceTitle = $('<span>').css({ // No I18N
		        //     'word-wrap': 'break-word' // No I18N
		        // }).text(this._getString('fontvariants.label')).appendTo(varianceDiv); // No I18N
		        // let variantArr = [];
		        // let variant = $('<b>').appendTo(varianceDiv); // No I18N
		        // let typeArray = [];
		        // let langDiv = $('<li>').appendTo(fontInfoDiv); // No I18N
		        // let langSpan = $('<span>').text(this._getString('language.label')).appendTo(langDiv); // No I18N
		        // let lang = $('<b>').appendTo(langDiv); // No I18N
		        // let timeout1, timeout2;
		        // this._fontInfo.on('click', function() { // No I18N
		        //     base._fontPreviewer.css({
		        //         overflow: 'hidden' // No I18N
		        //     }); // IE
		        //     fontfamilyName = base._currFont.data('fontfamily'); // No I18N
		        //     title.text(fontfamilyName).appendTo(titleDiv); // No I18N
		        //     variantArr = [];
		        //     let fontObj = ZFontsUtil.getWebFont(fontfamilyName);
		        //     if (fontObj) {
		        //         for (let j in fontObj.variants) {
		        //             variantArr.push(base.fontWeights[j]);
		        //         }
		        //         if (variantArr.indexOf(base.fontWeights['700']) === -1) { // No I18N
		        //             variantArr.push(base.fontWeights['700']); // No I18N
		        //         }
		        //         if (variantArr.indexOf(base.fontWeights['400i']) === -1) { // No I18N
		        //             variantArr.push(base.fontWeights['400i']); // No I18N
		        //         }
		        //         if (variantArr.indexOf(base.fontWeights['700i']) === -1) { // No I18N
		        //             variantArr.push(base.fontWeights['700i']); // No I18N
		        //         }
		        //         let fontType = fontObj.type ? fontObj.type : 'others'; // No I18N
		        //         let fontTypetext = (!base._fontTypeArray[fontType]) ? base._otherCategoryTypes[fontType].label : base._fontTypeArray[fontType].label;
		        //         type.text(fontTypetext);
		        //         lang.text((fontObj.languages) ? fontObj.languages : 'English'); // No I18N
		        //         if (fontObj.languages) {
		        //             lang.append('.'); // No I18N
		        //         }
		        //     }
		        //     // eslint-disable-next-line no-useless-escape
		        //     variantArr = variantArr.toString().replace(/\,/g, ', '); // No I18N
		        //     variant.text(variantArr).append('.').appendTo(varianceDiv);
		        //     if (timeout1) {
		        //         clearTimeout(timeout1);
		        //     }
		        //     if (base._isIE9) {
		        //         base._fontPreviewer.clearQueue().animate({
		        //             opacity: 0.1,
		        //             left: '-340px' // No I18N
		        //         }, animTime);
		        //         hiddenDiv.clearQueue().show().animate({
		        //             opacity: 1,
		        //             left: '30px' // No I18N
		        //         }, animTime);
		        //     } else {
		        //         base._fontPreviewer.addClass('zfontlibrary__previewareaanimate'); // No I18N
		        //         hiddenDiv.show();
		        //         let timeout1 = setTimeout(function() {
		        //             hiddenDiv.addClass('zfontlibrary__fontdetailsanimate'); // No I18N
		        //         }, 50);
		        //     }
		        //     base._fontInfo.css('display', 'none'); // No I18N
		        //     base._returnBackIcon.css('display', 'inline-block').focus(); // No I18N
		        //     base._fontInfoShown = true;
		        // });
		        // hiddenDiv.on('scroll.zfl', function(e) {
		        //     if ($(e.target).scrollTop() && (hiddenDiv.outerHeight() + hiddenDiv.scrollTop() < hiddenDiv[0].scrollHeight)) {
		        //         hiddenDiv.addClass('zfontlibrary__fontdetailsshadow'); // No I18N
		        //     } else {
		        //         hiddenDiv.removeClass('zfontlibrary__fontdetailsshadow'); // No I18N
		        //     }
		        // });
		        // this._returnBackIcon.on('click', function() { // No I18N
		        //     if (timeout2) {
		        //         clearTimeout(timeout2);
		        //     }
		        //     if (base._isIE9) {
		        //         hiddenDiv.clearQueue().animate({
		        //             opacity: 0,
		        //             left: '330px' // No I18N
		        //         }, animTime, function() {
		        //             $(this).hide();
		        //         });
		        //         base._fontPreviewer.clearQueue().animate({
		        //             opacity: 1,
		        //             left: '0px' // No I18N
		        //         }, animTime);
		        //     } else {
		        //         base._fontPreviewer.removeClass('zfontlibrary__previewareaanimate'); // No I18N
		        //         hiddenDiv.removeClass('zfontlibrary__fontdetailsanimate'); // No I18N
		        //         timeout2 = setTimeout(function() {
		        //             hiddenDiv.hide();
		        //         }, animTime);
		        //     }
		        //     base._fontInfo.css('display', 'inline-block').focus(); // No I18N
		        //     base._returnBackIcon.css('display', 'none'); // No I18N
		        //     base._fontInfoShown = false;
		        // });
		        // this._fontPreviewer.click(function(e) {
		        //     if ((e.target !== base._textArea) && base._textArea.val() === '') {
		        //         base._textArea.val(base._defaultValue);
		        //         base._backgroundSubjDiv.hide();
		        //     }
		        // });
		        // this._textArea.on('focus.zfl', function() { // No I18N
		        //     base._textArea.select();
		        //     base._textArea.mouseup(function() {
		        //         base._textArea.off('mouseup'); // No I18N
		        //         return false;
		        //     });
		        //     base._textAreaVal = base._textArea.val();
		        // }).on('keydown.zfl', function(e) { // No I18N
		        //     if (e.keyCode === 27) {
		        //         e.preventDefault();
		        //         e.stopPropagation();
		        //         base._textArea.val(base._textAreaVal);
		        //     }
		        //     base._hideTextarea();
		        // }).on('keyup.zfl', function() { // No I18N
		        //     base._hideTextarea();
		        // });
		        // this._returnBackDiv = $('<div>').addClass('zfontlibrary__curve').appendTo(this._container).hide(); // No I18N
		        // $('<span>').addClass('zfontlibrary__arrow').appendTo(this._returnBackDiv); // No I18N
		        // this._fontSizeButton.on('click', function() { // No I18N
		        //     if (!base._fontSizeButton.hasClass('ui-zfl-btn-disable')) { // No I18N
		        //         setTimeout(function() {
		        //             base._showPreview();
		        //             if (!base._lesserText) {
		        //                 base._fontSizeButton.addClass('ui-zfl-btn-disable'); // No I18N
		        //             }
		        //         }, 10);
		        //     }
		        // }).on('dblclick', function(e) { // No I18N
		        //     e.stopPropagation();
		        //     e.preventDefault();
		        // });
		        // this._returnBackDiv.on('click', function(e) { // No I18N
		        //     base._restorePreview();
		        // });
		        // this._fontTypesList.find('li:first').append(this._myFontsCountContainer); // No I18N
		        // this._fontTypesList.children(':nth-child(2)').addClass('has-focus').find('a').focus(); // No I18N
		    }
		    _mouseActions(liEle, enter) {
		        let base = this;
		        if (this._currentType !== 'myfonts') { // No I18N
		            setTimeout(function() {
		                let tick = '',
		                    title = '';
		                if (liEle.hasClass('zfontlibrary__selectedicon') && enter) { // No I18N
		                    tick = base._plusSVG;
		                    title = base._getString('addToLibrary.label'); // No I18N
		                } else if (liEle.hasClass('zfontlibrary__deselectedicon')) { // No I18N
		                    tick = enter === undefined ? '' : base._minusSVG;
		                    title = enter === undefined ? '' : base._getString('removeFromLibrary.label'); // No I18N
		                }
		                liEle.find('i').html(tick).css({
		                    visibility: 'visible' // No I18N
		                }).attr('title', title); // No I18N
		                if (!enter) {
		                    liEle.find('i').css({ // No I18N
		                        visibility: 'hidden' // No I18N
		                    });
		                }
		            }, 1);
		        }
		    }
		    _hideTextarea() {
		        if (this._textArea.val() === '') {
		            this._backgroundSubjDiv.css({
		                opacity: 0.15,
		                'font-family': this._fontFamily // No I18N
		            }).show();
		        } else {
		            this._backgroundSubjDiv.hide();
		            this._textArea.show();
		        }
		    }
		    _upDownKeyScroll(downArrow) {
		        let mouseenteredElt = this._fontGroup.find('li span.zfontlibrary__icon').parent().not(this._currFont[0]); // No I18N
		        let indexPush = 0,
		            newEle = this._currFont.next(),
		            base = this;
		        if (!downArrow) {
		            indexPush = 7;
		            newEle = this._currFont.prev();
		        }
		        this._currFont.trigger('mouseleave.zfl'); // No I18N
		        newEle.trigger('click'); // No I18N
		        this._currFont.trigger('mouseenter.zfl'); // No I18N
		        let zscrollEle = this._fontListGroup.children('.zscroll__container').children('.zscroll__content'); // No I18N
		        if (this._currFont.offset().top < zscrollEle.offset().top) {
		            zscrollEle.scrollTop((this._currFont.index() - indexPush) * this._currFont.outerHeight());
		        } else if (this._currFont.offset().top - zscrollEle.offset().top + 10 > zscrollEle.outerHeight()) {
		            zscrollEle.scrollTop((this._currFont.index() - indexPush) * this._currFont.outerHeight());
		        }
		        setTimeout(function() {
		            base._container.zdialog('refreshContent'); // No I18N
		        }, 0);
		    }
		    _upDownKey(ele, down) {
		        ele.trigger('mouseleave.zfl'); // No I18N
		        if (down) {
		            if (ele.next().length > 0) {
		                ele.next().trigger('click'); // No I18N
		            } else {
		                ele.parent().find('li:first').trigger('click'); // No I18N
		            }
		        } else if (ele.prev().length > 0) {
		            ele.prev().trigger('click'); // No I18N
		        } else {
		            ele.parent().find('li:last').trigger('click'); // No I18N
		        }
		        ele.trigger('mouseenter.zfl'); // No I18N
		    }
		    _hideMoreDetails() {
		        this._previewContent();
		        this._fontPreviewer.hide();
		    }
		    _changeTabIndex(ele, index) {
		        ele.attr('tabindex', index); // No I18N
		        if (index !== -1) {
		            ele.focus();
		        }
		        let base = this;
		        setTimeout(function() {
		            base._container.zdialog('refreshContent'); // No I18N
		        }, 1)
		    }
		    // _keyEvents(e) {
		    //     // if(!((this._container.find("input,textarea").is(":focus")) || this._fontPreviewShown || this._noFontsShown || this._fontInfoShown)) {   //No I18N
		    //     let len = this._fontList.find('.zfontlibrary__selectedcategory').length, // No I18N
		    //         isKeydown = e.keyCode === 40,
		    //         base = this;
		    //     let ele = this._container.find(':focus'); // No I18N
		    //     let isList = !!((ele.hasClass('zfontlibrary__fontlist') || ele.closest('li').attr('data-font'))), // No I18N
		    //         isType = !!((ele.hasClass('zfontlibrary__fonttypecontainer') || ele.closest('li').data('label'))); // No I18N
		    //     if (isList) {
		    //         if (((e.keyCode === 8 || e.key === 'Backspace' || e.key === 'Del') && this._currentType === 'myfonts') || (e.keyCode === 32 && this._currentType !== 'myfonts')) { // No I18N
		    //             if (e.key === 'Backspace' || e.key === 'Del' || e.keyCode === 8 || e.keyCode === 32) { // No I18N
		    //                 e.preventDefault();
		    //             }
		    //             if (this._currFont) {
		    //                 let nextEle;
		    //                 if (this._currFont.next().length) {
		    //                     nextEle = this._currFont.next();
		    //                 } else if (this._fontList.find('li').length > 0) {
		    //                     nextEle = this._fontList.find('li:first'); // No I18N
		    //                 }
		    //                 if (nextEle) {
		    //                     this._currFont.find('i').trigger('click'); // No I18N
		    //                     if (this._currentType === 'myfonts') { // No I18N
		    //                         setTimeout(function() {
		    //                             nextEle.closest('li').addClass('zfontlibrary__selectedcategory').trigger('click'); // No I18N
		    //                             base._changeTabIndex(nextEle.closest('li a'), 10004); // No I18N
		    //                             base._currFont = nextEle;
		    //                         }, 50)
		    //                     }
		    //                 } else {
		    //                     this._fontTypesList.find('li:first').addClass('has-focus').find('a').focus(); // No I18N
		    //                 }
		    //             }
		    //         }
		    //     }
		    //     if (e.keyCode === 9 || (e.shiftKey === true && e.key === 9)) {
		    //         if (isType || isList) {
		    //             let eleUL = ele.closest('ul'), // No I18N
		    //                 eleSelect = eleUL.find('li.zfontlibrary__selectedcategory'); // No I18N
		    //             if (eleSelect.length > 0) {
		    //                 eleSelect.addClass('has-focus').trigger('mouseenter.zfl'); // No I18N
		    //             } else {
		    //                 eleUL.find('li:first').addClass('has-focus').trigger('click'); // No I18N
		    //                 eleUL.find('li:first').trigger('mouseenter.zfl'); // No I18N
		    //             }
		    //         } else {
		    //             this._fontTypesList.find('li.has-focus').removeClass('has-focus'); // No I18N
		    //             this._fontGroup.find('li.has-focus').removeClass('has-focus'); // No I18N
		    //         }
		    //         !isList && this._fontGroup.find('li.zfontlibrary__selectedcategory').trigger('mouseleave.zfl'); // No I18N
		    //     }
		    //     if (e.keyCode === 40 || e.keyCode === 38) {
		    //         if ($(e.target).attr('id') !== 'ui-textArea-id') { // No I18N
		    //             e.preventDefault();
		    //         }
		    //         isList && this._upDownKeyScroll(isKeydown);
		    //         isType && this._upDownKey(this._currFontType, isKeydown);
		    //     }
		    //     // }
		    // }
		    _clearTextBox() {
		        this._searchtoggleIcon.attr('class', 'zfontlibrary__elementcollapse').html(''); // No I18N
		        this._searchBox.val('');
		        this._currTextVal = '';
		        this._resetDivs();
		        this._searchBox.focus();
		        this._currFontType.add(this._currFont).addClass('zfontlibrary__selectedcategory'); // No I18N
		        this._toRefresh = true;
		        this._pushCount = 0;
		        let title = ZFontsUtil.currentType = this._currentType = this._currFontType.data('label'), // No I18N
		            base = this;
		        this._addElt = (title === 'allfonts' || title === 'myfonts') ? title : 'type'; // No I18N
		        if (this._currLangVal !== this._getString('alllanguages.label')) { // No I18N
		            this._addElt = 'language'; // No I18N
		        }
		        this._addElements(this._addElt, this._pushCount, this._addElt !== 'type' ? '' : title, true); // No I18N
		        setTimeout(function() {
		            base._resetMyfonts();
		        }, 10);
		    }
		    _resetDivs(search) {
		        if (!search) {
		            if (this._noFontsShown) {
		                this._resetNoFonts();
		            }
		        }
		        if (this._fontPreviewShown) {
		            this._restorePreview();
		        } else if (this._fontInfoShown) {
		            this._returnbackPreview();
		        }
		    }
		    _loadFontFace(ele, fontObj, selFontIndex) {
		        this._css = '';
		        if (fontObj && fontObj.variants) {
		            for (let j in fontObj.variants) {
		                let fontURL = this._fontPath + fontObj.variants[j];
		                let fontStyle = 'normal'; // No I18N
		                if (j.indexOf('i') > -1) { // No I18N
		                    fontStyle = 'italic'; // No I18N
		                }
		                let currfWeight = parseInt(j);
		                let fontPath = fontURL;
		                this._createFontFaceCSS(fontObj.name, fontPath, currfWeight, fontStyle); // No I18N
		            }
		        }
		        this._styleElt.append(this._css);
		    }
		    _showPreview() {
		        let base = this;
		        let time = 300;
		        this._fontSizeButton.addClass('fontSizeSelected'); // No I18N
		        this._fontInfo.hide();
		        this._resetTextarea();
		        if (this._fontPreviewShown) {
		            this._restorePreview();
		        } else {
		            this._fontSizeDiv.css('visibility', 'visible'); // No I18N
		            this._textArea.hide();
		            this._fontSizeDiv.children().find('span').removeClass('zfontlibrary__previewshadow').css({ // No I18N
		                'font-family': base._fontFamily // No I18N
		            }).show(); // No I18N
		            if (this._textArea.val().length > 20) {
		                this._lesserText = false;
		                if (!this._fontNameSpan) {
		                    this._fontNameSpan = $('<span>').text(base._fontFamily).addClass('zdialog__title zfontlibrary__fonttitle').insertBefore(this._dialog.find('.zdialog__actiongroup.zdialog__action')).fadeIn(400); // No I18N
		                } else {
		                    this._fontNameSpan.text(base._fontFamily).fadeIn(400);
		                }
		                this._textArea.hide();
		                this._fontList.addClass('zfontlibrary__borderrlwhite'); // No I18N
		                if (this._isIE9) {
		                    this._fontType.clearQueue().animate({
		                        width: 0,
		                        paddingRight: 0
		                    }, time);
		                    this._fontList.clearQueue().animate({
		                        width: 0,
		                        height: 0
		                    }, time);
		                    this._previewContainer.clearQueue().animate({
		                        width: 742,
		                        marginLeft: '-20', // No I18N
		                        right: 0
		                    }, time);
		                } else {
		                    this._fontType.addClass('zfontlibrary__fonttypeanimate'); // No I18N
		                    this._fontList.addClass('zfontlibrary__fontlistanimate'); // No I18N
		                    this._previewContainer.addClass('zfontlibrary__previeweranimate'); // No I18N
		                }
		                setTimeout(function(e) {
		                    base._fontType.children().hide();
		                    base._fontList.children().fadeOut(100);
		                    if (base._isIE9) {
		                        base._returnBackDiv.clearQueue().animate({
		                            left: '-30px' // No I18N
		                        }, 80, 'easeOutQuart').show(); // No I18N
		                    } else {
		                        base._returnBackDiv.addClass('zfontlibrary__curveanimate').show(); // No I18N
		                    }
		                    setTimeout(function(e) {
		                        $(base._fontSizeButton).addClass('zfontlibrary__icon'); // No I18N
		                        base._fontPreviewShown = true;
		                        base._fontSizeButton.removeClass('ui-zfl-btn-disable'); // No I18N
		                    }, 150);
		                }, 200);
		            } else {
		                base._fontSizeButton.addClass('zfontlibrary__icon').removeClass('ui-zfl-btn-disable'); // No I18N
		                base._fontPreviewShown = true;
		                base._lesserText = true;
		            }
		            let prevSpan = this._varFontSize.find('span'); // No I18N
		            let prevAnchor = this._varFontSize.find('a');
		            this._changeTabIndex(prevAnchor, -1);
		            if (this._textArea.val().length < 80) {
		                let fontSize1 = 48;
		                for (var i = 0; i < 3; i++) {
		                    $(prevSpan[i]).css({
		                        'font-size': fontSize1 // No I18N
		                    }).attr('class', 'zfontlibrary__previewless zfontlibrary__previewshadow'); // No I18N
		                    $(prevAnchor[i]).text(fontSize1);
		                    fontSize1 = fontSize1 - (2 * (6 - i));
		                }
		                let fontSize = 20;
		                $(prevSpan[i]).css({
		                    'font-size': fontSize // No I18N
		                }).attr('class', 'zfontlibrary__previewless zfontlibrary__previewshadow'); // No I18N
		                $(prevAnchor[i]).text(fontSize);
		                fontSize1 = 16;
		                for (i = 4; i < 8; i++) {
		                    $(prevSpan[i]).css({
		                        'font-size': fontSize1 // No I18N
		                    }).attr('class', 'zfontlibrary__previewmin zfontlibrary__previewshadow'); // No I18N
		                    $(prevAnchor[i]).text(fontSize1);
		                    fontSize1 = fontSize1 - 2;
		                }
		            } else {
		                prevSpan.slice(0, 3).hide();
		                prevAnchor.slice(0, 3).hide();
		                for (i = 3; i <= 7; i++) {
		                    fontSize = 25 - (2 * i);
		                    $(prevSpan[i]).css({
		                        'font-size': fontSize // No I18N
		                    }).attr('class', 'zfontlibrary__previewmore'); // No I18N
		                    $(prevAnchor[i]).text(fontSize);
		                }
		            }
		            this._varFontSize[0].children[0].scrollTop = 0;
		            this._varFontSize.css('width', ''); // No I18N
		            setTimeout(function() {
		                base._handleScroll(null, base._varFontSize);
		            }, 250);
		        }
		    }
		    _restorePreview() {
		        let time = 300;
		        if (!this._lesserText) {
		            this._fontNameSpan.remove();
		        }
		        if (this._isIE9) {
		            this._previewContainer.clearQueue().animate({
		                width: 328,
		                marginLeft: 0
		            }, time);
		            this._returnBackDiv.clearQueue().animate({
		                left: '-61px' // No I18N
		            }, 100, 'easeOutQuart').show(); // No I18N
		            this._fontList.clearQueue().animate({
		                width: 230
		            }, time);
		            this._fontType.clearQueue().animate({
		                width: 140,
		                paddingRight: 20
		            }, time);
		        } else {
		            this._previewContainer.removeClass('zfontlibrary__previeweranimate'); // No I18N
		            this._returnBackDiv.hide().removeClass('zfontlibrary__curveanimate'); // No I18N
		            this._fontList.removeClass('zfontlibrary__fontlistanimate'); // No I18N
		            this._fontType.removeClass('zfontlibrary__fonttypeanimate'); // No I18N
		        }
		        this._fontSizeDiv.css('visibility', 'hidden'); // No I18N
		        this._textArea.show();
		        this._fontType.children().show();
		        this._fontList.removeClass('zfontlibrary__borderrlwhite').children().show(); // No I18N
		        let base = this;
		        setTimeout(function() {
		            base._fontSizeButton.removeClass('zfontlibrary__icon'); // No I18N
		            base._fontPreviewShown = false;
		            base._fontSizeButton.removeClass('ui-zfl-btn-disable'); // No I18N
		        });
		        setTimeout(function() {
		            base._fontInfo.css('display', 'inline-block'); // No I18N
		        }, 50);
		        setTimeout(function() {
		            if (base._addElt === 'myfonts' && base._fontPreviewShown) {
		                base._fontList.addClass('zfontlibrary__myfontswidth'); // No I18N
		            }
		        }, 270);
		    }
		    _resetTextarea() {
		        if (this._textArea.val() === '') {
		            this._textArea.val(this._defaultValue);
		            this._backgroundSubjDiv.hide();
		        }
		    }
		    _getFontDetails(fontName) {
		        let fontObj = {},
		            fontDetail = ZFontsUtil.getWebFont(fontName);
		        if (!fontDetail) {
		            return fontObj;
		        }
		        let currFontFace, currVariant,
		            fontFamily = fontDetail.name,
		            fontStyle;
		        fontObj = {
		            allFontFace: '',
		            fontFace: '',
		            fontFaceWithSubest: '',
		            fontName: fontFamily,
		            fontCategory: fontDetail.type,
		            languages: fontDetail.languages ? fontDetail.languages : 'English' // No I18N
		        };
		        for (let currWeight in fontDetail.variants) {
		            currVariant = fontDetail.variants[currWeight];
		            fontStyle = currWeight.indexOf('i') > -1 ? 'italic' : 'normal'; // No I18N
		            currFontFace = ZFontsUtil.getFontFace(fontFamily, currWeight, fontStyle, this._fontPath + currVariant);
		            if (currWeight === '400') { // No I18N
		                fontObj.fontFace = currFontFace;
		            }
		            fontObj.allFontFace += currFontFace;
		            fontObj.fontFaceWithSubest += this._createFontFaceWithSubset(fontFamily, currWeight, fontStyle, this._fontPath + currVariant, fontDetail.subsets);
		        }
		        return fontObj;
		    }
		    _createFontFaceWithSubset(fontFamily, fontWeight, fontStyle, fontPath, subsets) {
		        let fontsString = ''; // No I18N
		        for (let i = 0; i < subsets.length; i++) {
		            fontsString += ZFontsUtil.getFontFace(fontFamily, fontWeight, fontStyle, fontPath, false, 'font_' + subsets[i].script + '.' + FCWebFont.SUPPORTED_WOFF, subsets[i].range); // No I18N
		        }
		        return fontsString;
		    }
		    _createFontFace(fontFamily, fontWeight, fontStyle, fontPath) {
		        return "@font-face{font-family:'" + fontFamily + "';font-weight:" + fontWeight + ';font-style:' + fontStyle + "; src: local('" + fontFamily + "'), url('" + fontPath + '/font.' + FCWebFont.SUPPORTED_WOFF + "') format('" + FCWebFont.SUPPORTED_WOFF + "');}"; // No I18N
		    }
		    _returnbackPreview() {
		        let ele = this._hiddenDiv;
		        if (this._isIE9) {
		            this._fontPreviewer.css({
		                opacity: 1,
		                left: '0px' // No I18N
		            });
		            ele.css({ // No I18N
		                left: '330px', // No I18N
		                opacity: 0.1
		            }).hide();
		        } else {
		            ele.add(this._fontPreviewer).removeClass('zfontlibrary__transition'); // No I18N
		            this._fontPreviewer.removeClass('zfontlibrary__previewareaanimate').show(); // No I18N
		            ele.removeClass('zfontlibrary__fontdetailsanimate').hide(); // No I18N
		            ele.add(this._fontPreviewer).addClass('zfontlibrary__transition'); // No I18N
		        }
		        this._returnBackIcon.hide();
		        this._fontList.removeClass('zfontlibrary__borderrlwhite'); // No I18N
		        this._fontInfoShown = false;
		    }
		    _refreshComponents(updatedfont, isFirst) {
		        let fontCombo = $('#ui-zfl-variant-combo'); // No I18N
		        // fontCombo.find('option').remove(); // No I18N
		        let fontArray = [],
		            fontObj,
		            selFontIndex = null,
		            i;
		        let updatedFontName = updatedfont ? updatedfont.data('label') : $(updatedfont).text(); // No I18N
		        let currFont = $(updatedfont).data('label'); // No I18N
		        let fontDetail = currFont && ZFontsUtil.getWebFont(currFont);
		        if (fontDetail) {
		            if (!fontDetail.subsetloaded) {
		                fontObj = fontDetail;
		                selFontIndex = fontDetail.index;
		            }
		            for (i in fontDetail.variants) {
		                fontArray.push(this.fontWeights[i]);
		            }
		        }
		        if (this._createFontInfo(fontDetail)) {
		            this._render(this._data, 'fontDetailsContainer', $('#ui-hiddenDiv-id')[0], null); // No I18N
		        }
		        if (fontArray.indexOf(this.fontWeights['700']) === -1) { // No I18N
		            fontArray.push(this.fontWeights['700']); // No I18N
		        }
		        let table = {};
		        for (i = 0; i < fontArray.length; i++) {
		            table[fontArray[i]] = fontArray[i];
		        }
		        fontArray = [];
		        for (let j = 0; j < this._onlyWeights.length; j++) {
		            let key = this.fontWeights[this._onlyWeights[j]];
		            if (key in table) {
		                fontArray.push(this._onlyWeights[j]); // add to array
		                fontArray.push(this._italicWeights[j]);
		                delete table[key]; // and prevent readding
		            }
		        }
		        for (let keyNew = 0; keyNew < table.length; keyNew++) {
		            fontArray.push(table[keyNew]); // add all leftover objects
		        }
		        let fontValues = [];
		        for (let k = 0; k < fontArray.length; k++) {
		            fontValues.push({
		                value: fontArray[k],
		                label: this.fontWeights[fontArray[k]]
		            })
		        }
		        this._fontFamily = this._currFont.data('label'); // No I18N
		        if (!fontCombo.data('zselect')) { // No I18N
		            fontCombo.zselect({
		                width: '90px' // No I18N
		            });
		        }
		        fontCombo.zselect('setAttribute', 'options', fontValues); // No I18N
		        fontCombo.zselect('setValue', '400'); // No I18N
		        if (!isFirst) {
		            // this._currFont.addClass('zfontlibrary__selectedcategory'); // No I18N
		            // this._changeTabIndex(this._currFont.find('a'), 10004);
		        }
		        if (fontDetail !== undefined) {
		            this._fontPreviewDiv[0].style.setProperty('font-family', fontDetail.name, 'important'); // No I18N
		            if (fontObj !== undefined) {
		                let fontWeight = fontObj[FCWebFont.PROP_DEFAULT_VARIANT];
		                let fontPath = this._fontPath + fontObj.getFontVariantName(fontWeight);
		                let baseObj = this;
		                // this._createFontFaceCSS(fontObj.name, fontPath, fontWeight, "normal"); //No I18N
		                this._loadFonts(fontPath + '/font.' + FCWebFont.SUPPORTED_WOFF, {}, function(CustomData) { // No I18N
		                    let fontObj = ZFontsUtil.getWebFont(baseObj._fontFamily);
		                    baseObj._updatePreview(fontObj);
		                    fontObj.setProperty('subsetloaded', true); // No I18N
		                    baseObj._loadFontFace(updatedfont || baseObj._currFont, fontObj, selFontIndex);
		                });
		            } else {
		                this._updatePreview(fontDetail);
		            }
		        }
		    }
		    _updatePreview(fontObj) {
		        let fontWeight = fontObj[FCWebFont.PROP_DEFAULT_VARIANT];
		        let defVariant = 'Normal'; // No I18N
		        let fontFamilyWithDefaut = this._fontFamily + ',arial,sans-serif'; // No I18N
		        this._varFontSize.find('span').css({
		            'font-family': fontFamilyWithDefaut, // No I18N
		            'font-style': defVariant, // No I18N
		            'font-weight': fontWeight // No I18N
		        });
		        this._textArea.css({
		            'font-style': defVariant, // No I18N
		            'font-weight': fontWeight // No I18N
		        });
		        this._backgroundSubjDiv.css({
		            'font-style': defVariant, // No I18N
		            'font-weight': fontWeight // No I18N
		        });
		        this._textArea[0].style.setProperty('font-family', fontFamilyWithDefaut, 'important'); // No I18N
		        this._backgroundSubjDiv[0].style.setProperty('font-family', fontFamilyWithDefaut, 'important'); // No I18N
		    }
		    _loaderIcon() {
		        let bottomDiv = $('<div>').attr({ // No I18N
		            id: 'ui-zfl-loader' // No I18N
		        });
		        let loaderDiv = $('<div>').attr({ // No I18N
		            id: 'ui-loaderDiv-id' // No I18N
		        }).appendTo(bottomDiv);
		        if (!this._isIE9) {
		            loaderDiv.addClass('zfontlibrary__loader'); // No I18N
		            $('<div class="zfontlibrary__cssloader1"></div><div class="zfontlibrary__cssloader2"></div><div class="zfontlibrary__cssloader3"></div>').appendTo(loaderDiv); // No I18N
		        } else {
		            loaderDiv.addClass('zfontlibrary__loaderie9 ui-icon-loader-small'); // No I18N
		        }
		        bottomDiv.appendTo(this._fontGroup); // No I18N
		    }
		    _getFurtherFonts() {
		        this._fontListGroup.off('zscrollbarverticalscrollend.zfontlibrary'); // No I18N
		        this._toRefresh = false;
		        if (this._fontGroup.find('#ui-zfl-loader').length === 0) { // No I18N
		            this._loaderIcon();
		        }
		        this._addElements(this._addElt, ++this._pushCount, this._currFontType.data('label'), true); // No I18N
		    }
		    _updFont(fontlist, state) {
		        this._increaseVal = state;
		        this._updateFontList(fontlist.join(','), true);
		    }
		    _updateFont() {
		        if (dialogOpen) {
		            let ele = this._currFontType;
		            this._currFontType = null;
		            ele.trigger('click'); // No I18N
		            this._myFontsCountContainer.find('div').text(this._selectedFonts.length); // No I18N
		        }
		    }
		    _updateFontList(item, fromUser) {
		        let fName = fromUser ? item.name : item.data('label'); // No I18N
		        let lowerCasedName = fName.toLowerCase();
		        let action = this._increaseVal ? 'add' : 'remove'; // No I18N
		        let reqData = {
		            fontName: fName,
		            fontAction: action
		        };
		        let baseObj = this;
		        let callbacks = {
		            progress(serverResponse) {
		                // Request progress
		            },
		            success(serverResponse) {
		                let updateTo = baseObj._fontCombo,
		                    cmtName;
		                updateTo && (cmtName = updateTo[0].tagName === 'SELECT' ? 'zselect' : 'zcombobox'); // No I18N
		                if (cmtName) {
		                    let DOMitems = baseObj._fontOptGroup.find('option'); // No I18N
		                    let items = [];
		                    for (let i = 0; i < DOMitems.length; i++) {
		                        items.push($(DOMitems[i]).val().toLowerCase());
		                    }
		                    if (action === 'add' && items.indexOf(lowerCasedName) === -1) { // No I18N
		                        items.push(lowerCasedName);
		                        items.sort();
		                        let elePos = items.indexOf(lowerCasedName);
		                        let val = {
		                            label: fName,
		                            value: lowerCasedName,
		                            position: elePos,
		                            style: 'font-family:' + fName + ';' // No I18N
		                        };
		                        if (baseObj._addToOptGroup) {
		                            val.optionGroup = baseObj._fontOptGroup;
		                        }
		                        updateTo[cmtName]('addOption', val); // No I18N
		                    } else if (action === 'remove' && items.indexOf(lowerCasedName) !== -1) { // No I18N
		                        updateTo[cmtName]('removeOption', lowerCasedName); // No I18N
		                    }
		                }
		                let ui = {};
		                if (action === 'add') { // No I18N
		                    ui = baseObj._getFontDetails(fName);
		                } else {
		                    ui.fonts = [ fName ];
		                }
		                ui.fontAction = action;
		                baseObj._triggerEvent(baseObj._EVENTS.ONUPDATE, ui);
		                fromUser && baseObj._getFontList(fromUser);
		            },
		            fail(serverResponse) {
		                baseObj._showError(baseObj._getString('updateerror.label'), true); // No I18N
		                // item.trigger('click');
		            }
		        }
		        this._editMyFonts(reqData, callbacks);
		    }
		    _editMyFonts(reqData, callbacks) {
		        FCUtil.ajaxUtil('updatefontlist.do', 'POST', reqData, callbacks); // No I18N
		    }
		    _changeFontType() {
		        this._currFontType.removeClass('zfontlibrary__selectedcategory'); // No I18N
		        this._changeTabIndex(this._currFontType.find('a'), -1);
		        this._currFontType = this._fontTypesList.children(':nth-child(2)').addClass('zfontlibrary__selectedcategory'); // No I18N
		        this._currFontType.find('a').attr('tabindex', 10001); // No I18N
		    }
		    _addElements(action, count, data, loadPreviewOnly) {
		        this._css = ''; // No I18N
		        this._displayCount = this._lazyLoadCount;
		        let initialCount = count * this._displayCount;
		        let tcount = 0,
		            res = 0,
		            base = this;
		        this._loadedCount = 0;
		        this._appendList = ''; // No I18N
		        this._isFinished = false;
		        ZFontsUtil.currentLanguage = this._langCombo.zcombobox('getAttribute', 'selectedIndex') === 0 ? -1 : this._currLangVal; // No I18N
		        ZFontsUtil.currentSearch = this._searchBox.val() !== '' ? this._searchBox.val().toLowerCase() : -1;
		        ZFontsUtil.selectedFonts = this._selectedFonts;
		        if (action === 'allfonts') { // No I18N
		            let that = this;
		            ZFontsUtil.filterWebFonts(function(aWebFont) {
		                tcount++;
		                that._displayElements(action, aWebFont.name, initialCount, tcount, loadPreviewOnly);
		                if (tcount >= initialCount + that._displayCount) {
		                    return 0;
		                }
		            });
		        } else if (action === 'type') { // No I18N
		            ZFontsUtil.filterWebFonts(function(aWebFont) {
		                if ((aWebFont.type || 'others') === data) { // No I18N
		                    tcount++;
		                    base._displayElements(action, aWebFont.name, initialCount, tcount, loadPreviewOnly);
		                    if (tcount >= initialCount + base._displayCount) {
		                        return 0;
		                    }
		                }
		            });
		        } else if (action === 'search') { // No I18N
		            ZFontsUtil.currentType = this._currentType = this._currFontType.data('label'); // No I18N
		            let valThis = this._searchBox.val().toLowerCase(),
		                langList, fontObj, filterStatus;
		            let filteredFonts = ZFontsUtil.getCategoriesFonts(function(propertyName) {
		                filterStatus = propertyName.name.toLowerCase().indexOf(valThis) > -1;
		                fontObj = propertyName;
		                langList = (fontObj.languages && fontObj.languages !== '') ? fontObj.languages.indexOf(base._currLangVal) > -1 : (base._currLangVal === 'English');
		                if (base._currentType === 'myfonts') {
		                    filterStatus = base._selectedFonts.indexOf(propertyName.name) !== -1 ? filterStatus : false;
		                }
		                if (filterStatus && (base._currLangVal === base._getString('alllanguages.label') || langList || base._currLangVal === -1)) { // No I18N
		                    base._displayElements(action, propertyName.name, initialCount, ++tcount, loadPreviewOnly);
		                }
		            });
		            setTimeout(function() {
		                base._resetMyfonts();
		            }, 100);
		        } else if (action === 'language') { // No I18N
		            ZFontsUtil.currentType = this._currentType = this._currFontType.data('label'); // No I18N
		            ZFontsUtil.getFontLanguageList(function(propertyName) {
		                base._displayElements(action, propertyName.name, initialCount, ++tcount, loadPreviewOnly);
		            });
		            setTimeout(function() {
		                base._resetMyfonts();
		            }, 100);
		        } else {
		            ZFontsUtil.filterWebFonts(function(propertyName) {
		                if (base._selectedFonts.indexOf(propertyName.name) !== -1) {
		                    base._displayElements(action, propertyName.name, initialCount, ++tcount, loadPreviewOnly);
		                }
		            });
		        }
		        action = (action === 'language' || action === 'search') && this._currentType === 'myfonts' ? 'myfonts' : action; // No I18N
		        this._showElements(action);
		        this._postAddition(tcount, initialCount);
		        this._styleElt.append(this._css);
		        if (initialCount === 0 && (this._addElt !== 'myfonts') || (this._addElt === 'myfonts' && this._selectedFonts.length > 0)) { // No I18N
		            this._hideMoreDetails();
		        } else {
		            this._fontPreviewer.css('visibility', 'visible'); // No I18N
		        }
		    }
		    _displayElements(action, fName, initialCount, tcount, loadPreviewOnly) {
		        let webFont = ZFontsUtil.getWebFont(fName);
		        this._fontPreviewer.css('visibility', 'hidden'); // No I18N
		        if (action === 'search' || action === 'language') { // No I18N
		            action = this._currentType;
		        }
		        if (initialCount < tcount && tcount < (initialCount + this._displayCount)) {
		            loadPreviewOnly = webFont.subsets && webFont.subsets.length === 0 ? false : loadPreviewOnly;
		            fName = webFont.getFontName();
		            let preview = fName + (loadPreviewOnly === true ? 'preview' : ''); // No I18N
		            let className = (action === 'myfonts' || this._selectedFonts && this._selectedFonts.indexOf(fName) > -1) ? 'zfontlibrary__deselectedicon' : 'zfontlibrary__selectedicon'; // No I18N
		            let previewLabel = webFont.previewLabel != undefined ? webFont.previewLabel : fName;
		            let tick = this._minusSVG,
		                title = this._getString('removeFromLibrary.label'); // No I18N
		            if (action === 'myfonts') { // No I18N
		                tick = this._closeSVG;
		                title = this._getString('remove.label'); // No I18N
		            } else if (className === 'zfontlibrary__selectedicon') { // No I18N
		                tick = this._plusSVG;
		                title = this._getString('addToLibrary.label'); // No I18N
		            }
		            this._appendList += '<li data-font=' + fName.replace(/ +/g, '') + ' data-fontfamily="' + fName + '" class="' + className + '"><span class="zflicon">' + this._tickSVG + '</span><a tabindex=' + (tcount === 1 ? 10004 : -1) + ' data-fontfamily="' + fName + '" style="font-family: ' + preview + ';">' + previewLabel + '</a><i class="zflicon" title="' + title + '">' + tick + '</i></li>'; // No I18N
		            if (this._flag) {
		                this._flag = false;
		                for (y in this._reqArray) {
		                    this._reqArray[y].abort();
		                }
		                this._reqArray = [];
		                this._tempArray = [];
		            }
		            this._fontsShown = false;
		            if ((loadPreviewOnly !== true && !webFont.import) || (loadPreviewOnly === true && !webFont.previewLoaded)) {
		                let base = this;
		                let defaultVariant = webFont[FCWebFont.PROP_DEFAULT_VARIANT];
		                let fontPath = this._fontPath + webFont.getFontVariantName(defaultVariant);
		                loadPreviewOnly = webFont.preview != false ? loadPreviewOnly : false;
		                this._createFontFaceCSS(fName, fontPath, defaultVariant, 'normal', loadPreviewOnly); // No I18N
		                this._tempArray.push(fName);
		                let CustomData = {
		                    fontObjIndex: fName,
		                    fontName: fName
		                };
		                this._loadFonts(webFont.getFontURL(defaultVariant, loadPreviewOnly), CustomData, function(CustomData) {
		                    base._tempArray.pop();
		                    if (loadPreviewOnly !== true) {
		                    } else {
		                        webFont.previewLoaded = true;
		                    }
		                    base._flag = true;
		                    base._handleShowElements(action, true);
		                });
		                initialCount === 0 && this._showPreLoader(true);
		            }
		        }
		    }
		    _handleShowElements(action, scrollPushEnabled) {
		        if (!this._tempArray.length) {
		            let base = this;
		            setTimeout(function() {
		                base._showElements(action, true);
		            }, 1);
		        }
		    }
		    _showElements(action, scrollPushEnabled) {
		        if (!this._tempArray.length) {
		            // this._resetLoader();
		            if (this._toRefresh) {
		                this._fontGroup.html(''); // No I18N
		                if (this._noFontsShown) {
		                    this._resetNoFonts();
		                }
		            }
		            this._fontList.add(this._previewContainer);
		            this._fontGroup.append(this._appendList); // No I18N
		            // this._handleScroll();
		            this._removeButton(this._currentType === 'myfonts');
		            if (this._toRefresh) {
		                this._currFont = this._fontGroup.find('li:first'); // No I18N
		                this._refreshComponents(this._currFont, true);
		                if (action === 'myfonts') { // No I18N
		                    if (!this._noFontsShown) {
		                        this._currFontType = this._fontTypesList.find('li:first');
		                        this._currFont.removeClass('has-focus zfontlibrary__selectedcategory'); // No I18N
		                        if (this._fontGroup.find('li:visible').hasClass('zfontlibrary__selectedcategory')) { // No I18N
		                            this._noPreviewContainer.hide();
		                        }
		                    }
		                }
		            }
		            if (this._addElt === 'search') { // No I18N
		                this._searchtoggleIcon.html('<i class="zfontlibrary__closeicon" title="' + this._getString('removeFromLibrary.label') + '">' + this._closeSVG + '</i>').removeClass('zfontlibrary__searchloader'); // No I18N
		            }
		            this._flag = false;
		            this._tempArray = [];
		            this._fontsShown = true;
		            this._container.zdialog('refreshContent'); // No I18N
		        }
		    }
		    _createFontFaceCSS(fontName, fontPath, fontWeight, fontStyle, isFontPreview) {
		        let clsName = fontName;
		        fontName = fontName + (isFontPreview ? 'preview' : ''); // No I18N
		        this._css += ZFontsUtil.getFontFace(fontName, fontWeight, fontStyle, fontPath, isFontPreview);
		        clsName = clsName.replace(/ +/g, ''); // No I18N
		        this._css += ` .zfontlibrary .zfc-${clsName.toLowerCase()}, .zfontlibrary #ui-zfl-fontlist-ul-${clsName}{ font-family:${fontName};font-style:${fontStyle};font-weight:400;} `; // No I18N
		    }
		    _getLocalName(fontFamily, fStyle) {
		        return 'font-style:' + fStyle + "; src :local('" + fontFamily + "'), local('" + fontFamily + ' ' + fStyle + "'), local('" + fontFamily.replace(/\s/g, '') + '-' + fStyle.replace(/\s/g, '') + "'),"; // No I18N
		    }
		    _postAddition(tcount, initialCount) {
		        if ((tcount - initialCount) < this._displayCount) {
		            this._isFinished = true;
		            // this._resetLoader();
		        }
		        if (this._toRefresh) {
		            if (!this._appendList) {
		                this._noFonts();
		                this._fontList.add(this._previewContainer);
		                this._searchtoggleIcon.attr('class', 'zfontlibrary__elementcollapse'); // No I18N
		                if (this._searchBox.val() !== '') { // No I18N
		                    this._searchtoggleIcon.removeClass('zfontlibrary__elementcollapse').html('<i class="zfontlibrary__closeicon" title="' + this._getString('removeFromLibrary.label') + '">' + this._closeSVG + '</i>'); // No I18N
		                }
		                if (!this._fontsShown) {
		                    this._showPreLoader(true);
		                    this._fontList.add(this._previewContainer);
		                }
		            }
		        }
		    }
		    _showPreLoader(show) {
		        if (show) {
		            this._preloader.show();
		            this._fontList.hide();
		            this._previewContainer.hide()
		        } else {
		            this._preloader.hide();
		            this._fontList && this._fontList.show();
		            this._previewContainer && this._previewContainer.show();
		        }
		    }
		    _resetLoader() {
		        let base = this;
		        this._fontGroup.find('#ui-zfl-loader').remove(); // No I18N
		        this._showPreLoader();
		        this._fontListGroup.off('zscrollbarverticalscrollend.zfontlibrary').on('zscrollbarverticalscrollend.zfontlibrary', function(e) { // No I18N
		            base._getFurtherFonts();
		        });
		    }
		    _getMyFonts() {
		        return this._selectedFonts;
		    }
		    _setPreviewText(text) {
		        if (text) {
		            this._defaultValue = text;
		        } else if (this._data.previewText) {
		            this._defaultValue = this._data.previewText;
		        } else if (this._getString('randomSentence1.label') === 'A quick brown fox jumps over the lazy dog.') { // No I18N
		            this._defaultValue = this._previewText[Math.floor(Math.random() * (this._previewText.length - 1))];
		        } else {
		            this._defaultValue = this._getString('defaultSentence.label'); // No I18N
		        }
		        this._data.previewText = this._defaultValue;
		        this._textArea && this._textArea.val(this._defaultValue);
		    }
		    _loadFonts(fontPath, CustomData, onSuccess) {
		        return $.ajax({
		            type: 'GET', // No I18N
		            accepts: {
		                font: 'font/' + FCWebFont.SUPPORTED_WOFF // No I18N
		            },
		            url: fontPath,
		            dataType: 'font', // No I18N
		            beforeSend(xhr) {
		                xhr.overrideMimeType('font/woff2'); // No I18N
		            },
		            complete(data) {
		                if (onSuccess) {
		                    setTimeout(function() {
		                        onSuccess(CustomData);
		                    }, 100);
		                }
		            }
		        });
		    }
		    _showError(msg, fromUsers) {
		        msg = (msg === '' || msg === undefined) ? this._getString('unknownerror.label') : msg; // No I18N
		        FCUtil.showError(msg, this._container, '#ui-zfl-main'); // No I18N
		    }
		    _getString(key, module, stringArray) {
		        return ZC.getI18NText('zfontlibrary', key, this._opts.keys, stringArray); // No i18n
		        // return FCUtil.getI18NString(module || 'zfontlibrary', key, stringArray, this.keys); // No I18N
		    }
		    _triggerEvent(orgEvent, _ui) {
		        this._container.trigger('zfontlibrary' + orgEvent, _ui); // No I18N
		    }
		    _handleScroll(isInit, forElement, options) {
		        if (forElement) {
		            let isLatestVersion = !!ZComponents.scrollbar;
		            let componentName = isLatestVersion ? 'scrollbar' : 'scroll'; // No I18N
		            if (isInit) {
		                ZComponents[componentName](forElement, options);
		            } else if (options) {
		                ZComponents[componentName](forElement).setAttribute(isLatestVersion ? 'scrollTop' : 'top', 0); // No I18N
		            } else {
		                ZComponents[componentName](forElement)[isLatestVersion ? 'update' : 'refresh'](); // No I18N
		            }
		        }
		    }
		    _updateMyFonts(serverResponse) {
		        if (serverResponse.myFonts !== undefined) {
		            this._selectedFonts = [];
		            let myFontsArray = serverResponse.myFonts.split(','),
		                length; // No I18N
		            this._data.currentCount = length = myFontsArray.length;
		            for (let i = 0; i < length; i++) {
		                let fontObj = ZFontsUtil.getWebFont(myFontsArray[i]);
		                if (fontObj) {
		                    this._selectedFonts.push(fontObj.getFontName());
		                    this._myFontsCount++;
		                }
		            }
		        }
		        return true;
		    }
		    open(data) {
		        let isOpen = this._opts.isDialogOpen;
		        if (isOpen) {
		            this._open(data);
		        } else {
		            this._init(element, data);
		        }
		    }
		    close() {
		        this._close();
		    }
		    addFont(fontlist) {
		        this._updateFont(fontlist, true);
		    }
		    removeFont(fontlist) {
		        this._updateFont(fontlist, false);
		    }
		    setPreviewText(text) {
		        this._setPreviewText(text);
		    }
		    getMyFonts() {
		        return this._getMyFonts();
		    }
		    getFontDetails(fontName) {
		        return this._getFontDetails(fontName);
		    }
		}
	ZC.registerComponent('ZFontlibrary', ZFontlibrary); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let template = ZC.zfontlibrary.Templates, Utilities = ZC.Templates.Utilities, button = ZC.zbutton.Templates.WCContainer; 
template.WCChildren = (data) => ZT.html `<div id='ui-zfl-container' class='zfontlibrary__container'> <div class='zfontlibrary__wrapper'> ${template.WCFontTypeContainer(data)} ${template.WCLoader(data)} ${template.WCFontListContainer(data)} ${template.WCFontPreviewContainer(data)} </div> <div class='zfontlibrary__curve zfontlibrary__curveanimate'> <span class='zfontlibrary__arrow'></span> </div> </div>`; 
template.WCFontTypeContainer = (data) => ZT.html `<div class='zfontlibrary__fonttype'> ${template.WCSearchbox(data.searchBox)} ${template.WCFontType(data)} <div class='zfontlibrary__fontfilter'></div> </div>`; 
template.WCSearchbox = (data) => ZT.html `<div class='zfontlibrary__searchbox'> ${Utilities.WCIcon(data.icon)} <input type='text' class='ztextbox' tabindex='9999' placeholder='${data.placeholder}' /> <span class='zh-dnone'> ${Utilities.WCIcon(data.closeIcon)} </span> </div>`; 
template.WCFontType = (data) => ZT.html `<div class='zfontlibrary__fonttypecontainer'> <ul id='ui-zfl-category'> ${data.fontTypeLabel && data.fontTypeLabel.map((value) => template.WCTypelist(data, value))} </ul> </div>`; 
template.WCTypelist = (data, type) => ZT.html ` <li data-label='${type}'> <a tabindex='-1'>${data.fontTypeArray[type].label}</a> ${data.fontTypeArray[type].isMyFonts && ZT.html `<span class='zfontlibrary__counts'> ${template.WCFontCount(data)} </span>`} </li>`; 
template.WCFontCount = (data) =>ZT.html `<div class='zfontlibrary__myfontscount'>${data.currentCount}</div> <div class='zfontlibrary__myfontscount zh-dnone'>${data.currentCount + 1}</div>`; 
template.WCLoader = (data) => ZT.html `<div class='zfontlibrary__preloader'> <div class='zfontlibrary__loadercircle'></div> </div>`; 
template.WCFontListContainer = (data) => ZT.html `<div class='zfontlibrary__fontlist'> <div class='zfontlibrary__fontlistgroup'> <div class='zfontlibrary__selectcontainer'> <button class='zfontlibrary__button'>${data.removeall}</button> </div> </div></div>`; 
template.WCFontPreviewContainer = (data) => ZT.html `<div class='zfontlibrary__previewer'> ${template.WCFontPreview(data)} <div class='zfontlibrary__nofontcontainer zh-dnone'><span id='ui-zfl-no-fonts'> ${data.noFonts} </span></div> <div id='ui-hiddenDiv-id' class='zfontlibrary__fontdetails zfontlibrary__transition'> ${template.WCFontDetailsContainer(data)} </div> <div class='zfontlibrary__nopreview'> <span class='zfontlibrary__viewmoredetails'>${data.selectmorefont}</span> <span class='ui-zfl-selection_content'></span> </div> <button title='${data.fontInfo}' tabindex="10008" class="zfontlibrary__infobutton zh-dnone">i</button> </div>`; 
template.WCFontDetailsContainer = (data) => ZT.html` <div class='ui-zfl-fontDetails'> ${data.fontDetails && data.fontDetails.map((value) => template.WCFontDetails(value))} </div>`; 
template.WCFontDetails = (font) => ZT.html `<li><span>${font.label}</span><b > ${font.value}</b></li>`; 
template.WCFontPreview = (data) => ZT.html `<div class='zfontlibrary__previewarea zfontlibrary__transition zh-dnone'> <div class='zfontlibrary__fontadder'></div> <div class='zfontlibrary__fontsize'> </div> <div class='zfontlibrary__fontpreview'> <textarea class='zfontlibrary__textarea' style="display:none;"></textarea> <textarea id='ui-textArea-id' spellcheck='false' tabindex='10007'> </textarea> <div class='zfontlibrary__fontsizecontainer'> <div class='zfontlibrary__fontsizepreview'> ${data.previewList && data.previewList.map((value) => template.WCPreview(data, value))} </div> </div> </div> </div>`; 
template.WCPreview = (data, value) => ZT.html `<span class='zfontlibrary__previewless zfontlibrary__previewshadow' font-size='${value}'> <a tabindex='-1'>${value}</a> ${data.previewText} </span>`; }(ZComponents)); 
 (function(ZC){ 
let template = ZC.zfontlibrary.Templates, Utilities = ZC.Templates.Utilities, button = ZC.zbutton.Templates.container; 
template.children = (data) => ZT.html `<div id='ui-zfl-container' class='zfontlibrary__container'> <div class='zfontlibrary__wrapper'> ${template.fontTypeContainer(data)} ${template.loader(data)} ${template.fontListContainer(data)} ${template.fontPreviewContainer(data)} </div> <div class='zfontlibrary__curve zfontlibrary__curveanimate'> <span class='zfontlibrary__arrow'></span> </div> </div>`; 
template.fontTypeContainer = (data) => ZT.html `<div class='zfontlibrary__fonttype'> ${template.searchbox(data.searchBox)} ${template.fontType(data)} <div class='zfontlibrary__fontfilter'></div> </div>`; 
template.searchbox = (data) => ZT.html `<div class='zfontlibrary__searchbox'> ${Utilities.icon(data.icon)} <input type='text' class='ztextbox' tabindex='9999' placeholder='${data.placeholder}' /> <span class='zh-dnone'> ${Utilities.icon(data.closeIcon)} </span> </div>`; 
template.fontType = (data) => ZT.html `<div class='zfontlibrary__fonttypecontainer'> <ul id='ui-zfl-category'> ${data.fontTypeLabel && data.fontTypeLabel.map((value) => template.typelist(data, value))} </ul> </div>`; 
template.typelist = (data, type) => ZT.html ` <li data-label='${type}'> <a tabindex='-1'>${data.fontTypeArray[type].label}</a> ${data.fontTypeArray[type].isMyFonts && ZT.html `<span class='zfontlibrary__counts'> ${template.fontCount(data)} </span>`} </li>`; 
template.fontCount = (data) =>ZT.html `<div class='zfontlibrary__myfontscount'>${data.currentCount}</div> <div class='zfontlibrary__myfontscount zh-dnone'>${data.currentCount + 1}</div>`; 
template.loader = (data) => ZT.html `<div class='zfontlibrary__preloader'> <div class='zfontlibrary__loadercircle'></div> </div>`; 
template.fontListContainer = (data) => ZT.html `<div class='zfontlibrary__fontlist'> <div class='zfontlibrary__fontlistgroup'> <div class='zfontlibrary__selectcontainer'> <button class='zfontlibrary__button'>${data.removeall}</button> </div> </div></div>`; 
template.fontPreviewContainer = (data) => ZT.html `<div class='zfontlibrary__previewer'> ${template.fontPreview(data)} <div class='zfontlibrary__nofontcontainer zh-dnone'><span id='ui-zfl-no-fonts'> ${data.noFonts} </span></div> <div id='ui-hiddenDiv-id' class='zfontlibrary__fontdetails zfontlibrary__transition'> ${template.fontDetailsContainer(data)} </div> <div class='zfontlibrary__nopreview'> <span class='zfontlibrary__viewmoredetails'>${data.selectmorefont}</span> <span class='ui-zfl-selection_content'></span> </div> <button title='${data.fontInfo}' tabindex="10008" class="zfontlibrary__infobutton zh-dnone">i</button> </div>`; 
template.fontDetailsContainer = (data) => ZT.html` <div class='ui-zfl-fontDetails'> ${data.fontDetails && data.fontDetails.map((value) => template.fontDetails(value))} </div>`; 
template.fontDetails = (font) => ZT.html `<li><span>${font.label}</span><b > ${font.value}</b></li>`; 
template.fontPreview = (data) => ZT.html `<div class='zfontlibrary__previewarea zfontlibrary__transition zh-dnone'> <div class='zfontlibrary__fontadder'></div> <div class='zfontlibrary__fontsize'> </div> <div class='zfontlibrary__fontpreview'> <textarea class='zfontlibrary__textarea' style="display:none;"></textarea> <textarea id='ui-textArea-id' spellcheck='false' tabindex='10007'> </textarea> <div class='zfontlibrary__fontsizecontainer'> <div class='zfontlibrary__fontsizepreview'> ${data.previewList && data.previewList.map((value) => template.preview(data, value))} </div> </div> </div> </div>`; 
template.preview = (data, value) => ZT.html `<span class='zfontlibrary__previewless zfontlibrary__previewshadow' font-size='${value}'> <a tabindex='-1'>${value}</a> ${data.previewText} </span>`; }(ZComponents)); 
(function(ZC, $){
		/* eslint-disable no-undef */
		/* eslint-disable no-unused-vars */
		class ZScreenGrabber  extends ZC.CoreComponent{
			get name(){
				return "zscreengrabber";
			}
		    static get DEFAULTS() {
		        return {
		            targetObject: false,
		            fetchImageURL: '', // No i18n
		            capture: undefined,
		            animationAfterComplete: true,
		            allowToEdit: false,
		            canParseSVG: false,
		            _partal: false,
		            _isIE9: false,
		            _rightDrag: false,
		            _overflow: true,
		            _ctx: undefined,
		            _memCtx: undefined,
		            keys: {
		                'capture.label': 'Capture', // No i18n
		                'cancel.label': 'Cancel', // No i18n
		                'done.label': 'Done', // No i18n
		                'edit.label': 'Edit', // No i18n
		                'capturing.label': 'Capturing', // No i18n
		                'message.label': 'Click to capture the fullscreen. Drag to select part of the screen.', // No i18n
		                'partialSelectMsg.label': 'Drag to select part of the screen.', // No i18n
		                'screencapturealert.label': 'Unable to capture your screen due to an unknown error', // No i18n
		                'screencapturefailure.label': 'Sorry! We are unable to capture your screen due to an unknown error', // No i18n
		                'retry.label': 'Retry', // No i18n
		                'quit.label': 'Quit' // No i18n
		            }
		        }
		    }
		    static _init(options) {
		        this._opts = $.extend(true, {}, this.DEFAULTS, options);
		        this._data = this._opts;
		        this._screengrabberOpen = true;
		        this._events = {
		            ONOPEN: 'open', // No i18n
		            ONFINISH: 'done', // No i18n
		            ONCLOSE: 'close' // No i18n
		        };
		        this._initalOverflow = $('body').css('overflow'); // No i18n
		        this._scrollTopVal = {};
		        this._screenGrabFailCount = 0;
		        this._isInvokedByShortcut = false;
		        this._data.screenGrabFail = false;
		        this._data.selectionDrag = false;
		        this._data.isCE = false;
		        this._data.scrollTop = document.documentElement.scrollTop || window.scrollY || window.pageYOffset || document.scrollingElement.scrollTop;
		        this._data.scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
		        this._isIE9 = ZC.Browser.isIE && ZC.Browser.getIEVersion() === 9;
		        this._data.cancelButton = this._data.editButton = this._data.doneButton = this._data.loader = {};
		        this._data.cancelButton = this._getbuttonProps('cancel'); // No I18N
		        this._data.doneButton = this._getbuttonProps('done'); // No I18N
		        this._data.editButton = this._getbuttonProps('edit'); // No I18N
		        this._data.captureText = this._getString('capture.label'); // No I18N
		        this._create();
		        this._createAlertBanner();
		        this._createScreenGrabber();
		    }
		    static _create() {
		        let isPartial = this._opts.capture === 'partial-screen'; // No I18N
		        this._data.loader = {
		            SVGIconClassName: 'zsgrabber__svgloader', // No I18N
		            SVGIconId: isPartial ? '#zsg-loader-icon' : '#zsg-fullscreen-loader-icon' // No I18N
		        };
		        this._data.message = this._getString(isPartial ? 'partialSelectMsg.label' : 'message.label'); // No I18N
		        this.container = $(ZC._render(this._data, 'zscreengrabber', null, null, document.body, {})); // No I18N
		        this._actionBtnsCont = this.container.find('.zsgrabber__actionbtnscontainer'); // No I18N
		        this._cancelBtn = this.container.find('.zsgrabber__cancelbtn'); // No I18N
		        this._editBtn = this.container.find('.zsgrabber__editbtn'); // No I18N
		        this._doneBtn = this.container.find('.zsgrabber__donebtn'); // No I18N
		        this._centralDiv = this.container.find('.zsgrabber__defaultmsg'); // No I18N
		        this._darkerDiv = this.container.find('.zsgrabber__fadeoutarea'); // No I18N
		        this._outerDragEle = this.container.find('.zsgrabber__editor'); // No I18N
		        this._loaderBar = this.container.find('.zsgrabber__loader'); // No I18N
		        this._leftDiv = this.container.find('.zsgrabber--selectoverlay.zh-left'); // No I18N
		        this._rightDiv = this.container.find('.zsgrabber--selectoverlay.zh-right'); // No I18N
		        this._topDiv = this.container.find('.zsgrabber--selectoverlay.zh-top'); // No I18N
		        this._bottomDiv = this.container.find('.zsgrabber--selectoverlay.zh-bottom'); // No I18N
		    }
		    static _createAlertBanner() {
		        this._screenCaptureError = $('<div class="zsgrabber__errorcontainer">').appendTo('body'); // No i18n
		        $('<span>').text(this._getString('screencapturealert.label')).appendTo(this._screenCaptureError); // No i18n
		        $('<span class="zsgrabber__retrylink">').text(this._getString('retry.label')).appendTo(this._screenCaptureError); // No i18n
		        $('<div>').attr({
		            'class': 'zsgrabber__quitbutton', // No i18n
		            title: this._getString('quit.label')
		        }).append('<span class = "zfc-icon ui-zfc-cross" ></span>').appendTo(this._screenCaptureError); // No i18n
		        if (!this._opts.allowToEdit) {
		            this._cancelBtn.addClass('zh-defaultsize');
		            this._doneBtn.addClass('zh-defaultsize');
		        }
		    }
		    static _scriptPath() {
		        let scripts = document.getElementsByTagName('SCRIPT'); // No i18n
		        let path = '';
		        if (scripts && scripts.length > 0) {
		            for (let i in scripts) {
		                if (scripts[i].src && scripts[i].src.match(/\/ui.zscreengrabber\.js$/)) {
		                    path = scripts[i].src.replace(/(.*)\/ui.zscreengrabber\.js$/, '$1'); // No i18n
		                    break;
		                }
		            }
		        }
		        let lastDir = path.lastIndexOf('/'); // No i18n
		        return path.substr(0, lastDir);
		    }
		    static _getbuttonProps(name, type) {
		        return ZC.ZButton.getBtnProps({
		            title: this._getString(`${name}.label`), // No I18N
		            type: 'icon' || type, // No I18N
		            className: `zsgrabber__actionbtn zsgrabber__${name}btn`, // No I18N
		            iconClassName: this._opts[`${name}iconClassName`], // No I18N
		            SVGIconId: this._opts[`${name}SVGIconId`], // No I18N
		            defaultSVGIconId: `zsg-${name}-icon`, // No I18N
		            templateRender: true
		        });
		    }
		    static _createScreenGrabber() {
		        let base = this;
		        let end1,
		            start1;
		        this._mouseMove = false;
		        this._restrictMouseDown = false;
		        this._handle = undefined;
		        this._dragSelection = false;
		        this._captureInProgress = false;
		        this._canvasEleCreated = false;
		        this._screenCaptured = false;
		        this.container.on('contextmenu', function(e) { // No i18n
		            e.preventDefault();
		            e.stopPropagation();
		            return false;
		        });
		        this.container.focus();
		        this._bindKeyboardEvents();
		        $(window).on('mouseup', function() { // No i18n
		            base._data.selectionDrag && base.container.trigger('mouseup'); // No i18n
		        });
		        this.container.on('mousedown', function(e) { // No i18n
		            if (e.button !== 2) {
		                e.preventDefault();
		                e.stopPropagation();
		                base.container.focus();
		                base._centralDiv.hide();
		                base._windowWidth = $(window).width();
		                base._windowHeight = $(window).height();
		                base.id = Math.round(Math.random() * 1000000);
		                if (!base._restrictMouseDown) {
		                    base._data.selectionDrag = true;
		                    start1 = [ e.clientX, e.clientY ];
		                }
		                base._outerDragEle.attr('id', base.id).removeClass('zh-dnone'); // No i18n
		            }
		        }).on('mouseup', function(e) {
		            if (e.button !== 2) {
		                base._data.selectionDrag = false;
		                base._dragSelection = false;
		                e.stopPropagation()
		                e.preventDefault();
		                $('body').get(0).style.cursor = 'auto'; // No i18n
		                base.container.css({
		                    'background-image': '', // No i18n
		                    cursor: 'default' // No i18n
		                });
		                if (!base._captureInProgress && !base._screenCaptured) {
		                    base._outerDragEle.css('cursor', 'move'); // No i18n
		                    if (base._mouseMove) {
		                        base._canvasEleCreated = true;
		                        base._restrictMouseDown = true;
		                        base._resizeSelectedScreen();
		                        base._outerDragEle.addClass('zh-partialscreen');
		                    } else if (base._opts.capture !== 'partial-screen') { // No i18n
		                        base._restrictMouseDown = true;
		                        base._defHeight = base._windowHeight;
		                        base._defWidth = base._windowWidth;
		                        base._createLoaderBar(true);
		                        base._outerDragEle.addClass('zh-fullscreen');
		                        base._loaderBar.trigger('click'); // No i18n
		                        base._actionButtonsPos();
		                    }
		                }
		            }
		        }).on('mousemove.screengrabber', function(e) { // No i18n
		            if (base._data.selectionDrag) {
		                base._mouseMove = true;
		                if (!base._restrictMouseDown) {
		                    base._createLoaderBar(false);
		                    $('body').css({
		                        cursor: 'crosshair' // No i18n
		                    }); // No i18n
		                }
		                base._actionBtnsCont.addClass('zh-dnone');
		                end1 = [ e.clientX, e.clientY ];
		                base._selectPartialScreen(end1, start1);
		            }
		        }).on('click.screengrabber', function(e) { // No i18n
		            e.preventDefault();
		            e.stopPropagation();
		        });
		        if (this.container) {
		            // eslint-disable-next-line no-unused-expressions
		            this._opts.capture === 'partial-screen' ? this._partialScreenInvoker() : this._fullScreenInvoker(); // No i18n
		            this.container.focus();
		            this._triggerEvent(this._events.ONOPEN);
		        }
		    }
		    static _bindKeyboardEvents() {
		        let base = this;
		        this.container.off('keydown.screengrabber keyup.screengrabber').on('keydown.screengrabber', function(e) { // No i18n
		            if (e.which === 27) {
		                base._data.screenGrabFail = true;
		                e.stopPropagation();
		                base._close(true);
		                e.preventDefault();
		                return false;
		            } else if (e.which === 13 && !base._captureInProgress) {
		                base._canvasEleCreated && base._loaderBar.trigger('click'); // No i18n
		                base._screenCaptured && base._doneBtn.trigger('click'); // No i18n
		            }
		        });
		    }
		    static _getString(key, module, replaceArray) {
		        return ZC.getI18NText('zscreengrabber',name, replaceArray,this._opts.key); // No i18n
		        // return FCUtil.getI18NString('zscreengrabber', key, replaceArray, this._opts.keys); //No I18N
		    }
		    static _close() {
		        this._loaderBar && this._loaderBar.remove();
		        this._opts.canParseSVG && $('body').find('svg.zsg-svg-element').removeClass('zsg-svg-element'); // No I18N
		        this._screenCaptureError.remove();
		        this._screengrabberOpen = false;
		        this.container.off('mousemove.screengrabber'); // No i18n
		        $('body').off('mousemove.screengrabber mouseup.screengrabber').removeClass('zsgrabber__userselect').css({
		            cursor: '',
		            overflow: this._initalOverflow
		        }); // No i18n
		        this._triggerEvent(this._events.ONCLOSE);
		        $(window).off('keydown.screengrabber, keyup.screengrabber'); // No i18n
		        this._bindShortcutEvents(this._opts);
		        this.container.remove();
		    }
		    static _bindShortcutEvents() {
		        let fullScreen, fullScreenKeyCodes, partialScreen, partialScreenKeyCodes;
		        if (ZC.OS.isMac()) {
		            fullScreen = [ 'Command', 'Option', 'Shift', '3' ]; // No i18n
		            partialScreen = [ 'Command', 'Option', 'Shift', '4' ]; // No i18n
		        } else {
		            fullScreen = [ 'Ctrl', 'Alt', 'PrtSc' ]; // No i18n
		            partialScreen = [ 'Ctrl', 'Shift', 'PrtSc' ]; // No i18n
		        }
		        this._contextPath = FComponents.option('contextPath'); // No i18n
		        let isCntrl = false,
		            isAlt = false,
		            isShift = false,
		            isCmd = false,
		            isOptn = false;
		        $(window).off('keydown.screengrabbershortcuts').on('keydown.screengrabbershortcuts', function(ev) { // No i18n
		            if (ZC.OS.isMac()) {
		                ev.metaKey && (isCmd = true);
		                ev.shiftKey && (isShift = true);
		                ev.keyCode === 16 && (isOptn = true);
		                if (isCmd && isOptn && isShift && !this._screengrabberOpen && (ev.keyCode === 51 || ev.keyCode === 52)) {
		                    zscreengrabber._open(ev, ev.keyCode === 52);
		                }
		            } else {
		                ev.ctrlKey && (isCntrl = true);
		                ev.altKey && (isAlt = true);
		                ev.shiftKey && (isShift = true);
		            }
		        }).on('keyup.screengrabbershortcuts', function(ev) { // No i18n
		            if (ZC.OS.isMac()) {
		                ev.metaKey && (isCmd = false);
		                ev.shiftKey && (isShift = false);
		                ev.keyCode === 16 && (isOptn = false);
		            } else {
		                if (isCntrl && ev.keyCode === 44 && !this._screengrabberOpen && (isShift || isAlt)) {
		                    zscreengrabber._open(ev, isShift);
		                }
		                ev.ctrlKey && (isCntrl = false);
		                ev.altKey && (isAlt = false);
		                ev.shiftKey && (isShift = false);
		            }
		        });
		    }
		    static _resizeSelectedScreen() {
		        let base = this;
		        let selctedAreaOffset = this._outerDragEle.offset(),
		            start1;
		        let scrollTop = document.documentElement.scrollTop || window.scrollY || window.pageYOffset || document.scrollingElement.scrollTop;
		        this._defHeight = this._outerDragEle.outerHeight();
		        this._defWidth = this._outerDragEle.outerWidth();
		        base._outerDragEle.off().on('mousedown', function(orgEv) { // No i18n
		            if (!base._captureInProgress && !base._screenCaptured) {
		                base._data.selectionDrag = true;
		                base._dragSelection = true;
		                start1 = [ selctedAreaOffset.left, selctedAreaOffset.top - scrollTop ];
		                base._cursorPos = [ orgEv.clientX, orgEv.clientY ];
		            }
		        }).on('contextmenu', function() { // No i18n
		            base._data.selectionDrag = false;
		            base._dragSelection = false;
		        });
		        $('.zsgrabber--handle').on('mousedown', function(ev) {
		            ev.preventDefault();
		            ev.stopPropagation();
		            base._data.selectionDrag = true;
		            base._handle = $(this);
		            base._outerDragEle.css('cursor', base._handle.css('cursor')); // No i18n
		            if ($(this).hasClass('zh-se') || $(this).hasClass('zh-s') || $(this).hasClass('zh-e')) {
		                start1 = [ selctedAreaOffset.left, selctedAreaOffset.top - scrollTop ];
		            } else if ($(this).hasClass('zh-ne') || $(this).hasClass('zh-n')) {
		                start1 = [ selctedAreaOffset.left, (selctedAreaOffset.top - scrollTop) + base._defHeight ];
		            } else if ($(this).hasClass('zh-sw') || $(this).hasClass('zh-w')) {
		                start1 = [ selctedAreaOffset.left + base._defWidth, selctedAreaOffset.top - scrollTop ];
		            } else if ($(this).hasClass('zh-nw')) {
		                start1 = [ selctedAreaOffset.left + base._defWidth, (selctedAreaOffset.top - scrollTop) + base._defHeight ];
		            }
		        });
		        this._actionButtonsPos(selctedAreaOffset.top);
		    }
		    static _selectPartialScreen(end1, start1) {
		        let divTop1, rightTop, divLeft1, divHeight1, divWidth1,
		            element = this._outerDragEle;
		        if (this._dragSelection) {
		            let left = start1[0] + (end1[0] - this._cursorPos[0]),
		                top = start1[1] + (end1[1] - this._cursorPos[1]);
		            if (top >= 1 && top + this._defHeight <= this._windowHeight) {
		                divTop1 = top; rightTop = top;
		            } else {
		                divTop1 = 0; rightTop = 0;
		                if (top + this._defHeight > this._windowHeight) {
		                    top = top - (top + this._defHeight - this._windowHeight);
		                    divTop1 = top; rightTop = top;
		                }
		            }
		            if (left >= 1 && left + this._defWidth <= this._windowWidth) {
		                divLeft1 = left;
		            } else {
		                divLeft1 = 0;
		                if (left + this._defWidth > this._windowWidth) {
		                    divLeft1 = left - (left + this._defWidth - this._windowWidth);
		                }
		            }
		            divHeight1 = element.outerHeight();
		            divWidth1 = element.outerWidth();
		        } else {
		            divTop1 = start1[1]; divLeft1 = start1[0]; rightTop = start1[1];
		            if (start1[1] > end1[1]) {
		                divTop1 = end1[1];
		                this._rightDrag = true;
		            }
		            if (start1[0] > end1[0]) {
		                divLeft1 = end1[0];
		            }
		            if (this._rightDrag) {
		                rightTop = end1[1];
		                this._rightDrag = false;
		            }
		            if (this._handle === undefined || (!this._handle.hasClass('zh-e') && !this._handle.hasClass('zh-w'))) {
		                divHeight1 = Math.abs(start1[1] - end1[1]);
		            }
		            if (this._handle === undefined || (!this._handle.hasClass('zh-n') && !this._handle.hasClass('zh-s'))) {
		                divWidth1 = Math.abs(start1[0] - end1[0]);
		            }
		        }
		        this._topDiv.css({
		            width: this._windowWidth,
		            height: divTop1
		        }); // No i18n
		        this._leftDiv.css({
		            width: divLeft1,
		            top: divTop1,
		            height: divHeight1
		        }); // No i18n
		        this._rightDiv.css({
		            top: rightTop,
		            left: divLeft1 + divWidth1,
		            height: divHeight1
		        }); // No i18n
		        this._bottomDiv.css({
		            top: rightTop + divHeight1,
		            width: this._windowWidth,
		            height: this._windowHeight - (divTop1 + divHeight1)
		        }); // No i18n
		        this._outerDragEle.css({
		            left: divLeft1,
		            top: divTop1,
		            width: divWidth1 - 2,
		            height: divHeight1 - 2
		        }); // No i18n
		    }
		    static _actionButtonsPos(top) {
		        this._actionBtnsCont.removeClass('zh-dnone').css('left', 'auto'); // No i18n
		        let base = this,
		            bottomSpace, contHeight, contWidth, rightVal;
		        bottomSpace = this._windowHeight - (this._defHeight + top);
		        contHeight = this._actionBtnsCont.outerHeight();
		        contWidth = this._actionBtnsCont.outerWidth();
		        rightVal = -(contWidth - this._defWidth) / 2;
		        if (this._defWidth >= contWidth + 20 && this._defHeight >= contHeight + 20) {
		            this._actionBtnsCont.css({
		                top: (this._defHeight - contHeight) / 2
		            }); // No i18n
		        } else if (bottomSpace >= contHeight + 10) {
		            this._actionBtnsCont.css({
		                top: this._defHeight + 10
		            }); // No i18n
		        } else if (top >= contHeight + 10) {
		            this._actionBtnsCont.css({
		                top: -(contHeight + 10)
		            }); // No i18n
		        } else if (bottomSpace <= contHeight + 10 && top <= contHeight + 10) {
		            this._actionBtnsCont.css({
		                top: (this._defHeight - contHeight) / 2
		            }); // No i18n
		        }
		        if (this._defWidth <= contWidth) {
		            this._actionBtnsCont.css({
		                left: rightVal
		            }); // No i18n
		        }
		        base._cancelBtn.off().on('mousedown', function() {
		            base._close(true);
		        });
		    }
		    static _grabScreen() {
		        let base = this;
		        let ele = this._outerDragEle.position();
		        this._defLeft = ele.left;
		        this._defTop = ele.top;
		        if (base._mouseMove) {
		            this._defWidth = this._outerDragEle.innerWidth();
		            this._defHeight = this._outerDragEle.innerHeight();
		        }
		        $('.zsgrabber--handle').hide();
		        this._scrollTopVal.topval = document.documentElement.scrollTop || window.scrollY || window.pageYOffset || document.scrollingElement.scrollTop;
		        this._outerDragEle.css({
		            left: this._defLeft,
		            top: this._defTop,
		            width: this._defWidth,
		            height: this._defHeight,
		            cursor: 'default' // No i18n
		        })
		        this._screenCaptureArea = {
		            top: this._defTop + this._scrollTopVal.topval,
		            height: this._defHeight,
		            left: this._defLeft,
		            width: this._defWidth
		        };
		        let req;
		        if (this._opts.canParseSVG) {
		            this._svgToCanvasConv();
		        }
		        this._captureInProgress = true;
		        let captureReq = setTimeout(function() {
		            let callbacks = {
		                success: function(canvas) {
		                    window.scroll(base._scrollTopVal.leftval, base._scrollTopVal.topval);
		                    let image = document.createElement('img'); // No i18n
		                    $(image).css({
		                        'max-width': '100%', // No i18n
		                        'max-height': '100%' // No i18n
		                    }); // No i18n
		                    base._captureInProgress = false;
		                    base._canvasEleCreated = false;
		                    base._screenCaptured = true;
		                    base._shutterAnimation();
		                    if (base._opts.allowToEdit) {
		                        base._editBtn.show();
		                    }
		                    base._cancelBtn.show(); // No i18n
		                    base._doneBtn.show(); // No i18n
		                    setTimeout(function() {
		                        base._outerDragEle.addClass('zh-capturedscreen');
		                    }, 100);
		                    let buffer = document.createElement('canvas'); // No i18n
		                    // eslint-disable-next-line camelcase
		                    let b_ctx = buffer.getContext('2d'); // No i18n
		                    buffer.width = base._defWidth;
		                    buffer.height = base._defHeight;
		                    // eslint-disable-next-line camelcase
		                    b_ctx.drawImage(canvas, base._defLeft, base._defTop + base._scrollTopVal.topval, base._defWidth, base._defHeight, 0, 0, base._defWidth, base._defHeight);
		                    canvas = buffer;
		                    image.src = canvas.toDataURL('image/png'); // No i18n
		                    if (!base._mouseMove) {
		                        base._darkerDiv.show();
		                        base._outerDragEle.css({
		                            left: 25,
		                            top: 25,
		                            width: base._defWidth - 50,
		                            height: base._defHeight - 50,
		                            'text-align': 'center' // No i18n
		                        }); // No i18n
		                    }
		                    base._outerDragEle.append(image).append(base._actionBtnsCont);
		                    if (base._opts.canParseSVG) {
		                        $('body').find('.zsgrabber__temp-canvas').remove(); // No I18N
		                        $('body').find('svg.zsg-svg-element').removeClass('zsg-svg-element'); // No I18N
		                    }
		                    base._doneBtn.off().on('click mousedown', function() { // No i18n
		                        base._takeScreenshot(canvas);
		                    });
		                    base._editBtn.off().on('mousedown', function() {
		                        base._close(true);
		                        base._opts.onEditModeOpen(canvas.toDataURL('image/png')); // No i18n
		                    });
		                },
		                fail: function(resp) {
		                    base._loaderBar.addClass('zh-dnone');
		                    base._screenCaptureError.fadeIn(200);
		                    base._captureInProgress = false;
		                    $(document).on('click', '.zsgrabber__retrylink', function(e) { // No i18n
		                        base._screenCaptureError.hide();
		                        $(this).hide();
		                        base._data.screenGrabFail = false;
		                        base._loaderBar.removeClass('zh-dnone');
		                        screenCapture();
		                    }).on('click', '.zsgrabber__quitbutton', function(e) { // No i18n
		                        base._screenCaptureError.hide();
		                        base._close();
		                    });
		                    if (base._screenGrabFailCount) {
		                        base._screenCaptureError.show();
		                        $('.zsgrabber__retrylink').remove(); // No i18n
		                        base._screenCaptureError.find('span').first().text(base._getString('screencapturefailure.label')); // No i18n
		                    } else {
		                        base._screenGrabFailCount = base._screenGrabFailCount + 1;
		                    }
		                }
		            }
		            if (!base._data.screenGrabFail) {
		                screenCapture();
		            }
		            function screenCapture() {
		                base._outerDragEle.css('border-color', 'transparent'); // No i18n
		                html2canvas(document.body, {
		                    proxy: base._opts.fetchImageURL, // No i18n
		                    grabArea: base._screenCaptureArea, // No I18N
		                    onrendered: function(canvas) {
		                        clearTimeout(req);
		                        if (!base._data.screenGrabFail) {
		                            setTimeout(function() {
		                                base.container.find('.ui-zsg-spinner').addClass('zh-spineffect'); // No i18n
		                            }, 2000);
		                            setTimeout(function() {
		                                callbacks.success(canvas);
		                                base._loaderBar.fadeOut(300); // No i18n
		                            }, 2500);
		                            base._data.screenGrabFail = false;
		                        }
		                    }
		                });
		                req = setTimeout(function() {
		                    callbacks.fail();
		                    clearTimeout(req);
		                    base._data.screenGrabFail = true;
		                }, 15000);
		            }
		        }, 50);
		    }
		    static _shutterAnimation() {
		        !this._data.screenGrabFail && this.container.find('zsgrabber__flash').fadeOut(500); // No i18n
		    }
		    static _takeScreenshot(canvas) {
		        // this._triggerEvent(this._events.ONSEND);
		        window.scroll(this._scrollTopVal.leftval, this._scrollTopVal.topval);
		        this._finalImg = $('<img>').attr({
		            src: canvas.toDataURL('image/png') // No i18n
		        });
		        this._finalImg.css({
		            position: 'absolute', // No i18n
		            top: this._defTop + this._scrollTopVal.topval,
		            left: this._defLeft,
		            width: this._defWidth,
		            height: this._defHeight,
		            'z-index': 100001 // No i18n
		        }).appendTo('body'); // No i18n
		        this._finishAnim();
		    }
		    static _svgToCanvasConv() {
		        let svgElements = $('body').find('svg'),
		            string, viewBox, temoSVGEle, canvas, temoUseEle,
		            thisObj = this; // No I18N
		        svgElements.each(function() {
		            let canvas, xml;
		            let currEle = $(this);
		            if (currEle.attr('class') !== 'zsgrabber__svgloader') { // No I18N
		                if (currEle.css('display') !== 'none' && currEle.css('visiblity') !== 'none') { // No I18N
		                    let cloneNode = currEle[0].cloneNode(true);
		                    temoUseEle = currEle.find('use'); // No I18N
		                    if (temoUseEle.length) {
		                        temoUseEle = $(temoUseEle.attr('xlink:href') || temoUseEle.attr('href'));
		                        $(cloneNode).html(temoUseEle[0].innerHTML);
		                        viewBox = temoUseEle[0].getAttribute('viewBox'); // No I18N
		                        if (viewBox) {
		                            cloneNode.setAttribute('viewBox', ' ' + viewBox); // No I18N
		                        }
		                    }
		                    cloneNode.setAttribute('width', currEle.width()); // No I18N
		                    cloneNode.setAttribute('height', currEle.height()); // No I18N
		                    if (Screengrabber.useCanVG) {
		                        canvas = document.createElement('canvas'); // No I18N
		                        canvas.className = 'zsgrabber__temp-canvas ' + cloneNode.getAttribute('class'); // No I18N
		                        let ctx = canvas.getContext('2d'); // No I18N
		                        if (temoUseEle.length) {
		                            string = cloneNode.outerHTML;
		                        } else {
		                            string = currEle.parent()[0].innerHTML;
		                        }
		                        canvg(canvas, string.trim(), {
		                            ignoreClear: true
		                        });
		                        // ctx.fillStyle = 'red';    //No I18N
		                        let img = new Image();
		                        img.src = canvas.toDataURL('image/png'); // No I18N
		                        $(canvas).insertAfter(this);
		                        currEle.addClass('zsg-svg-element'); // No I18N
		                    } else if (cloneNode) {
		                        $cloneNode = $(cloneNode).insertAfter(currEle);
		                        thisObj._parseSVG(cloneNode);
		                        let svgContent = new XMLSerializer().serializeToString(cloneNode);
		                        thisObj._convertImage(svgContent, currEle, $cloneNode);
		                    }
		                }
		            }
		        });
		    }
		    static _parseSVG(svgContent) {
		        let childrens = $(svgContent).children();
		        if (childrens.length) {
		            for (let i = 0; i < childrens.length; i++) {
		                this._parseSVG(childrens[i]);
		            }
		        } else {
		            let style = window.getComputedStyle(svgContent);
		            let attrs = [ 'alignment-baseline', 'baseline-shift', 'clip', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cursor', 'direction', 'display', 'dominant-baseline', 'enable-background', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'image-rendering', 'kerning', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'mask', 'opacity', 'overflow', 'pointer-events', 'shape-rendering', 'stop-color', 'stop-opacity', 'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'unicode-bidi', 'vector-effect', 'visibility', 'word-spacing', 'writing-mode' ]; // No I18N
		            for (let i = 0; i < attrs.length; i++) {
		                svgContent.setAttribute(attrs[i], style[attrs[i]])
		            }
		            if (!$(svgContent).is(':visible')) { // No I18N
		                svgContent.setAttribute('display', 'none'); // No I18N
		            }
		        }
		    }
		    static _convertImage(svgContent, currEle, $cloneNode) {
		        setTimeout(function() {
		            $cloneNode.remove();
		            let img = new Image();
		            let canvas = document.createElement('canvas'); // No I18N
		            let imgTag = document.createElement('img'); // No I18N
		            canvas.className = 'zsgrabber__temp-canvas ' + $cloneNode[0].getAttribute('class'); // No I18N
		            let ctxt = canvas.getContext('2d'); // No I18N
		            let svg = new Blob([ svgContent ], {
		                type: 'image/svg+xml;charset=utf-8' // No i18n
		            });
		            let url = URL.createObjectURL(svg);
		            img.src = url;
		            imgTag.src = url;
		            canvas.width = currEle.width();
		            imgTag.width = currEle.width();
		            canvas.height = currEle.height();
		            imgTag.height = currEle.height();
		            canvas.style.width = currEle.width() + 'px'; // No I18N
		            canvas.style.height = currEle.height() + 'px'; // No I18N
		            img.onload = function() {
		                ctxt.drawImage(img, 0, 0, currEle.width(), currEle.height());
		                currEle.addClass('zsg-svg-element'); // No I18N
		                $(canvas).insertAfter(currEle);
		            };
		        }, 0)
		    }
		    static _finishAnim() {
		        let base = this;
		        this.container.hide();
		        let targetTop, targetLeft, targetWidth, targetHeight;
		        let ui = {};
		        ui.imageSource = this._finalImg.attr('src'); // No i18n
		        this._triggerEvent(this._events.ONFINISH, ui);
		        if (this._opts.targetObject) {
		            let targetObject = this._opts.targetObject;
		            targetTop = targetObject.offset().top;
		            targetLeft = targetObject.offset().left;
		            targetWidth = targetObject.innerWidth();
		            targetHeight = targetObject.innerHeight()
		        } else {
		            let body = $('body'); // No i18n
		            targetTop = body.innerHeight() / 2;
		            targetLeft = body.innerWidth() / 2;
		            targetWidth = 0;
		            targetHeight = 0;
		        }
		        if (this._opts.animationAfterComplete) {
		            this._finalImg.animate({
		                top: targetTop,
		                left: targetLeft,
		                width: targetWidth,
		                height: targetHeight,
		                opacity: 0.2
		            }, 500, function() { // No i18n
		                base._close();
		                $(this).remove();
		                base._captureInProgress = false;
		            });
		        } else {
		            base._close();
		            this._finalImg.remove();
		            base._captureInProgress = false;
		        }
		    }
		    static _createLoaderBar(fullscreen) {
		        let base = this;
		        this._loaderBar.off().on('mousedown click', function(orgEvent) { // No i18n
		            orgEvent.stopPropagation();
		            orgEvent.preventDefault();
		            base._data.captureText = base._getString('capturing.label'); // No i18n
		            if (base._opts.capture === 'partial-screen') {
		                base._loaderBar.off().css('background-color', 'rgba(0, 0, 0, 0.85)').animate({ // No i18n
		                    width: 54,
		                    left: 92
		                }, '_default', function() { // No i18n
		                    // base._loaderBar.find(".zsgrabber__captureicon").append(progressIndicator);
		                    base._loaderBar.find('.zsgrabber__wrapper').removeClass('zh-dnone');
		                    base._grabScreen();
		                });
		            } else {
		                base._loaderBar.off().css('background-color', 'rgba(0, 0, 0, 0.85)'); // No i18n
		                base._loaderBar.find('.zsgrabber__wrapper').removeClass('zh-dnone');
		                base._grabScreen();
		            }
		            base._loaderBar.find('.zsgrabber__captureicon').animate({
		                left: 11
		            }, 200); // No i18n
		            base._loaderBar.find('.zsgrabber__capturelabel').hide();
		            base._cancelBtn.animate({
		                left: 92
		            }, 100).fadeOut(200); // No i18n
		        });
		    }
		    static _fullScreenInvoker() {
		        this.container.trigger('mousedown'); // No i18n
		        this.container.trigger('mouseup'); // No i18n
		    }
		    static _partialScreenInvoker() {
		        this._opts.capture = 'partial-screen'; // No i18n
		        this.container.css({
		            cursor: 'crosshair' // No i18n
		        });
		        this._centralDiv.children().text(this._getString('partialSelectMsg.label')); // No i18n
		        /* this._isInvokedByShortcut = true; */
		        // this.container.addClass('zsgrabber__partialscreen-area');    //No i18n
		    }
		    static _triggerEvent(orgEvent, _ui) {
		        let ui = _ui;
		        if (_ui === undefined) {
		            ui = $.extend(ui, _ui);
		        }
		        $('body').trigger(this.widgetEventPrefix + orgEvent, ui);
		    }
		    static _open(ev, type) {
		        ev.stopPropagation();
		        ev.preventDefault();
		        // zscreengrabber._create();
		        if (type) {
		            this._partialScreenInvoker();
		        } else {
		            this._fullScreenInvoker()
		        }
		        $(window).off('keydown.screengrabbershortcuts');
		    }
		    static open(opts) {
		        !this._screengrabberOpen && this._init(opts);
		    }
		    static close() {
		        this._close();
		    }
		    static init(opts) {
		        // this._screengrabberOpen = false;
		        this._opts = $.extend(true, {}, this.DEFAULTS, opts);
		        this._bindShortcutEvents();
		    }
		}
	ZC.registerComponent('ZScreenGrabber', ZScreenGrabber); 
})(ZComponents, ZComponents.DOMUtil);
 (function(ZC){ 
let button = ZC.zbutton.Templates.WCContainer, template = ZC.zscreengrabber.Templates, utilities = ZC.Templates.Utilities; 
template.WCContainer = (data) => ZT.html `<z-screengrabber id="ui-zsg-screen-select" class="zscreengrabber zsgrabber__screenselect" tabindex="1" role="screengrabber" data-html2canvas-ignore=true style="top:${data.scrollTop}">${data.children && template.WCChildren(data)}</z-screengrabber>`; 
template.WCChildren = (data) => ZT.html ` <div class="zsgrabber__fadeoutarea" data-html2canvas-ignore=true></div> ${template.WCEditor(data)} ${template.WCSelectoverlay(data)} ${!data.screenGrabFail && ZT.html `<div class="zsgrabber__flash"></div>`} ${data.image && ZT.html `<img src="${data.imagesrc}"></img>`} ${data.capture === 'partial-screen' && ZT.html `<div class="zsgrabber__defaultmsg"><span>${data.message}</span></div>`} `; 
template.WCSelectoverlay = () => ZT.html ` <div class="zsgrabber--selectoverlay zh-left"></div> <div class="zsgrabber--selectoverlay zh-top"></div> <div class="zsgrabber--selectoverlay zh-right"></div> <div class="zsgrabber--selectoverlay zh-bottom"></div> `; 
template.WCEditor = (data) => ZT.html `<div class="zsgrabber__editor zh-dnone" id="zsgrabberEditor"> ${template.WCActionContainer(data)} <div class="zsgrabber--handle zh-n"></div> <div class="zsgrabber--handle zh-s"></div> <div class="zsgrabber--handle zh-e"></div> <div class="zsgrabber--handle zh-w"></div> <div class="zsgrabber--handle zh-ne"></div> <div class="zsgrabber--handle zh-se"></div> <div class="zsgrabber--handle zh-sw"></div> <div class="zsgrabber--handle zh-nw"></div> </div>`; 
template.WCActionContainer = (data) => ZT.html `<div class="zsgrabber__actionbtnscontainer zh-dnone"> ${data.cancelButton && button(data.cancelButton)} ${data.editButton && button(data.editButton)} ${data.doneButton && button(data.doneButton)} <div class="zsgrabber__loader" data-html2-ignore=true> <span class="zsgrabber__captureicon"> ${utilities.WCIcon(data.loader)} <div class="zsgrabber__wrapper zh-dnone"> <div class="zsgrabber__lefthalf"></div> <div class="zsgrabber__spinner"></div> <div class="zsgrabber__righthalf"></div> </div> </span> <span class="zsgrabber__capturelabel">${data.captureText} </span> </div> </div>`; }(ZComponents)); 
 (function(ZC){ 
let button = ZC.zbutton.Templates.container, template = ZC.zscreengrabber.Templates, utilities = ZC.Templates.Utilities; 
template.container = (data) => ZT.html `<div id="ui-zsg-screen-select" class="zscreengrabber zsgrabber__screenselect" tabindex="1" role="screengrabber" data-html2canvas-ignore=true style="top:${data.scrollTop}">${data.children && template.children(data)}</div>`; 
template.children = (data) => ZT.html ` <div class="zsgrabber__fadeoutarea" data-html2canvas-ignore=true></div> ${template.editor(data)} ${template.selectoverlay(data)} ${!data.screenGrabFail && ZT.html `<div class="zsgrabber__flash"></div>`} ${data.image && ZT.html `<img src="${data.imagesrc}"></img>`} ${data.capture === 'partial-screen' && ZT.html `<div class="zsgrabber__defaultmsg"><span>${data.message}</span></div>`} `; 
template.selectoverlay = () => ZT.html ` <div class="zsgrabber--selectoverlay zh-left"></div> <div class="zsgrabber--selectoverlay zh-top"></div> <div class="zsgrabber--selectoverlay zh-right"></div> <div class="zsgrabber--selectoverlay zh-bottom"></div> `; 
template.editor = (data) => ZT.html `<div class="zsgrabber__editor zh-dnone" id="zsgrabberEditor"> ${template.actionContainer(data)} <div class="zsgrabber--handle zh-n"></div> <div class="zsgrabber--handle zh-s"></div> <div class="zsgrabber--handle zh-e"></div> <div class="zsgrabber--handle zh-w"></div> <div class="zsgrabber--handle zh-ne"></div> <div class="zsgrabber--handle zh-se"></div> <div class="zsgrabber--handle zh-sw"></div> <div class="zsgrabber--handle zh-nw"></div> </div>`; 
template.actionContainer = (data) => ZT.html `<div class="zsgrabber__actionbtnscontainer zh-dnone"> ${data.cancelButton && button(data.cancelButton)} ${data.editButton && button(data.editButton)} ${data.doneButton && button(data.doneButton)} <div class="zsgrabber__loader" data-html2-ignore=true> <span class="zsgrabber__captureicon"> ${utilities.icon(data.loader)} <div class="zsgrabber__wrapper zh-dnone"> <div class="zsgrabber__lefthalf"></div> <div class="zsgrabber__spinner"></div> <div class="zsgrabber__righthalf"></div> </div> </span> <span class="zsgrabber__capturelabel">${data.captureText} </span> </div> </div>`; }(ZComponents)); 